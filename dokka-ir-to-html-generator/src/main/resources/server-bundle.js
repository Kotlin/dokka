/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
var SSR;
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/fast-text-encoding/text.min.js":
/*!*****************************************************!*\
  !*** ./node_modules/fast-text-encoding/text.min.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval("{(function(scope) {'use strict';\nfunction B(r,e){var f;return r instanceof Buffer?f=r:f=Buffer.from(r.buffer,r.byteOffset,r.byteLength),f.toString(e)}var w=function(r){return Buffer.from(r)};function h(r){for(var e=0,f=Math.min(256*256,r.length+1),n=new Uint16Array(f),i=[],o=0;;){var t=e<r.length;if(!t||o>=f-1){var s=n.subarray(0,o),m=s;if(i.push(String.fromCharCode.apply(null,m)),!t)return i.join(\"\");r=r.subarray(e),e=0,o=0}var a=r[e++];if((a&128)===0)n[o++]=a;else if((a&224)===192){var d=r[e++]&63;n[o++]=(a&31)<<6|d}else if((a&240)===224){var d=r[e++]&63,l=r[e++]&63;n[o++]=(a&31)<<12|d<<6|l}else if((a&248)===240){var d=r[e++]&63,l=r[e++]&63,R=r[e++]&63,c=(a&7)<<18|d<<12|l<<6|R;c>65535&&(c-=65536,n[o++]=c>>>10&1023|55296,c=56320|c&1023),n[o++]=c}}}function F(r){for(var e=0,f=r.length,n=0,i=Math.max(32,f+(f>>>1)+7),o=new Uint8Array(i>>>3<<3);e<f;){var t=r.charCodeAt(e++);if(t>=55296&&t<=56319){if(e<f){var s=r.charCodeAt(e);(s&64512)===56320&&(++e,t=((t&1023)<<10)+(s&1023)+65536)}if(t>=55296&&t<=56319)continue}if(n+4>o.length){i+=8,i*=1+e/r.length*2,i=i>>>3<<3;var m=new Uint8Array(i);m.set(o),o=m}if((t&4294967168)===0){o[n++]=t;continue}else if((t&4294965248)===0)o[n++]=t>>>6&31|192;else if((t&4294901760)===0)o[n++]=t>>>12&15|224,o[n++]=t>>>6&63|128;else if((t&4292870144)===0)o[n++]=t>>>18&7|240,o[n++]=t>>>12&63|128,o[n++]=t>>>6&63|128;else continue;o[n++]=t&63|128}return o.slice?o.slice(0,n):o.subarray(0,n)}var u=\"Failed to \",p=function(r,e,f){if(r)throw new Error(\"\".concat(u).concat(e,\": the '\").concat(f,\"' option is unsupported.\"))};var x=typeof Buffer==\"function\"&&Buffer.from;var A=x?w:F;function v(){this.encoding=\"utf-8\"}v.prototype.encode=function(r,e){return p(e&&e.stream,\"encode\",\"stream\"),A(r)};function U(r){var e;try{var f=new Blob([r],{type:\"text/plain;charset=UTF-8\"});e=URL.createObjectURL(f);var n=new XMLHttpRequest;return n.open(\"GET\",e,!1),n.send(),n.responseText}finally{e&&URL.revokeObjectURL(e)}}var O=!x&&typeof Blob==\"function\"&&typeof URL==\"function\"&&typeof URL.createObjectURL==\"function\",S=[\"utf-8\",\"utf8\",\"unicode-1-1-utf-8\"],T=h;x?T=B:O&&(T=function(r){try{return U(r)}catch(e){return h(r)}});var y=\"construct 'TextDecoder'\",E=\"\".concat(u,\" \").concat(y,\": the \");function g(r,e){p(e&&e.fatal,y,\"fatal\"),r=r||\"utf-8\";var f;if(x?f=Buffer.isEncoding(r):f=S.indexOf(r.toLowerCase())!==-1,!f)throw new RangeError(\"\".concat(E,\" encoding label provided ('\").concat(r,\"') is invalid.\"));this.encoding=r,this.fatal=!1,this.ignoreBOM=!1}g.prototype.decode=function(r,e){p(e&&e.stream,\"decode\",\"stream\");var f;return r instanceof Uint8Array?f=r:r.buffer instanceof ArrayBuffer?f=new Uint8Array(r.buffer):f=new Uint8Array(r),T(f,this.encoding)};scope.TextEncoder=scope.TextEncoder||v;scope.TextDecoder=scope.TextDecoder||g;\n}(typeof window !== 'undefined' ? window : (typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : this)));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmFzdC10ZXh0LWVuY29kaW5nL3RleHQubWluLmpzIiwibWFwcGluZ3MiOiJBQUFBLGtCQUFrQjtBQUNsQixnQkFBZ0IsTUFBTSwrRkFBK0Ysa0JBQWtCLHVCQUF1QixjQUFjLDBFQUEwRSxFQUFFLGlCQUFpQixlQUFlLDBCQUEwQixrRUFBa0Usd0JBQXdCLGFBQWEsd0JBQXdCLHVCQUF1QixnQkFBZ0IsbUJBQW1CLHVCQUF1Qiw0QkFBNEIseUJBQXlCLHVCQUF1QixpRUFBaUUsdUVBQXVFLGNBQWMsaUZBQWlGLElBQUksRUFBRSx3QkFBd0IsdUJBQXVCLFFBQVEsc0JBQXNCLHlEQUF5RCwrQkFBK0IsaUJBQWlCLGtDQUFrQyx3QkFBd0IsYUFBYSx1QkFBdUIsU0FBUyxTQUFTLCtDQUErQyxvRUFBb0Usd0ZBQXdGLGNBQWMsZ0JBQWdCLDRDQUE0QyxxQ0FBcUMsNkZBQTZGLDZDQUE2QyxZQUFZLGFBQWEsc0JBQXNCLGlDQUFpQyw4Q0FBOEMsY0FBYyxNQUFNLElBQUksb0JBQW9CLGlCQUFpQixlQUFlLEVBQUUseUJBQXlCLHlCQUF5QixrREFBa0QsUUFBUSwyQkFBMkIsNklBQTZJLHdCQUF3QixJQUFJLFlBQVksU0FBUyxhQUFhLEVBQUUsc0VBQXNFLGdCQUFnQixxQ0FBcUMsTUFBTSw2SkFBNkosZ0RBQWdELGlDQUFpQyxpQ0FBaUMsTUFBTSxzSUFBc0ksdUNBQXVDO0FBQ3hvRixDQUFDLGtEQUFrRCxxQkFBTSxtQkFBbUIscUJBQU0iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TU1IvLi9ub2RlX21vZHVsZXMvZmFzdC10ZXh0LWVuY29kaW5nL3RleHQubWluLmpzP2Y3Y2IiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKHNjb3BlKSB7J3VzZSBzdHJpY3QnO1xuZnVuY3Rpb24gQihyLGUpe3ZhciBmO3JldHVybiByIGluc3RhbmNlb2YgQnVmZmVyP2Y9cjpmPUJ1ZmZlci5mcm9tKHIuYnVmZmVyLHIuYnl0ZU9mZnNldCxyLmJ5dGVMZW5ndGgpLGYudG9TdHJpbmcoZSl9dmFyIHc9ZnVuY3Rpb24ocil7cmV0dXJuIEJ1ZmZlci5mcm9tKHIpfTtmdW5jdGlvbiBoKHIpe2Zvcih2YXIgZT0wLGY9TWF0aC5taW4oMjU2KjI1NixyLmxlbmd0aCsxKSxuPW5ldyBVaW50MTZBcnJheShmKSxpPVtdLG89MDs7KXt2YXIgdD1lPHIubGVuZ3RoO2lmKCF0fHxvPj1mLTEpe3ZhciBzPW4uc3ViYXJyYXkoMCxvKSxtPXM7aWYoaS5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCxtKSksIXQpcmV0dXJuIGkuam9pbihcIlwiKTtyPXIuc3ViYXJyYXkoZSksZT0wLG89MH12YXIgYT1yW2UrK107aWYoKGEmMTI4KT09PTApbltvKytdPWE7ZWxzZSBpZigoYSYyMjQpPT09MTkyKXt2YXIgZD1yW2UrK10mNjM7bltvKytdPShhJjMxKTw8NnxkfWVsc2UgaWYoKGEmMjQwKT09PTIyNCl7dmFyIGQ9cltlKytdJjYzLGw9cltlKytdJjYzO25bbysrXT0oYSYzMSk8PDEyfGQ8PDZ8bH1lbHNlIGlmKChhJjI0OCk9PT0yNDApe3ZhciBkPXJbZSsrXSY2MyxsPXJbZSsrXSY2MyxSPXJbZSsrXSY2MyxjPShhJjcpPDwxOHxkPDwxMnxsPDw2fFI7Yz42NTUzNSYmKGMtPTY1NTM2LG5bbysrXT1jPj4+MTAmMTAyM3w1NTI5NixjPTU2MzIwfGMmMTAyMyksbltvKytdPWN9fX1mdW5jdGlvbiBGKHIpe2Zvcih2YXIgZT0wLGY9ci5sZW5ndGgsbj0wLGk9TWF0aC5tYXgoMzIsZisoZj4+PjEpKzcpLG89bmV3IFVpbnQ4QXJyYXkoaT4+PjM8PDMpO2U8Zjspe3ZhciB0PXIuY2hhckNvZGVBdChlKyspO2lmKHQ+PTU1Mjk2JiZ0PD01NjMxOSl7aWYoZTxmKXt2YXIgcz1yLmNoYXJDb2RlQXQoZSk7KHMmNjQ1MTIpPT09NTYzMjAmJigrK2UsdD0oKHQmMTAyMyk8PDEwKSsocyYxMDIzKSs2NTUzNil9aWYodD49NTUyOTYmJnQ8PTU2MzE5KWNvbnRpbnVlfWlmKG4rND5vLmxlbmd0aCl7aSs9OCxpKj0xK2Uvci5sZW5ndGgqMixpPWk+Pj4zPDwzO3ZhciBtPW5ldyBVaW50OEFycmF5KGkpO20uc2V0KG8pLG89bX1pZigodCY0Mjk0OTY3MTY4KT09PTApe29bbisrXT10O2NvbnRpbnVlfWVsc2UgaWYoKHQmNDI5NDk2NTI0OCk9PT0wKW9bbisrXT10Pj4+NiYzMXwxOTI7ZWxzZSBpZigodCY0Mjk0OTAxNzYwKT09PTApb1tuKytdPXQ+Pj4xMiYxNXwyMjQsb1tuKytdPXQ+Pj42JjYzfDEyODtlbHNlIGlmKCh0JjQyOTI4NzAxNDQpPT09MClvW24rK109dD4+PjE4Jjd8MjQwLG9bbisrXT10Pj4+MTImNjN8MTI4LG9bbisrXT10Pj4+NiY2M3wxMjg7ZWxzZSBjb250aW51ZTtvW24rK109dCY2M3wxMjh9cmV0dXJuIG8uc2xpY2U/by5zbGljZSgwLG4pOm8uc3ViYXJyYXkoMCxuKX12YXIgdT1cIkZhaWxlZCB0byBcIixwPWZ1bmN0aW9uKHIsZSxmKXtpZihyKXRocm93IG5ldyBFcnJvcihcIlwiLmNvbmNhdCh1KS5jb25jYXQoZSxcIjogdGhlICdcIikuY29uY2F0KGYsXCInIG9wdGlvbiBpcyB1bnN1cHBvcnRlZC5cIikpfTt2YXIgeD10eXBlb2YgQnVmZmVyPT1cImZ1bmN0aW9uXCImJkJ1ZmZlci5mcm9tO3ZhciBBPXg/dzpGO2Z1bmN0aW9uIHYoKXt0aGlzLmVuY29kaW5nPVwidXRmLThcIn12LnByb3RvdHlwZS5lbmNvZGU9ZnVuY3Rpb24ocixlKXtyZXR1cm4gcChlJiZlLnN0cmVhbSxcImVuY29kZVwiLFwic3RyZWFtXCIpLEEocil9O2Z1bmN0aW9uIFUocil7dmFyIGU7dHJ5e3ZhciBmPW5ldyBCbG9iKFtyXSx7dHlwZTpcInRleHQvcGxhaW47Y2hhcnNldD1VVEYtOFwifSk7ZT1VUkwuY3JlYXRlT2JqZWN0VVJMKGYpO3ZhciBuPW5ldyBYTUxIdHRwUmVxdWVzdDtyZXR1cm4gbi5vcGVuKFwiR0VUXCIsZSwhMSksbi5zZW5kKCksbi5yZXNwb25zZVRleHR9ZmluYWxseXtlJiZVUkwucmV2b2tlT2JqZWN0VVJMKGUpfX12YXIgTz0heCYmdHlwZW9mIEJsb2I9PVwiZnVuY3Rpb25cIiYmdHlwZW9mIFVSTD09XCJmdW5jdGlvblwiJiZ0eXBlb2YgVVJMLmNyZWF0ZU9iamVjdFVSTD09XCJmdW5jdGlvblwiLFM9W1widXRmLThcIixcInV0ZjhcIixcInVuaWNvZGUtMS0xLXV0Zi04XCJdLFQ9aDt4P1Q9QjpPJiYoVD1mdW5jdGlvbihyKXt0cnl7cmV0dXJuIFUocil9Y2F0Y2goZSl7cmV0dXJuIGgocil9fSk7dmFyIHk9XCJjb25zdHJ1Y3QgJ1RleHREZWNvZGVyJ1wiLEU9XCJcIi5jb25jYXQodSxcIiBcIikuY29uY2F0KHksXCI6IHRoZSBcIik7ZnVuY3Rpb24gZyhyLGUpe3AoZSYmZS5mYXRhbCx5LFwiZmF0YWxcIikscj1yfHxcInV0Zi04XCI7dmFyIGY7aWYoeD9mPUJ1ZmZlci5pc0VuY29kaW5nKHIpOmY9Uy5pbmRleE9mKHIudG9Mb3dlckNhc2UoKSkhPT0tMSwhZil0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlwiLmNvbmNhdChFLFwiIGVuY29kaW5nIGxhYmVsIHByb3ZpZGVkICgnXCIpLmNvbmNhdChyLFwiJykgaXMgaW52YWxpZC5cIikpO3RoaXMuZW5jb2Rpbmc9cix0aGlzLmZhdGFsPSExLHRoaXMuaWdub3JlQk9NPSExfWcucHJvdG90eXBlLmRlY29kZT1mdW5jdGlvbihyLGUpe3AoZSYmZS5zdHJlYW0sXCJkZWNvZGVcIixcInN0cmVhbVwiKTt2YXIgZjtyZXR1cm4gciBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk/Zj1yOnIuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXI/Zj1uZXcgVWludDhBcnJheShyLmJ1ZmZlcik6Zj1uZXcgVWludDhBcnJheShyKSxUKGYsdGhpcy5lbmNvZGluZyl9O3Njb3BlLlRleHRFbmNvZGVyPXNjb3BlLlRleHRFbmNvZGVyfHx2O3Njb3BlLlRleHREZWNvZGVyPXNjb3BlLlRleHREZWNvZGVyfHxnO1xufSh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6ICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHRoaXMpKSk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/fast-text-encoding/text.min.js\n\n}");

/***/ }),

/***/ "./node_modules/react-dom/cjs/react-dom-server-legacy.browser.development.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/react-dom/cjs/react-dom-server-legacy.browser.development.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{/**\n * @license React\n * react-dom-server-legacy.browser.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/*\n\n\n JS Implementation of MurmurHash3 (r136) (as of May 20, 2011)\n\n Copyright (c) 2011 Gary Court\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n SOFTWARE.\n*/\n\n true &&\n  (function () {\n    function styleReplacer(match, prefix, s, suffix) {\n      return \"\" + prefix + (\"s\" === s ? \"\\\\73 \" : \"\\\\53 \") + suffix;\n    }\n    function scriptReplacer(match, prefix, s, suffix) {\n      return \"\" + prefix + (\"s\" === s ? \"\\\\u0073\" : \"\\\\u0053\") + suffix;\n    }\n    function getIteratorFn(maybeIterable) {\n      if (null === maybeIterable || \"object\" !== typeof maybeIterable)\n        return null;\n      maybeIterable =\n        (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||\n        maybeIterable[\"@@iterator\"];\n      return \"function\" === typeof maybeIterable ? maybeIterable : null;\n    }\n    function objectName(object) {\n      object = Object.prototype.toString.call(object);\n      return object.slice(8, object.length - 1);\n    }\n    function describeKeyForErrorMessage(key) {\n      var encodedKey = JSON.stringify(key);\n      return '\"' + key + '\"' === encodedKey ? key : encodedKey;\n    }\n    function describeValueForErrorMessage(value) {\n      switch (typeof value) {\n        case \"string\":\n          return JSON.stringify(\n            10 >= value.length ? value : value.slice(0, 10) + \"...\"\n          );\n        case \"object\":\n          if (isArrayImpl(value)) return \"[...]\";\n          if (null !== value && value.$$typeof === CLIENT_REFERENCE_TAG)\n            return \"client\";\n          value = objectName(value);\n          return \"Object\" === value ? \"{...}\" : value;\n        case \"function\":\n          return value.$$typeof === CLIENT_REFERENCE_TAG\n            ? \"client\"\n            : (value = value.displayName || value.name)\n              ? \"function \" + value\n              : \"function\";\n        default:\n          return String(value);\n      }\n    }\n    function describeElementType(type) {\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n      }\n      if (\"object\" === typeof type)\n        switch (type.$$typeof) {\n          case REACT_FORWARD_REF_TYPE:\n            return describeElementType(type.render);\n          case REACT_MEMO_TYPE:\n            return describeElementType(type.type);\n          case REACT_LAZY_TYPE:\n            var payload = type._payload;\n            type = type._init;\n            try {\n              return describeElementType(type(payload));\n            } catch (x) {}\n        }\n      return \"\";\n    }\n    function describeObjectForErrorMessage(objectOrArray, expandedName) {\n      var objKind = objectName(objectOrArray);\n      if (\"Object\" !== objKind && \"Array\" !== objKind) return objKind;\n      var start = -1,\n        length = 0;\n      if (isArrayImpl(objectOrArray))\n        if (jsxChildrenParents.has(objectOrArray)) {\n          var type = jsxChildrenParents.get(objectOrArray);\n          objKind = \"<\" + describeElementType(type) + \">\";\n          for (var i = 0; i < objectOrArray.length; i++) {\n            var value = objectOrArray[i];\n            value =\n              \"string\" === typeof value\n                ? value\n                : \"object\" === typeof value && null !== value\n                  ? \"{\" + describeObjectForErrorMessage(value) + \"}\"\n                  : \"{\" + describeValueForErrorMessage(value) + \"}\";\n            \"\" + i === expandedName\n              ? ((start = objKind.length),\n                (length = value.length),\n                (objKind += value))\n              : (objKind =\n                  15 > value.length && 40 > objKind.length + value.length\n                    ? objKind + value\n                    : objKind + \"{...}\");\n          }\n          objKind += \"</\" + describeElementType(type) + \">\";\n        } else {\n          objKind = \"[\";\n          for (type = 0; type < objectOrArray.length; type++)\n            0 < type && (objKind += \", \"),\n              (i = objectOrArray[type]),\n              (i =\n                \"object\" === typeof i && null !== i\n                  ? describeObjectForErrorMessage(i)\n                  : describeValueForErrorMessage(i)),\n              \"\" + type === expandedName\n                ? ((start = objKind.length),\n                  (length = i.length),\n                  (objKind += i))\n                : (objKind =\n                    10 > i.length && 40 > objKind.length + i.length\n                      ? objKind + i\n                      : objKind + \"...\");\n          objKind += \"]\";\n        }\n      else if (objectOrArray.$$typeof === REACT_ELEMENT_TYPE)\n        objKind = \"<\" + describeElementType(objectOrArray.type) + \"/>\";\n      else {\n        if (objectOrArray.$$typeof === CLIENT_REFERENCE_TAG) return \"client\";\n        if (jsxPropsParents.has(objectOrArray)) {\n          objKind = jsxPropsParents.get(objectOrArray);\n          objKind = \"<\" + (describeElementType(objKind) || \"...\");\n          type = Object.keys(objectOrArray);\n          for (i = 0; i < type.length; i++) {\n            objKind += \" \";\n            value = type[i];\n            objKind += describeKeyForErrorMessage(value) + \"=\";\n            var _value2 = objectOrArray[value];\n            var _substr2 =\n              value === expandedName &&\n              \"object\" === typeof _value2 &&\n              null !== _value2\n                ? describeObjectForErrorMessage(_value2)\n                : describeValueForErrorMessage(_value2);\n            \"string\" !== typeof _value2 && (_substr2 = \"{\" + _substr2 + \"}\");\n            value === expandedName\n              ? ((start = objKind.length),\n                (length = _substr2.length),\n                (objKind += _substr2))\n              : (objKind =\n                  10 > _substr2.length && 40 > objKind.length + _substr2.length\n                    ? objKind + _substr2\n                    : objKind + \"...\");\n          }\n          objKind += \">\";\n        } else {\n          objKind = \"{\";\n          type = Object.keys(objectOrArray);\n          for (i = 0; i < type.length; i++)\n            0 < i && (objKind += \", \"),\n              (value = type[i]),\n              (objKind += describeKeyForErrorMessage(value) + \": \"),\n              (_value2 = objectOrArray[value]),\n              (_value2 =\n                \"object\" === typeof _value2 && null !== _value2\n                  ? describeObjectForErrorMessage(_value2)\n                  : describeValueForErrorMessage(_value2)),\n              value === expandedName\n                ? ((start = objKind.length),\n                  (length = _value2.length),\n                  (objKind += _value2))\n                : (objKind =\n                    10 > _value2.length && 40 > objKind.length + _value2.length\n                      ? objKind + _value2\n                      : objKind + \"...\");\n          objKind += \"}\";\n        }\n      }\n      return void 0 === expandedName\n        ? objKind\n        : -1 < start && 0 < length\n          ? ((objectOrArray = \" \".repeat(start) + \"^\".repeat(length)),\n            \"\\n  \" + objKind + \"\\n  \" + objectOrArray)\n          : \"\\n  \" + objKind;\n    }\n    function murmurhash3_32_gc(key, seed) {\n      var remainder = key.length & 3;\n      var bytes = key.length - remainder;\n      var h1 = seed;\n      for (seed = 0; seed < bytes; ) {\n        var k1 =\n          (key.charCodeAt(seed) & 255) |\n          ((key.charCodeAt(++seed) & 255) << 8) |\n          ((key.charCodeAt(++seed) & 255) << 16) |\n          ((key.charCodeAt(++seed) & 255) << 24);\n        ++seed;\n        k1 =\n          (3432918353 * (k1 & 65535) +\n            (((3432918353 * (k1 >>> 16)) & 65535) << 16)) &\n          4294967295;\n        k1 = (k1 << 15) | (k1 >>> 17);\n        k1 =\n          (461845907 * (k1 & 65535) +\n            (((461845907 * (k1 >>> 16)) & 65535) << 16)) &\n          4294967295;\n        h1 ^= k1;\n        h1 = (h1 << 13) | (h1 >>> 19);\n        h1 =\n          (5 * (h1 & 65535) + (((5 * (h1 >>> 16)) & 65535) << 16)) & 4294967295;\n        h1 = (h1 & 65535) + 27492 + ((((h1 >>> 16) + 58964) & 65535) << 16);\n      }\n      k1 = 0;\n      switch (remainder) {\n        case 3:\n          k1 ^= (key.charCodeAt(seed + 2) & 255) << 16;\n        case 2:\n          k1 ^= (key.charCodeAt(seed + 1) & 255) << 8;\n        case 1:\n          (k1 ^= key.charCodeAt(seed) & 255),\n            (k1 =\n              (3432918353 * (k1 & 65535) +\n                (((3432918353 * (k1 >>> 16)) & 65535) << 16)) &\n              4294967295),\n            (k1 = (k1 << 15) | (k1 >>> 17)),\n            (h1 ^=\n              (461845907 * (k1 & 65535) +\n                (((461845907 * (k1 >>> 16)) & 65535) << 16)) &\n              4294967295);\n      }\n      h1 ^= key.length;\n      h1 ^= h1 >>> 16;\n      h1 =\n        (2246822507 * (h1 & 65535) +\n          (((2246822507 * (h1 >>> 16)) & 65535) << 16)) &\n        4294967295;\n      h1 ^= h1 >>> 13;\n      h1 =\n        (3266489909 * (h1 & 65535) +\n          (((3266489909 * (h1 >>> 16)) & 65535) << 16)) &\n        4294967295;\n      return (h1 ^ (h1 >>> 16)) >>> 0;\n    }\n    function typeName(value) {\n      return (\n        (\"function\" === typeof Symbol &&\n          Symbol.toStringTag &&\n          value[Symbol.toStringTag]) ||\n        value.constructor.name ||\n        \"Object\"\n      );\n    }\n    function willCoercionThrow(value) {\n      try {\n        return testStringCoercion(value), !1;\n      } catch (e) {\n        return !0;\n      }\n    }\n    function testStringCoercion(value) {\n      return \"\" + value;\n    }\n    function checkAttributeStringCoercion(value, attributeName) {\n      if (willCoercionThrow(value))\n        return (\n          console.error(\n            \"The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before using it here.\",\n            attributeName,\n            typeName(value)\n          ),\n          testStringCoercion(value)\n        );\n    }\n    function checkCSSPropertyStringCoercion(value, propName) {\n      if (willCoercionThrow(value))\n        return (\n          console.error(\n            \"The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before using it here.\",\n            propName,\n            typeName(value)\n          ),\n          testStringCoercion(value)\n        );\n    }\n    function checkHtmlStringCoercion(value) {\n      if (willCoercionThrow(value))\n        return (\n          console.error(\n            \"The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before using it here.\",\n            typeName(value)\n          ),\n          testStringCoercion(value)\n        );\n    }\n    function isAttributeNameSafe(attributeName) {\n      if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))\n        return !0;\n      if (hasOwnProperty.call(illegalAttributeNameCache, attributeName))\n        return !1;\n      if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))\n        return (validatedAttributeNameCache[attributeName] = !0);\n      illegalAttributeNameCache[attributeName] = !0;\n      console.error(\"Invalid attribute name: `%s`\", attributeName);\n      return !1;\n    }\n    function checkControlledValueProps(tagName, props) {\n      hasReadOnlyValue[props.type] ||\n        props.onChange ||\n        props.onInput ||\n        props.readOnly ||\n        props.disabled ||\n        null == props.value ||\n        (\"select\" === tagName\n          ? console.error(\n              \"You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set `onChange`.\"\n            )\n          : console.error(\n              \"You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.\"\n            ));\n      props.onChange ||\n        props.readOnly ||\n        props.disabled ||\n        null == props.checked ||\n        console.error(\n          \"You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.\"\n        );\n    }\n    function validateProperty$1(tagName, name) {\n      if (\n        hasOwnProperty.call(warnedProperties$1, name) &&\n        warnedProperties$1[name]\n      )\n        return !0;\n      if (rARIACamel$1.test(name)) {\n        tagName = \"aria-\" + name.slice(4).toLowerCase();\n        tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;\n        if (null == tagName)\n          return (\n            console.error(\n              \"Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.\",\n              name\n            ),\n            (warnedProperties$1[name] = !0)\n          );\n        if (name !== tagName)\n          return (\n            console.error(\n              \"Invalid ARIA attribute `%s`. Did you mean `%s`?\",\n              name,\n              tagName\n            ),\n            (warnedProperties$1[name] = !0)\n          );\n      }\n      if (rARIA$1.test(name)) {\n        tagName = name.toLowerCase();\n        tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;\n        if (null == tagName) return (warnedProperties$1[name] = !0), !1;\n        name !== tagName &&\n          (console.error(\n            \"Unknown ARIA attribute `%s`. Did you mean `%s`?\",\n            name,\n            tagName\n          ),\n          (warnedProperties$1[name] = !0));\n      }\n      return !0;\n    }\n    function validateProperties$2(type, props) {\n      var invalidProps = [],\n        key;\n      for (key in props)\n        validateProperty$1(type, key) || invalidProps.push(key);\n      props = invalidProps\n        .map(function (prop) {\n          return \"`\" + prop + \"`\";\n        })\n        .join(\", \");\n      1 === invalidProps.length\n        ? console.error(\n            \"Invalid aria prop %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props\",\n            props,\n            type\n          )\n        : 1 < invalidProps.length &&\n          console.error(\n            \"Invalid aria props %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props\",\n            props,\n            type\n          );\n    }\n    function validateProperty(tagName, name, value, eventRegistry) {\n      if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name])\n        return !0;\n      var lowerCasedName = name.toLowerCase();\n      if (\"onfocusin\" === lowerCasedName || \"onfocusout\" === lowerCasedName)\n        return (\n          console.error(\n            \"React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.\"\n          ),\n          (warnedProperties[name] = !0)\n        );\n      if (\n        \"function\" === typeof value &&\n        ((\"form\" === tagName && \"action\" === name) ||\n          (\"input\" === tagName && \"formAction\" === name) ||\n          (\"button\" === tagName && \"formAction\" === name))\n      )\n        return !0;\n      if (null != eventRegistry) {\n        tagName = eventRegistry.possibleRegistrationNames;\n        if (eventRegistry.registrationNameDependencies.hasOwnProperty(name))\n          return !0;\n        eventRegistry = tagName.hasOwnProperty(lowerCasedName)\n          ? tagName[lowerCasedName]\n          : null;\n        if (null != eventRegistry)\n          return (\n            console.error(\n              \"Invalid event handler property `%s`. Did you mean `%s`?\",\n              name,\n              eventRegistry\n            ),\n            (warnedProperties[name] = !0)\n          );\n        if (EVENT_NAME_REGEX.test(name))\n          return (\n            console.error(\n              \"Unknown event handler property `%s`. It will be ignored.\",\n              name\n            ),\n            (warnedProperties[name] = !0)\n          );\n      } else if (EVENT_NAME_REGEX.test(name))\n        return (\n          INVALID_EVENT_NAME_REGEX.test(name) &&\n            console.error(\n              \"Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.\",\n              name\n            ),\n          (warnedProperties[name] = !0)\n        );\n      if (rARIA.test(name) || rARIACamel.test(name)) return !0;\n      if (\"innerhtml\" === lowerCasedName)\n        return (\n          console.error(\n            \"Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.\"\n          ),\n          (warnedProperties[name] = !0)\n        );\n      if (\"aria\" === lowerCasedName)\n        return (\n          console.error(\n            \"The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.\"\n          ),\n          (warnedProperties[name] = !0)\n        );\n      if (\n        \"is\" === lowerCasedName &&\n        null !== value &&\n        void 0 !== value &&\n        \"string\" !== typeof value\n      )\n        return (\n          console.error(\n            \"Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.\",\n            typeof value\n          ),\n          (warnedProperties[name] = !0)\n        );\n      if (\"number\" === typeof value && isNaN(value))\n        return (\n          console.error(\n            \"Received NaN for the `%s` attribute. If this is expected, cast the value to a string.\",\n            name\n          ),\n          (warnedProperties[name] = !0)\n        );\n      if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {\n        if (\n          ((lowerCasedName = possibleStandardNames[lowerCasedName]),\n          lowerCasedName !== name)\n        )\n          return (\n            console.error(\n              \"Invalid DOM property `%s`. Did you mean `%s`?\",\n              name,\n              lowerCasedName\n            ),\n            (warnedProperties[name] = !0)\n          );\n      } else if (name !== lowerCasedName)\n        return (\n          console.error(\n            \"React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.\",\n            name,\n            lowerCasedName\n          ),\n          (warnedProperties[name] = !0)\n        );\n      switch (name) {\n        case \"dangerouslySetInnerHTML\":\n        case \"children\":\n        case \"style\":\n        case \"suppressContentEditableWarning\":\n        case \"suppressHydrationWarning\":\n        case \"defaultValue\":\n        case \"defaultChecked\":\n        case \"innerHTML\":\n        case \"ref\":\n          return !0;\n        case \"innerText\":\n        case \"textContent\":\n          return !0;\n      }\n      switch (typeof value) {\n        case \"boolean\":\n          switch (name) {\n            case \"autoFocus\":\n            case \"checked\":\n            case \"multiple\":\n            case \"muted\":\n            case \"selected\":\n            case \"contentEditable\":\n            case \"spellCheck\":\n            case \"draggable\":\n            case \"value\":\n            case \"autoReverse\":\n            case \"externalResourcesRequired\":\n            case \"focusable\":\n            case \"preserveAlpha\":\n            case \"allowFullScreen\":\n            case \"async\":\n            case \"autoPlay\":\n            case \"controls\":\n            case \"default\":\n            case \"defer\":\n            case \"disabled\":\n            case \"disablePictureInPicture\":\n            case \"disableRemotePlayback\":\n            case \"formNoValidate\":\n            case \"hidden\":\n            case \"loop\":\n            case \"noModule\":\n            case \"noValidate\":\n            case \"open\":\n            case \"playsInline\":\n            case \"readOnly\":\n            case \"required\":\n            case \"reversed\":\n            case \"scoped\":\n            case \"seamless\":\n            case \"itemScope\":\n            case \"capture\":\n            case \"download\":\n            case \"inert\":\n              return !0;\n            default:\n              lowerCasedName = name.toLowerCase().slice(0, 5);\n              if (\"data-\" === lowerCasedName || \"aria-\" === lowerCasedName)\n                return !0;\n              value\n                ? console.error(\n                    'Received `%s` for a non-boolean attribute `%s`.\\n\\nIf you want to write it to the DOM, pass a string instead: %s=\"%s\" or %s={value.toString()}.',\n                    value,\n                    name,\n                    name,\n                    value,\n                    name\n                  )\n                : console.error(\n                    'Received `%s` for a non-boolean attribute `%s`.\\n\\nIf you want to write it to the DOM, pass a string instead: %s=\"%s\" or %s={value.toString()}.\\n\\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.',\n                    value,\n                    name,\n                    name,\n                    value,\n                    name,\n                    name,\n                    name\n                  );\n              return (warnedProperties[name] = !0);\n          }\n        case \"function\":\n        case \"symbol\":\n          return (warnedProperties[name] = !0), !1;\n        case \"string\":\n          if (\"false\" === value || \"true\" === value) {\n            switch (name) {\n              case \"checked\":\n              case \"selected\":\n              case \"multiple\":\n              case \"muted\":\n              case \"allowFullScreen\":\n              case \"async\":\n              case \"autoPlay\":\n              case \"controls\":\n              case \"default\":\n              case \"defer\":\n              case \"disabled\":\n              case \"disablePictureInPicture\":\n              case \"disableRemotePlayback\":\n              case \"formNoValidate\":\n              case \"hidden\":\n              case \"loop\":\n              case \"noModule\":\n              case \"noValidate\":\n              case \"open\":\n              case \"playsInline\":\n              case \"readOnly\":\n              case \"required\":\n              case \"reversed\":\n              case \"scoped\":\n              case \"seamless\":\n              case \"itemScope\":\n              case \"inert\":\n                break;\n              default:\n                return !0;\n            }\n            console.error(\n              \"Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?\",\n              value,\n              name,\n              \"false\" === value\n                ? \"The browser will interpret it as a truthy value.\"\n                : 'Although this works, it will not work as expected if you pass the string \"false\".',\n              name,\n              value\n            );\n            warnedProperties[name] = !0;\n          }\n      }\n      return !0;\n    }\n    function warnUnknownProperties(type, props, eventRegistry) {\n      var unknownProps = [],\n        key;\n      for (key in props)\n        validateProperty(type, key, props[key], eventRegistry) ||\n          unknownProps.push(key);\n      props = unknownProps\n        .map(function (prop) {\n          return \"`\" + prop + \"`\";\n        })\n        .join(\", \");\n      1 === unknownProps.length\n        ? console.error(\n            \"Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://react.dev/link/attribute-behavior \",\n            props,\n            type\n          )\n        : 1 < unknownProps.length &&\n          console.error(\n            \"Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://react.dev/link/attribute-behavior \",\n            props,\n            type\n          );\n    }\n    function camelize(string) {\n      return string.replace(hyphenPattern, function (_, character) {\n        return character.toUpperCase();\n      });\n    }\n    function escapeTextForBrowser(text) {\n      if (\n        \"boolean\" === typeof text ||\n        \"number\" === typeof text ||\n        \"bigint\" === typeof text\n      )\n        return \"\" + text;\n      checkHtmlStringCoercion(text);\n      text = \"\" + text;\n      var match = matchHtmlRegExp.exec(text);\n      if (match) {\n        var html = \"\",\n          index,\n          lastIndex = 0;\n        for (index = match.index; index < text.length; index++) {\n          switch (text.charCodeAt(index)) {\n            case 34:\n              match = \"&quot;\";\n              break;\n            case 38:\n              match = \"&amp;\";\n              break;\n            case 39:\n              match = \"&#x27;\";\n              break;\n            case 60:\n              match = \"&lt;\";\n              break;\n            case 62:\n              match = \"&gt;\";\n              break;\n            default:\n              continue;\n          }\n          lastIndex !== index && (html += text.slice(lastIndex, index));\n          lastIndex = index + 1;\n          html += match;\n        }\n        text = lastIndex !== index ? html + text.slice(lastIndex, index) : html;\n      }\n      return text;\n    }\n    function sanitizeURL(url) {\n      return isJavaScriptProtocol.test(\"\" + url)\n        ? \"javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')\"\n        : url;\n    }\n    function escapeEntireInlineScriptContent(scriptText) {\n      checkHtmlStringCoercion(scriptText);\n      return (\"\" + scriptText).replace(scriptRegex, scriptReplacer);\n    }\n    function createResumableState(\n      identifierPrefix,\n      externalRuntimeConfig,\n      bootstrapScriptContent,\n      bootstrapScripts,\n      bootstrapModules\n    ) {\n      return {\n        idPrefix: void 0 === identifierPrefix ? \"\" : identifierPrefix,\n        nextFormID: 0,\n        streamingFormat: 0,\n        bootstrapScriptContent: bootstrapScriptContent,\n        bootstrapScripts: bootstrapScripts,\n        bootstrapModules: bootstrapModules,\n        instructions: NothingSent,\n        hasBody: !1,\n        hasHtml: !1,\n        unknownResources: {},\n        dnsResources: {},\n        connectResources: { default: {}, anonymous: {}, credentials: {} },\n        imageResources: {},\n        styleResources: {},\n        scriptResources: {},\n        moduleUnknownResources: {},\n        moduleScriptResources: {}\n      };\n    }\n    function createFormatContext(\n      insertionMode,\n      selectedValue,\n      tagScope,\n      viewTransition\n    ) {\n      return {\n        insertionMode: insertionMode,\n        selectedValue: selectedValue,\n        tagScope: tagScope,\n        viewTransition: viewTransition\n      };\n    }\n    function getChildFormatContext(parentContext, type, props) {\n      var subtreeScope = parentContext.tagScope & -25;\n      switch (type) {\n        case \"noscript\":\n          return createFormatContext(HTML_MODE, null, subtreeScope | 1, null);\n        case \"select\":\n          return createFormatContext(\n            HTML_MODE,\n            null != props.value ? props.value : props.defaultValue,\n            subtreeScope,\n            null\n          );\n        case \"svg\":\n          return createFormatContext(SVG_MODE, null, subtreeScope, null);\n        case \"picture\":\n          return createFormatContext(HTML_MODE, null, subtreeScope | 2, null);\n        case \"math\":\n          return createFormatContext(MATHML_MODE, null, subtreeScope, null);\n        case \"foreignObject\":\n          return createFormatContext(HTML_MODE, null, subtreeScope, null);\n        case \"table\":\n          return createFormatContext(HTML_TABLE_MODE, null, subtreeScope, null);\n        case \"thead\":\n        case \"tbody\":\n        case \"tfoot\":\n          return createFormatContext(\n            HTML_TABLE_BODY_MODE,\n            null,\n            subtreeScope,\n            null\n          );\n        case \"colgroup\":\n          return createFormatContext(\n            HTML_COLGROUP_MODE,\n            null,\n            subtreeScope,\n            null\n          );\n        case \"tr\":\n          return createFormatContext(\n            HTML_TABLE_ROW_MODE,\n            null,\n            subtreeScope,\n            null\n          );\n        case \"head\":\n          if (parentContext.insertionMode < HTML_MODE)\n            return createFormatContext(\n              HTML_HEAD_MODE,\n              null,\n              subtreeScope,\n              null\n            );\n          break;\n        case \"html\":\n          if (parentContext.insertionMode === ROOT_HTML_MODE)\n            return createFormatContext(\n              HTML_HTML_MODE,\n              null,\n              subtreeScope,\n              null\n            );\n      }\n      return parentContext.insertionMode >= HTML_TABLE_MODE ||\n        parentContext.insertionMode < HTML_MODE\n        ? createFormatContext(HTML_MODE, null, subtreeScope, null)\n        : parentContext.tagScope !== subtreeScope\n          ? createFormatContext(\n              parentContext.insertionMode,\n              parentContext.selectedValue,\n              subtreeScope,\n              null\n            )\n          : parentContext;\n    }\n    function getSuspenseViewTransition(parentViewTransition) {\n      return null === parentViewTransition\n        ? null\n        : {\n            update: parentViewTransition.update,\n            enter: \"none\",\n            exit: \"none\",\n            share: parentViewTransition.update,\n            name: parentViewTransition.autoName,\n            autoName: parentViewTransition.autoName,\n            nameIdx: 0\n          };\n    }\n    function getSuspenseFallbackFormatContext(resumableState, parentContext) {\n      parentContext.tagScope & 32 && (resumableState.instructions |= 128);\n      return createFormatContext(\n        parentContext.insertionMode,\n        parentContext.selectedValue,\n        parentContext.tagScope | 12,\n        getSuspenseViewTransition(parentContext.viewTransition)\n      );\n    }\n    function getSuspenseContentFormatContext(resumableState, parentContext) {\n      resumableState = getSuspenseViewTransition(parentContext.viewTransition);\n      var subtreeScope = parentContext.tagScope | 16;\n      null !== resumableState &&\n        \"none\" !== resumableState.share &&\n        (subtreeScope |= 64);\n      return createFormatContext(\n        parentContext.insertionMode,\n        parentContext.selectedValue,\n        subtreeScope,\n        resumableState\n      );\n    }\n    function pushStyleAttribute(target, style) {\n      if (\"object\" !== typeof style)\n        throw Error(\n          \"The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.\"\n        );\n      var isFirst = !0,\n        styleName;\n      for (styleName in style)\n        if (hasOwnProperty.call(style, styleName)) {\n          var styleValue = style[styleName];\n          if (\n            null != styleValue &&\n            \"boolean\" !== typeof styleValue &&\n            \"\" !== styleValue\n          ) {\n            if (0 === styleName.indexOf(\"--\")) {\n              var nameChunk = escapeTextForBrowser(styleName);\n              checkCSSPropertyStringCoercion(styleValue, styleName);\n              styleValue = escapeTextForBrowser((\"\" + styleValue).trim());\n            } else {\n              nameChunk = styleName;\n              var value = styleValue;\n              if (-1 < nameChunk.indexOf(\"-\")) {\n                var name = nameChunk;\n                (warnedStyleNames.hasOwnProperty(name) &&\n                  warnedStyleNames[name]) ||\n                  ((warnedStyleNames[name] = !0),\n                  console.error(\n                    \"Unsupported style property %s. Did you mean %s?\",\n                    name,\n                    camelize(name.replace(msPattern$1, \"ms-\"))\n                  ));\n              } else if (badVendoredStyleNamePattern.test(nameChunk))\n                (name = nameChunk),\n                  (warnedStyleNames.hasOwnProperty(name) &&\n                    warnedStyleNames[name]) ||\n                    ((warnedStyleNames[name] = !0),\n                    console.error(\n                      \"Unsupported vendor-prefixed style property %s. Did you mean %s?\",\n                      name,\n                      name.charAt(0).toUpperCase() + name.slice(1)\n                    ));\n              else if (badStyleValueWithSemicolonPattern.test(value)) {\n                name = nameChunk;\n                var value$jscomp$0 = value;\n                (warnedStyleValues.hasOwnProperty(value$jscomp$0) &&\n                  warnedStyleValues[value$jscomp$0]) ||\n                  ((warnedStyleValues[value$jscomp$0] = !0),\n                  console.error(\n                    'Style property values shouldn\\'t contain a semicolon. Try \"%s: %s\" instead.',\n                    name,\n                    value$jscomp$0.replace(\n                      badStyleValueWithSemicolonPattern,\n                      \"\"\n                    )\n                  ));\n              }\n              \"number\" === typeof value &&\n                (isNaN(value)\n                  ? warnedForNaNValue ||\n                    ((warnedForNaNValue = !0),\n                    console.error(\n                      \"`NaN` is an invalid value for the `%s` css style property.\",\n                      nameChunk\n                    ))\n                  : isFinite(value) ||\n                    warnedForInfinityValue ||\n                    ((warnedForInfinityValue = !0),\n                    console.error(\n                      \"`Infinity` is an invalid value for the `%s` css style property.\",\n                      nameChunk\n                    )));\n              nameChunk = styleName;\n              value = styleNameCache.get(nameChunk);\n              void 0 !== value\n                ? (nameChunk = value)\n                : ((value = escapeTextForBrowser(\n                    nameChunk\n                      .replace(uppercasePattern, \"-$1\")\n                      .toLowerCase()\n                      .replace(msPattern, \"-ms-\")\n                  )),\n                  styleNameCache.set(nameChunk, value),\n                  (nameChunk = value));\n              \"number\" === typeof styleValue\n                ? (styleValue =\n                    0 === styleValue || unitlessNumbers.has(styleName)\n                      ? \"\" + styleValue\n                      : styleValue + \"px\")\n                : (checkCSSPropertyStringCoercion(styleValue, styleName),\n                  (styleValue = escapeTextForBrowser(\n                    (\"\" + styleValue).trim()\n                  )));\n            }\n            isFirst\n              ? ((isFirst = !1),\n                target.push(\n                  styleAttributeStart,\n                  nameChunk,\n                  styleAssign,\n                  styleValue\n                ))\n              : target.push(styleSeparator, nameChunk, styleAssign, styleValue);\n          }\n        }\n      isFirst || target.push(attributeEnd);\n    }\n    function pushBooleanAttribute(target, name, value) {\n      value &&\n        \"function\" !== typeof value &&\n        \"symbol\" !== typeof value &&\n        target.push(attributeSeparator, name, attributeEmptyString);\n    }\n    function pushStringAttribute(target, name, value) {\n      \"function\" !== typeof value &&\n        \"symbol\" !== typeof value &&\n        \"boolean\" !== typeof value &&\n        target.push(\n          attributeSeparator,\n          name,\n          attributeAssign,\n          escapeTextForBrowser(value),\n          attributeEnd\n        );\n    }\n    function pushAdditionalFormField(value, key) {\n      this.push('<input type=\"hidden\"');\n      validateAdditionalFormField(value);\n      pushStringAttribute(this, \"name\", key);\n      pushStringAttribute(this, \"value\", value);\n      this.push(endOfStartTagSelfClosing);\n    }\n    function validateAdditionalFormField(value) {\n      if (\"string\" !== typeof value)\n        throw Error(\n          \"File/Blob fields are not yet supported in progressive forms. Will fallback to client hydration.\"\n        );\n    }\n    function getCustomFormFields(resumableState, formAction) {\n      if (\"function\" === typeof formAction.$$FORM_ACTION) {\n        var id = resumableState.nextFormID++;\n        resumableState = resumableState.idPrefix + id;\n        try {\n          var customFields = formAction.$$FORM_ACTION(resumableState);\n          if (customFields) {\n            var formData = customFields.data;\n            null != formData && formData.forEach(validateAdditionalFormField);\n          }\n          return customFields;\n        } catch (x) {\n          if (\n            \"object\" === typeof x &&\n            null !== x &&\n            \"function\" === typeof x.then\n          )\n            throw x;\n          console.error(\n            \"Failed to serialize an action for progressive enhancement:\\n%s\",\n            x\n          );\n        }\n      }\n      return null;\n    }\n    function pushFormActionAttribute(\n      target,\n      resumableState,\n      renderState,\n      formAction,\n      formEncType,\n      formMethod,\n      formTarget,\n      name\n    ) {\n      var formData = null;\n      if (\"function\" === typeof formAction) {\n        null === name ||\n          didWarnFormActionName ||\n          ((didWarnFormActionName = !0),\n          console.error(\n            'Cannot specify a \"name\" prop for a button that specifies a function as a formAction. React needs it to encode which action should be invoked. It will get overridden.'\n          ));\n        (null === formEncType && null === formMethod) ||\n          didWarnFormActionMethod ||\n          ((didWarnFormActionMethod = !0),\n          console.error(\n            \"Cannot specify a formEncType or formMethod for a button that specifies a function as a formAction. React provides those automatically. They will get overridden.\"\n          ));\n        null === formTarget ||\n          didWarnFormActionTarget ||\n          ((didWarnFormActionTarget = !0),\n          console.error(\n            \"Cannot specify a formTarget for a button that specifies a function as a formAction. The function will always be executed in the same window.\"\n          ));\n        var customFields = getCustomFormFields(resumableState, formAction);\n        null !== customFields\n          ? ((name = customFields.name),\n            (formAction = customFields.action || \"\"),\n            (formEncType = customFields.encType),\n            (formMethod = customFields.method),\n            (formTarget = customFields.target),\n            (formData = customFields.data))\n          : (target.push(\n              attributeSeparator,\n              \"formAction\",\n              attributeAssign,\n              actionJavaScriptURL,\n              attributeEnd\n            ),\n            (formTarget = formMethod = formEncType = formAction = name = null),\n            injectFormReplayingRuntime(resumableState, renderState));\n      }\n      null != name && pushAttribute(target, \"name\", name);\n      null != formAction && pushAttribute(target, \"formAction\", formAction);\n      null != formEncType && pushAttribute(target, \"formEncType\", formEncType);\n      null != formMethod && pushAttribute(target, \"formMethod\", formMethod);\n      null != formTarget && pushAttribute(target, \"formTarget\", formTarget);\n      return formData;\n    }\n    function pushAttribute(target, name, value) {\n      switch (name) {\n        case \"className\":\n          pushStringAttribute(target, \"class\", value);\n          break;\n        case \"tabIndex\":\n          pushStringAttribute(target, \"tabindex\", value);\n          break;\n        case \"dir\":\n        case \"role\":\n        case \"viewBox\":\n        case \"width\":\n        case \"height\":\n          pushStringAttribute(target, name, value);\n          break;\n        case \"style\":\n          pushStyleAttribute(target, value);\n          break;\n        case \"src\":\n        case \"href\":\n          if (\"\" === value) {\n            \"src\" === name\n              ? console.error(\n                  'An empty string (\"\") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',\n                  name,\n                  name\n                )\n              : console.error(\n                  'An empty string (\"\") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',\n                  name,\n                  name\n                );\n            break;\n          }\n        case \"action\":\n        case \"formAction\":\n          if (\n            null == value ||\n            \"function\" === typeof value ||\n            \"symbol\" === typeof value ||\n            \"boolean\" === typeof value\n          )\n            break;\n          checkAttributeStringCoercion(value, name);\n          value = sanitizeURL(\"\" + value);\n          target.push(\n            attributeSeparator,\n            name,\n            attributeAssign,\n            escapeTextForBrowser(value),\n            attributeEnd\n          );\n          break;\n        case \"defaultValue\":\n        case \"defaultChecked\":\n        case \"innerHTML\":\n        case \"suppressContentEditableWarning\":\n        case \"suppressHydrationWarning\":\n        case \"ref\":\n          break;\n        case \"autoFocus\":\n        case \"multiple\":\n        case \"muted\":\n          pushBooleanAttribute(target, name.toLowerCase(), value);\n          break;\n        case \"xlinkHref\":\n          if (\n            \"function\" === typeof value ||\n            \"symbol\" === typeof value ||\n            \"boolean\" === typeof value\n          )\n            break;\n          checkAttributeStringCoercion(value, name);\n          value = sanitizeURL(\"\" + value);\n          target.push(\n            attributeSeparator,\n            \"xlink:href\",\n            attributeAssign,\n            escapeTextForBrowser(value),\n            attributeEnd\n          );\n          break;\n        case \"contentEditable\":\n        case \"spellCheck\":\n        case \"draggable\":\n        case \"value\":\n        case \"autoReverse\":\n        case \"externalResourcesRequired\":\n        case \"focusable\":\n        case \"preserveAlpha\":\n          \"function\" !== typeof value &&\n            \"symbol\" !== typeof value &&\n            target.push(\n              attributeSeparator,\n              name,\n              attributeAssign,\n              escapeTextForBrowser(value),\n              attributeEnd\n            );\n          break;\n        case \"inert\":\n          \"\" !== value ||\n            didWarnForNewBooleanPropsWithEmptyValue[name] ||\n            ((didWarnForNewBooleanPropsWithEmptyValue[name] = !0),\n            console.error(\n              \"Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.\",\n              name\n            ));\n        case \"allowFullScreen\":\n        case \"async\":\n        case \"autoPlay\":\n        case \"controls\":\n        case \"default\":\n        case \"defer\":\n        case \"disabled\":\n        case \"disablePictureInPicture\":\n        case \"disableRemotePlayback\":\n        case \"formNoValidate\":\n        case \"hidden\":\n        case \"loop\":\n        case \"noModule\":\n        case \"noValidate\":\n        case \"open\":\n        case \"playsInline\":\n        case \"readOnly\":\n        case \"required\":\n        case \"reversed\":\n        case \"scoped\":\n        case \"seamless\":\n        case \"itemScope\":\n          value &&\n            \"function\" !== typeof value &&\n            \"symbol\" !== typeof value &&\n            target.push(attributeSeparator, name, attributeEmptyString);\n          break;\n        case \"capture\":\n        case \"download\":\n          !0 === value\n            ? target.push(attributeSeparator, name, attributeEmptyString)\n            : !1 !== value &&\n              \"function\" !== typeof value &&\n              \"symbol\" !== typeof value &&\n              target.push(\n                attributeSeparator,\n                name,\n                attributeAssign,\n                escapeTextForBrowser(value),\n                attributeEnd\n              );\n          break;\n        case \"cols\":\n        case \"rows\":\n        case \"size\":\n        case \"span\":\n          \"function\" !== typeof value &&\n            \"symbol\" !== typeof value &&\n            !isNaN(value) &&\n            1 <= value &&\n            target.push(\n              attributeSeparator,\n              name,\n              attributeAssign,\n              escapeTextForBrowser(value),\n              attributeEnd\n            );\n          break;\n        case \"rowSpan\":\n        case \"start\":\n          \"function\" === typeof value ||\n            \"symbol\" === typeof value ||\n            isNaN(value) ||\n            target.push(\n              attributeSeparator,\n              name,\n              attributeAssign,\n              escapeTextForBrowser(value),\n              attributeEnd\n            );\n          break;\n        case \"xlinkActuate\":\n          pushStringAttribute(target, \"xlink:actuate\", value);\n          break;\n        case \"xlinkArcrole\":\n          pushStringAttribute(target, \"xlink:arcrole\", value);\n          break;\n        case \"xlinkRole\":\n          pushStringAttribute(target, \"xlink:role\", value);\n          break;\n        case \"xlinkShow\":\n          pushStringAttribute(target, \"xlink:show\", value);\n          break;\n        case \"xlinkTitle\":\n          pushStringAttribute(target, \"xlink:title\", value);\n          break;\n        case \"xlinkType\":\n          pushStringAttribute(target, \"xlink:type\", value);\n          break;\n        case \"xmlBase\":\n          pushStringAttribute(target, \"xml:base\", value);\n          break;\n        case \"xmlLang\":\n          pushStringAttribute(target, \"xml:lang\", value);\n          break;\n        case \"xmlSpace\":\n          pushStringAttribute(target, \"xml:space\", value);\n          break;\n        default:\n          if (\n            !(2 < name.length) ||\n            (\"o\" !== name[0] && \"O\" !== name[0]) ||\n            (\"n\" !== name[1] && \"N\" !== name[1])\n          )\n            if (\n              ((name = aliases.get(name) || name), isAttributeNameSafe(name))\n            ) {\n              switch (typeof value) {\n                case \"function\":\n                case \"symbol\":\n                  return;\n                case \"boolean\":\n                  var prefix = name.toLowerCase().slice(0, 5);\n                  if (\"data-\" !== prefix && \"aria-\" !== prefix) return;\n              }\n              target.push(\n                attributeSeparator,\n                name,\n                attributeAssign,\n                escapeTextForBrowser(value),\n                attributeEnd\n              );\n            }\n      }\n    }\n    function pushInnerHTML(target, innerHTML, children) {\n      if (null != innerHTML) {\n        if (null != children)\n          throw Error(\n            \"Can only set one of `children` or `props.dangerouslySetInnerHTML`.\"\n          );\n        if (\"object\" !== typeof innerHTML || !(\"__html\" in innerHTML))\n          throw Error(\n            \"`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information.\"\n          );\n        innerHTML = innerHTML.__html;\n        null !== innerHTML &&\n          void 0 !== innerHTML &&\n          (checkHtmlStringCoercion(innerHTML), target.push(\"\" + innerHTML));\n      }\n    }\n    function checkSelectProp(props, propName) {\n      var value = props[propName];\n      null != value &&\n        ((value = isArrayImpl(value)),\n        props.multiple && !value\n          ? console.error(\n              \"The `%s` prop supplied to <select> must be an array if `multiple` is true.\",\n              propName\n            )\n          : !props.multiple &&\n            value &&\n            console.error(\n              \"The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.\",\n              propName\n            ));\n    }\n    function flattenOptionChildren(children) {\n      var content = \"\";\n      React.Children.forEach(children, function (child) {\n        null != child &&\n          ((content += child),\n          didWarnInvalidOptionChildren ||\n            \"string\" === typeof child ||\n            \"number\" === typeof child ||\n            \"bigint\" === typeof child ||\n            ((didWarnInvalidOptionChildren = !0),\n            console.error(\n              \"Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.\"\n            )));\n      });\n      return content;\n    }\n    function injectFormReplayingRuntime(resumableState, renderState) {\n      if ((resumableState.instructions & 16) === NothingSent) {\n        resumableState.instructions |= 16;\n        var preamble = renderState.preamble,\n          bootstrapChunks = renderState.bootstrapChunks;\n        (preamble.htmlChunks || preamble.headChunks) &&\n        0 === bootstrapChunks.length\n          ? (bootstrapChunks.push(renderState.startInlineScript),\n            pushCompletedShellIdAttribute(bootstrapChunks, resumableState),\n            bootstrapChunks.push(\n              endOfStartTag,\n              formReplayingRuntimeScript,\n              endInlineScript\n            ))\n          : bootstrapChunks.unshift(\n              renderState.startInlineScript,\n              endOfStartTag,\n              formReplayingRuntimeScript,\n              endInlineScript\n            );\n      }\n    }\n    function pushLinkImpl(target, props) {\n      target.push(startChunkForTag(\"link\"));\n      for (var propKey in props)\n        if (hasOwnProperty.call(props, propKey)) {\n          var propValue = props[propKey];\n          if (null != propValue)\n            switch (propKey) {\n              case \"children\":\n              case \"dangerouslySetInnerHTML\":\n                throw Error(\n                  \"link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.\"\n                );\n              default:\n                pushAttribute(target, propKey, propValue);\n            }\n        }\n      target.push(endOfStartTagSelfClosing);\n      return null;\n    }\n    function escapeStyleTextContent(styleText) {\n      checkHtmlStringCoercion(styleText);\n      return (\"\" + styleText).replace(styleRegex, styleReplacer);\n    }\n    function pushSelfClosing(target, props, tag) {\n      target.push(startChunkForTag(tag));\n      for (var propKey in props)\n        if (hasOwnProperty.call(props, propKey)) {\n          var propValue = props[propKey];\n          if (null != propValue)\n            switch (propKey) {\n              case \"children\":\n              case \"dangerouslySetInnerHTML\":\n                throw Error(\n                  tag +\n                    \" is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.\"\n                );\n              default:\n                pushAttribute(target, propKey, propValue);\n            }\n        }\n      target.push(endOfStartTagSelfClosing);\n      return null;\n    }\n    function pushTitleImpl(target, props) {\n      target.push(startChunkForTag(\"title\"));\n      var children = null,\n        innerHTML = null,\n        propKey;\n      for (propKey in props)\n        if (hasOwnProperty.call(props, propKey)) {\n          var propValue = props[propKey];\n          if (null != propValue)\n            switch (propKey) {\n              case \"children\":\n                children = propValue;\n                break;\n              case \"dangerouslySetInnerHTML\":\n                innerHTML = propValue;\n                break;\n              default:\n                pushAttribute(target, propKey, propValue);\n            }\n        }\n      target.push(endOfStartTag);\n      props = Array.isArray(children)\n        ? 2 > children.length\n          ? children[0]\n          : null\n        : children;\n      \"function\" !== typeof props &&\n        \"symbol\" !== typeof props &&\n        null !== props &&\n        void 0 !== props &&\n        target.push(escapeTextForBrowser(\"\" + props));\n      pushInnerHTML(target, innerHTML, children);\n      target.push(endChunkForTag(\"title\"));\n      return null;\n    }\n    function pushScriptImpl(target, props) {\n      target.push(startChunkForTag(\"script\"));\n      var children = null,\n        innerHTML = null,\n        propKey;\n      for (propKey in props)\n        if (hasOwnProperty.call(props, propKey)) {\n          var propValue = props[propKey];\n          if (null != propValue)\n            switch (propKey) {\n              case \"children\":\n                children = propValue;\n                break;\n              case \"dangerouslySetInnerHTML\":\n                innerHTML = propValue;\n                break;\n              default:\n                pushAttribute(target, propKey, propValue);\n            }\n        }\n      target.push(endOfStartTag);\n      null != children &&\n        \"string\" !== typeof children &&\n        ((props =\n          \"number\" === typeof children\n            ? \"a number for children\"\n            : Array.isArray(children)\n              ? \"an array for children\"\n              : \"something unexpected for children\"),\n        console.error(\n          \"A script element was rendered with %s. If script element has children it must be a single string. Consider using dangerouslySetInnerHTML or passing a plain string as children.\",\n          props\n        ));\n      pushInnerHTML(target, innerHTML, children);\n      \"string\" === typeof children &&\n        target.push(escapeEntireInlineScriptContent(children));\n      target.push(endChunkForTag(\"script\"));\n      return null;\n    }\n    function pushStartSingletonElement(target, props, tag) {\n      target.push(startChunkForTag(tag));\n      var innerHTML = (tag = null),\n        propKey;\n      for (propKey in props)\n        if (hasOwnProperty.call(props, propKey)) {\n          var propValue = props[propKey];\n          if (null != propValue)\n            switch (propKey) {\n              case \"children\":\n                tag = propValue;\n                break;\n              case \"dangerouslySetInnerHTML\":\n                innerHTML = propValue;\n                break;\n              default:\n                pushAttribute(target, propKey, propValue);\n            }\n        }\n      target.push(endOfStartTag);\n      pushInnerHTML(target, innerHTML, tag);\n      return tag;\n    }\n    function pushStartGenericElement(target, props, tag) {\n      target.push(startChunkForTag(tag));\n      var innerHTML = (tag = null),\n        propKey;\n      for (propKey in props)\n        if (hasOwnProperty.call(props, propKey)) {\n          var propValue = props[propKey];\n          if (null != propValue)\n            switch (propKey) {\n              case \"children\":\n                tag = propValue;\n                break;\n              case \"dangerouslySetInnerHTML\":\n                innerHTML = propValue;\n                break;\n              default:\n                pushAttribute(target, propKey, propValue);\n            }\n        }\n      target.push(endOfStartTag);\n      pushInnerHTML(target, innerHTML, tag);\n      return \"string\" === typeof tag\n        ? (target.push(escapeTextForBrowser(tag)), null)\n        : tag;\n    }\n    function startChunkForTag(tag) {\n      var tagStartChunk = validatedTagCache.get(tag);\n      if (void 0 === tagStartChunk) {\n        if (!VALID_TAG_REGEX.test(tag)) throw Error(\"Invalid tag: \" + tag);\n        tagStartChunk = \"<\" + tag;\n        validatedTagCache.set(tag, tagStartChunk);\n      }\n      return tagStartChunk;\n    }\n    function pushStartInstance(\n      target$jscomp$0,\n      type,\n      props,\n      resumableState,\n      renderState,\n      preambleState,\n      hoistableState,\n      formatContext,\n      textEmbedded\n    ) {\n      validateProperties$2(type, props);\n      (\"input\" !== type && \"textarea\" !== type && \"select\" !== type) ||\n        null == props ||\n        null !== props.value ||\n        didWarnValueNull ||\n        ((didWarnValueNull = !0),\n        \"select\" === type && props.multiple\n          ? console.error(\n              \"`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.\",\n              type\n            )\n          : console.error(\n              \"`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.\",\n              type\n            ));\n      b: if (-1 === type.indexOf(\"-\")) var JSCompiler_inline_result = !1;\n      else\n        switch (type) {\n          case \"annotation-xml\":\n          case \"color-profile\":\n          case \"font-face\":\n          case \"font-face-src\":\n          case \"font-face-uri\":\n          case \"font-face-format\":\n          case \"font-face-name\":\n          case \"missing-glyph\":\n            JSCompiler_inline_result = !1;\n            break b;\n          default:\n            JSCompiler_inline_result = !0;\n        }\n      JSCompiler_inline_result ||\n        \"string\" === typeof props.is ||\n        warnUnknownProperties(type, props, null);\n      !props.suppressContentEditableWarning &&\n        props.contentEditable &&\n        null != props.children &&\n        console.error(\n          \"A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.\"\n        );\n      formatContext.insertionMode !== SVG_MODE &&\n        formatContext.insertionMode !== MATHML_MODE &&\n        -1 === type.indexOf(\"-\") &&\n        type.toLowerCase() !== type &&\n        console.error(\n          \"<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.\",\n          type\n        );\n      switch (type) {\n        case \"div\":\n        case \"span\":\n        case \"svg\":\n        case \"path\":\n          break;\n        case \"a\":\n          target$jscomp$0.push(startChunkForTag(\"a\"));\n          var children = null,\n            innerHTML = null,\n            propKey;\n          for (propKey in props)\n            if (hasOwnProperty.call(props, propKey)) {\n              var propValue = props[propKey];\n              if (null != propValue)\n                switch (propKey) {\n                  case \"children\":\n                    children = propValue;\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    innerHTML = propValue;\n                    break;\n                  case \"href\":\n                    \"\" === propValue\n                      ? pushStringAttribute(target$jscomp$0, \"href\", \"\")\n                      : pushAttribute(target$jscomp$0, propKey, propValue);\n                    break;\n                  default:\n                    pushAttribute(target$jscomp$0, propKey, propValue);\n                }\n            }\n          target$jscomp$0.push(endOfStartTag);\n          pushInnerHTML(target$jscomp$0, innerHTML, children);\n          if (\"string\" === typeof children) {\n            target$jscomp$0.push(escapeTextForBrowser(children));\n            var JSCompiler_inline_result$jscomp$0 = null;\n          } else JSCompiler_inline_result$jscomp$0 = children;\n          return JSCompiler_inline_result$jscomp$0;\n        case \"g\":\n        case \"p\":\n        case \"li\":\n          break;\n        case \"select\":\n          checkControlledValueProps(\"select\", props);\n          checkSelectProp(props, \"value\");\n          checkSelectProp(props, \"defaultValue\");\n          void 0 === props.value ||\n            void 0 === props.defaultValue ||\n            didWarnDefaultSelectValue ||\n            (console.error(\n              \"Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://react.dev/link/controlled-components\"\n            ),\n            (didWarnDefaultSelectValue = !0));\n          target$jscomp$0.push(startChunkForTag(\"select\"));\n          var children$jscomp$0 = null,\n            innerHTML$jscomp$0 = null,\n            propKey$jscomp$0;\n          for (propKey$jscomp$0 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$0)) {\n              var propValue$jscomp$0 = props[propKey$jscomp$0];\n              if (null != propValue$jscomp$0)\n                switch (propKey$jscomp$0) {\n                  case \"children\":\n                    children$jscomp$0 = propValue$jscomp$0;\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    innerHTML$jscomp$0 = propValue$jscomp$0;\n                    break;\n                  case \"defaultValue\":\n                  case \"value\":\n                    break;\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$0,\n                      propValue$jscomp$0\n                    );\n                }\n            }\n          target$jscomp$0.push(endOfStartTag);\n          pushInnerHTML(target$jscomp$0, innerHTML$jscomp$0, children$jscomp$0);\n          return children$jscomp$0;\n        case \"option\":\n          var selectedValue = formatContext.selectedValue;\n          target$jscomp$0.push(startChunkForTag(\"option\"));\n          var children$jscomp$1 = null,\n            value = null,\n            selected = null,\n            innerHTML$jscomp$1 = null,\n            propKey$jscomp$1;\n          for (propKey$jscomp$1 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$1)) {\n              var propValue$jscomp$1 = props[propKey$jscomp$1];\n              if (null != propValue$jscomp$1)\n                switch (propKey$jscomp$1) {\n                  case \"children\":\n                    children$jscomp$1 = propValue$jscomp$1;\n                    break;\n                  case \"selected\":\n                    selected = propValue$jscomp$1;\n                    didWarnSelectedSetOnOption ||\n                      (console.error(\n                        \"Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.\"\n                      ),\n                      (didWarnSelectedSetOnOption = !0));\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    innerHTML$jscomp$1 = propValue$jscomp$1;\n                    break;\n                  case \"value\":\n                    value = propValue$jscomp$1;\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$1,\n                      propValue$jscomp$1\n                    );\n                }\n            }\n          if (null != selectedValue) {\n            if (null !== value) {\n              checkAttributeStringCoercion(value, \"value\");\n              var stringValue = \"\" + value;\n            } else\n              null === innerHTML$jscomp$1 ||\n                didWarnInvalidOptionInnerHTML ||\n                ((didWarnInvalidOptionInnerHTML = !0),\n                console.error(\n                  \"Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.\"\n                )),\n                (stringValue = flattenOptionChildren(children$jscomp$1));\n            if (isArrayImpl(selectedValue))\n              for (var i = 0; i < selectedValue.length; i++) {\n                if (\n                  (checkAttributeStringCoercion(selectedValue[i], \"value\"),\n                  \"\" + selectedValue[i] === stringValue)\n                ) {\n                  target$jscomp$0.push(' selected=\"\"');\n                  break;\n                }\n              }\n            else\n              checkAttributeStringCoercion(selectedValue, \"select.value\"),\n                \"\" + selectedValue === stringValue &&\n                  target$jscomp$0.push(' selected=\"\"');\n          } else selected && target$jscomp$0.push(' selected=\"\"');\n          target$jscomp$0.push(endOfStartTag);\n          pushInnerHTML(target$jscomp$0, innerHTML$jscomp$1, children$jscomp$1);\n          return children$jscomp$1;\n        case \"textarea\":\n          checkControlledValueProps(\"textarea\", props);\n          void 0 === props.value ||\n            void 0 === props.defaultValue ||\n            didWarnDefaultTextareaValue ||\n            (console.error(\n              \"Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://react.dev/link/controlled-components\"\n            ),\n            (didWarnDefaultTextareaValue = !0));\n          target$jscomp$0.push(startChunkForTag(\"textarea\"));\n          var value$jscomp$0 = null,\n            defaultValue = null,\n            children$jscomp$2 = null,\n            propKey$jscomp$2;\n          for (propKey$jscomp$2 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$2)) {\n              var propValue$jscomp$2 = props[propKey$jscomp$2];\n              if (null != propValue$jscomp$2)\n                switch (propKey$jscomp$2) {\n                  case \"children\":\n                    children$jscomp$2 = propValue$jscomp$2;\n                    break;\n                  case \"value\":\n                    value$jscomp$0 = propValue$jscomp$2;\n                    break;\n                  case \"defaultValue\":\n                    defaultValue = propValue$jscomp$2;\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    throw Error(\n                      \"`dangerouslySetInnerHTML` does not make sense on <textarea>.\"\n                    );\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$2,\n                      propValue$jscomp$2\n                    );\n                }\n            }\n          null === value$jscomp$0 &&\n            null !== defaultValue &&\n            (value$jscomp$0 = defaultValue);\n          target$jscomp$0.push(endOfStartTag);\n          if (null != children$jscomp$2) {\n            console.error(\n              \"Use the `defaultValue` or `value` props instead of setting children on <textarea>.\"\n            );\n            if (null != value$jscomp$0)\n              throw Error(\n                \"If you supply `defaultValue` on a <textarea>, do not pass children.\"\n              );\n            if (isArrayImpl(children$jscomp$2)) {\n              if (1 < children$jscomp$2.length)\n                throw Error(\"<textarea> can only have at most one child.\");\n              checkHtmlStringCoercion(children$jscomp$2[0]);\n              value$jscomp$0 = \"\" + children$jscomp$2[0];\n            }\n            checkHtmlStringCoercion(children$jscomp$2);\n            value$jscomp$0 = \"\" + children$jscomp$2;\n          }\n          \"string\" === typeof value$jscomp$0 &&\n            \"\\n\" === value$jscomp$0[0] &&\n            target$jscomp$0.push(leadingNewline);\n          null !== value$jscomp$0 &&\n            (checkAttributeStringCoercion(value$jscomp$0, \"value\"),\n            target$jscomp$0.push(escapeTextForBrowser(\"\" + value$jscomp$0)));\n          return null;\n        case \"input\":\n          checkControlledValueProps(\"input\", props);\n          target$jscomp$0.push(startChunkForTag(\"input\"));\n          var name = null,\n            formAction = null,\n            formEncType = null,\n            formMethod = null,\n            formTarget = null,\n            value$jscomp$1 = null,\n            defaultValue$jscomp$0 = null,\n            checked = null,\n            defaultChecked = null,\n            propKey$jscomp$3;\n          for (propKey$jscomp$3 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$3)) {\n              var propValue$jscomp$3 = props[propKey$jscomp$3];\n              if (null != propValue$jscomp$3)\n                switch (propKey$jscomp$3) {\n                  case \"children\":\n                  case \"dangerouslySetInnerHTML\":\n                    throw Error(\n                      \"input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.\"\n                    );\n                  case \"name\":\n                    name = propValue$jscomp$3;\n                    break;\n                  case \"formAction\":\n                    formAction = propValue$jscomp$3;\n                    break;\n                  case \"formEncType\":\n                    formEncType = propValue$jscomp$3;\n                    break;\n                  case \"formMethod\":\n                    formMethod = propValue$jscomp$3;\n                    break;\n                  case \"formTarget\":\n                    formTarget = propValue$jscomp$3;\n                    break;\n                  case \"defaultChecked\":\n                    defaultChecked = propValue$jscomp$3;\n                    break;\n                  case \"defaultValue\":\n                    defaultValue$jscomp$0 = propValue$jscomp$3;\n                    break;\n                  case \"checked\":\n                    checked = propValue$jscomp$3;\n                    break;\n                  case \"value\":\n                    value$jscomp$1 = propValue$jscomp$3;\n                    break;\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$3,\n                      propValue$jscomp$3\n                    );\n                }\n            }\n          null === formAction ||\n            \"image\" === props.type ||\n            \"submit\" === props.type ||\n            didWarnFormActionType ||\n            ((didWarnFormActionType = !0),\n            console.error(\n              'An input can only specify a formAction along with type=\"submit\" or type=\"image\".'\n            ));\n          var formData = pushFormActionAttribute(\n            target$jscomp$0,\n            resumableState,\n            renderState,\n            formAction,\n            formEncType,\n            formMethod,\n            formTarget,\n            name\n          );\n          null === checked ||\n            null === defaultChecked ||\n            didWarnDefaultChecked ||\n            (console.error(\n              \"%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components\",\n              \"A component\",\n              props.type\n            ),\n            (didWarnDefaultChecked = !0));\n          null === value$jscomp$1 ||\n            null === defaultValue$jscomp$0 ||\n            didWarnDefaultInputValue ||\n            (console.error(\n              \"%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components\",\n              \"A component\",\n              props.type\n            ),\n            (didWarnDefaultInputValue = !0));\n          null !== checked\n            ? pushBooleanAttribute(target$jscomp$0, \"checked\", checked)\n            : null !== defaultChecked &&\n              pushBooleanAttribute(target$jscomp$0, \"checked\", defaultChecked);\n          null !== value$jscomp$1\n            ? pushAttribute(target$jscomp$0, \"value\", value$jscomp$1)\n            : null !== defaultValue$jscomp$0 &&\n              pushAttribute(target$jscomp$0, \"value\", defaultValue$jscomp$0);\n          target$jscomp$0.push(endOfStartTagSelfClosing);\n          null != formData &&\n            formData.forEach(pushAdditionalFormField, target$jscomp$0);\n          return null;\n        case \"button\":\n          target$jscomp$0.push(startChunkForTag(\"button\"));\n          var children$jscomp$3 = null,\n            innerHTML$jscomp$2 = null,\n            name$jscomp$0 = null,\n            formAction$jscomp$0 = null,\n            formEncType$jscomp$0 = null,\n            formMethod$jscomp$0 = null,\n            formTarget$jscomp$0 = null,\n            propKey$jscomp$4;\n          for (propKey$jscomp$4 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$4)) {\n              var propValue$jscomp$4 = props[propKey$jscomp$4];\n              if (null != propValue$jscomp$4)\n                switch (propKey$jscomp$4) {\n                  case \"children\":\n                    children$jscomp$3 = propValue$jscomp$4;\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    innerHTML$jscomp$2 = propValue$jscomp$4;\n                    break;\n                  case \"name\":\n                    name$jscomp$0 = propValue$jscomp$4;\n                    break;\n                  case \"formAction\":\n                    formAction$jscomp$0 = propValue$jscomp$4;\n                    break;\n                  case \"formEncType\":\n                    formEncType$jscomp$0 = propValue$jscomp$4;\n                    break;\n                  case \"formMethod\":\n                    formMethod$jscomp$0 = propValue$jscomp$4;\n                    break;\n                  case \"formTarget\":\n                    formTarget$jscomp$0 = propValue$jscomp$4;\n                    break;\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$4,\n                      propValue$jscomp$4\n                    );\n                }\n            }\n          null === formAction$jscomp$0 ||\n            null == props.type ||\n            \"submit\" === props.type ||\n            didWarnFormActionType ||\n            ((didWarnFormActionType = !0),\n            console.error(\n              'A button can only specify a formAction along with type=\"submit\" or no type.'\n            ));\n          var formData$jscomp$0 = pushFormActionAttribute(\n            target$jscomp$0,\n            resumableState,\n            renderState,\n            formAction$jscomp$0,\n            formEncType$jscomp$0,\n            formMethod$jscomp$0,\n            formTarget$jscomp$0,\n            name$jscomp$0\n          );\n          target$jscomp$0.push(endOfStartTag);\n          null != formData$jscomp$0 &&\n            formData$jscomp$0.forEach(pushAdditionalFormField, target$jscomp$0);\n          pushInnerHTML(target$jscomp$0, innerHTML$jscomp$2, children$jscomp$3);\n          if (\"string\" === typeof children$jscomp$3) {\n            target$jscomp$0.push(escapeTextForBrowser(children$jscomp$3));\n            var JSCompiler_inline_result$jscomp$1 = null;\n          } else JSCompiler_inline_result$jscomp$1 = children$jscomp$3;\n          return JSCompiler_inline_result$jscomp$1;\n        case \"form\":\n          target$jscomp$0.push(startChunkForTag(\"form\"));\n          var children$jscomp$4 = null,\n            innerHTML$jscomp$3 = null,\n            formAction$jscomp$1 = null,\n            formEncType$jscomp$1 = null,\n            formMethod$jscomp$1 = null,\n            formTarget$jscomp$1 = null,\n            propKey$jscomp$5;\n          for (propKey$jscomp$5 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$5)) {\n              var propValue$jscomp$5 = props[propKey$jscomp$5];\n              if (null != propValue$jscomp$5)\n                switch (propKey$jscomp$5) {\n                  case \"children\":\n                    children$jscomp$4 = propValue$jscomp$5;\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    innerHTML$jscomp$3 = propValue$jscomp$5;\n                    break;\n                  case \"action\":\n                    formAction$jscomp$1 = propValue$jscomp$5;\n                    break;\n                  case \"encType\":\n                    formEncType$jscomp$1 = propValue$jscomp$5;\n                    break;\n                  case \"method\":\n                    formMethod$jscomp$1 = propValue$jscomp$5;\n                    break;\n                  case \"target\":\n                    formTarget$jscomp$1 = propValue$jscomp$5;\n                    break;\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$5,\n                      propValue$jscomp$5\n                    );\n                }\n            }\n          var formData$jscomp$1 = null,\n            formActionName = null;\n          if (\"function\" === typeof formAction$jscomp$1) {\n            (null === formEncType$jscomp$1 && null === formMethod$jscomp$1) ||\n              didWarnFormActionMethod ||\n              ((didWarnFormActionMethod = !0),\n              console.error(\n                \"Cannot specify a encType or method for a form that specifies a function as the action. React provides those automatically. They will get overridden.\"\n              ));\n            null === formTarget$jscomp$1 ||\n              didWarnFormActionTarget ||\n              ((didWarnFormActionTarget = !0),\n              console.error(\n                \"Cannot specify a target for a form that specifies a function as the action. The function will always be executed in the same window.\"\n              ));\n            var customFields = getCustomFormFields(\n              resumableState,\n              formAction$jscomp$1\n            );\n            null !== customFields\n              ? ((formAction$jscomp$1 = customFields.action || \"\"),\n                (formEncType$jscomp$1 = customFields.encType),\n                (formMethod$jscomp$1 = customFields.method),\n                (formTarget$jscomp$1 = customFields.target),\n                (formData$jscomp$1 = customFields.data),\n                (formActionName = customFields.name))\n              : (target$jscomp$0.push(\n                  attributeSeparator,\n                  \"action\",\n                  attributeAssign,\n                  actionJavaScriptURL,\n                  attributeEnd\n                ),\n                (formTarget$jscomp$1 =\n                  formMethod$jscomp$1 =\n                  formEncType$jscomp$1 =\n                  formAction$jscomp$1 =\n                    null),\n                injectFormReplayingRuntime(resumableState, renderState));\n          }\n          null != formAction$jscomp$1 &&\n            pushAttribute(target$jscomp$0, \"action\", formAction$jscomp$1);\n          null != formEncType$jscomp$1 &&\n            pushAttribute(target$jscomp$0, \"encType\", formEncType$jscomp$1);\n          null != formMethod$jscomp$1 &&\n            pushAttribute(target$jscomp$0, \"method\", formMethod$jscomp$1);\n          null != formTarget$jscomp$1 &&\n            pushAttribute(target$jscomp$0, \"target\", formTarget$jscomp$1);\n          target$jscomp$0.push(endOfStartTag);\n          null !== formActionName &&\n            (target$jscomp$0.push('<input type=\"hidden\"'),\n            pushStringAttribute(target$jscomp$0, \"name\", formActionName),\n            target$jscomp$0.push(endOfStartTagSelfClosing),\n            null != formData$jscomp$1 &&\n              formData$jscomp$1.forEach(\n                pushAdditionalFormField,\n                target$jscomp$0\n              ));\n          pushInnerHTML(target$jscomp$0, innerHTML$jscomp$3, children$jscomp$4);\n          if (\"string\" === typeof children$jscomp$4) {\n            target$jscomp$0.push(escapeTextForBrowser(children$jscomp$4));\n            var JSCompiler_inline_result$jscomp$2 = null;\n          } else JSCompiler_inline_result$jscomp$2 = children$jscomp$4;\n          return JSCompiler_inline_result$jscomp$2;\n        case \"menuitem\":\n          target$jscomp$0.push(startChunkForTag(\"menuitem\"));\n          for (var propKey$jscomp$6 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$6)) {\n              var propValue$jscomp$6 = props[propKey$jscomp$6];\n              if (null != propValue$jscomp$6)\n                switch (propKey$jscomp$6) {\n                  case \"children\":\n                  case \"dangerouslySetInnerHTML\":\n                    throw Error(\n                      \"menuitems cannot have `children` nor `dangerouslySetInnerHTML`.\"\n                    );\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$6,\n                      propValue$jscomp$6\n                    );\n                }\n            }\n          target$jscomp$0.push(endOfStartTag);\n          return null;\n        case \"object\":\n          target$jscomp$0.push(startChunkForTag(\"object\"));\n          var children$jscomp$5 = null,\n            innerHTML$jscomp$4 = null,\n            propKey$jscomp$7;\n          for (propKey$jscomp$7 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$7)) {\n              var propValue$jscomp$7 = props[propKey$jscomp$7];\n              if (null != propValue$jscomp$7)\n                switch (propKey$jscomp$7) {\n                  case \"children\":\n                    children$jscomp$5 = propValue$jscomp$7;\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    innerHTML$jscomp$4 = propValue$jscomp$7;\n                    break;\n                  case \"data\":\n                    checkAttributeStringCoercion(propValue$jscomp$7, \"data\");\n                    var sanitizedValue = sanitizeURL(\"\" + propValue$jscomp$7);\n                    if (\"\" === sanitizedValue) {\n                      console.error(\n                        'An empty string (\"\") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',\n                        propKey$jscomp$7,\n                        propKey$jscomp$7\n                      );\n                      break;\n                    }\n                    target$jscomp$0.push(\n                      attributeSeparator,\n                      \"data\",\n                      attributeAssign,\n                      escapeTextForBrowser(sanitizedValue),\n                      attributeEnd\n                    );\n                    break;\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$7,\n                      propValue$jscomp$7\n                    );\n                }\n            }\n          target$jscomp$0.push(endOfStartTag);\n          pushInnerHTML(target$jscomp$0, innerHTML$jscomp$4, children$jscomp$5);\n          if (\"string\" === typeof children$jscomp$5) {\n            target$jscomp$0.push(escapeTextForBrowser(children$jscomp$5));\n            var JSCompiler_inline_result$jscomp$3 = null;\n          } else JSCompiler_inline_result$jscomp$3 = children$jscomp$5;\n          return JSCompiler_inline_result$jscomp$3;\n        case \"title\":\n          var noscriptTagInScope = formatContext.tagScope & 1,\n            isFallback = formatContext.tagScope & 4;\n          if (hasOwnProperty.call(props, \"children\")) {\n            var children$jscomp$6 = props.children,\n              child = Array.isArray(children$jscomp$6)\n                ? 2 > children$jscomp$6.length\n                  ? children$jscomp$6[0]\n                  : null\n                : children$jscomp$6;\n            Array.isArray(children$jscomp$6) && 1 < children$jscomp$6.length\n              ? console.error(\n                  \"React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an Array with length %s instead. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert `children` of <title> tags to a single string value which is why Arrays of length greater than 1 are not supported. When using JSX it can be common to combine text nodes and value nodes. For example: <title>hello {nameOfUser}</title>. While not immediately apparent, `children` in this case is an Array with length 2. If your `children` prop is using this form try rewriting it using a template string: <title>{`hello ${nameOfUser}`}</title>.\",\n                  children$jscomp$6.length\n                )\n              : \"function\" === typeof child || \"symbol\" === typeof child\n                ? console.error(\n                    \"React expect children of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found %s instead. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value.\",\n                    \"function\" === typeof child ? \"a Function\" : \"a Sybmol\"\n                  )\n                : child &&\n                  child.toString === {}.toString &&\n                  (null != child.$$typeof\n                    ? console.error(\n                        \"React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an object that appears to be a React element which never implements a suitable `toString` method. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value which is why rendering React elements is not supported. If the `children` of <title> is a React Component try moving the <title> tag into that component. If the `children` of <title> is some HTML markup change it to be Text only to be valid HTML.\"\n                      )\n                    : console.error(\n                        \"React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an object that does not implement a suitable `toString` method. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value. Using the default `toString` method available on every object is almost certainly an error. Consider whether the `children` of this <title> is an object in error and change it to a string or number value if so. Otherwise implement a `toString` method that React can use to produce a valid <title>.\"\n                      ));\n          }\n          if (\n            formatContext.insertionMode === SVG_MODE ||\n            noscriptTagInScope ||\n            null != props.itemProp\n          )\n            var JSCompiler_inline_result$jscomp$4 = pushTitleImpl(\n              target$jscomp$0,\n              props\n            );\n          else\n            isFallback\n              ? (JSCompiler_inline_result$jscomp$4 = null)\n              : (pushTitleImpl(renderState.hoistableChunks, props),\n                (JSCompiler_inline_result$jscomp$4 = void 0));\n          return JSCompiler_inline_result$jscomp$4;\n        case \"link\":\n          var noscriptTagInScope$jscomp$0 = formatContext.tagScope & 1,\n            isFallback$jscomp$0 = formatContext.tagScope & 4,\n            rel = props.rel,\n            href = props.href,\n            precedence = props.precedence;\n          if (\n            formatContext.insertionMode === SVG_MODE ||\n            noscriptTagInScope$jscomp$0 ||\n            null != props.itemProp ||\n            \"string\" !== typeof rel ||\n            \"string\" !== typeof href ||\n            \"\" === href\n          ) {\n            \"stylesheet\" === rel &&\n              \"string\" === typeof props.precedence &&\n              ((\"string\" === typeof href && href) ||\n                console.error(\n                  'React encountered a `<link rel=\"stylesheet\" .../>` with a `precedence` prop and expected the `href` prop to be a non-empty string but ecountered %s instead. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop ensure there is a non-empty string `href` prop as well, otherwise remove the `precedence` prop.',\n                  null === href\n                    ? \"`null`\"\n                    : void 0 === href\n                      ? \"`undefined`\"\n                      : \"\" === href\n                        ? \"an empty string\"\n                        : 'something with type \"' + typeof href + '\"'\n                ));\n            pushLinkImpl(target$jscomp$0, props);\n            var JSCompiler_inline_result$jscomp$5 = null;\n          } else if (\"stylesheet\" === props.rel)\n            if (\n              \"string\" !== typeof precedence ||\n              null != props.disabled ||\n              props.onLoad ||\n              props.onError\n            ) {\n              if (\"string\" === typeof precedence)\n                if (null != props.disabled)\n                  console.error(\n                    'React encountered a `<link rel=\"stylesheet\" .../>` with a `precedence` prop and a `disabled` prop. The presence of the `disabled` prop indicates an intent to manage the stylesheet active state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the `disabled` prop, otherwise remove the `precedence` prop.'\n                  );\n                else if (props.onLoad || props.onError) {\n                  var propDescription =\n                    props.onLoad && props.onError\n                      ? \"`onLoad` and `onError` props\"\n                      : props.onLoad\n                        ? \"`onLoad` prop\"\n                        : \"`onError` prop\";\n                  console.error(\n                    'React encountered a `<link rel=\"stylesheet\" .../>` with a `precedence` prop and %s. The presence of loading and error handlers indicates an intent to manage the stylesheet loading state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the %s, otherwise remove the `precedence` prop.',\n                    propDescription,\n                    propDescription\n                  );\n                }\n              JSCompiler_inline_result$jscomp$5 = pushLinkImpl(\n                target$jscomp$0,\n                props\n              );\n            } else {\n              var styleQueue = renderState.styles.get(precedence),\n                resourceState = resumableState.styleResources.hasOwnProperty(\n                  href\n                )\n                  ? resumableState.styleResources[href]\n                  : void 0;\n              if (resourceState !== EXISTS) {\n                resumableState.styleResources[href] = EXISTS;\n                styleQueue ||\n                  ((styleQueue = {\n                    precedence: escapeTextForBrowser(precedence),\n                    rules: [],\n                    hrefs: [],\n                    sheets: new Map()\n                  }),\n                  renderState.styles.set(precedence, styleQueue));\n                var resource = {\n                  state: PENDING$1,\n                  props: assign({}, props, {\n                    \"data-precedence\": props.precedence,\n                    precedence: null\n                  })\n                };\n                if (resourceState) {\n                  2 === resourceState.length &&\n                    adoptPreloadCredentials(resource.props, resourceState);\n                  var preloadResource =\n                    renderState.preloads.stylesheets.get(href);\n                  preloadResource && 0 < preloadResource.length\n                    ? (preloadResource.length = 0)\n                    : (resource.state = PRELOADED);\n                }\n                styleQueue.sheets.set(href, resource);\n                hoistableState && hoistableState.stylesheets.add(resource);\n              } else if (styleQueue) {\n                var _resource = styleQueue.sheets.get(href);\n                _resource &&\n                  hoistableState &&\n                  hoistableState.stylesheets.add(_resource);\n              }\n              textEmbedded && target$jscomp$0.push(\"\\x3c!-- --\\x3e\");\n              JSCompiler_inline_result$jscomp$5 = null;\n            }\n          else\n            props.onLoad || props.onError\n              ? (JSCompiler_inline_result$jscomp$5 = pushLinkImpl(\n                  target$jscomp$0,\n                  props\n                ))\n              : (textEmbedded && target$jscomp$0.push(\"\\x3c!-- --\\x3e\"),\n                (JSCompiler_inline_result$jscomp$5 = isFallback$jscomp$0\n                  ? null\n                  : pushLinkImpl(renderState.hoistableChunks, props)));\n          return JSCompiler_inline_result$jscomp$5;\n        case \"script\":\n          var noscriptTagInScope$jscomp$1 = formatContext.tagScope & 1,\n            asyncProp = props.async;\n          if (\n            \"string\" !== typeof props.src ||\n            !props.src ||\n            !asyncProp ||\n            \"function\" === typeof asyncProp ||\n            \"symbol\" === typeof asyncProp ||\n            props.onLoad ||\n            props.onError ||\n            formatContext.insertionMode === SVG_MODE ||\n            noscriptTagInScope$jscomp$1 ||\n            null != props.itemProp\n          )\n            var JSCompiler_inline_result$jscomp$6 = pushScriptImpl(\n              target$jscomp$0,\n              props\n            );\n          else {\n            var key = props.src;\n            if (\"module\" === props.type) {\n              var resources = resumableState.moduleScriptResources;\n              var preloads = renderState.preloads.moduleScripts;\n            } else\n              (resources = resumableState.scriptResources),\n                (preloads = renderState.preloads.scripts);\n            var resourceState$jscomp$0 = resources.hasOwnProperty(key)\n              ? resources[key]\n              : void 0;\n            if (resourceState$jscomp$0 !== EXISTS) {\n              resources[key] = EXISTS;\n              var scriptProps = props;\n              if (resourceState$jscomp$0) {\n                2 === resourceState$jscomp$0.length &&\n                  ((scriptProps = assign({}, props)),\n                  adoptPreloadCredentials(scriptProps, resourceState$jscomp$0));\n                var preloadResource$jscomp$0 = preloads.get(key);\n                preloadResource$jscomp$0 &&\n                  (preloadResource$jscomp$0.length = 0);\n              }\n              var resource$jscomp$0 = [];\n              renderState.scripts.add(resource$jscomp$0);\n              pushScriptImpl(resource$jscomp$0, scriptProps);\n            }\n            textEmbedded && target$jscomp$0.push(\"\\x3c!-- --\\x3e\");\n            JSCompiler_inline_result$jscomp$6 = null;\n          }\n          return JSCompiler_inline_result$jscomp$6;\n        case \"style\":\n          var noscriptTagInScope$jscomp$2 = formatContext.tagScope & 1;\n          if (hasOwnProperty.call(props, \"children\")) {\n            var children$jscomp$7 = props.children,\n              child$jscomp$0 = Array.isArray(children$jscomp$7)\n                ? 2 > children$jscomp$7.length\n                  ? children$jscomp$7[0]\n                  : null\n                : children$jscomp$7;\n            (\"function\" === typeof child$jscomp$0 ||\n              \"symbol\" === typeof child$jscomp$0 ||\n              Array.isArray(child$jscomp$0)) &&\n              console.error(\n                \"React expect children of <style> tags to be a string, number, or object with a `toString` method but found %s instead. In browsers style Elements can only have `Text` Nodes as children.\",\n                \"function\" === typeof child$jscomp$0\n                  ? \"a Function\"\n                  : \"symbol\" === typeof child$jscomp$0\n                    ? \"a Sybmol\"\n                    : \"an Array\"\n              );\n          }\n          var precedence$jscomp$0 = props.precedence,\n            href$jscomp$0 = props.href,\n            nonce = props.nonce;\n          if (\n            formatContext.insertionMode === SVG_MODE ||\n            noscriptTagInScope$jscomp$2 ||\n            null != props.itemProp ||\n            \"string\" !== typeof precedence$jscomp$0 ||\n            \"string\" !== typeof href$jscomp$0 ||\n            \"\" === href$jscomp$0\n          ) {\n            target$jscomp$0.push(startChunkForTag(\"style\"));\n            var children$jscomp$8 = null,\n              innerHTML$jscomp$5 = null,\n              propKey$jscomp$8;\n            for (propKey$jscomp$8 in props)\n              if (hasOwnProperty.call(props, propKey$jscomp$8)) {\n                var propValue$jscomp$8 = props[propKey$jscomp$8];\n                if (null != propValue$jscomp$8)\n                  switch (propKey$jscomp$8) {\n                    case \"children\":\n                      children$jscomp$8 = propValue$jscomp$8;\n                      break;\n                    case \"dangerouslySetInnerHTML\":\n                      innerHTML$jscomp$5 = propValue$jscomp$8;\n                      break;\n                    default:\n                      pushAttribute(\n                        target$jscomp$0,\n                        propKey$jscomp$8,\n                        propValue$jscomp$8\n                      );\n                  }\n              }\n            target$jscomp$0.push(endOfStartTag);\n            var child$jscomp$1 = Array.isArray(children$jscomp$8)\n              ? 2 > children$jscomp$8.length\n                ? children$jscomp$8[0]\n                : null\n              : children$jscomp$8;\n            \"function\" !== typeof child$jscomp$1 &&\n              \"symbol\" !== typeof child$jscomp$1 &&\n              null !== child$jscomp$1 &&\n              void 0 !== child$jscomp$1 &&\n              target$jscomp$0.push(escapeStyleTextContent(child$jscomp$1));\n            pushInnerHTML(\n              target$jscomp$0,\n              innerHTML$jscomp$5,\n              children$jscomp$8\n            );\n            target$jscomp$0.push(endChunkForTag(\"style\"));\n            var JSCompiler_inline_result$jscomp$7 = null;\n          } else {\n            href$jscomp$0.includes(\" \") &&\n              console.error(\n                'React expected the `href` prop for a <style> tag opting into hoisting semantics using the `precedence` prop to not have any spaces but ecountered spaces instead. using spaces in this prop will cause hydration of this style to fail on the client. The href for the <style> where this ocurred is \"%s\".',\n                href$jscomp$0\n              );\n            var styleQueue$jscomp$0 =\n                renderState.styles.get(precedence$jscomp$0),\n              resourceState$jscomp$1 =\n                resumableState.styleResources.hasOwnProperty(href$jscomp$0)\n                  ? resumableState.styleResources[href$jscomp$0]\n                  : void 0;\n            if (resourceState$jscomp$1 !== EXISTS) {\n              resumableState.styleResources[href$jscomp$0] = EXISTS;\n              resourceState$jscomp$1 &&\n                console.error(\n                  'React encountered a hoistable style tag for the same href as a preload: \"%s\". When using a style tag to inline styles you should not also preload it as a stylsheet.',\n                  href$jscomp$0\n                );\n              styleQueue$jscomp$0 ||\n                ((styleQueue$jscomp$0 = {\n                  precedence: escapeTextForBrowser(precedence$jscomp$0),\n                  rules: [],\n                  hrefs: [],\n                  sheets: new Map()\n                }),\n                renderState.styles.set(\n                  precedence$jscomp$0,\n                  styleQueue$jscomp$0\n                ));\n              var nonceStyle = renderState.nonce.style;\n              if (nonceStyle && nonceStyle !== nonce)\n                console.error(\n                  'React encountered a style tag with `precedence` \"%s\" and `nonce` \"%s\". When React manages style rules using `precedence` it will only include rules if the nonce matches the style nonce \"%s\" that was included with this render.',\n                  precedence$jscomp$0,\n                  nonce,\n                  nonceStyle\n                );\n              else {\n                !nonceStyle &&\n                  nonce &&\n                  console.error(\n                    'React encountered a style tag with `precedence` \"%s\" and `nonce` \"%s\". When React manages style rules using `precedence` it will only include a nonce attributes if you also provide the same style nonce value as a render option.',\n                    precedence$jscomp$0,\n                    nonce\n                  );\n                styleQueue$jscomp$0.hrefs.push(\n                  escapeTextForBrowser(href$jscomp$0)\n                );\n                var target = styleQueue$jscomp$0.rules,\n                  children$jscomp$9 = null,\n                  innerHTML$jscomp$6 = null,\n                  propKey$jscomp$9;\n                for (propKey$jscomp$9 in props)\n                  if (hasOwnProperty.call(props, propKey$jscomp$9)) {\n                    var propValue$jscomp$9 = props[propKey$jscomp$9];\n                    if (null != propValue$jscomp$9)\n                      switch (propKey$jscomp$9) {\n                        case \"children\":\n                          children$jscomp$9 = propValue$jscomp$9;\n                          break;\n                        case \"dangerouslySetInnerHTML\":\n                          innerHTML$jscomp$6 = propValue$jscomp$9;\n                      }\n                  }\n                var child$jscomp$2 = Array.isArray(children$jscomp$9)\n                  ? 2 > children$jscomp$9.length\n                    ? children$jscomp$9[0]\n                    : null\n                  : children$jscomp$9;\n                \"function\" !== typeof child$jscomp$2 &&\n                  \"symbol\" !== typeof child$jscomp$2 &&\n                  null !== child$jscomp$2 &&\n                  void 0 !== child$jscomp$2 &&\n                  target.push(escapeStyleTextContent(child$jscomp$2));\n                pushInnerHTML(target, innerHTML$jscomp$6, children$jscomp$9);\n              }\n            }\n            styleQueue$jscomp$0 &&\n              hoistableState &&\n              hoistableState.styles.add(styleQueue$jscomp$0);\n            textEmbedded && target$jscomp$0.push(\"\\x3c!-- --\\x3e\");\n            JSCompiler_inline_result$jscomp$7 = void 0;\n          }\n          return JSCompiler_inline_result$jscomp$7;\n        case \"meta\":\n          var noscriptTagInScope$jscomp$3 = formatContext.tagScope & 1,\n            isFallback$jscomp$1 = formatContext.tagScope & 4;\n          if (\n            formatContext.insertionMode === SVG_MODE ||\n            noscriptTagInScope$jscomp$3 ||\n            null != props.itemProp\n          )\n            var JSCompiler_inline_result$jscomp$8 = pushSelfClosing(\n              target$jscomp$0,\n              props,\n              \"meta\"\n            );\n          else\n            textEmbedded && target$jscomp$0.push(\"\\x3c!-- --\\x3e\"),\n              (JSCompiler_inline_result$jscomp$8 = isFallback$jscomp$1\n                ? null\n                : \"string\" === typeof props.charSet\n                  ? pushSelfClosing(renderState.charsetChunks, props, \"meta\")\n                  : \"viewport\" === props.name\n                    ? pushSelfClosing(renderState.viewportChunks, props, \"meta\")\n                    : pushSelfClosing(\n                        renderState.hoistableChunks,\n                        props,\n                        \"meta\"\n                      ));\n          return JSCompiler_inline_result$jscomp$8;\n        case \"listing\":\n        case \"pre\":\n          target$jscomp$0.push(startChunkForTag(type));\n          var children$jscomp$10 = null,\n            innerHTML$jscomp$7 = null,\n            propKey$jscomp$10;\n          for (propKey$jscomp$10 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$10)) {\n              var propValue$jscomp$10 = props[propKey$jscomp$10];\n              if (null != propValue$jscomp$10)\n                switch (propKey$jscomp$10) {\n                  case \"children\":\n                    children$jscomp$10 = propValue$jscomp$10;\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    innerHTML$jscomp$7 = propValue$jscomp$10;\n                    break;\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$10,\n                      propValue$jscomp$10\n                    );\n                }\n            }\n          target$jscomp$0.push(endOfStartTag);\n          if (null != innerHTML$jscomp$7) {\n            if (null != children$jscomp$10)\n              throw Error(\n                \"Can only set one of `children` or `props.dangerouslySetInnerHTML`.\"\n              );\n            if (\n              \"object\" !== typeof innerHTML$jscomp$7 ||\n              !(\"__html\" in innerHTML$jscomp$7)\n            )\n              throw Error(\n                \"`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information.\"\n              );\n            var html = innerHTML$jscomp$7.__html;\n            null !== html &&\n              void 0 !== html &&\n              (\"string\" === typeof html && 0 < html.length && \"\\n\" === html[0]\n                ? target$jscomp$0.push(leadingNewline, html)\n                : (checkHtmlStringCoercion(html),\n                  target$jscomp$0.push(\"\" + html)));\n          }\n          \"string\" === typeof children$jscomp$10 &&\n            \"\\n\" === children$jscomp$10[0] &&\n            target$jscomp$0.push(leadingNewline);\n          return children$jscomp$10;\n        case \"img\":\n          var pictureOrNoScriptTagInScope = formatContext.tagScope & 3,\n            src = props.src,\n            srcSet = props.srcSet;\n          if (\n            !(\n              \"lazy\" === props.loading ||\n              (!src && !srcSet) ||\n              (\"string\" !== typeof src && null != src) ||\n              (\"string\" !== typeof srcSet && null != srcSet) ||\n              \"low\" === props.fetchPriority ||\n              pictureOrNoScriptTagInScope\n            ) &&\n            (\"string\" !== typeof src ||\n              \":\" !== src[4] ||\n              (\"d\" !== src[0] && \"D\" !== src[0]) ||\n              (\"a\" !== src[1] && \"A\" !== src[1]) ||\n              (\"t\" !== src[2] && \"T\" !== src[2]) ||\n              (\"a\" !== src[3] && \"A\" !== src[3])) &&\n            (\"string\" !== typeof srcSet ||\n              \":\" !== srcSet[4] ||\n              (\"d\" !== srcSet[0] && \"D\" !== srcSet[0]) ||\n              (\"a\" !== srcSet[1] && \"A\" !== srcSet[1]) ||\n              (\"t\" !== srcSet[2] && \"T\" !== srcSet[2]) ||\n              (\"a\" !== srcSet[3] && \"A\" !== srcSet[3]))\n          ) {\n            null !== hoistableState &&\n              formatContext.tagScope & 64 &&\n              (hoistableState.suspenseyImages = !0);\n            var sizes = \"string\" === typeof props.sizes ? props.sizes : void 0,\n              key$jscomp$0 = srcSet ? srcSet + \"\\n\" + (sizes || \"\") : src,\n              promotablePreloads = renderState.preloads.images,\n              resource$jscomp$1 = promotablePreloads.get(key$jscomp$0);\n            if (resource$jscomp$1) {\n              if (\n                \"high\" === props.fetchPriority ||\n                10 > renderState.highImagePreloads.size\n              )\n                promotablePreloads.delete(key$jscomp$0),\n                  renderState.highImagePreloads.add(resource$jscomp$1);\n            } else if (\n              !resumableState.imageResources.hasOwnProperty(key$jscomp$0)\n            ) {\n              resumableState.imageResources[key$jscomp$0] = PRELOAD_NO_CREDS;\n              var input = props.crossOrigin;\n              var crossOrigin =\n                \"string\" === typeof input\n                  ? \"use-credentials\" === input\n                    ? input\n                    : \"\"\n                  : void 0;\n              var headers = renderState.headers,\n                header;\n              headers &&\n              0 < headers.remainingCapacity &&\n              \"string\" !== typeof props.srcSet &&\n              (\"high\" === props.fetchPriority ||\n                500 > headers.highImagePreloads.length) &&\n              ((header = getPreloadAsHeader(src, \"image\", {\n                imageSrcSet: props.srcSet,\n                imageSizes: props.sizes,\n                crossOrigin: crossOrigin,\n                integrity: props.integrity,\n                nonce: props.nonce,\n                type: props.type,\n                fetchPriority: props.fetchPriority,\n                referrerPolicy: props.refererPolicy\n              })),\n              0 <= (headers.remainingCapacity -= header.length + 2))\n                ? ((renderState.resets.image[key$jscomp$0] = PRELOAD_NO_CREDS),\n                  headers.highImagePreloads &&\n                    (headers.highImagePreloads += \", \"),\n                  (headers.highImagePreloads += header))\n                : ((resource$jscomp$1 = []),\n                  pushLinkImpl(resource$jscomp$1, {\n                    rel: \"preload\",\n                    as: \"image\",\n                    href: srcSet ? void 0 : src,\n                    imageSrcSet: srcSet,\n                    imageSizes: sizes,\n                    crossOrigin: crossOrigin,\n                    integrity: props.integrity,\n                    type: props.type,\n                    fetchPriority: props.fetchPriority,\n                    referrerPolicy: props.referrerPolicy\n                  }),\n                  \"high\" === props.fetchPriority ||\n                  10 > renderState.highImagePreloads.size\n                    ? renderState.highImagePreloads.add(resource$jscomp$1)\n                    : (renderState.bulkPreloads.add(resource$jscomp$1),\n                      promotablePreloads.set(key$jscomp$0, resource$jscomp$1)));\n            }\n          }\n          return pushSelfClosing(target$jscomp$0, props, \"img\");\n        case \"base\":\n        case \"area\":\n        case \"br\":\n        case \"col\":\n        case \"embed\":\n        case \"hr\":\n        case \"keygen\":\n        case \"param\":\n        case \"source\":\n        case \"track\":\n        case \"wbr\":\n          return pushSelfClosing(target$jscomp$0, props, type);\n        case \"annotation-xml\":\n        case \"color-profile\":\n        case \"font-face\":\n        case \"font-face-src\":\n        case \"font-face-uri\":\n        case \"font-face-format\":\n        case \"font-face-name\":\n        case \"missing-glyph\":\n          break;\n        case \"head\":\n          if (formatContext.insertionMode < HTML_MODE) {\n            var preamble = preambleState || renderState.preamble;\n            if (preamble.headChunks)\n              throw Error(\"The `<head>` tag may only be rendered once.\");\n            null !== preambleState && target$jscomp$0.push(\"\\x3c!--head--\\x3e\");\n            preamble.headChunks = [];\n            var JSCompiler_inline_result$jscomp$9 = pushStartSingletonElement(\n              preamble.headChunks,\n              props,\n              \"head\"\n            );\n          } else\n            JSCompiler_inline_result$jscomp$9 = pushStartGenericElement(\n              target$jscomp$0,\n              props,\n              \"head\"\n            );\n          return JSCompiler_inline_result$jscomp$9;\n        case \"body\":\n          if (formatContext.insertionMode < HTML_MODE) {\n            var preamble$jscomp$0 = preambleState || renderState.preamble;\n            if (preamble$jscomp$0.bodyChunks)\n              throw Error(\"The `<body>` tag may only be rendered once.\");\n            null !== preambleState && target$jscomp$0.push(\"\\x3c!--body--\\x3e\");\n            preamble$jscomp$0.bodyChunks = [];\n            var JSCompiler_inline_result$jscomp$10 = pushStartSingletonElement(\n              preamble$jscomp$0.bodyChunks,\n              props,\n              \"body\"\n            );\n          } else\n            JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(\n              target$jscomp$0,\n              props,\n              \"body\"\n            );\n          return JSCompiler_inline_result$jscomp$10;\n        case \"html\":\n          if (formatContext.insertionMode === ROOT_HTML_MODE) {\n            var preamble$jscomp$1 = preambleState || renderState.preamble;\n            if (preamble$jscomp$1.htmlChunks)\n              throw Error(\"The `<html>` tag may only be rendered once.\");\n            null !== preambleState && target$jscomp$0.push(\"\\x3c!--html--\\x3e\");\n            preamble$jscomp$1.htmlChunks = [doctypeChunk];\n            var JSCompiler_inline_result$jscomp$11 = pushStartSingletonElement(\n              preamble$jscomp$1.htmlChunks,\n              props,\n              \"html\"\n            );\n          } else\n            JSCompiler_inline_result$jscomp$11 = pushStartGenericElement(\n              target$jscomp$0,\n              props,\n              \"html\"\n            );\n          return JSCompiler_inline_result$jscomp$11;\n        default:\n          if (-1 !== type.indexOf(\"-\")) {\n            target$jscomp$0.push(startChunkForTag(type));\n            var children$jscomp$11 = null,\n              innerHTML$jscomp$8 = null,\n              propKey$jscomp$11;\n            for (propKey$jscomp$11 in props)\n              if (hasOwnProperty.call(props, propKey$jscomp$11)) {\n                var propValue$jscomp$11 = props[propKey$jscomp$11];\n                if (null != propValue$jscomp$11) {\n                  var attributeName = propKey$jscomp$11;\n                  switch (propKey$jscomp$11) {\n                    case \"children\":\n                      children$jscomp$11 = propValue$jscomp$11;\n                      break;\n                    case \"dangerouslySetInnerHTML\":\n                      innerHTML$jscomp$8 = propValue$jscomp$11;\n                      break;\n                    case \"style\":\n                      pushStyleAttribute(target$jscomp$0, propValue$jscomp$11);\n                      break;\n                    case \"suppressContentEditableWarning\":\n                    case \"suppressHydrationWarning\":\n                    case \"ref\":\n                      break;\n                    case \"className\":\n                      attributeName = \"class\";\n                    default:\n                      if (\n                        isAttributeNameSafe(propKey$jscomp$11) &&\n                        \"function\" !== typeof propValue$jscomp$11 &&\n                        \"symbol\" !== typeof propValue$jscomp$11 &&\n                        !1 !== propValue$jscomp$11\n                      ) {\n                        if (!0 === propValue$jscomp$11)\n                          propValue$jscomp$11 = \"\";\n                        else if (\"object\" === typeof propValue$jscomp$11)\n                          continue;\n                        target$jscomp$0.push(\n                          attributeSeparator,\n                          attributeName,\n                          attributeAssign,\n                          escapeTextForBrowser(propValue$jscomp$11),\n                          attributeEnd\n                        );\n                      }\n                  }\n                }\n              }\n            target$jscomp$0.push(endOfStartTag);\n            pushInnerHTML(\n              target$jscomp$0,\n              innerHTML$jscomp$8,\n              children$jscomp$11\n            );\n            return children$jscomp$11;\n          }\n      }\n      return pushStartGenericElement(target$jscomp$0, props, type);\n    }\n    function endChunkForTag(tag) {\n      var chunk = endTagCache.get(tag);\n      void 0 === chunk &&\n        ((chunk = \"</\" + tag + \">\"), endTagCache.set(tag, chunk));\n      return chunk;\n    }\n    function hoistPreambleState(renderState, preambleState) {\n      renderState = renderState.preamble;\n      null === renderState.htmlChunks &&\n        preambleState.htmlChunks &&\n        (renderState.htmlChunks = preambleState.htmlChunks);\n      null === renderState.headChunks &&\n        preambleState.headChunks &&\n        (renderState.headChunks = preambleState.headChunks);\n      null === renderState.bodyChunks &&\n        preambleState.bodyChunks &&\n        (renderState.bodyChunks = preambleState.bodyChunks);\n    }\n    function writeBootstrap(destination, renderState) {\n      renderState = renderState.bootstrapChunks;\n      for (var i = 0; i < renderState.length - 1; i++)\n        destination.push(renderState[i]);\n      return i < renderState.length\n        ? ((i = renderState[i]), (renderState.length = 0), destination.push(i))\n        : !0;\n    }\n    function writeStartPendingSuspenseBoundary(destination, renderState, id) {\n      destination.push(startPendingSuspenseBoundary1);\n      if (null === id)\n        throw Error(\n          \"An ID must have been assigned before we can complete the boundary.\"\n        );\n      destination.push(renderState.boundaryPrefix);\n      renderState = id.toString(16);\n      destination.push(renderState);\n      return destination.push(startPendingSuspenseBoundary2);\n    }\n    function writeStartSegment(destination, renderState, formatContext, id) {\n      switch (formatContext.insertionMode) {\n        case ROOT_HTML_MODE:\n        case HTML_HTML_MODE:\n        case HTML_HEAD_MODE:\n        case HTML_MODE:\n          return (\n            destination.push(startSegmentHTML),\n            destination.push(renderState.segmentPrefix),\n            (renderState = id.toString(16)),\n            destination.push(renderState),\n            destination.push(startSegmentHTML2)\n          );\n        case SVG_MODE:\n          return (\n            destination.push(startSegmentSVG),\n            destination.push(renderState.segmentPrefix),\n            (renderState = id.toString(16)),\n            destination.push(renderState),\n            destination.push(startSegmentSVG2)\n          );\n        case MATHML_MODE:\n          return (\n            destination.push(startSegmentMathML),\n            destination.push(renderState.segmentPrefix),\n            (renderState = id.toString(16)),\n            destination.push(renderState),\n            destination.push(startSegmentMathML2)\n          );\n        case HTML_TABLE_MODE:\n          return (\n            destination.push(startSegmentTable),\n            destination.push(renderState.segmentPrefix),\n            (renderState = id.toString(16)),\n            destination.push(renderState),\n            destination.push(startSegmentTable2)\n          );\n        case HTML_TABLE_BODY_MODE:\n          return (\n            destination.push(startSegmentTableBody),\n            destination.push(renderState.segmentPrefix),\n            (renderState = id.toString(16)),\n            destination.push(renderState),\n            destination.push(startSegmentTableBody2)\n          );\n        case HTML_TABLE_ROW_MODE:\n          return (\n            destination.push(startSegmentTableRow),\n            destination.push(renderState.segmentPrefix),\n            (renderState = id.toString(16)),\n            destination.push(renderState),\n            destination.push(startSegmentTableRow2)\n          );\n        case HTML_COLGROUP_MODE:\n          return (\n            destination.push(startSegmentColGroup),\n            destination.push(renderState.segmentPrefix),\n            (renderState = id.toString(16)),\n            destination.push(renderState),\n            destination.push(startSegmentColGroup2)\n          );\n        default:\n          throw Error(\"Unknown insertion mode. This is a bug in React.\");\n      }\n    }\n    function writeEndSegment(destination, formatContext) {\n      switch (formatContext.insertionMode) {\n        case ROOT_HTML_MODE:\n        case HTML_HTML_MODE:\n        case HTML_HEAD_MODE:\n        case HTML_MODE:\n          return destination.push(endSegmentHTML);\n        case SVG_MODE:\n          return destination.push(endSegmentSVG);\n        case MATHML_MODE:\n          return destination.push(endSegmentMathML);\n        case HTML_TABLE_MODE:\n          return destination.push(endSegmentTable);\n        case HTML_TABLE_BODY_MODE:\n          return destination.push(endSegmentTableBody);\n        case HTML_TABLE_ROW_MODE:\n          return destination.push(endSegmentTableRow);\n        case HTML_COLGROUP_MODE:\n          return destination.push(endSegmentColGroup);\n        default:\n          throw Error(\"Unknown insertion mode. This is a bug in React.\");\n      }\n    }\n    function escapeJSStringsForInstructionScripts(input) {\n      return JSON.stringify(input).replace(\n        regexForJSStringsInInstructionScripts,\n        function (match) {\n          switch (match) {\n            case \"<\":\n              return \"\\\\u003c\";\n            case \"\\u2028\":\n              return \"\\\\u2028\";\n            case \"\\u2029\":\n              return \"\\\\u2029\";\n            default:\n              throw Error(\n                \"escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React\"\n              );\n          }\n        }\n      );\n    }\n    function escapeJSObjectForInstructionScripts(input) {\n      return JSON.stringify(input).replace(\n        regexForJSStringsInScripts,\n        function (match) {\n          switch (match) {\n            case \"&\":\n              return \"\\\\u0026\";\n            case \">\":\n              return \"\\\\u003e\";\n            case \"<\":\n              return \"\\\\u003c\";\n            case \"\\u2028\":\n              return \"\\\\u2028\";\n            case \"\\u2029\":\n              return \"\\\\u2029\";\n            default:\n              throw Error(\n                \"escapeJSObjectForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React\"\n              );\n          }\n        }\n      );\n    }\n    function flushStyleTagsLateForBoundary(styleQueue) {\n      var rules = styleQueue.rules,\n        hrefs = styleQueue.hrefs;\n      0 < rules.length &&\n        0 === hrefs.length &&\n        console.error(\n          \"React expected to have at least one href for an a hoistable style but found none. This is a bug in React.\"\n        );\n      var i = 0;\n      if (hrefs.length) {\n        this.push(currentlyFlushingRenderState.startInlineStyle);\n        this.push(lateStyleTagResourceOpen1);\n        this.push(styleQueue.precedence);\n        for (this.push(lateStyleTagResourceOpen2); i < hrefs.length - 1; i++)\n          this.push(hrefs[i]), this.push(spaceSeparator);\n        this.push(hrefs[i]);\n        this.push(lateStyleTagResourceOpen3);\n        for (i = 0; i < rules.length; i++) this.push(rules[i]);\n        destinationHasCapacity = this.push(lateStyleTagTemplateClose);\n        currentlyRenderingBoundaryHasStylesToHoist = !0;\n        rules.length = 0;\n        hrefs.length = 0;\n      }\n    }\n    function hasStylesToHoist(stylesheet) {\n      return stylesheet.state !== PREAMBLE\n        ? (currentlyRenderingBoundaryHasStylesToHoist = !0)\n        : !1;\n    }\n    function writeHoistablesForBoundary(\n      destination,\n      hoistableState,\n      renderState\n    ) {\n      currentlyRenderingBoundaryHasStylesToHoist = !1;\n      destinationHasCapacity = !0;\n      currentlyFlushingRenderState = renderState;\n      hoistableState.styles.forEach(flushStyleTagsLateForBoundary, destination);\n      currentlyFlushingRenderState = null;\n      hoistableState.stylesheets.forEach(hasStylesToHoist);\n      currentlyRenderingBoundaryHasStylesToHoist &&\n        (renderState.stylesToHoist = !0);\n      return destinationHasCapacity;\n    }\n    function flushResource(resource) {\n      for (var i = 0; i < resource.length; i++) this.push(resource[i]);\n      resource.length = 0;\n    }\n    function flushStyleInPreamble(stylesheet) {\n      pushLinkImpl(stylesheetFlushingQueue, stylesheet.props);\n      for (var i = 0; i < stylesheetFlushingQueue.length; i++)\n        this.push(stylesheetFlushingQueue[i]);\n      stylesheetFlushingQueue.length = 0;\n      stylesheet.state = PREAMBLE;\n    }\n    function flushStylesInPreamble(styleQueue) {\n      var hasStylesheets = 0 < styleQueue.sheets.size;\n      styleQueue.sheets.forEach(flushStyleInPreamble, this);\n      styleQueue.sheets.clear();\n      var rules = styleQueue.rules,\n        hrefs = styleQueue.hrefs;\n      if (!hasStylesheets || hrefs.length) {\n        this.push(currentlyFlushingRenderState.startInlineStyle);\n        this.push(styleTagResourceOpen1);\n        this.push(styleQueue.precedence);\n        styleQueue = 0;\n        if (hrefs.length) {\n          for (\n            this.push(styleTagResourceOpen2);\n            styleQueue < hrefs.length - 1;\n            styleQueue++\n          )\n            this.push(hrefs[styleQueue]), this.push(spaceSeparator);\n          this.push(hrefs[styleQueue]);\n        }\n        this.push(styleTagResourceOpen3);\n        for (styleQueue = 0; styleQueue < rules.length; styleQueue++)\n          this.push(rules[styleQueue]);\n        this.push(styleTagResourceClose);\n        rules.length = 0;\n        hrefs.length = 0;\n      }\n    }\n    function preloadLateStyle(stylesheet) {\n      if (stylesheet.state === PENDING$1) {\n        stylesheet.state = PRELOADED;\n        var props = stylesheet.props;\n        pushLinkImpl(stylesheetFlushingQueue, {\n          rel: \"preload\",\n          as: \"style\",\n          href: stylesheet.props.href,\n          crossOrigin: props.crossOrigin,\n          fetchPriority: props.fetchPriority,\n          integrity: props.integrity,\n          media: props.media,\n          hrefLang: props.hrefLang,\n          referrerPolicy: props.referrerPolicy\n        });\n        for (\n          stylesheet = 0;\n          stylesheet < stylesheetFlushingQueue.length;\n          stylesheet++\n        )\n          this.push(stylesheetFlushingQueue[stylesheet]);\n        stylesheetFlushingQueue.length = 0;\n      }\n    }\n    function preloadLateStyles(styleQueue) {\n      styleQueue.sheets.forEach(preloadLateStyle, this);\n      styleQueue.sheets.clear();\n    }\n    function pushCompletedShellIdAttribute(target, resumableState) {\n      (resumableState.instructions & SentCompletedShellId) === NothingSent &&\n        ((resumableState.instructions |= SentCompletedShellId),\n        target.push(\n          completedShellIdAttributeStart,\n          escapeTextForBrowser(\"_\" + resumableState.idPrefix + \"R_\"),\n          attributeEnd\n        ));\n    }\n    function writeStyleResourceDependenciesInJS(destination, hoistableState) {\n      destination.push(arrayFirstOpenBracket);\n      var nextArrayOpenBrackChunk = arrayFirstOpenBracket;\n      hoistableState.stylesheets.forEach(function (resource) {\n        if (resource.state !== PREAMBLE)\n          if (resource.state === LATE)\n            destination.push(nextArrayOpenBrackChunk),\n              (resource = resource.props.href),\n              checkAttributeStringCoercion(resource, \"href\"),\n              (resource = escapeJSObjectForInstructionScripts(\"\" + resource)),\n              destination.push(resource),\n              destination.push(arrayCloseBracket),\n              (nextArrayOpenBrackChunk = arraySubsequentOpenBracket);\n          else {\n            destination.push(nextArrayOpenBrackChunk);\n            var precedence = resource.props[\"data-precedence\"],\n              props = resource.props,\n              coercedHref = sanitizeURL(\"\" + resource.props.href);\n            coercedHref = escapeJSObjectForInstructionScripts(coercedHref);\n            destination.push(coercedHref);\n            checkAttributeStringCoercion(precedence, \"precedence\");\n            precedence = \"\" + precedence;\n            destination.push(arrayInterstitial);\n            precedence = escapeJSObjectForInstructionScripts(precedence);\n            destination.push(precedence);\n            for (var propKey in props)\n              if (\n                hasOwnProperty.call(props, propKey) &&\n                ((precedence = props[propKey]), null != precedence)\n              )\n                switch (propKey) {\n                  case \"href\":\n                  case \"rel\":\n                  case \"precedence\":\n                  case \"data-precedence\":\n                    break;\n                  case \"children\":\n                  case \"dangerouslySetInnerHTML\":\n                    throw Error(\n                      \"link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.\"\n                    );\n                  default:\n                    writeStyleResourceAttributeInJS(\n                      destination,\n                      propKey,\n                      precedence\n                    );\n                }\n            destination.push(arrayCloseBracket);\n            nextArrayOpenBrackChunk = arraySubsequentOpenBracket;\n            resource.state = LATE;\n          }\n      });\n      destination.push(arrayCloseBracket);\n    }\n    function writeStyleResourceAttributeInJS(destination, name, value) {\n      var attributeName = name.toLowerCase();\n      switch (typeof value) {\n        case \"function\":\n        case \"symbol\":\n          return;\n      }\n      switch (name) {\n        case \"innerHTML\":\n        case \"dangerouslySetInnerHTML\":\n        case \"suppressContentEditableWarning\":\n        case \"suppressHydrationWarning\":\n        case \"style\":\n        case \"ref\":\n          return;\n        case \"className\":\n          attributeName = \"class\";\n          checkAttributeStringCoercion(value, attributeName);\n          name = \"\" + value;\n          break;\n        case \"hidden\":\n          if (!1 === value) return;\n          name = \"\";\n          break;\n        case \"src\":\n        case \"href\":\n          value = sanitizeURL(value);\n          checkAttributeStringCoercion(value, attributeName);\n          name = \"\" + value;\n          break;\n        default:\n          if (\n            (2 < name.length &&\n              (\"o\" === name[0] || \"O\" === name[0]) &&\n              (\"n\" === name[1] || \"N\" === name[1])) ||\n            !isAttributeNameSafe(name)\n          )\n            return;\n          checkAttributeStringCoercion(value, attributeName);\n          name = \"\" + value;\n      }\n      destination.push(arrayInterstitial);\n      attributeName = escapeJSObjectForInstructionScripts(attributeName);\n      destination.push(attributeName);\n      destination.push(arrayInterstitial);\n      attributeName = escapeJSObjectForInstructionScripts(name);\n      destination.push(attributeName);\n    }\n    function createHoistableState() {\n      return { styles: new Set(), stylesheets: new Set(), suspenseyImages: !1 };\n    }\n    function preloadBootstrapScriptOrModule(\n      resumableState,\n      renderState,\n      href,\n      props\n    ) {\n      (resumableState.scriptResources.hasOwnProperty(href) ||\n        resumableState.moduleScriptResources.hasOwnProperty(href)) &&\n        console.error(\n          'Internal React Error: React expected bootstrap script or module with src \"%s\" to not have been preloaded already. please file an issue',\n          href\n        );\n      resumableState.scriptResources[href] = EXISTS;\n      resumableState.moduleScriptResources[href] = EXISTS;\n      resumableState = [];\n      pushLinkImpl(resumableState, props);\n      renderState.bootstrapScripts.add(resumableState);\n    }\n    function adoptPreloadCredentials(target, preloadState) {\n      null == target.crossOrigin && (target.crossOrigin = preloadState[0]);\n      null == target.integrity && (target.integrity = preloadState[1]);\n    }\n    function getPreloadAsHeader(href, as, params) {\n      href = escapeHrefForLinkHeaderURLContext(href);\n      as = escapeStringForLinkHeaderQuotedParamValueContext(as, \"as\");\n      as = \"<\" + href + '>; rel=preload; as=\"' + as + '\"';\n      for (var paramName in params)\n        hasOwnProperty.call(params, paramName) &&\n          ((href = params[paramName]),\n          \"string\" === typeof href &&\n            (as +=\n              \"; \" +\n              paramName.toLowerCase() +\n              '=\"' +\n              escapeStringForLinkHeaderQuotedParamValueContext(\n                href,\n                paramName\n              ) +\n              '\"'));\n      return as;\n    }\n    function escapeHrefForLinkHeaderURLContext(hrefInput) {\n      checkAttributeStringCoercion(hrefInput, \"href\");\n      return (\"\" + hrefInput).replace(\n        regexForHrefInLinkHeaderURLContext,\n        escapeHrefForLinkHeaderURLContextReplacer\n      );\n    }\n    function escapeHrefForLinkHeaderURLContextReplacer(match) {\n      switch (match) {\n        case \"<\":\n          return \"%3C\";\n        case \">\":\n          return \"%3E\";\n        case \"\\n\":\n          return \"%0A\";\n        case \"\\r\":\n          return \"%0D\";\n        default:\n          throw Error(\n            \"escapeLinkHrefForHeaderContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React\"\n          );\n      }\n    }\n    function escapeStringForLinkHeaderQuotedParamValueContext(value, name) {\n      willCoercionThrow(value) &&\n        (console.error(\n          \"The provided `%s` option is an unsupported type %s. This value must be coerced to a string before using it here.\",\n          name,\n          typeName(value)\n        ),\n        testStringCoercion(value));\n      return (\"\" + value).replace(\n        regexForLinkHeaderQuotedParamValueContext,\n        escapeStringForLinkHeaderQuotedParamValueContextReplacer\n      );\n    }\n    function escapeStringForLinkHeaderQuotedParamValueContextReplacer(match) {\n      switch (match) {\n        case '\"':\n          return \"%22\";\n        case \"'\":\n          return \"%27\";\n        case \";\":\n          return \"%3B\";\n        case \",\":\n          return \"%2C\";\n        case \"\\n\":\n          return \"%0A\";\n        case \"\\r\":\n          return \"%0D\";\n        default:\n          throw Error(\n            \"escapeStringForLinkHeaderQuotedParamValueContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React\"\n          );\n      }\n    }\n    function hoistStyleQueueDependency(styleQueue) {\n      this.styles.add(styleQueue);\n    }\n    function hoistStylesheetDependency(stylesheet) {\n      this.stylesheets.add(stylesheet);\n    }\n    function hoistHoistables(parentState, childState) {\n      childState.styles.forEach(hoistStyleQueueDependency, parentState);\n      childState.stylesheets.forEach(hoistStylesheetDependency, parentState);\n      childState.suspenseyImages && (parentState.suspenseyImages = !0);\n    }\n    function createRenderState(resumableState, generateStaticMarkup) {\n      var idPrefix = resumableState.idPrefix,\n        bootstrapChunks = [],\n        bootstrapScriptContent = resumableState.bootstrapScriptContent,\n        bootstrapScripts = resumableState.bootstrapScripts,\n        bootstrapModules = resumableState.bootstrapModules;\n      void 0 !== bootstrapScriptContent &&\n        (bootstrapChunks.push(\"<script\"),\n        pushCompletedShellIdAttribute(bootstrapChunks, resumableState),\n        bootstrapChunks.push(\n          endOfStartTag,\n          escapeEntireInlineScriptContent(bootstrapScriptContent),\n          endInlineScript\n        ));\n      idPrefix = {\n        placeholderPrefix: idPrefix + \"P:\",\n        segmentPrefix: idPrefix + \"S:\",\n        boundaryPrefix: idPrefix + \"B:\",\n        startInlineScript: \"<script\",\n        startInlineStyle: \"<style\",\n        preamble: { htmlChunks: null, headChunks: null, bodyChunks: null },\n        externalRuntimeScript: null,\n        bootstrapChunks: bootstrapChunks,\n        importMapChunks: [],\n        onHeaders: void 0,\n        headers: null,\n        resets: {\n          font: {},\n          dns: {},\n          connect: { default: {}, anonymous: {}, credentials: {} },\n          image: {},\n          style: {}\n        },\n        charsetChunks: [],\n        viewportChunks: [],\n        hoistableChunks: [],\n        preconnects: new Set(),\n        fontPreloads: new Set(),\n        highImagePreloads: new Set(),\n        styles: new Map(),\n        bootstrapScripts: new Set(),\n        scripts: new Set(),\n        bulkPreloads: new Set(),\n        preloads: {\n          images: new Map(),\n          stylesheets: new Map(),\n          scripts: new Map(),\n          moduleScripts: new Map()\n        },\n        nonce: { script: void 0, style: void 0 },\n        hoistableState: null,\n        stylesToHoist: !1\n      };\n      if (void 0 !== bootstrapScripts)\n        for (\n          bootstrapScriptContent = 0;\n          bootstrapScriptContent < bootstrapScripts.length;\n          bootstrapScriptContent++\n        ) {\n          var scriptConfig = bootstrapScripts[bootstrapScriptContent],\n            src,\n            crossOrigin = void 0,\n            integrity = void 0,\n            props = {\n              rel: \"preload\",\n              as: \"script\",\n              fetchPriority: \"low\",\n              nonce: void 0\n            };\n          \"string\" === typeof scriptConfig\n            ? (props.href = src = scriptConfig)\n            : ((props.href = src = scriptConfig.src),\n              (props.integrity = integrity =\n                \"string\" === typeof scriptConfig.integrity\n                  ? scriptConfig.integrity\n                  : void 0),\n              (props.crossOrigin = crossOrigin =\n                \"string\" === typeof scriptConfig ||\n                null == scriptConfig.crossOrigin\n                  ? void 0\n                  : \"use-credentials\" === scriptConfig.crossOrigin\n                    ? \"use-credentials\"\n                    : \"\"));\n          preloadBootstrapScriptOrModule(resumableState, idPrefix, src, props);\n          bootstrapChunks.push(\n            '<script src=\"',\n            escapeTextForBrowser(src),\n            attributeEnd\n          );\n          \"string\" === typeof integrity &&\n            bootstrapChunks.push(\n              ' integrity=\"',\n              escapeTextForBrowser(integrity),\n              attributeEnd\n            );\n          \"string\" === typeof crossOrigin &&\n            bootstrapChunks.push(\n              ' crossorigin=\"',\n              escapeTextForBrowser(crossOrigin),\n              attributeEnd\n            );\n          pushCompletedShellIdAttribute(bootstrapChunks, resumableState);\n          bootstrapChunks.push(' async=\"\">\\x3c/script>');\n        }\n      if (void 0 !== bootstrapModules)\n        for (\n          bootstrapScripts = 0;\n          bootstrapScripts < bootstrapModules.length;\n          bootstrapScripts++\n        )\n          (bootstrapScriptContent = bootstrapModules[bootstrapScripts]),\n            (crossOrigin = src = void 0),\n            (integrity = {\n              rel: \"modulepreload\",\n              fetchPriority: \"low\",\n              nonce: void 0\n            }),\n            \"string\" === typeof bootstrapScriptContent\n              ? (integrity.href = scriptConfig = bootstrapScriptContent)\n              : ((integrity.href = scriptConfig = bootstrapScriptContent.src),\n                (integrity.integrity = crossOrigin =\n                  \"string\" === typeof bootstrapScriptContent.integrity\n                    ? bootstrapScriptContent.integrity\n                    : void 0),\n                (integrity.crossOrigin = src =\n                  \"string\" === typeof bootstrapScriptContent ||\n                  null == bootstrapScriptContent.crossOrigin\n                    ? void 0\n                    : \"use-credentials\" === bootstrapScriptContent.crossOrigin\n                      ? \"use-credentials\"\n                      : \"\")),\n            preloadBootstrapScriptOrModule(\n              resumableState,\n              idPrefix,\n              scriptConfig,\n              integrity\n            ),\n            bootstrapChunks.push(\n              '<script type=\"module\" src=\"',\n              escapeTextForBrowser(scriptConfig),\n              attributeEnd\n            ),\n            \"string\" === typeof crossOrigin &&\n              bootstrapChunks.push(\n                ' integrity=\"',\n                escapeTextForBrowser(crossOrigin),\n                attributeEnd\n              ),\n            \"string\" === typeof src &&\n              bootstrapChunks.push(\n                ' crossorigin=\"',\n                escapeTextForBrowser(src),\n                attributeEnd\n              ),\n            pushCompletedShellIdAttribute(bootstrapChunks, resumableState),\n            bootstrapChunks.push(' async=\"\">\\x3c/script>');\n      return {\n        placeholderPrefix: idPrefix.placeholderPrefix,\n        segmentPrefix: idPrefix.segmentPrefix,\n        boundaryPrefix: idPrefix.boundaryPrefix,\n        startInlineScript: idPrefix.startInlineScript,\n        startInlineStyle: idPrefix.startInlineStyle,\n        preamble: idPrefix.preamble,\n        externalRuntimeScript: idPrefix.externalRuntimeScript,\n        bootstrapChunks: idPrefix.bootstrapChunks,\n        importMapChunks: idPrefix.importMapChunks,\n        onHeaders: idPrefix.onHeaders,\n        headers: idPrefix.headers,\n        resets: idPrefix.resets,\n        charsetChunks: idPrefix.charsetChunks,\n        viewportChunks: idPrefix.viewportChunks,\n        hoistableChunks: idPrefix.hoistableChunks,\n        preconnects: idPrefix.preconnects,\n        fontPreloads: idPrefix.fontPreloads,\n        highImagePreloads: idPrefix.highImagePreloads,\n        styles: idPrefix.styles,\n        bootstrapScripts: idPrefix.bootstrapScripts,\n        scripts: idPrefix.scripts,\n        bulkPreloads: idPrefix.bulkPreloads,\n        preloads: idPrefix.preloads,\n        nonce: idPrefix.nonce,\n        stylesToHoist: idPrefix.stylesToHoist,\n        generateStaticMarkup: generateStaticMarkup\n      };\n    }\n    function pushTextInstance(target, text, renderState, textEmbedded) {\n      if (renderState.generateStaticMarkup)\n        return target.push(escapeTextForBrowser(text)), !1;\n      \"\" === text\n        ? (target = textEmbedded)\n        : (textEmbedded && target.push(\"\\x3c!-- --\\x3e\"),\n          target.push(escapeTextForBrowser(text)),\n          (target = !0));\n      return target;\n    }\n    function pushSegmentFinale(\n      target,\n      renderState,\n      lastPushedText,\n      textEmbedded\n    ) {\n      renderState.generateStaticMarkup ||\n        (lastPushedText && textEmbedded && target.push(\"\\x3c!-- --\\x3e\"));\n    }\n    function getComponentNameFromType(type) {\n      if (null == type) return null;\n      if (\"function\" === typeof type)\n        return type.$$typeof === REACT_CLIENT_REFERENCE\n          ? null\n          : type.displayName || type.name || null;\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return \"Fragment\";\n        case REACT_PROFILER_TYPE:\n          return \"Profiler\";\n        case REACT_STRICT_MODE_TYPE:\n          return \"StrictMode\";\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n        case REACT_ACTIVITY_TYPE:\n          return \"Activity\";\n      }\n      if (\"object\" === typeof type)\n        switch (\n          (\"number\" === typeof type.tag &&\n            console.error(\n              \"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"\n            ),\n          type.$$typeof)\n        ) {\n          case REACT_PORTAL_TYPE:\n            return \"Portal\";\n          case REACT_CONTEXT_TYPE:\n            return type.displayName || \"Context\";\n          case REACT_CONSUMER_TYPE:\n            return (type._context.displayName || \"Context\") + \".Consumer\";\n          case REACT_FORWARD_REF_TYPE:\n            var innerType = type.render;\n            type = type.displayName;\n            type ||\n              ((type = innerType.displayName || innerType.name || \"\"),\n              (type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\"));\n            return type;\n          case REACT_MEMO_TYPE:\n            return (\n              (innerType = type.displayName || null),\n              null !== innerType\n                ? innerType\n                : getComponentNameFromType(type.type) || \"Memo\"\n            );\n          case REACT_LAZY_TYPE:\n            innerType = type._payload;\n            type = type._init;\n            try {\n              return getComponentNameFromType(type(innerType));\n            } catch (x) {}\n        }\n      return null;\n    }\n    function popToNearestCommonAncestor(prev, next) {\n      if (prev !== next) {\n        prev.context._currentValue2 = prev.parentValue;\n        prev = prev.parent;\n        var parentNext = next.parent;\n        if (null === prev) {\n          if (null !== parentNext)\n            throw Error(\n              \"The stacks must reach the root at the same time. This is a bug in React.\"\n            );\n        } else {\n          if (null === parentNext)\n            throw Error(\n              \"The stacks must reach the root at the same time. This is a bug in React.\"\n            );\n          popToNearestCommonAncestor(prev, parentNext);\n        }\n        next.context._currentValue2 = next.value;\n      }\n    }\n    function popAllPrevious(prev) {\n      prev.context._currentValue2 = prev.parentValue;\n      prev = prev.parent;\n      null !== prev && popAllPrevious(prev);\n    }\n    function pushAllNext(next) {\n      var parentNext = next.parent;\n      null !== parentNext && pushAllNext(parentNext);\n      next.context._currentValue2 = next.value;\n    }\n    function popPreviousToCommonLevel(prev, next) {\n      prev.context._currentValue2 = prev.parentValue;\n      prev = prev.parent;\n      if (null === prev)\n        throw Error(\n          \"The depth must equal at least at zero before reaching the root. This is a bug in React.\"\n        );\n      prev.depth === next.depth\n        ? popToNearestCommonAncestor(prev, next)\n        : popPreviousToCommonLevel(prev, next);\n    }\n    function popNextToCommonLevel(prev, next) {\n      var parentNext = next.parent;\n      if (null === parentNext)\n        throw Error(\n          \"The depth must equal at least at zero before reaching the root. This is a bug in React.\"\n        );\n      prev.depth === parentNext.depth\n        ? popToNearestCommonAncestor(prev, parentNext)\n        : popNextToCommonLevel(prev, parentNext);\n      next.context._currentValue2 = next.value;\n    }\n    function switchContext(newSnapshot) {\n      var prev = currentActiveSnapshot;\n      prev !== newSnapshot &&\n        (null === prev\n          ? pushAllNext(newSnapshot)\n          : null === newSnapshot\n            ? popAllPrevious(prev)\n            : prev.depth === newSnapshot.depth\n              ? popToNearestCommonAncestor(prev, newSnapshot)\n              : prev.depth > newSnapshot.depth\n                ? popPreviousToCommonLevel(prev, newSnapshot)\n                : popNextToCommonLevel(prev, newSnapshot),\n        (currentActiveSnapshot = newSnapshot));\n    }\n    function warnOnInvalidCallback(callback) {\n      if (null !== callback && \"function\" !== typeof callback) {\n        var key = String(callback);\n        didWarnOnInvalidCallback.has(key) ||\n          (didWarnOnInvalidCallback.add(key),\n          console.error(\n            \"Expected the last optional `callback` argument to be a function. Instead received: %s.\",\n            callback\n          ));\n      }\n    }\n    function warnNoop(publicInstance, callerName) {\n      publicInstance =\n        ((publicInstance = publicInstance.constructor) &&\n          getComponentNameFromType(publicInstance)) ||\n        \"ReactClass\";\n      var warningKey = publicInstance + \".\" + callerName;\n      didWarnAboutNoopUpdateForComponent[warningKey] ||\n        (console.error(\n          \"Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.\\n\\nPlease check the code for the %s component.\",\n          callerName,\n          publicInstance\n        ),\n        (didWarnAboutNoopUpdateForComponent[warningKey] = !0));\n    }\n    function pushTreeContext(baseContext, totalChildren, index) {\n      var baseIdWithLeadingBit = baseContext.id;\n      baseContext = baseContext.overflow;\n      var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;\n      baseIdWithLeadingBit &= ~(1 << baseLength);\n      index += 1;\n      var length = 32 - clz32(totalChildren) + baseLength;\n      if (30 < length) {\n        var numberOfOverflowBits = baseLength - (baseLength % 5);\n        length = (\n          baseIdWithLeadingBit &\n          ((1 << numberOfOverflowBits) - 1)\n        ).toString(32);\n        baseIdWithLeadingBit >>= numberOfOverflowBits;\n        baseLength -= numberOfOverflowBits;\n        return {\n          id:\n            (1 << (32 - clz32(totalChildren) + baseLength)) |\n            (index << baseLength) |\n            baseIdWithLeadingBit,\n          overflow: length + baseContext\n        };\n      }\n      return {\n        id: (1 << length) | (index << baseLength) | baseIdWithLeadingBit,\n        overflow: baseContext\n      };\n    }\n    function clz32Fallback(x) {\n      x >>>= 0;\n      return 0 === x ? 32 : (31 - ((log(x) / LN2) | 0)) | 0;\n    }\n    function noop() {}\n    function trackUsedThenable(thenableState, thenable, index) {\n      index = thenableState[index];\n      void 0 === index\n        ? thenableState.push(thenable)\n        : index !== thenable && (thenable.then(noop, noop), (thenable = index));\n      switch (thenable.status) {\n        case \"fulfilled\":\n          return thenable.value;\n        case \"rejected\":\n          throw thenable.reason;\n        default:\n          \"string\" === typeof thenable.status\n            ? thenable.then(noop, noop)\n            : ((thenableState = thenable),\n              (thenableState.status = \"pending\"),\n              thenableState.then(\n                function (fulfilledValue) {\n                  if (\"pending\" === thenable.status) {\n                    var fulfilledThenable = thenable;\n                    fulfilledThenable.status = \"fulfilled\";\n                    fulfilledThenable.value = fulfilledValue;\n                  }\n                },\n                function (error) {\n                  if (\"pending\" === thenable.status) {\n                    var rejectedThenable = thenable;\n                    rejectedThenable.status = \"rejected\";\n                    rejectedThenable.reason = error;\n                  }\n                }\n              ));\n          switch (thenable.status) {\n            case \"fulfilled\":\n              return thenable.value;\n            case \"rejected\":\n              throw thenable.reason;\n          }\n          suspendedThenable = thenable;\n          throw SuspenseException;\n      }\n    }\n    function getSuspendedThenable() {\n      if (null === suspendedThenable)\n        throw Error(\n          \"Expected a suspended thenable. This is a bug in React. Please file an issue.\"\n        );\n      var thenable = suspendedThenable;\n      suspendedThenable = null;\n      return thenable;\n    }\n    function is(x, y) {\n      return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);\n    }\n    function resolveCurrentlyRenderingComponent() {\n      if (null === currentlyRenderingComponent)\n        throw Error(\n          \"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\\n1. You might have mismatching versions of React and the renderer (such as React DOM)\\n2. You might be breaking the Rules of Hooks\\n3. You might have more than one copy of React in the same app\\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.\"\n        );\n      isInHookUserCodeInDev &&\n        console.error(\n          \"Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks\"\n        );\n      return currentlyRenderingComponent;\n    }\n    function createHook() {\n      if (0 < numberOfReRenders)\n        throw Error(\"Rendered more hooks than during the previous render\");\n      return { memoizedState: null, queue: null, next: null };\n    }\n    function createWorkInProgressHook() {\n      null === workInProgressHook\n        ? null === firstWorkInProgressHook\n          ? ((isReRender = !1),\n            (firstWorkInProgressHook = workInProgressHook = createHook()))\n          : ((isReRender = !0), (workInProgressHook = firstWorkInProgressHook))\n        : null === workInProgressHook.next\n          ? ((isReRender = !1),\n            (workInProgressHook = workInProgressHook.next = createHook()))\n          : ((isReRender = !0), (workInProgressHook = workInProgressHook.next));\n      return workInProgressHook;\n    }\n    function getThenableStateAfterSuspending() {\n      var state = thenableState;\n      thenableState = null;\n      return state;\n    }\n    function resetHooksState() {\n      isInHookUserCodeInDev = !1;\n      currentlyRenderingKeyPath =\n        currentlyRenderingRequest =\n        currentlyRenderingTask =\n        currentlyRenderingComponent =\n          null;\n      didScheduleRenderPhaseUpdate = !1;\n      firstWorkInProgressHook = null;\n      numberOfReRenders = 0;\n      workInProgressHook = renderPhaseUpdates = null;\n    }\n    function readContext(context) {\n      isInHookUserCodeInDev &&\n        console.error(\n          \"Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().\"\n        );\n      return context._currentValue2;\n    }\n    function basicStateReducer(state, action) {\n      return \"function\" === typeof action ? action(state) : action;\n    }\n    function useReducer(reducer, initialArg, init) {\n      reducer !== basicStateReducer && (currentHookNameInDev = \"useReducer\");\n      currentlyRenderingComponent = resolveCurrentlyRenderingComponent();\n      workInProgressHook = createWorkInProgressHook();\n      if (isReRender) {\n        init = workInProgressHook.queue;\n        initialArg = init.dispatch;\n        if (null !== renderPhaseUpdates) {\n          var firstRenderPhaseUpdate = renderPhaseUpdates.get(init);\n          if (void 0 !== firstRenderPhaseUpdate) {\n            renderPhaseUpdates.delete(init);\n            init = workInProgressHook.memoizedState;\n            do {\n              var action = firstRenderPhaseUpdate.action;\n              isInHookUserCodeInDev = !0;\n              init = reducer(init, action);\n              isInHookUserCodeInDev = !1;\n              firstRenderPhaseUpdate = firstRenderPhaseUpdate.next;\n            } while (null !== firstRenderPhaseUpdate);\n            workInProgressHook.memoizedState = init;\n            return [init, initialArg];\n          }\n        }\n        return [workInProgressHook.memoizedState, initialArg];\n      }\n      isInHookUserCodeInDev = !0;\n      reducer =\n        reducer === basicStateReducer\n          ? \"function\" === typeof initialArg\n            ? initialArg()\n            : initialArg\n          : void 0 !== init\n            ? init(initialArg)\n            : initialArg;\n      isInHookUserCodeInDev = !1;\n      workInProgressHook.memoizedState = reducer;\n      reducer = workInProgressHook.queue = { last: null, dispatch: null };\n      reducer = reducer.dispatch = dispatchAction.bind(\n        null,\n        currentlyRenderingComponent,\n        reducer\n      );\n      return [workInProgressHook.memoizedState, reducer];\n    }\n    function useMemo(nextCreate, deps) {\n      currentlyRenderingComponent = resolveCurrentlyRenderingComponent();\n      workInProgressHook = createWorkInProgressHook();\n      deps = void 0 === deps ? null : deps;\n      if (null !== workInProgressHook) {\n        var prevState = workInProgressHook.memoizedState;\n        if (null !== prevState && null !== deps) {\n          a: {\n            var JSCompiler_inline_result = prevState[1];\n            if (null === JSCompiler_inline_result)\n              console.error(\n                \"%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.\",\n                currentHookNameInDev\n              ),\n                (JSCompiler_inline_result = !1);\n            else {\n              deps.length !== JSCompiler_inline_result.length &&\n                console.error(\n                  \"The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\\n\\nPrevious: %s\\nIncoming: %s\",\n                  currentHookNameInDev,\n                  \"[\" + deps.join(\", \") + \"]\",\n                  \"[\" + JSCompiler_inline_result.join(\", \") + \"]\"\n                );\n              for (\n                var i = 0;\n                i < JSCompiler_inline_result.length && i < deps.length;\n                i++\n              )\n                if (!objectIs(deps[i], JSCompiler_inline_result[i])) {\n                  JSCompiler_inline_result = !1;\n                  break a;\n                }\n              JSCompiler_inline_result = !0;\n            }\n          }\n          if (JSCompiler_inline_result) return prevState[0];\n        }\n      }\n      isInHookUserCodeInDev = !0;\n      nextCreate = nextCreate();\n      isInHookUserCodeInDev = !1;\n      workInProgressHook.memoizedState = [nextCreate, deps];\n      return nextCreate;\n    }\n    function dispatchAction(componentIdentity, queue, action) {\n      if (25 <= numberOfReRenders)\n        throw Error(\n          \"Too many re-renders. React limits the number of renders to prevent an infinite loop.\"\n        );\n      if (componentIdentity === currentlyRenderingComponent)\n        if (\n          ((didScheduleRenderPhaseUpdate = !0),\n          (componentIdentity = { action: action, next: null }),\n          null === renderPhaseUpdates && (renderPhaseUpdates = new Map()),\n          (action = renderPhaseUpdates.get(queue)),\n          void 0 === action)\n        )\n          renderPhaseUpdates.set(queue, componentIdentity);\n        else {\n          for (queue = action; null !== queue.next; ) queue = queue.next;\n          queue.next = componentIdentity;\n        }\n    }\n    function throwOnUseEffectEventCall() {\n      throw Error(\n        \"A function wrapped in useEffectEvent can't be called during rendering.\"\n      );\n    }\n    function unsupportedStartTransition() {\n      throw Error(\"startTransition cannot be called during server rendering.\");\n    }\n    function unsupportedSetOptimisticState() {\n      throw Error(\"Cannot update optimistic state while rendering.\");\n    }\n    function useActionState(action, initialState, permalink) {\n      resolveCurrentlyRenderingComponent();\n      var actionStateHookIndex = actionStateCounter++,\n        request = currentlyRenderingRequest;\n      if (\"function\" === typeof action.$$FORM_ACTION) {\n        var nextPostbackStateKey = null,\n          componentKeyPath = currentlyRenderingKeyPath;\n        request = request.formState;\n        var isSignatureEqual = action.$$IS_SIGNATURE_EQUAL;\n        if (null !== request && \"function\" === typeof isSignatureEqual) {\n          var postbackKey = request[1];\n          isSignatureEqual.call(action, request[2], request[3]) &&\n            ((nextPostbackStateKey =\n              void 0 !== permalink\n                ? \"p\" + permalink\n                : \"k\" +\n                  murmurhash3_32_gc(\n                    JSON.stringify([\n                      componentKeyPath,\n                      null,\n                      actionStateHookIndex\n                    ]),\n                    0\n                  )),\n            postbackKey === nextPostbackStateKey &&\n              ((actionStateMatchingIndex = actionStateHookIndex),\n              (initialState = request[0])));\n        }\n        var boundAction = action.bind(null, initialState);\n        action = function (payload) {\n          boundAction(payload);\n        };\n        \"function\" === typeof boundAction.$$FORM_ACTION &&\n          (action.$$FORM_ACTION = function (prefix) {\n            prefix = boundAction.$$FORM_ACTION(prefix);\n            void 0 !== permalink &&\n              (checkAttributeStringCoercion(permalink, \"target\"),\n              (permalink += \"\"),\n              (prefix.action = permalink));\n            var formData = prefix.data;\n            formData &&\n              (null === nextPostbackStateKey &&\n                (nextPostbackStateKey =\n                  void 0 !== permalink\n                    ? \"p\" + permalink\n                    : \"k\" +\n                      murmurhash3_32_gc(\n                        JSON.stringify([\n                          componentKeyPath,\n                          null,\n                          actionStateHookIndex\n                        ]),\n                        0\n                      )),\n              formData.append(\"$ACTION_KEY\", nextPostbackStateKey));\n            return prefix;\n          });\n        return [initialState, action, !1];\n      }\n      var _boundAction = action.bind(null, initialState);\n      return [\n        initialState,\n        function (payload) {\n          _boundAction(payload);\n        },\n        !1\n      ];\n    }\n    function unwrapThenable(thenable) {\n      var index = thenableIndexCounter;\n      thenableIndexCounter += 1;\n      null === thenableState && (thenableState = []);\n      return trackUsedThenable(thenableState, thenable, index);\n    }\n    function unsupportedRefresh() {\n      throw Error(\"Cache cannot be refreshed during server rendering.\");\n    }\n    function disabledLog() {}\n    function disableLogs() {\n      if (0 === disabledDepth) {\n        prevLog = console.log;\n        prevInfo = console.info;\n        prevWarn = console.warn;\n        prevError = console.error;\n        prevGroup = console.group;\n        prevGroupCollapsed = console.groupCollapsed;\n        prevGroupEnd = console.groupEnd;\n        var props = {\n          configurable: !0,\n          enumerable: !0,\n          value: disabledLog,\n          writable: !0\n        };\n        Object.defineProperties(console, {\n          info: props,\n          log: props,\n          warn: props,\n          error: props,\n          group: props,\n          groupCollapsed: props,\n          groupEnd: props\n        });\n      }\n      disabledDepth++;\n    }\n    function reenableLogs() {\n      disabledDepth--;\n      if (0 === disabledDepth) {\n        var props = { configurable: !0, enumerable: !0, writable: !0 };\n        Object.defineProperties(console, {\n          log: assign({}, props, { value: prevLog }),\n          info: assign({}, props, { value: prevInfo }),\n          warn: assign({}, props, { value: prevWarn }),\n          error: assign({}, props, { value: prevError }),\n          group: assign({}, props, { value: prevGroup }),\n          groupCollapsed: assign({}, props, { value: prevGroupCollapsed }),\n          groupEnd: assign({}, props, { value: prevGroupEnd })\n        });\n      }\n      0 > disabledDepth &&\n        console.error(\n          \"disabledDepth fell below zero. This is a bug in React. Please file an issue.\"\n        );\n    }\n    function formatOwnerStack(error) {\n      var prevPrepareStackTrace = Error.prepareStackTrace;\n      Error.prepareStackTrace = void 0;\n      error = error.stack;\n      Error.prepareStackTrace = prevPrepareStackTrace;\n      error.startsWith(\"Error: react-stack-top-frame\\n\") &&\n        (error = error.slice(29));\n      prevPrepareStackTrace = error.indexOf(\"\\n\");\n      -1 !== prevPrepareStackTrace &&\n        (error = error.slice(prevPrepareStackTrace + 1));\n      prevPrepareStackTrace = error.indexOf(\"react_stack_bottom_frame\");\n      -1 !== prevPrepareStackTrace &&\n        (prevPrepareStackTrace = error.lastIndexOf(\n          \"\\n\",\n          prevPrepareStackTrace\n        ));\n      if (-1 !== prevPrepareStackTrace)\n        error = error.slice(0, prevPrepareStackTrace);\n      else return \"\";\n      return error;\n    }\n    function describeBuiltInComponentFrame(name) {\n      if (void 0 === prefix)\n        try {\n          throw Error();\n        } catch (x) {\n          var match = x.stack.trim().match(/\\n( *(at )?)/);\n          prefix = (match && match[1]) || \"\";\n          suffix =\n            -1 < x.stack.indexOf(\"\\n    at\")\n              ? \" (<anonymous>)\"\n              : -1 < x.stack.indexOf(\"@\")\n                ? \"@unknown:0:0\"\n                : \"\";\n        }\n      return \"\\n\" + prefix + name + suffix;\n    }\n    function describeNativeComponentFrame(fn, construct) {\n      if (!fn || reentry) return \"\";\n      var frame = componentFrameCache.get(fn);\n      if (void 0 !== frame) return frame;\n      reentry = !0;\n      frame = Error.prepareStackTrace;\n      Error.prepareStackTrace = void 0;\n      var previousDispatcher = null;\n      previousDispatcher = ReactSharedInternals.H;\n      ReactSharedInternals.H = null;\n      disableLogs();\n      try {\n        var RunInRootFrame = {\n          DetermineComponentFrameRoot: function () {\n            try {\n              if (construct) {\n                var Fake = function () {\n                  throw Error();\n                };\n                Object.defineProperty(Fake.prototype, \"props\", {\n                  set: function () {\n                    throw Error();\n                  }\n                });\n                if (\"object\" === typeof Reflect && Reflect.construct) {\n                  try {\n                    Reflect.construct(Fake, []);\n                  } catch (x) {\n                    var control = x;\n                  }\n                  Reflect.construct(fn, [], Fake);\n                } else {\n                  try {\n                    Fake.call();\n                  } catch (x$0) {\n                    control = x$0;\n                  }\n                  fn.call(Fake.prototype);\n                }\n              } else {\n                try {\n                  throw Error();\n                } catch (x$1) {\n                  control = x$1;\n                }\n                (Fake = fn()) &&\n                  \"function\" === typeof Fake.catch &&\n                  Fake.catch(function () {});\n              }\n            } catch (sample) {\n              if (sample && control && \"string\" === typeof sample.stack)\n                return [sample.stack, control.stack];\n            }\n            return [null, null];\n          }\n        };\n        RunInRootFrame.DetermineComponentFrameRoot.displayName =\n          \"DetermineComponentFrameRoot\";\n        var namePropDescriptor = Object.getOwnPropertyDescriptor(\n          RunInRootFrame.DetermineComponentFrameRoot,\n          \"name\"\n        );\n        namePropDescriptor &&\n          namePropDescriptor.configurable &&\n          Object.defineProperty(\n            RunInRootFrame.DetermineComponentFrameRoot,\n            \"name\",\n            { value: \"DetermineComponentFrameRoot\" }\n          );\n        var _RunInRootFrame$Deter =\n            RunInRootFrame.DetermineComponentFrameRoot(),\n          sampleStack = _RunInRootFrame$Deter[0],\n          controlStack = _RunInRootFrame$Deter[1];\n        if (sampleStack && controlStack) {\n          var sampleLines = sampleStack.split(\"\\n\"),\n            controlLines = controlStack.split(\"\\n\");\n          for (\n            _RunInRootFrame$Deter = namePropDescriptor = 0;\n            namePropDescriptor < sampleLines.length &&\n            !sampleLines[namePropDescriptor].includes(\n              \"DetermineComponentFrameRoot\"\n            );\n\n          )\n            namePropDescriptor++;\n          for (\n            ;\n            _RunInRootFrame$Deter < controlLines.length &&\n            !controlLines[_RunInRootFrame$Deter].includes(\n              \"DetermineComponentFrameRoot\"\n            );\n\n          )\n            _RunInRootFrame$Deter++;\n          if (\n            namePropDescriptor === sampleLines.length ||\n            _RunInRootFrame$Deter === controlLines.length\n          )\n            for (\n              namePropDescriptor = sampleLines.length - 1,\n                _RunInRootFrame$Deter = controlLines.length - 1;\n              1 <= namePropDescriptor &&\n              0 <= _RunInRootFrame$Deter &&\n              sampleLines[namePropDescriptor] !==\n                controlLines[_RunInRootFrame$Deter];\n\n            )\n              _RunInRootFrame$Deter--;\n          for (\n            ;\n            1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter;\n            namePropDescriptor--, _RunInRootFrame$Deter--\n          )\n            if (\n              sampleLines[namePropDescriptor] !==\n              controlLines[_RunInRootFrame$Deter]\n            ) {\n              if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {\n                do\n                  if (\n                    (namePropDescriptor--,\n                    _RunInRootFrame$Deter--,\n                    0 > _RunInRootFrame$Deter ||\n                      sampleLines[namePropDescriptor] !==\n                        controlLines[_RunInRootFrame$Deter])\n                  ) {\n                    var _frame =\n                      \"\\n\" +\n                      sampleLines[namePropDescriptor].replace(\n                        \" at new \",\n                        \" at \"\n                      );\n                    fn.displayName &&\n                      _frame.includes(\"<anonymous>\") &&\n                      (_frame = _frame.replace(\"<anonymous>\", fn.displayName));\n                    \"function\" === typeof fn &&\n                      componentFrameCache.set(fn, _frame);\n                    return _frame;\n                  }\n                while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);\n              }\n              break;\n            }\n        }\n      } finally {\n        (reentry = !1),\n          (ReactSharedInternals.H = previousDispatcher),\n          reenableLogs(),\n          (Error.prepareStackTrace = frame);\n      }\n      sampleLines = (sampleLines = fn ? fn.displayName || fn.name : \"\")\n        ? describeBuiltInComponentFrame(sampleLines)\n        : \"\";\n      \"function\" === typeof fn && componentFrameCache.set(fn, sampleLines);\n      return sampleLines;\n    }\n    function describeComponentStackByType(type) {\n      if (\"string\" === typeof type) return describeBuiltInComponentFrame(type);\n      if (\"function\" === typeof type)\n        return type.prototype && type.prototype.isReactComponent\n          ? describeNativeComponentFrame(type, !0)\n          : describeNativeComponentFrame(type, !1);\n      if (\"object\" === typeof type && null !== type) {\n        switch (type.$$typeof) {\n          case REACT_FORWARD_REF_TYPE:\n            return describeNativeComponentFrame(type.render, !1);\n          case REACT_MEMO_TYPE:\n            return describeNativeComponentFrame(type.type, !1);\n          case REACT_LAZY_TYPE:\n            var lazyComponent = type,\n              payload = lazyComponent._payload;\n            lazyComponent = lazyComponent._init;\n            try {\n              type = lazyComponent(payload);\n            } catch (x) {\n              return describeBuiltInComponentFrame(\"Lazy\");\n            }\n            return describeComponentStackByType(type);\n        }\n        if (\"string\" === typeof type.name) {\n          a: {\n            payload = type.name;\n            lazyComponent = type.env;\n            type = type.debugLocation;\n            if (null != type) {\n              type = formatOwnerStack(type);\n              var idx = type.lastIndexOf(\"\\n\");\n              type = -1 === idx ? type : type.slice(idx + 1);\n              if (-1 !== type.indexOf(payload)) {\n                payload = \"\\n\" + type;\n                break a;\n              }\n            }\n            payload = describeBuiltInComponentFrame(\n              payload + (lazyComponent ? \" [\" + lazyComponent + \"]\" : \"\")\n            );\n          }\n          return payload;\n        }\n      }\n      switch (type) {\n        case REACT_SUSPENSE_LIST_TYPE:\n          return describeBuiltInComponentFrame(\"SuspenseList\");\n        case REACT_SUSPENSE_TYPE:\n          return describeBuiltInComponentFrame(\"Suspense\");\n      }\n      return \"\";\n    }\n    function isEligibleForOutlining(request, boundary) {\n      return (\n        (500 < boundary.byteSize || !1) && null === boundary.contentPreamble\n      );\n    }\n    function defaultErrorHandler(error) {\n      if (\n        \"object\" === typeof error &&\n        null !== error &&\n        \"string\" === typeof error.environmentName\n      ) {\n        var JSCompiler_inline_result = error.environmentName;\n        error = [error].slice(0);\n        \"string\" === typeof error[0]\n          ? error.splice(\n              0,\n              1,\n              \"[%s] \" + error[0],\n              \" \" + JSCompiler_inline_result + \" \"\n            )\n          : error.splice(0, 0, \"[%s]\", \" \" + JSCompiler_inline_result + \" \");\n        error.unshift(console);\n        JSCompiler_inline_result = bind.apply(console.error, error);\n        JSCompiler_inline_result();\n      } else console.error(error);\n      return null;\n    }\n    function RequestInstance(\n      resumableState,\n      renderState,\n      rootFormatContext,\n      progressiveChunkSize,\n      onError,\n      onAllReady,\n      onShellReady,\n      onShellError,\n      onFatalError,\n      onPostpone,\n      formState\n    ) {\n      var abortSet = new Set();\n      this.destination = null;\n      this.flushScheduled = !1;\n      this.resumableState = resumableState;\n      this.renderState = renderState;\n      this.rootFormatContext = rootFormatContext;\n      this.progressiveChunkSize =\n        void 0 === progressiveChunkSize ? 12800 : progressiveChunkSize;\n      this.status = 10;\n      this.fatalError = null;\n      this.pendingRootTasks = this.allPendingTasks = this.nextSegmentId = 0;\n      this.completedPreambleSegments = this.completedRootSegment = null;\n      this.byteSize = 0;\n      this.abortableTasks = abortSet;\n      this.pingedTasks = [];\n      this.clientRenderedBoundaries = [];\n      this.completedBoundaries = [];\n      this.partialBoundaries = [];\n      this.trackedPostpones = null;\n      this.onError = void 0 === onError ? defaultErrorHandler : onError;\n      this.onPostpone = void 0 === onPostpone ? noop : onPostpone;\n      this.onAllReady = void 0 === onAllReady ? noop : onAllReady;\n      this.onShellReady = void 0 === onShellReady ? noop : onShellReady;\n      this.onShellError = void 0 === onShellError ? noop : onShellError;\n      this.onFatalError = void 0 === onFatalError ? noop : onFatalError;\n      this.formState = void 0 === formState ? null : formState;\n      this.didWarnForKey = null;\n    }\n    function createRequest(\n      children,\n      resumableState,\n      renderState,\n      rootFormatContext,\n      progressiveChunkSize,\n      onError,\n      onAllReady,\n      onShellReady,\n      onShellError,\n      onFatalError,\n      onPostpone,\n      formState\n    ) {\n      var now = getCurrentTime();\n      1e3 < now - lastResetTime &&\n        ((ReactSharedInternals.recentlyCreatedOwnerStacks = 0),\n        (lastResetTime = now));\n      resumableState = new RequestInstance(\n        resumableState,\n        renderState,\n        rootFormatContext,\n        progressiveChunkSize,\n        onError,\n        onAllReady,\n        onShellReady,\n        onShellError,\n        onFatalError,\n        onPostpone,\n        formState\n      );\n      renderState = createPendingSegment(\n        resumableState,\n        0,\n        null,\n        rootFormatContext,\n        !1,\n        !1\n      );\n      renderState.parentFlushed = !0;\n      children = createRenderTask(\n        resumableState,\n        null,\n        children,\n        -1,\n        null,\n        renderState,\n        null,\n        null,\n        resumableState.abortableTasks,\n        null,\n        rootFormatContext,\n        null,\n        emptyTreeContext,\n        null,\n        null,\n        emptyContextObject,\n        null\n      );\n      pushComponentStack(children);\n      resumableState.pingedTasks.push(children);\n      return resumableState;\n    }\n    function pingTask(request, task) {\n      request.pingedTasks.push(task);\n      1 === request.pingedTasks.length &&\n        ((request.flushScheduled = null !== request.destination),\n        performWork(request));\n    }\n    function createSuspenseBoundary(\n      request,\n      row,\n      fallbackAbortableTasks,\n      contentPreamble,\n      fallbackPreamble\n    ) {\n      fallbackAbortableTasks = {\n        status: PENDING,\n        rootSegmentID: -1,\n        parentFlushed: !1,\n        pendingTasks: 0,\n        row: row,\n        completedSegments: [],\n        byteSize: 0,\n        fallbackAbortableTasks: fallbackAbortableTasks,\n        errorDigest: null,\n        contentState: createHoistableState(),\n        fallbackState: createHoistableState(),\n        contentPreamble: contentPreamble,\n        fallbackPreamble: fallbackPreamble,\n        trackedContentKeyPath: null,\n        trackedFallbackNode: null,\n        errorMessage: null,\n        errorStack: null,\n        errorComponentStack: null\n      };\n      null !== row &&\n        (row.pendingTasks++,\n        (contentPreamble = row.boundaries),\n        null !== contentPreamble &&\n          (request.allPendingTasks++,\n          fallbackAbortableTasks.pendingTasks++,\n          contentPreamble.push(fallbackAbortableTasks)),\n        (request = row.inheritedHoistables),\n        null !== request &&\n          hoistHoistables(fallbackAbortableTasks.contentState, request));\n      return fallbackAbortableTasks;\n    }\n    function createRenderTask(\n      request,\n      thenableState,\n      node,\n      childIndex,\n      blockedBoundary,\n      blockedSegment,\n      blockedPreamble,\n      hoistableState,\n      abortSet,\n      keyPath,\n      formatContext,\n      context,\n      treeContext,\n      row,\n      componentStack,\n      legacyContext,\n      debugTask\n    ) {\n      request.allPendingTasks++;\n      null === blockedBoundary\n        ? request.pendingRootTasks++\n        : blockedBoundary.pendingTasks++;\n      null !== row && row.pendingTasks++;\n      var task = {\n        replay: null,\n        node: node,\n        childIndex: childIndex,\n        ping: function () {\n          return pingTask(request, task);\n        },\n        blockedBoundary: blockedBoundary,\n        blockedSegment: blockedSegment,\n        blockedPreamble: blockedPreamble,\n        hoistableState: hoistableState,\n        abortSet: abortSet,\n        keyPath: keyPath,\n        formatContext: formatContext,\n        context: context,\n        treeContext: treeContext,\n        row: row,\n        componentStack: componentStack,\n        thenableState: thenableState\n      };\n      task.debugTask = debugTask;\n      abortSet.add(task);\n      return task;\n    }\n    function createReplayTask(\n      request,\n      thenableState,\n      replay,\n      node,\n      childIndex,\n      blockedBoundary,\n      hoistableState,\n      abortSet,\n      keyPath,\n      formatContext,\n      context,\n      treeContext,\n      row,\n      componentStack,\n      legacyContext,\n      debugTask\n    ) {\n      request.allPendingTasks++;\n      null === blockedBoundary\n        ? request.pendingRootTasks++\n        : blockedBoundary.pendingTasks++;\n      null !== row && row.pendingTasks++;\n      replay.pendingTasks++;\n      var task = {\n        replay: replay,\n        node: node,\n        childIndex: childIndex,\n        ping: function () {\n          return pingTask(request, task);\n        },\n        blockedBoundary: blockedBoundary,\n        blockedSegment: null,\n        blockedPreamble: null,\n        hoistableState: hoistableState,\n        abortSet: abortSet,\n        keyPath: keyPath,\n        formatContext: formatContext,\n        context: context,\n        treeContext: treeContext,\n        row: row,\n        componentStack: componentStack,\n        thenableState: thenableState\n      };\n      task.debugTask = debugTask;\n      abortSet.add(task);\n      return task;\n    }\n    function createPendingSegment(\n      request,\n      index,\n      boundary,\n      parentFormatContext,\n      lastPushedText,\n      textEmbedded\n    ) {\n      return {\n        status: PENDING,\n        parentFlushed: !1,\n        id: -1,\n        index: index,\n        chunks: [],\n        children: [],\n        preambleChildren: [],\n        parentFormatContext: parentFormatContext,\n        boundary: boundary,\n        lastPushedText: lastPushedText,\n        textEmbedded: textEmbedded\n      };\n    }\n    function getCurrentStackInDEV() {\n      if (null === currentTaskInDEV || null === currentTaskInDEV.componentStack)\n        return \"\";\n      var componentStack = currentTaskInDEV.componentStack;\n      try {\n        var info = \"\";\n        if (\"string\" === typeof componentStack.type)\n          info += describeBuiltInComponentFrame(componentStack.type);\n        else if (\"function\" === typeof componentStack.type) {\n          if (!componentStack.owner) {\n            var JSCompiler_temp_const = info,\n              fn = componentStack.type,\n              name = fn ? fn.displayName || fn.name : \"\";\n            var JSCompiler_inline_result = name\n              ? describeBuiltInComponentFrame(name)\n              : \"\";\n            info = JSCompiler_temp_const + JSCompiler_inline_result;\n          }\n        } else\n          componentStack.owner ||\n            (info += describeComponentStackByType(componentStack.type));\n        for (; componentStack; )\n          (JSCompiler_temp_const = null),\n            null != componentStack.debugStack\n              ? (JSCompiler_temp_const = formatOwnerStack(\n                  componentStack.debugStack\n                ))\n              : ((JSCompiler_inline_result = componentStack),\n                null != JSCompiler_inline_result.stack &&\n                  (JSCompiler_temp_const =\n                    \"string\" !== typeof JSCompiler_inline_result.stack\n                      ? (JSCompiler_inline_result.stack = formatOwnerStack(\n                          JSCompiler_inline_result.stack\n                        ))\n                      : JSCompiler_inline_result.stack)),\n            (componentStack = componentStack.owner) &&\n              JSCompiler_temp_const &&\n              (info += \"\\n\" + JSCompiler_temp_const);\n        var JSCompiler_inline_result$jscomp$0 = info;\n      } catch (x) {\n        JSCompiler_inline_result$jscomp$0 =\n          \"\\nError generating stack: \" + x.message + \"\\n\" + x.stack;\n      }\n      return JSCompiler_inline_result$jscomp$0;\n    }\n    function pushHaltedAwaitOnComponentStack(task, debugInfo) {\n      if (null != debugInfo)\n        for (var i = debugInfo.length - 1; 0 <= i; i--) {\n          var info = debugInfo[i];\n          if (\"string\" === typeof info.name) break;\n          if (\"number\" === typeof info.time) break;\n          if (null != info.awaited) {\n            var bestStack = null == info.debugStack ? info.awaited : info;\n            if (void 0 !== bestStack.debugStack) {\n              task.componentStack = {\n                parent: task.componentStack,\n                type: info,\n                owner: bestStack.owner,\n                stack: bestStack.debugStack\n              };\n              task.debugTask = bestStack.debugTask;\n              break;\n            }\n          }\n        }\n    }\n    function pushServerComponentStack(task, debugInfo) {\n      if (null != debugInfo)\n        for (var i = 0; i < debugInfo.length; i++) {\n          var componentInfo = debugInfo[i];\n          \"string\" === typeof componentInfo.name &&\n            void 0 !== componentInfo.debugStack &&\n            ((task.componentStack = {\n              parent: task.componentStack,\n              type: componentInfo,\n              owner: componentInfo.owner,\n              stack: componentInfo.debugStack\n            }),\n            (task.debugTask = componentInfo.debugTask));\n        }\n    }\n    function pushComponentStack(task) {\n      var node = task.node;\n      if (\"object\" === typeof node && null !== node)\n        switch (node.$$typeof) {\n          case REACT_ELEMENT_TYPE:\n            var type = node.type,\n              owner = node._owner,\n              stack = node._debugStack;\n            pushServerComponentStack(task, node._debugInfo);\n            task.debugTask = node._debugTask;\n            task.componentStack = {\n              parent: task.componentStack,\n              type: type,\n              owner: owner,\n              stack: stack\n            };\n            break;\n          case REACT_LAZY_TYPE:\n            pushServerComponentStack(task, node._debugInfo);\n            break;\n          default:\n            \"function\" === typeof node.then &&\n              pushServerComponentStack(task, node._debugInfo);\n        }\n    }\n    function replaceSuspenseComponentStackWithSuspenseFallbackStack(\n      componentStack\n    ) {\n      return null === componentStack\n        ? null\n        : {\n            parent: componentStack.parent,\n            type: \"Suspense Fallback\",\n            owner: componentStack.owner,\n            stack: componentStack.stack\n          };\n    }\n    function getThrownInfo(node$jscomp$0) {\n      var errorInfo = {};\n      node$jscomp$0 &&\n        Object.defineProperty(errorInfo, \"componentStack\", {\n          configurable: !0,\n          enumerable: !0,\n          get: function () {\n            try {\n              var info = \"\",\n                node = node$jscomp$0;\n              do\n                (info += describeComponentStackByType(node.type)),\n                  (node = node.parent);\n              while (node);\n              var stack = info;\n            } catch (x) {\n              stack = \"\\nError generating stack: \" + x.message + \"\\n\" + x.stack;\n            }\n            Object.defineProperty(errorInfo, \"componentStack\", {\n              value: stack\n            });\n            return stack;\n          }\n        });\n      return errorInfo;\n    }\n    function encodeErrorForBoundary(\n      boundary,\n      digest,\n      error,\n      thrownInfo,\n      wasAborted\n    ) {\n      boundary.errorDigest = digest;\n      error instanceof Error\n        ? ((digest = String(error.message)), (error = String(error.stack)))\n        : ((digest =\n            \"object\" === typeof error && null !== error\n              ? describeObjectForErrorMessage(error)\n              : String(error)),\n          (error = null));\n      wasAborted = wasAborted\n        ? \"Switched to client rendering because the server rendering aborted due to:\\n\\n\"\n        : \"Switched to client rendering because the server rendering errored:\\n\\n\";\n      boundary.errorMessage = wasAborted + digest;\n      boundary.errorStack = null !== error ? wasAborted + error : null;\n      boundary.errorComponentStack = thrownInfo.componentStack;\n    }\n    function logRecoverableError(request, error, errorInfo, debugTask) {\n      request = request.onError;\n      error = debugTask\n        ? debugTask.run(request.bind(null, error, errorInfo))\n        : request(error, errorInfo);\n      if (null != error && \"string\" !== typeof error)\n        console.error(\n          'onError returned something with a type other than \"string\". onError should return a string and may return null or undefined but must not return anything else. It received something of type \"%s\" instead',\n          typeof error\n        );\n      else return error;\n    }\n    function fatalError(request, error, errorInfo, debugTask) {\n      errorInfo = request.onShellError;\n      var onFatalError = request.onFatalError;\n      debugTask\n        ? (debugTask.run(errorInfo.bind(null, error)),\n          debugTask.run(onFatalError.bind(null, error)))\n        : (errorInfo(error), onFatalError(error));\n      null !== request.destination\n        ? ((request.status = CLOSED), request.destination.destroy(error))\n        : ((request.status = 13), (request.fatalError = error));\n    }\n    function finishSuspenseListRow(request, row) {\n      unblockSuspenseListRow(request, row.next, row.hoistables);\n    }\n    function unblockSuspenseListRow(\n      request,\n      unblockedRow,\n      inheritedHoistables\n    ) {\n      for (; null !== unblockedRow; ) {\n        null !== inheritedHoistables &&\n          (hoistHoistables(unblockedRow.hoistables, inheritedHoistables),\n          (unblockedRow.inheritedHoistables = inheritedHoistables));\n        var unblockedBoundaries = unblockedRow.boundaries;\n        if (null !== unblockedBoundaries) {\n          unblockedRow.boundaries = null;\n          for (var i = 0; i < unblockedBoundaries.length; i++) {\n            var unblockedBoundary = unblockedBoundaries[i];\n            null !== inheritedHoistables &&\n              hoistHoistables(\n                unblockedBoundary.contentState,\n                inheritedHoistables\n              );\n            finishedTask(request, unblockedBoundary, null, null);\n          }\n        }\n        unblockedRow.pendingTasks--;\n        if (0 < unblockedRow.pendingTasks) break;\n        inheritedHoistables = unblockedRow.hoistables;\n        unblockedRow = unblockedRow.next;\n      }\n    }\n    function tryToResolveTogetherRow(request, togetherRow) {\n      var boundaries = togetherRow.boundaries;\n      if (\n        null !== boundaries &&\n        togetherRow.pendingTasks === boundaries.length\n      ) {\n        for (\n          var allCompleteAndInlinable = !0, i = 0;\n          i < boundaries.length;\n          i++\n        ) {\n          var rowBoundary = boundaries[i];\n          if (\n            1 !== rowBoundary.pendingTasks ||\n            rowBoundary.parentFlushed ||\n            isEligibleForOutlining(request, rowBoundary)\n          ) {\n            allCompleteAndInlinable = !1;\n            break;\n          }\n        }\n        allCompleteAndInlinable &&\n          unblockSuspenseListRow(request, togetherRow, togetherRow.hoistables);\n      }\n    }\n    function createSuspenseListRow(previousRow) {\n      var newRow = {\n        pendingTasks: 1,\n        boundaries: null,\n        hoistables: createHoistableState(),\n        inheritedHoistables: null,\n        together: !1,\n        next: null\n      };\n      null !== previousRow &&\n        0 < previousRow.pendingTasks &&\n        (newRow.pendingTasks++,\n        (newRow.boundaries = []),\n        (previousRow.next = newRow));\n      return newRow;\n    }\n    function renderSuspenseListRows(request, task, keyPath, rows, revealOrder) {\n      var prevKeyPath = task.keyPath,\n        prevTreeContext = task.treeContext,\n        prevRow = task.row,\n        previousComponentStack = task.componentStack;\n      var previousDebugTask = task.debugTask;\n      pushServerComponentStack(task, task.node.props.children._debugInfo);\n      task.keyPath = keyPath;\n      keyPath = rows.length;\n      var previousSuspenseListRow = null;\n      if (null !== task.replay) {\n        var resumeSlots = task.replay.slots;\n        if (null !== resumeSlots && \"object\" === typeof resumeSlots)\n          for (var n = 0; n < keyPath; n++) {\n            var i =\n                \"backwards\" !== revealOrder &&\n                \"unstable_legacy-backwards\" !== revealOrder\n                  ? n\n                  : keyPath - 1 - n,\n              node = rows[i];\n            task.row = previousSuspenseListRow = createSuspenseListRow(\n              previousSuspenseListRow\n            );\n            task.treeContext = pushTreeContext(prevTreeContext, keyPath, i);\n            var resumeSegmentID = resumeSlots[i];\n            \"number\" === typeof resumeSegmentID\n              ? (resumeNode(request, task, resumeSegmentID, node, i),\n                delete resumeSlots[i])\n              : renderNode(request, task, node, i);\n            0 === --previousSuspenseListRow.pendingTasks &&\n              finishSuspenseListRow(request, previousSuspenseListRow);\n          }\n        else\n          for (resumeSlots = 0; resumeSlots < keyPath; resumeSlots++)\n            (n =\n              \"backwards\" !== revealOrder &&\n              \"unstable_legacy-backwards\" !== revealOrder\n                ? resumeSlots\n                : keyPath - 1 - resumeSlots),\n              (i = rows[n]),\n              warnForMissingKey(request, task, i),\n              (task.row = previousSuspenseListRow =\n                createSuspenseListRow(previousSuspenseListRow)),\n              (task.treeContext = pushTreeContext(prevTreeContext, keyPath, n)),\n              renderNode(request, task, i, n),\n              0 === --previousSuspenseListRow.pendingTasks &&\n                finishSuspenseListRow(request, previousSuspenseListRow);\n      } else if (\n        \"backwards\" !== revealOrder &&\n        \"unstable_legacy-backwards\" !== revealOrder\n      )\n        for (revealOrder = 0; revealOrder < keyPath; revealOrder++)\n          (resumeSlots = rows[revealOrder]),\n            warnForMissingKey(request, task, resumeSlots),\n            (task.row = previousSuspenseListRow =\n              createSuspenseListRow(previousSuspenseListRow)),\n            (task.treeContext = pushTreeContext(\n              prevTreeContext,\n              keyPath,\n              revealOrder\n            )),\n            renderNode(request, task, resumeSlots, revealOrder),\n            0 === --previousSuspenseListRow.pendingTasks &&\n              finishSuspenseListRow(request, previousSuspenseListRow);\n      else {\n        revealOrder = task.blockedSegment;\n        resumeSlots = revealOrder.children.length;\n        n = revealOrder.chunks.length;\n        for (i = keyPath - 1; 0 <= i; i--) {\n          node = rows[i];\n          task.row = previousSuspenseListRow = createSuspenseListRow(\n            previousSuspenseListRow\n          );\n          task.treeContext = pushTreeContext(prevTreeContext, keyPath, i);\n          resumeSegmentID = createPendingSegment(\n            request,\n            n,\n            null,\n            task.formatContext,\n            0 === i ? revealOrder.lastPushedText : !0,\n            !0\n          );\n          revealOrder.children.splice(resumeSlots, 0, resumeSegmentID);\n          task.blockedSegment = resumeSegmentID;\n          warnForMissingKey(request, task, node);\n          try {\n            renderNode(request, task, node, i),\n              pushSegmentFinale(\n                resumeSegmentID.chunks,\n                request.renderState,\n                resumeSegmentID.lastPushedText,\n                resumeSegmentID.textEmbedded\n              ),\n              (resumeSegmentID.status = COMPLETED),\n              0 === --previousSuspenseListRow.pendingTasks &&\n                finishSuspenseListRow(request, previousSuspenseListRow);\n          } catch (thrownValue) {\n            throw (\n              ((resumeSegmentID.status =\n                12 === request.status ? ABORTED : ERRORED),\n              thrownValue)\n            );\n          }\n        }\n        task.blockedSegment = revealOrder;\n        revealOrder.lastPushedText = !1;\n      }\n      null !== prevRow &&\n        null !== previousSuspenseListRow &&\n        0 < previousSuspenseListRow.pendingTasks &&\n        (prevRow.pendingTasks++, (previousSuspenseListRow.next = prevRow));\n      task.treeContext = prevTreeContext;\n      task.row = prevRow;\n      task.keyPath = prevKeyPath;\n      task.componentStack = previousComponentStack;\n      task.debugTask = previousDebugTask;\n    }\n    function renderWithHooks(\n      request,\n      task,\n      keyPath,\n      Component,\n      props,\n      secondArg\n    ) {\n      var prevThenableState = task.thenableState;\n      task.thenableState = null;\n      currentlyRenderingComponent = {};\n      currentlyRenderingTask = task;\n      currentlyRenderingRequest = request;\n      currentlyRenderingKeyPath = keyPath;\n      isInHookUserCodeInDev = !1;\n      actionStateCounter = localIdCounter = 0;\n      actionStateMatchingIndex = -1;\n      thenableIndexCounter = 0;\n      thenableState = prevThenableState;\n      for (\n        request = callComponentInDEV(Component, props, secondArg);\n        didScheduleRenderPhaseUpdate;\n\n      )\n        (didScheduleRenderPhaseUpdate = !1),\n          (actionStateCounter = localIdCounter = 0),\n          (actionStateMatchingIndex = -1),\n          (thenableIndexCounter = 0),\n          (numberOfReRenders += 1),\n          (workInProgressHook = null),\n          (request = Component(props, secondArg));\n      resetHooksState();\n      return request;\n    }\n    function finishFunctionComponent(\n      request,\n      task,\n      keyPath,\n      children,\n      hasId,\n      actionStateCount,\n      actionStateMatchingIndex\n    ) {\n      var didEmitActionStateMarkers = !1;\n      if (0 !== actionStateCount && null !== request.formState) {\n        var segment = task.blockedSegment;\n        if (null !== segment) {\n          didEmitActionStateMarkers = !0;\n          segment = segment.chunks;\n          for (var i = 0; i < actionStateCount; i++)\n            i === actionStateMatchingIndex\n              ? segment.push(\"\\x3c!--F!--\\x3e\")\n              : segment.push(\"\\x3c!--F--\\x3e\");\n        }\n      }\n      actionStateCount = task.keyPath;\n      task.keyPath = keyPath;\n      hasId\n        ? ((keyPath = task.treeContext),\n          (task.treeContext = pushTreeContext(keyPath, 1, 0)),\n          renderNode(request, task, children, -1),\n          (task.treeContext = keyPath))\n        : didEmitActionStateMarkers\n          ? renderNode(request, task, children, -1)\n          : renderNodeDestructive(request, task, children, -1);\n      task.keyPath = actionStateCount;\n    }\n    function renderElement(request, task, keyPath, type, props, ref) {\n      if (\"function\" === typeof type)\n        if (type.prototype && type.prototype.isReactComponent) {\n          var newProps = props;\n          if (\"ref\" in props) {\n            newProps = {};\n            for (var propName in props)\n              \"ref\" !== propName && (newProps[propName] = props[propName]);\n          }\n          var defaultProps = type.defaultProps;\n          if (defaultProps) {\n            newProps === props && (newProps = assign({}, newProps, props));\n            for (var _propName in defaultProps)\n              void 0 === newProps[_propName] &&\n                (newProps[_propName] = defaultProps[_propName]);\n          }\n          var resolvedProps = newProps;\n          var context = emptyContextObject,\n            contextType = type.contextType;\n          if (\n            \"contextType\" in type &&\n            null !== contextType &&\n            (void 0 === contextType ||\n              contextType.$$typeof !== REACT_CONTEXT_TYPE) &&\n            !didWarnAboutInvalidateContextType.has(type)\n          ) {\n            didWarnAboutInvalidateContextType.add(type);\n            var addendum =\n              void 0 === contextType\n                ? \" However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.\"\n                : \"object\" !== typeof contextType\n                  ? \" However, it is set to a \" + typeof contextType + \".\"\n                  : contextType.$$typeof === REACT_CONSUMER_TYPE\n                    ? \" Did you accidentally pass the Context.Consumer instead?\"\n                    : \" However, it is set to an object with keys {\" +\n                      Object.keys(contextType).join(\", \") +\n                      \"}.\";\n            console.error(\n              \"%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s\",\n              getComponentNameFromType(type) || \"Component\",\n              addendum\n            );\n          }\n          \"object\" === typeof contextType &&\n            null !== contextType &&\n            (context = contextType._currentValue2);\n          var instance = new type(resolvedProps, context);\n          if (\n            \"function\" === typeof type.getDerivedStateFromProps &&\n            (null === instance.state || void 0 === instance.state)\n          ) {\n            var componentName = getComponentNameFromType(type) || \"Component\";\n            didWarnAboutUninitializedState.has(componentName) ||\n              (didWarnAboutUninitializedState.add(componentName),\n              console.error(\n                \"`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.\",\n                componentName,\n                null === instance.state ? \"null\" : \"undefined\",\n                componentName\n              ));\n          }\n          if (\n            \"function\" === typeof type.getDerivedStateFromProps ||\n            \"function\" === typeof instance.getSnapshotBeforeUpdate\n          ) {\n            var foundWillMountName = null,\n              foundWillReceivePropsName = null,\n              foundWillUpdateName = null;\n            \"function\" === typeof instance.componentWillMount &&\n            !0 !== instance.componentWillMount.__suppressDeprecationWarning\n              ? (foundWillMountName = \"componentWillMount\")\n              : \"function\" === typeof instance.UNSAFE_componentWillMount &&\n                (foundWillMountName = \"UNSAFE_componentWillMount\");\n            \"function\" === typeof instance.componentWillReceiveProps &&\n            !0 !==\n              instance.componentWillReceiveProps.__suppressDeprecationWarning\n              ? (foundWillReceivePropsName = \"componentWillReceiveProps\")\n              : \"function\" ===\n                  typeof instance.UNSAFE_componentWillReceiveProps &&\n                (foundWillReceivePropsName =\n                  \"UNSAFE_componentWillReceiveProps\");\n            \"function\" === typeof instance.componentWillUpdate &&\n            !0 !== instance.componentWillUpdate.__suppressDeprecationWarning\n              ? (foundWillUpdateName = \"componentWillUpdate\")\n              : \"function\" === typeof instance.UNSAFE_componentWillUpdate &&\n                (foundWillUpdateName = \"UNSAFE_componentWillUpdate\");\n            if (\n              null !== foundWillMountName ||\n              null !== foundWillReceivePropsName ||\n              null !== foundWillUpdateName\n            ) {\n              var _componentName =\n                  getComponentNameFromType(type) || \"Component\",\n                newApiName =\n                  \"function\" === typeof type.getDerivedStateFromProps\n                    ? \"getDerivedStateFromProps()\"\n                    : \"getSnapshotBeforeUpdate()\";\n              didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName) ||\n                (didWarnAboutLegacyLifecyclesAndDerivedState.add(\n                  _componentName\n                ),\n                console.error(\n                  \"Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\nThe above lifecycles should be removed. Learn more about this warning here:\\nhttps://react.dev/link/unsafe-component-lifecycles\",\n                  _componentName,\n                  newApiName,\n                  null !== foundWillMountName\n                    ? \"\\n  \" + foundWillMountName\n                    : \"\",\n                  null !== foundWillReceivePropsName\n                    ? \"\\n  \" + foundWillReceivePropsName\n                    : \"\",\n                  null !== foundWillUpdateName\n                    ? \"\\n  \" + foundWillUpdateName\n                    : \"\"\n                ));\n            }\n          }\n          var name = getComponentNameFromType(type) || \"Component\";\n          instance.render ||\n            (type.prototype && \"function\" === typeof type.prototype.render\n              ? console.error(\n                  \"No `render` method found on the %s instance: did you accidentally return an object from the constructor?\",\n                  name\n                )\n              : console.error(\n                  \"No `render` method found on the %s instance: you may have forgotten to define `render`.\",\n                  name\n                ));\n          !instance.getInitialState ||\n            instance.getInitialState.isReactClassApproved ||\n            instance.state ||\n            console.error(\n              \"getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?\",\n              name\n            );\n          instance.getDefaultProps &&\n            !instance.getDefaultProps.isReactClassApproved &&\n            console.error(\n              \"getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.\",\n              name\n            );\n          instance.contextType &&\n            console.error(\n              \"contextType was defined as an instance property on %s. Use a static property to define contextType instead.\",\n              name\n            );\n          type.childContextTypes &&\n            !didWarnAboutChildContextTypes.has(type) &&\n            (didWarnAboutChildContextTypes.add(type),\n            console.error(\n              \"%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)\",\n              name\n            ));\n          type.contextTypes &&\n            !didWarnAboutContextTypes$1.has(type) &&\n            (didWarnAboutContextTypes$1.add(type),\n            console.error(\n              \"%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)\",\n              name\n            ));\n          \"function\" === typeof instance.componentShouldUpdate &&\n            console.error(\n              \"%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.\",\n              name\n            );\n          type.prototype &&\n            type.prototype.isPureReactComponent &&\n            \"undefined\" !== typeof instance.shouldComponentUpdate &&\n            console.error(\n              \"%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.\",\n              getComponentNameFromType(type) || \"A pure component\"\n            );\n          \"function\" === typeof instance.componentDidUnmount &&\n            console.error(\n              \"%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?\",\n              name\n            );\n          \"function\" === typeof instance.componentDidReceiveProps &&\n            console.error(\n              \"%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().\",\n              name\n            );\n          \"function\" === typeof instance.componentWillRecieveProps &&\n            console.error(\n              \"%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?\",\n              name\n            );\n          \"function\" === typeof instance.UNSAFE_componentWillRecieveProps &&\n            console.error(\n              \"%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?\",\n              name\n            );\n          var hasMutatedProps = instance.props !== resolvedProps;\n          void 0 !== instance.props &&\n            hasMutatedProps &&\n            console.error(\n              \"When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.\",\n              name\n            );\n          instance.defaultProps &&\n            console.error(\n              \"Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.\",\n              name,\n              name\n            );\n          \"function\" !== typeof instance.getSnapshotBeforeUpdate ||\n            \"function\" === typeof instance.componentDidUpdate ||\n            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(type) ||\n            (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(type),\n            console.error(\n              \"%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.\",\n              getComponentNameFromType(type)\n            ));\n          \"function\" === typeof instance.getDerivedStateFromProps &&\n            console.error(\n              \"%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.\",\n              name\n            );\n          \"function\" === typeof instance.getDerivedStateFromError &&\n            console.error(\n              \"%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.\",\n              name\n            );\n          \"function\" === typeof type.getSnapshotBeforeUpdate &&\n            console.error(\n              \"%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.\",\n              name\n            );\n          var state = instance.state;\n          state &&\n            (\"object\" !== typeof state || isArrayImpl(state)) &&\n            console.error(\"%s.state: must be set to an object or null\", name);\n          \"function\" === typeof instance.getChildContext &&\n            \"object\" !== typeof type.childContextTypes &&\n            console.error(\n              \"%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().\",\n              name\n            );\n          var initialState = void 0 !== instance.state ? instance.state : null;\n          instance.updater = classComponentUpdater;\n          instance.props = resolvedProps;\n          instance.state = initialState;\n          var internalInstance = { queue: [], replace: !1 };\n          instance._reactInternals = internalInstance;\n          var contextType$jscomp$0 = type.contextType;\n          instance.context =\n            \"object\" === typeof contextType$jscomp$0 &&\n            null !== contextType$jscomp$0\n              ? contextType$jscomp$0._currentValue2\n              : emptyContextObject;\n          if (instance.state === resolvedProps) {\n            var componentName$jscomp$0 =\n              getComponentNameFromType(type) || \"Component\";\n            didWarnAboutDirectlyAssigningPropsToState.has(\n              componentName$jscomp$0\n            ) ||\n              (didWarnAboutDirectlyAssigningPropsToState.add(\n                componentName$jscomp$0\n              ),\n              console.error(\n                \"%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.\",\n                componentName$jscomp$0\n              ));\n          }\n          var getDerivedStateFromProps = type.getDerivedStateFromProps;\n          if (\"function\" === typeof getDerivedStateFromProps) {\n            var partialState = getDerivedStateFromProps(\n              resolvedProps,\n              initialState\n            );\n            if (void 0 === partialState) {\n              var componentName$jscomp$1 =\n                getComponentNameFromType(type) || \"Component\";\n              didWarnAboutUndefinedDerivedState.has(componentName$jscomp$1) ||\n                (didWarnAboutUndefinedDerivedState.add(componentName$jscomp$1),\n                console.error(\n                  \"%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.\",\n                  componentName$jscomp$1\n                ));\n            }\n            var JSCompiler_inline_result =\n              null === partialState || void 0 === partialState\n                ? initialState\n                : assign({}, initialState, partialState);\n            instance.state = JSCompiler_inline_result;\n          }\n          if (\n            \"function\" !== typeof type.getDerivedStateFromProps &&\n            \"function\" !== typeof instance.getSnapshotBeforeUpdate &&\n            (\"function\" === typeof instance.UNSAFE_componentWillMount ||\n              \"function\" === typeof instance.componentWillMount)\n          ) {\n            var oldState = instance.state;\n            if (\"function\" === typeof instance.componentWillMount) {\n              if (\n                !0 !== instance.componentWillMount.__suppressDeprecationWarning\n              ) {\n                var componentName$jscomp$2 =\n                  getComponentNameFromType(type) || \"Unknown\";\n                didWarnAboutDeprecatedWillMount[componentName$jscomp$2] ||\n                  (console.warn(\n                    \"componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.\\n\\nPlease update the following components: %s\",\n                    componentName$jscomp$2\n                  ),\n                  (didWarnAboutDeprecatedWillMount[componentName$jscomp$2] =\n                    !0));\n              }\n              instance.componentWillMount();\n            }\n            \"function\" === typeof instance.UNSAFE_componentWillMount &&\n              instance.UNSAFE_componentWillMount();\n            oldState !== instance.state &&\n              (console.error(\n                \"%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.\",\n                getComponentNameFromType(type) || \"Component\"\n              ),\n              classComponentUpdater.enqueueReplaceState(\n                instance,\n                instance.state,\n                null\n              ));\n            if (\n              null !== internalInstance.queue &&\n              0 < internalInstance.queue.length\n            ) {\n              var oldQueue = internalInstance.queue,\n                oldReplace = internalInstance.replace;\n              internalInstance.queue = null;\n              internalInstance.replace = !1;\n              if (oldReplace && 1 === oldQueue.length)\n                instance.state = oldQueue[0];\n              else {\n                for (\n                  var nextState = oldReplace ? oldQueue[0] : instance.state,\n                    dontMutate = !0,\n                    i = oldReplace ? 1 : 0;\n                  i < oldQueue.length;\n                  i++\n                ) {\n                  var partial = oldQueue[i],\n                    partialState$jscomp$0 =\n                      \"function\" === typeof partial\n                        ? partial.call(\n                            instance,\n                            nextState,\n                            resolvedProps,\n                            void 0\n                          )\n                        : partial;\n                  null != partialState$jscomp$0 &&\n                    (dontMutate\n                      ? ((dontMutate = !1),\n                        (nextState = assign(\n                          {},\n                          nextState,\n                          partialState$jscomp$0\n                        )))\n                      : assign(nextState, partialState$jscomp$0));\n                }\n                instance.state = nextState;\n              }\n            } else internalInstance.queue = null;\n          }\n          var nextChildren = callRenderInDEV(instance);\n          if (12 === request.status) throw null;\n          instance.props !== resolvedProps &&\n            (didWarnAboutReassigningProps ||\n              console.error(\n                \"It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.\",\n                getComponentNameFromType(type) || \"a component\"\n              ),\n            (didWarnAboutReassigningProps = !0));\n          var prevKeyPath = task.keyPath;\n          task.keyPath = keyPath;\n          renderNodeDestructive(request, task, nextChildren, -1);\n          task.keyPath = prevKeyPath;\n        } else {\n          if (type.prototype && \"function\" === typeof type.prototype.render) {\n            var componentName$jscomp$3 =\n              getComponentNameFromType(type) || \"Unknown\";\n            didWarnAboutBadClass[componentName$jscomp$3] ||\n              (console.error(\n                \"The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.\",\n                componentName$jscomp$3,\n                componentName$jscomp$3\n              ),\n              (didWarnAboutBadClass[componentName$jscomp$3] = !0));\n          }\n          var value = renderWithHooks(\n            request,\n            task,\n            keyPath,\n            type,\n            props,\n            void 0\n          );\n          if (12 === request.status) throw null;\n          var hasId = 0 !== localIdCounter,\n            actionStateCount = actionStateCounter,\n            actionStateMatchingIndex$jscomp$0 = actionStateMatchingIndex;\n          if (type.contextTypes) {\n            var _componentName$jscomp$0 =\n              getComponentNameFromType(type) || \"Unknown\";\n            didWarnAboutContextTypes[_componentName$jscomp$0] ||\n              ((didWarnAboutContextTypes[_componentName$jscomp$0] = !0),\n              console.error(\n                \"%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)\",\n                _componentName$jscomp$0\n              ));\n          }\n          type &&\n            type.childContextTypes &&\n            console.error(\n              \"childContextTypes cannot be defined on a function component.\\n  %s.childContextTypes = ...\",\n              type.displayName || type.name || \"Component\"\n            );\n          if (\"function\" === typeof type.getDerivedStateFromProps) {\n            var componentName$jscomp$4 =\n              getComponentNameFromType(type) || \"Unknown\";\n            didWarnAboutGetDerivedStateOnFunctionComponent[\n              componentName$jscomp$4\n            ] ||\n              (console.error(\n                \"%s: Function components do not support getDerivedStateFromProps.\",\n                componentName$jscomp$4\n              ),\n              (didWarnAboutGetDerivedStateOnFunctionComponent[\n                componentName$jscomp$4\n              ] = !0));\n          }\n          if (\n            \"object\" === typeof type.contextType &&\n            null !== type.contextType\n          ) {\n            var _componentName2 = getComponentNameFromType(type) || \"Unknown\";\n            didWarnAboutContextTypeOnFunctionComponent[_componentName2] ||\n              (console.error(\n                \"%s: Function components do not support contextType.\",\n                _componentName2\n              ),\n              (didWarnAboutContextTypeOnFunctionComponent[_componentName2] =\n                !0));\n          }\n          finishFunctionComponent(\n            request,\n            task,\n            keyPath,\n            value,\n            hasId,\n            actionStateCount,\n            actionStateMatchingIndex$jscomp$0\n          );\n        }\n      else if (\"string\" === typeof type) {\n        var segment = task.blockedSegment;\n        if (null === segment) {\n          var children = props.children,\n            prevContext = task.formatContext,\n            prevKeyPath$jscomp$0 = task.keyPath;\n          task.formatContext = getChildFormatContext(prevContext, type, props);\n          task.keyPath = keyPath;\n          renderNode(request, task, children, -1);\n          task.formatContext = prevContext;\n          task.keyPath = prevKeyPath$jscomp$0;\n        } else {\n          var _children = pushStartInstance(\n            segment.chunks,\n            type,\n            props,\n            request.resumableState,\n            request.renderState,\n            task.blockedPreamble,\n            task.hoistableState,\n            task.formatContext,\n            segment.lastPushedText\n          );\n          segment.lastPushedText = !1;\n          var _prevContext2 = task.formatContext,\n            _prevKeyPath3 = task.keyPath;\n          task.keyPath = keyPath;\n          if (\n            (task.formatContext = getChildFormatContext(\n              _prevContext2,\n              type,\n              props\n            )).insertionMode === HTML_HEAD_MODE\n          ) {\n            var preambleSegment = createPendingSegment(\n              request,\n              0,\n              null,\n              task.formatContext,\n              !1,\n              !1\n            );\n            segment.preambleChildren.push(preambleSegment);\n            task.blockedSegment = preambleSegment;\n            try {\n              (preambleSegment.status = 6),\n                renderNode(request, task, _children, -1),\n                pushSegmentFinale(\n                  preambleSegment.chunks,\n                  request.renderState,\n                  preambleSegment.lastPushedText,\n                  preambleSegment.textEmbedded\n                ),\n                (preambleSegment.status = COMPLETED);\n            } finally {\n              task.blockedSegment = segment;\n            }\n          } else renderNode(request, task, _children, -1);\n          task.formatContext = _prevContext2;\n          task.keyPath = _prevKeyPath3;\n          a: {\n            var target = segment.chunks,\n              resumableState = request.resumableState;\n            switch (type) {\n              case \"title\":\n              case \"style\":\n              case \"script\":\n              case \"area\":\n              case \"base\":\n              case \"br\":\n              case \"col\":\n              case \"embed\":\n              case \"hr\":\n              case \"img\":\n              case \"input\":\n              case \"keygen\":\n              case \"link\":\n              case \"meta\":\n              case \"param\":\n              case \"source\":\n              case \"track\":\n              case \"wbr\":\n                break a;\n              case \"body\":\n                if (_prevContext2.insertionMode <= HTML_HTML_MODE) {\n                  resumableState.hasBody = !0;\n                  break a;\n                }\n                break;\n              case \"html\":\n                if (_prevContext2.insertionMode === ROOT_HTML_MODE) {\n                  resumableState.hasHtml = !0;\n                  break a;\n                }\n                break;\n              case \"head\":\n                if (_prevContext2.insertionMode <= HTML_HTML_MODE) break a;\n            }\n            target.push(endChunkForTag(type));\n          }\n          segment.lastPushedText = !1;\n        }\n      } else {\n        switch (type) {\n          case REACT_LEGACY_HIDDEN_TYPE:\n          case REACT_STRICT_MODE_TYPE:\n          case REACT_PROFILER_TYPE:\n          case REACT_FRAGMENT_TYPE:\n            var prevKeyPath$jscomp$1 = task.keyPath;\n            task.keyPath = keyPath;\n            renderNodeDestructive(request, task, props.children, -1);\n            task.keyPath = prevKeyPath$jscomp$1;\n            return;\n          case REACT_ACTIVITY_TYPE:\n            var segment$jscomp$0 = task.blockedSegment;\n            if (null === segment$jscomp$0) {\n              if (\"hidden\" !== props.mode) {\n                var prevKeyPath$jscomp$2 = task.keyPath;\n                task.keyPath = keyPath;\n                renderNode(request, task, props.children, -1);\n                task.keyPath = prevKeyPath$jscomp$2;\n              }\n            } else if (\"hidden\" !== props.mode) {\n              request.renderState.generateStaticMarkup ||\n                segment$jscomp$0.chunks.push(\"\\x3c!--&--\\x3e\");\n              segment$jscomp$0.lastPushedText = !1;\n              var _prevKeyPath4 = task.keyPath;\n              task.keyPath = keyPath;\n              renderNode(request, task, props.children, -1);\n              task.keyPath = _prevKeyPath4;\n              request.renderState.generateStaticMarkup ||\n                segment$jscomp$0.chunks.push(\"\\x3c!--/&--\\x3e\");\n              segment$jscomp$0.lastPushedText = !1;\n            }\n            return;\n          case REACT_SUSPENSE_LIST_TYPE:\n            a: {\n              var children$jscomp$0 = props.children,\n                revealOrder = props.revealOrder;\n              if (\n                \"forwards\" === revealOrder ||\n                \"backwards\" === revealOrder ||\n                \"unstable_legacy-backwards\" === revealOrder\n              ) {\n                if (isArrayImpl(children$jscomp$0)) {\n                  renderSuspenseListRows(\n                    request,\n                    task,\n                    keyPath,\n                    children$jscomp$0,\n                    revealOrder\n                  );\n                  break a;\n                }\n                var iteratorFn = getIteratorFn(children$jscomp$0);\n                if (iteratorFn) {\n                  var iterator = iteratorFn.call(children$jscomp$0);\n                  if (iterator) {\n                    validateIterable(\n                      task,\n                      children$jscomp$0,\n                      -1,\n                      iterator,\n                      iteratorFn\n                    );\n                    var step = iterator.next();\n                    if (!step.done) {\n                      var rows = [];\n                      do rows.push(step.value), (step = iterator.next());\n                      while (!step.done);\n                      renderSuspenseListRows(\n                        request,\n                        task,\n                        keyPath,\n                        children$jscomp$0,\n                        revealOrder\n                      );\n                    }\n                    break a;\n                  }\n                }\n              }\n              if (\"together\" === revealOrder) {\n                var _prevKeyPath2 = task.keyPath,\n                  prevRow = task.row,\n                  newRow = (task.row = createSuspenseListRow(null));\n                newRow.boundaries = [];\n                newRow.together = !0;\n                task.keyPath = keyPath;\n                renderNodeDestructive(request, task, children$jscomp$0, -1);\n                0 === --newRow.pendingTasks &&\n                  finishSuspenseListRow(request, newRow);\n                task.keyPath = _prevKeyPath2;\n                task.row = prevRow;\n                null !== prevRow &&\n                  0 < newRow.pendingTasks &&\n                  (prevRow.pendingTasks++, (newRow.next = prevRow));\n              } else {\n                var prevKeyPath$jscomp$3 = task.keyPath;\n                task.keyPath = keyPath;\n                renderNodeDestructive(request, task, children$jscomp$0, -1);\n                task.keyPath = prevKeyPath$jscomp$3;\n              }\n            }\n            return;\n          case REACT_VIEW_TRANSITION_TYPE:\n          case REACT_SCOPE_TYPE:\n            throw Error(\n              \"ReactDOMServer does not yet support scope components.\"\n            );\n          case REACT_SUSPENSE_TYPE:\n            a: if (null !== task.replay) {\n              var _prevKeyPath = task.keyPath,\n                _prevContext = task.formatContext,\n                _prevRow = task.row;\n              task.keyPath = keyPath;\n              task.formatContext = getSuspenseContentFormatContext(\n                request.resumableState,\n                _prevContext\n              );\n              task.row = null;\n              var _content = props.children;\n              try {\n                renderNode(request, task, _content, -1);\n              } finally {\n                (task.keyPath = _prevKeyPath),\n                  (task.formatContext = _prevContext),\n                  (task.row = _prevRow);\n              }\n            } else {\n              var prevKeyPath$jscomp$4 = task.keyPath,\n                prevContext$jscomp$0 = task.formatContext,\n                prevRow$jscomp$0 = task.row,\n                parentBoundary = task.blockedBoundary,\n                parentPreamble = task.blockedPreamble,\n                parentHoistableState = task.hoistableState,\n                parentSegment = task.blockedSegment,\n                fallback = props.fallback,\n                content = props.children,\n                fallbackAbortSet = new Set();\n              var newBoundary = createSuspenseBoundary(\n                request,\n                task.row,\n                fallbackAbortSet,\n                null,\n                null\n              );\n              null !== request.trackedPostpones &&\n                (newBoundary.trackedContentKeyPath = keyPath);\n              var boundarySegment = createPendingSegment(\n                request,\n                parentSegment.chunks.length,\n                newBoundary,\n                task.formatContext,\n                !1,\n                !1\n              );\n              parentSegment.children.push(boundarySegment);\n              parentSegment.lastPushedText = !1;\n              var contentRootSegment = createPendingSegment(\n                request,\n                0,\n                null,\n                task.formatContext,\n                !1,\n                !1\n              );\n              contentRootSegment.parentFlushed = !0;\n              if (null !== request.trackedPostpones) {\n                var suspenseComponentStack = task.componentStack,\n                  fallbackKeyPath = [\n                    keyPath[0],\n                    \"Suspense Fallback\",\n                    keyPath[2]\n                  ],\n                  fallbackReplayNode = [\n                    fallbackKeyPath[1],\n                    fallbackKeyPath[2],\n                    [],\n                    null\n                  ];\n                request.trackedPostpones.workingMap.set(\n                  fallbackKeyPath,\n                  fallbackReplayNode\n                );\n                newBoundary.trackedFallbackNode = fallbackReplayNode;\n                task.blockedSegment = boundarySegment;\n                task.blockedPreamble = newBoundary.fallbackPreamble;\n                task.keyPath = fallbackKeyPath;\n                task.formatContext = getSuspenseFallbackFormatContext(\n                  request.resumableState,\n                  prevContext$jscomp$0\n                );\n                task.componentStack =\n                  replaceSuspenseComponentStackWithSuspenseFallbackStack(\n                    suspenseComponentStack\n                  );\n                boundarySegment.status = 6;\n                try {\n                  renderNode(request, task, fallback, -1),\n                    pushSegmentFinale(\n                      boundarySegment.chunks,\n                      request.renderState,\n                      boundarySegment.lastPushedText,\n                      boundarySegment.textEmbedded\n                    ),\n                    (boundarySegment.status = COMPLETED);\n                } catch (thrownValue) {\n                  throw (\n                    ((boundarySegment.status =\n                      12 === request.status ? ABORTED : ERRORED),\n                    thrownValue)\n                  );\n                } finally {\n                  (task.blockedSegment = parentSegment),\n                    (task.blockedPreamble = parentPreamble),\n                    (task.keyPath = prevKeyPath$jscomp$4),\n                    (task.formatContext = prevContext$jscomp$0);\n                }\n                var suspendedPrimaryTask = createRenderTask(\n                  request,\n                  null,\n                  content,\n                  -1,\n                  newBoundary,\n                  contentRootSegment,\n                  newBoundary.contentPreamble,\n                  newBoundary.contentState,\n                  task.abortSet,\n                  keyPath,\n                  getSuspenseContentFormatContext(\n                    request.resumableState,\n                    task.formatContext\n                  ),\n                  task.context,\n                  task.treeContext,\n                  null,\n                  suspenseComponentStack,\n                  emptyContextObject,\n                  task.debugTask\n                );\n                pushComponentStack(suspendedPrimaryTask);\n                request.pingedTasks.push(suspendedPrimaryTask);\n              } else {\n                task.blockedBoundary = newBoundary;\n                task.blockedPreamble = newBoundary.contentPreamble;\n                task.hoistableState = newBoundary.contentState;\n                task.blockedSegment = contentRootSegment;\n                task.keyPath = keyPath;\n                task.formatContext = getSuspenseContentFormatContext(\n                  request.resumableState,\n                  prevContext$jscomp$0\n                );\n                task.row = null;\n                contentRootSegment.status = 6;\n                try {\n                  if (\n                    (renderNode(request, task, content, -1),\n                    pushSegmentFinale(\n                      contentRootSegment.chunks,\n                      request.renderState,\n                      contentRootSegment.lastPushedText,\n                      contentRootSegment.textEmbedded\n                    ),\n                    (contentRootSegment.status = COMPLETED),\n                    queueCompletedSegment(newBoundary, contentRootSegment),\n                    0 === newBoundary.pendingTasks &&\n                      newBoundary.status === PENDING)\n                  ) {\n                    if (\n                      ((newBoundary.status = COMPLETED),\n                      !isEligibleForOutlining(request, newBoundary))\n                    ) {\n                      null !== prevRow$jscomp$0 &&\n                        0 === --prevRow$jscomp$0.pendingTasks &&\n                        finishSuspenseListRow(request, prevRow$jscomp$0);\n                      0 === request.pendingRootTasks &&\n                        task.blockedPreamble &&\n                        preparePreamble(request);\n                      break a;\n                    }\n                  } else\n                    null !== prevRow$jscomp$0 &&\n                      prevRow$jscomp$0.together &&\n                      tryToResolveTogetherRow(request, prevRow$jscomp$0);\n                } catch (thrownValue$2) {\n                  newBoundary.status = CLIENT_RENDERED;\n                  if (12 === request.status) {\n                    contentRootSegment.status = ABORTED;\n                    var error = request.fatalError;\n                  } else\n                    (contentRootSegment.status = ERRORED),\n                      (error = thrownValue$2);\n                  var thrownInfo = getThrownInfo(task.componentStack);\n                  var errorDigest = logRecoverableError(\n                    request,\n                    error,\n                    thrownInfo,\n                    task.debugTask\n                  );\n                  encodeErrorForBoundary(\n                    newBoundary,\n                    errorDigest,\n                    error,\n                    thrownInfo,\n                    !1\n                  );\n                  untrackBoundary(request, newBoundary);\n                } finally {\n                  (task.blockedBoundary = parentBoundary),\n                    (task.blockedPreamble = parentPreamble),\n                    (task.hoistableState = parentHoistableState),\n                    (task.blockedSegment = parentSegment),\n                    (task.keyPath = prevKeyPath$jscomp$4),\n                    (task.formatContext = prevContext$jscomp$0),\n                    (task.row = prevRow$jscomp$0);\n                }\n                var suspendedFallbackTask = createRenderTask(\n                  request,\n                  null,\n                  fallback,\n                  -1,\n                  parentBoundary,\n                  boundarySegment,\n                  newBoundary.fallbackPreamble,\n                  newBoundary.fallbackState,\n                  fallbackAbortSet,\n                  [keyPath[0], \"Suspense Fallback\", keyPath[2]],\n                  getSuspenseFallbackFormatContext(\n                    request.resumableState,\n                    task.formatContext\n                  ),\n                  task.context,\n                  task.treeContext,\n                  task.row,\n                  replaceSuspenseComponentStackWithSuspenseFallbackStack(\n                    task.componentStack\n                  ),\n                  emptyContextObject,\n                  task.debugTask\n                );\n                pushComponentStack(suspendedFallbackTask);\n                request.pingedTasks.push(suspendedFallbackTask);\n              }\n            }\n            return;\n        }\n        if (\"object\" === typeof type && null !== type)\n          switch (type.$$typeof) {\n            case REACT_FORWARD_REF_TYPE:\n              if (\"ref\" in props) {\n                var propsWithoutRef = {};\n                for (var key in props)\n                  \"ref\" !== key && (propsWithoutRef[key] = props[key]);\n              } else propsWithoutRef = props;\n              var children$jscomp$1 = renderWithHooks(\n                request,\n                task,\n                keyPath,\n                type.render,\n                propsWithoutRef,\n                ref\n              );\n              finishFunctionComponent(\n                request,\n                task,\n                keyPath,\n                children$jscomp$1,\n                0 !== localIdCounter,\n                actionStateCounter,\n                actionStateMatchingIndex\n              );\n              return;\n            case REACT_MEMO_TYPE:\n              renderElement(request, task, keyPath, type.type, props, ref);\n              return;\n            case REACT_CONTEXT_TYPE:\n              var value$jscomp$0 = props.value,\n                children$jscomp$2 = props.children;\n              var prevSnapshot = task.context;\n              var prevKeyPath$jscomp$5 = task.keyPath;\n              var prevValue = type._currentValue2;\n              type._currentValue2 = value$jscomp$0;\n              void 0 !== type._currentRenderer2 &&\n                null !== type._currentRenderer2 &&\n                type._currentRenderer2 !== rendererSigil &&\n                console.error(\n                  \"Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.\"\n                );\n              type._currentRenderer2 = rendererSigil;\n              var prevNode = currentActiveSnapshot,\n                newNode = {\n                  parent: prevNode,\n                  depth: null === prevNode ? 0 : prevNode.depth + 1,\n                  context: type,\n                  parentValue: prevValue,\n                  value: value$jscomp$0\n                };\n              currentActiveSnapshot = newNode;\n              task.context = newNode;\n              task.keyPath = keyPath;\n              renderNodeDestructive(request, task, children$jscomp$2, -1);\n              var prevSnapshot$jscomp$0 = currentActiveSnapshot;\n              if (null === prevSnapshot$jscomp$0)\n                throw Error(\n                  \"Tried to pop a Context at the root of the app. This is a bug in React.\"\n                );\n              prevSnapshot$jscomp$0.context !== type &&\n                console.error(\n                  \"The parent context is not the expected context. This is probably a bug in React.\"\n                );\n              prevSnapshot$jscomp$0.context._currentValue2 =\n                prevSnapshot$jscomp$0.parentValue;\n              void 0 !== type._currentRenderer2 &&\n                null !== type._currentRenderer2 &&\n                type._currentRenderer2 !== rendererSigil &&\n                console.error(\n                  \"Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.\"\n                );\n              type._currentRenderer2 = rendererSigil;\n              var JSCompiler_inline_result$jscomp$0 = (currentActiveSnapshot =\n                prevSnapshot$jscomp$0.parent);\n              task.context = JSCompiler_inline_result$jscomp$0;\n              task.keyPath = prevKeyPath$jscomp$5;\n              prevSnapshot !== task.context &&\n                console.error(\n                  \"Popping the context provider did not return back to the original snapshot. This is a bug in React.\"\n                );\n              return;\n            case REACT_CONSUMER_TYPE:\n              var context$jscomp$0 = type._context,\n                render = props.children;\n              \"function\" !== typeof render &&\n                console.error(\n                  \"A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.\"\n                );\n              var newChildren = render(context$jscomp$0._currentValue2),\n                prevKeyPath$jscomp$6 = task.keyPath;\n              task.keyPath = keyPath;\n              renderNodeDestructive(request, task, newChildren, -1);\n              task.keyPath = prevKeyPath$jscomp$6;\n              return;\n            case REACT_LAZY_TYPE:\n              var Component = callLazyInitInDEV(type);\n              if (12 === request.status) throw null;\n              renderElement(request, task, keyPath, Component, props, ref);\n              return;\n          }\n        var info = \"\";\n        if (\n          void 0 === type ||\n          (\"object\" === typeof type &&\n            null !== type &&\n            0 === Object.keys(type).length)\n        )\n          info +=\n            \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\";\n        throw Error(\n          \"Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: \" +\n            ((null == type ? type : typeof type) + \".\" + info)\n        );\n      }\n    }\n    function resumeNode(request, task, segmentId, node, childIndex) {\n      var prevReplay = task.replay,\n        blockedBoundary = task.blockedBoundary,\n        resumedSegment = createPendingSegment(\n          request,\n          0,\n          null,\n          task.formatContext,\n          !1,\n          !1\n        );\n      resumedSegment.id = segmentId;\n      resumedSegment.parentFlushed = !0;\n      try {\n        (task.replay = null),\n          (task.blockedSegment = resumedSegment),\n          renderNode(request, task, node, childIndex),\n          (resumedSegment.status = COMPLETED),\n          null === blockedBoundary\n            ? (request.completedRootSegment = resumedSegment)\n            : (queueCompletedSegment(blockedBoundary, resumedSegment),\n              blockedBoundary.parentFlushed &&\n                request.partialBoundaries.push(blockedBoundary));\n      } finally {\n        (task.replay = prevReplay), (task.blockedSegment = null);\n      }\n    }\n    function replayElement(\n      request,\n      task,\n      keyPath,\n      name,\n      keyOrIndex,\n      childIndex,\n      type,\n      props,\n      ref,\n      replay\n    ) {\n      childIndex = replay.nodes;\n      for (var i = 0; i < childIndex.length; i++) {\n        var node = childIndex[i];\n        if (keyOrIndex === node[1]) {\n          if (4 === node.length) {\n            if (null !== name && name !== node[0])\n              throw Error(\n                \"Expected the resume to render <\" +\n                  node[0] +\n                  \"> in this slot but instead it rendered <\" +\n                  name +\n                  \">. The tree doesn't match so React will fallback to client rendering.\"\n              );\n            var childNodes = node[2];\n            name = node[3];\n            keyOrIndex = task.node;\n            task.replay = { nodes: childNodes, slots: name, pendingTasks: 1 };\n            try {\n              renderElement(request, task, keyPath, type, props, ref);\n              if (\n                1 === task.replay.pendingTasks &&\n                0 < task.replay.nodes.length\n              )\n                throw Error(\n                  \"Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.\"\n                );\n              task.replay.pendingTasks--;\n            } catch (x) {\n              if (\n                \"object\" === typeof x &&\n                null !== x &&\n                (x === SuspenseException || \"function\" === typeof x.then)\n              )\n                throw (\n                  (task.node === keyOrIndex\n                    ? (task.replay = replay)\n                    : childIndex.splice(i, 1),\n                  x)\n                );\n              task.replay.pendingTasks--;\n              type = getThrownInfo(task.componentStack);\n              props = request;\n              request = task.blockedBoundary;\n              keyPath = x;\n              ref = name;\n              name = logRecoverableError(props, keyPath, type, task.debugTask);\n              abortRemainingReplayNodes(\n                props,\n                request,\n                childNodes,\n                ref,\n                keyPath,\n                name,\n                type,\n                !1\n              );\n            }\n            task.replay = replay;\n          } else {\n            if (type !== REACT_SUSPENSE_TYPE)\n              throw Error(\n                \"Expected the resume to render <Suspense> in this slot but instead it rendered <\" +\n                  (getComponentNameFromType(type) || \"Unknown\") +\n                  \">. The tree doesn't match so React will fallback to client rendering.\"\n              );\n            a: {\n              replay = void 0;\n              name = node[5];\n              type = node[2];\n              ref = node[3];\n              keyOrIndex = null === node[4] ? [] : node[4][2];\n              node = null === node[4] ? null : node[4][3];\n              var prevKeyPath = task.keyPath,\n                prevContext = task.formatContext,\n                prevRow = task.row,\n                previousReplaySet = task.replay,\n                parentBoundary = task.blockedBoundary,\n                parentHoistableState = task.hoistableState,\n                content = props.children,\n                fallback = props.fallback,\n                fallbackAbortSet = new Set();\n              props = createSuspenseBoundary(\n                request,\n                task.row,\n                fallbackAbortSet,\n                null,\n                null\n              );\n              props.parentFlushed = !0;\n              props.rootSegmentID = name;\n              task.blockedBoundary = props;\n              task.hoistableState = props.contentState;\n              task.keyPath = keyPath;\n              task.formatContext = getSuspenseContentFormatContext(\n                request.resumableState,\n                prevContext\n              );\n              task.row = null;\n              task.replay = { nodes: type, slots: ref, pendingTasks: 1 };\n              try {\n                renderNode(request, task, content, -1);\n                if (\n                  1 === task.replay.pendingTasks &&\n                  0 < task.replay.nodes.length\n                )\n                  throw Error(\n                    \"Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.\"\n                  );\n                task.replay.pendingTasks--;\n                if (0 === props.pendingTasks && props.status === PENDING) {\n                  props.status = COMPLETED;\n                  request.completedBoundaries.push(props);\n                  break a;\n                }\n              } catch (error) {\n                (props.status = CLIENT_RENDERED),\n                  (childNodes = getThrownInfo(task.componentStack)),\n                  (replay = logRecoverableError(\n                    request,\n                    error,\n                    childNodes,\n                    task.debugTask\n                  )),\n                  encodeErrorForBoundary(props, replay, error, childNodes, !1),\n                  task.replay.pendingTasks--,\n                  request.clientRenderedBoundaries.push(props);\n              } finally {\n                (task.blockedBoundary = parentBoundary),\n                  (task.hoistableState = parentHoistableState),\n                  (task.replay = previousReplaySet),\n                  (task.keyPath = prevKeyPath),\n                  (task.formatContext = prevContext),\n                  (task.row = prevRow);\n              }\n              props = createReplayTask(\n                request,\n                null,\n                { nodes: keyOrIndex, slots: node, pendingTasks: 0 },\n                fallback,\n                -1,\n                parentBoundary,\n                props.fallbackState,\n                fallbackAbortSet,\n                [keyPath[0], \"Suspense Fallback\", keyPath[2]],\n                getSuspenseFallbackFormatContext(\n                  request.resumableState,\n                  task.formatContext\n                ),\n                task.context,\n                task.treeContext,\n                task.row,\n                replaceSuspenseComponentStackWithSuspenseFallbackStack(\n                  task.componentStack\n                ),\n                emptyContextObject,\n                task.debugTask\n              );\n              pushComponentStack(props);\n              request.pingedTasks.push(props);\n            }\n          }\n          childIndex.splice(i, 1);\n          break;\n        }\n      }\n    }\n    function validateIterable(\n      task,\n      iterable,\n      childIndex,\n      iterator,\n      iteratorFn\n    ) {\n      if (iterator === iterable) {\n        if (\n          -1 !== childIndex ||\n          null === task.componentStack ||\n          \"function\" !== typeof task.componentStack.type ||\n          \"[object GeneratorFunction]\" !==\n            Object.prototype.toString.call(task.componentStack.type) ||\n          \"[object Generator]\" !== Object.prototype.toString.call(iterator)\n        )\n          didWarnAboutGenerators ||\n            console.error(\n              \"Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items.\"\n            ),\n            (didWarnAboutGenerators = !0);\n      } else\n        iterable.entries !== iteratorFn ||\n          didWarnAboutMaps ||\n          (console.error(\n            \"Using Maps as children is not supported. Use an array of keyed ReactElements instead.\"\n          ),\n          (didWarnAboutMaps = !0));\n    }\n    function renderNodeDestructive(request, task, node, childIndex) {\n      null !== task.replay && \"number\" === typeof task.replay.slots\n        ? resumeNode(request, task, task.replay.slots, node, childIndex)\n        : ((task.node = node),\n          (task.childIndex = childIndex),\n          (node = task.componentStack),\n          (childIndex = task.debugTask),\n          pushComponentStack(task),\n          retryNode(request, task),\n          (task.componentStack = node),\n          (task.debugTask = childIndex));\n    }\n    function retryNode(request, task) {\n      var node = task.node,\n        childIndex = task.childIndex;\n      if (null !== node) {\n        if (\"object\" === typeof node) {\n          switch (node.$$typeof) {\n            case REACT_ELEMENT_TYPE:\n              var type = node.type,\n                key = node.key;\n              node = node.props;\n              var refProp = node.ref;\n              refProp = void 0 !== refProp ? refProp : null;\n              var debugTask = task.debugTask,\n                name = getComponentNameFromType(type);\n              key = null == key ? (-1 === childIndex ? 0 : childIndex) : key;\n              var keyPath = [task.keyPath, name, key];\n              null !== task.replay\n                ? debugTask\n                  ? debugTask.run(\n                      replayElement.bind(\n                        null,\n                        request,\n                        task,\n                        keyPath,\n                        name,\n                        key,\n                        childIndex,\n                        type,\n                        node,\n                        refProp,\n                        task.replay\n                      )\n                    )\n                  : replayElement(\n                      request,\n                      task,\n                      keyPath,\n                      name,\n                      key,\n                      childIndex,\n                      type,\n                      node,\n                      refProp,\n                      task.replay\n                    )\n                : debugTask\n                  ? debugTask.run(\n                      renderElement.bind(\n                        null,\n                        request,\n                        task,\n                        keyPath,\n                        type,\n                        node,\n                        refProp\n                      )\n                    )\n                  : renderElement(request, task, keyPath, type, node, refProp);\n              return;\n            case REACT_PORTAL_TYPE:\n              throw Error(\n                \"Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.\"\n              );\n            case REACT_LAZY_TYPE:\n              type = callLazyInitInDEV(node);\n              if (12 === request.status) throw null;\n              renderNodeDestructive(request, task, type, childIndex);\n              return;\n          }\n          if (isArrayImpl(node)) {\n            renderChildrenArray(request, task, node, childIndex);\n            return;\n          }\n          if ((key = getIteratorFn(node)))\n            if ((type = key.call(node))) {\n              validateIterable(task, node, childIndex, type, key);\n              node = type.next();\n              if (!node.done) {\n                key = [];\n                do key.push(node.value), (node = type.next());\n                while (!node.done);\n                renderChildrenArray(request, task, key, childIndex);\n              }\n              return;\n            }\n          if (\"function\" === typeof node.then)\n            return (\n              (task.thenableState = null),\n              renderNodeDestructive(\n                request,\n                task,\n                unwrapThenable(node),\n                childIndex\n              )\n            );\n          if (node.$$typeof === REACT_CONTEXT_TYPE)\n            return renderNodeDestructive(\n              request,\n              task,\n              node._currentValue2,\n              childIndex\n            );\n          request = Object.prototype.toString.call(node);\n          throw Error(\n            \"Objects are not valid as a React child (found: \" +\n              (\"[object Object]\" === request\n                ? \"object with keys {\" + Object.keys(node).join(\", \") + \"}\"\n                : request) +\n              \"). If you meant to render a collection of children, use an array instead.\"\n          );\n        }\n        \"string\" === typeof node\n          ? ((task = task.blockedSegment),\n            null !== task &&\n              (task.lastPushedText = pushTextInstance(\n                task.chunks,\n                node,\n                request.renderState,\n                task.lastPushedText\n              )))\n          : \"number\" === typeof node || \"bigint\" === typeof node\n            ? ((task = task.blockedSegment),\n              null !== task &&\n                (task.lastPushedText = pushTextInstance(\n                  task.chunks,\n                  \"\" + node,\n                  request.renderState,\n                  task.lastPushedText\n                )))\n            : (\"function\" === typeof node &&\n                ((request = node.displayName || node.name || \"Component\"),\n                console.error(\n                  \"Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\",\n                  request,\n                  request\n                )),\n              \"symbol\" === typeof node &&\n                console.error(\n                  \"Symbols are not valid as a React child.\\n  %s\",\n                  String(node)\n                ));\n      }\n    }\n    function warnForMissingKey(request, task, child) {\n      if (\n        null !== child &&\n        \"object\" === typeof child &&\n        (child.$$typeof === REACT_ELEMENT_TYPE ||\n          child.$$typeof === REACT_PORTAL_TYPE) &&\n        child._store &&\n        ((!child._store.validated && null == child.key) ||\n          2 === child._store.validated)\n      ) {\n        if (\"object\" !== typeof child._store)\n          throw Error(\n            \"React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.\"\n          );\n        child._store.validated = 1;\n        var didWarnForKey = request.didWarnForKey;\n        null == didWarnForKey &&\n          (didWarnForKey = request.didWarnForKey = new WeakSet());\n        request = task.componentStack;\n        if (null !== request && !didWarnForKey.has(request)) {\n          didWarnForKey.add(request);\n          var componentName = getComponentNameFromType(child.type);\n          didWarnForKey = child._owner;\n          var parentOwner = request.owner;\n          request = \"\";\n          if (parentOwner && \"undefined\" !== typeof parentOwner.type) {\n            var name = getComponentNameFromType(parentOwner.type);\n            name &&\n              (request = \"\\n\\nCheck the render method of `\" + name + \"`.\");\n          }\n          request ||\n            (componentName &&\n              (request =\n                \"\\n\\nCheck the top-level render call using <\" +\n                componentName +\n                \">.\"));\n          componentName = \"\";\n          null != didWarnForKey &&\n            parentOwner !== didWarnForKey &&\n            ((parentOwner = null),\n            \"undefined\" !== typeof didWarnForKey.type\n              ? (parentOwner = getComponentNameFromType(didWarnForKey.type))\n              : \"string\" === typeof didWarnForKey.name &&\n                (parentOwner = didWarnForKey.name),\n            parentOwner &&\n              (componentName =\n                \" It was passed a child from \" + parentOwner + \".\"));\n          didWarnForKey = task.componentStack;\n          task.componentStack = {\n            parent: task.componentStack,\n            type: child.type,\n            owner: child._owner,\n            stack: child._debugStack\n          };\n          console.error(\n            'Each child in a list should have a unique \"key\" prop.%s%s See https://react.dev/link/warning-keys for more information.',\n            request,\n            componentName\n          );\n          task.componentStack = didWarnForKey;\n        }\n      }\n    }\n    function renderChildrenArray(request, task, children, childIndex) {\n      var prevKeyPath = task.keyPath,\n        previousComponentStack = task.componentStack;\n      var previousDebugTask = task.debugTask;\n      pushServerComponentStack(task, task.node._debugInfo);\n      if (\n        -1 !== childIndex &&\n        ((task.keyPath = [task.keyPath, \"Fragment\", childIndex]),\n        null !== task.replay)\n      ) {\n        for (\n          var replay = task.replay, replayNodes = replay.nodes, j = 0;\n          j < replayNodes.length;\n          j++\n        ) {\n          var node = replayNodes[j];\n          if (node[1] === childIndex) {\n            childIndex = node[2];\n            node = node[3];\n            task.replay = { nodes: childIndex, slots: node, pendingTasks: 1 };\n            try {\n              renderChildrenArray(request, task, children, -1);\n              if (\n                1 === task.replay.pendingTasks &&\n                0 < task.replay.nodes.length\n              )\n                throw Error(\n                  \"Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.\"\n                );\n              task.replay.pendingTasks--;\n            } catch (x) {\n              if (\n                \"object\" === typeof x &&\n                null !== x &&\n                (x === SuspenseException || \"function\" === typeof x.then)\n              )\n                throw x;\n              task.replay.pendingTasks--;\n              var thrownInfo = getThrownInfo(task.componentStack);\n              children = task.blockedBoundary;\n              var error = x,\n                resumeSlots = node;\n              node = logRecoverableError(\n                request,\n                error,\n                thrownInfo,\n                task.debugTask\n              );\n              abortRemainingReplayNodes(\n                request,\n                children,\n                childIndex,\n                resumeSlots,\n                error,\n                node,\n                thrownInfo,\n                !1\n              );\n            }\n            task.replay = replay;\n            replayNodes.splice(j, 1);\n            break;\n          }\n        }\n        task.keyPath = prevKeyPath;\n        task.componentStack = previousComponentStack;\n        task.debugTask = previousDebugTask;\n        return;\n      }\n      replay = task.treeContext;\n      replayNodes = children.length;\n      if (\n        null !== task.replay &&\n        ((j = task.replay.slots), null !== j && \"object\" === typeof j)\n      ) {\n        for (childIndex = 0; childIndex < replayNodes; childIndex++)\n          (node = children[childIndex]),\n            (task.treeContext = pushTreeContext(\n              replay,\n              replayNodes,\n              childIndex\n            )),\n            (error = j[childIndex]),\n            \"number\" === typeof error\n              ? (resumeNode(request, task, error, node, childIndex),\n                delete j[childIndex])\n              : renderNode(request, task, node, childIndex);\n        task.treeContext = replay;\n        task.keyPath = prevKeyPath;\n        task.componentStack = previousComponentStack;\n        task.debugTask = previousDebugTask;\n        return;\n      }\n      for (j = 0; j < replayNodes; j++)\n        (childIndex = children[j]),\n          warnForMissingKey(request, task, childIndex),\n          (task.treeContext = pushTreeContext(replay, replayNodes, j)),\n          renderNode(request, task, childIndex, j);\n      task.treeContext = replay;\n      task.keyPath = prevKeyPath;\n      task.componentStack = previousComponentStack;\n      task.debugTask = previousDebugTask;\n    }\n    function trackPostponedBoundary(request, trackedPostpones, boundary) {\n      boundary.status = POSTPONED;\n      boundary.rootSegmentID = request.nextSegmentId++;\n      request = boundary.trackedContentKeyPath;\n      if (null === request)\n        throw Error(\n          \"It should not be possible to postpone at the root. This is a bug in React.\"\n        );\n      var fallbackReplayNode = boundary.trackedFallbackNode,\n        children = [],\n        boundaryNode = trackedPostpones.workingMap.get(request);\n      if (void 0 === boundaryNode)\n        return (\n          (boundary = [\n            request[1],\n            request[2],\n            children,\n            null,\n            fallbackReplayNode,\n            boundary.rootSegmentID\n          ]),\n          trackedPostpones.workingMap.set(request, boundary),\n          addToReplayParent(boundary, request[0], trackedPostpones),\n          boundary\n        );\n      boundaryNode[4] = fallbackReplayNode;\n      boundaryNode[5] = boundary.rootSegmentID;\n      return boundaryNode;\n    }\n    function trackPostpone(request, trackedPostpones, task, segment) {\n      segment.status = POSTPONED;\n      var keyPath = task.keyPath,\n        boundary = task.blockedBoundary;\n      if (null === boundary)\n        (segment.id = request.nextSegmentId++),\n          (trackedPostpones.rootSlots = segment.id),\n          null !== request.completedRootSegment &&\n            (request.completedRootSegment.status = POSTPONED);\n      else {\n        if (null !== boundary && boundary.status === PENDING) {\n          var boundaryNode = trackPostponedBoundary(\n            request,\n            trackedPostpones,\n            boundary\n          );\n          if (\n            boundary.trackedContentKeyPath === keyPath &&\n            -1 === task.childIndex\n          ) {\n            -1 === segment.id &&\n              (segment.id = segment.parentFlushed\n                ? boundary.rootSegmentID\n                : request.nextSegmentId++);\n            boundaryNode[3] = segment.id;\n            return;\n          }\n        }\n        -1 === segment.id &&\n          (segment.id =\n            segment.parentFlushed && null !== boundary\n              ? boundary.rootSegmentID\n              : request.nextSegmentId++);\n        if (-1 === task.childIndex)\n          null === keyPath\n            ? (trackedPostpones.rootSlots = segment.id)\n            : ((task = trackedPostpones.workingMap.get(keyPath)),\n              void 0 === task\n                ? ((task = [keyPath[1], keyPath[2], [], segment.id]),\n                  addToReplayParent(task, keyPath[0], trackedPostpones))\n                : (task[3] = segment.id));\n        else {\n          if (null === keyPath)\n            if (((request = trackedPostpones.rootSlots), null === request))\n              request = trackedPostpones.rootSlots = {};\n            else {\n              if (\"number\" === typeof request)\n                throw Error(\n                  \"It should not be possible to postpone both at the root of an element as well as a slot below. This is a bug in React.\"\n                );\n            }\n          else if (\n            ((boundary = trackedPostpones.workingMap),\n            (boundaryNode = boundary.get(keyPath)),\n            void 0 === boundaryNode)\n          )\n            (request = {}),\n              (boundaryNode = [keyPath[1], keyPath[2], [], request]),\n              boundary.set(keyPath, boundaryNode),\n              addToReplayParent(boundaryNode, keyPath[0], trackedPostpones);\n          else if (((request = boundaryNode[3]), null === request))\n            request = boundaryNode[3] = {};\n          else if (\"number\" === typeof request)\n            throw Error(\n              \"It should not be possible to postpone both at the root of an element as well as a slot below. This is a bug in React.\"\n            );\n          request[task.childIndex] = segment.id;\n        }\n      }\n    }\n    function untrackBoundary(request, boundary) {\n      request = request.trackedPostpones;\n      null !== request &&\n        ((boundary = boundary.trackedContentKeyPath),\n        null !== boundary &&\n          ((boundary = request.workingMap.get(boundary)),\n          void 0 !== boundary &&\n            ((boundary.length = 4), (boundary[2] = []), (boundary[3] = null))));\n    }\n    function spawnNewSuspendedReplayTask(request, task, thenableState) {\n      return createReplayTask(\n        request,\n        thenableState,\n        task.replay,\n        task.node,\n        task.childIndex,\n        task.blockedBoundary,\n        task.hoistableState,\n        task.abortSet,\n        task.keyPath,\n        task.formatContext,\n        task.context,\n        task.treeContext,\n        task.row,\n        task.componentStack,\n        emptyContextObject,\n        task.debugTask\n      );\n    }\n    function spawnNewSuspendedRenderTask(request, task, thenableState) {\n      var segment = task.blockedSegment,\n        newSegment = createPendingSegment(\n          request,\n          segment.chunks.length,\n          null,\n          task.formatContext,\n          segment.lastPushedText,\n          !0\n        );\n      segment.children.push(newSegment);\n      segment.lastPushedText = !1;\n      return createRenderTask(\n        request,\n        thenableState,\n        task.node,\n        task.childIndex,\n        task.blockedBoundary,\n        newSegment,\n        task.blockedPreamble,\n        task.hoistableState,\n        task.abortSet,\n        task.keyPath,\n        task.formatContext,\n        task.context,\n        task.treeContext,\n        task.row,\n        task.componentStack,\n        emptyContextObject,\n        task.debugTask\n      );\n    }\n    function renderNode(request, task, node, childIndex) {\n      var previousFormatContext = task.formatContext,\n        previousContext = task.context,\n        previousKeyPath = task.keyPath,\n        previousTreeContext = task.treeContext,\n        previousComponentStack = task.componentStack,\n        previousDebugTask = task.debugTask,\n        segment = task.blockedSegment;\n      if (null === segment) {\n        segment = task.replay;\n        try {\n          return renderNodeDestructive(request, task, node, childIndex);\n        } catch (thrownValue) {\n          if (\n            (resetHooksState(),\n            (node =\n              thrownValue === SuspenseException\n                ? getSuspendedThenable()\n                : thrownValue),\n            12 !== request.status && \"object\" === typeof node && null !== node)\n          ) {\n            if (\"function\" === typeof node.then) {\n              childIndex =\n                thrownValue === SuspenseException\n                  ? getThenableStateAfterSuspending()\n                  : null;\n              request = spawnNewSuspendedReplayTask(\n                request,\n                task,\n                childIndex\n              ).ping;\n              node.then(request, request);\n              task.formatContext = previousFormatContext;\n              task.context = previousContext;\n              task.keyPath = previousKeyPath;\n              task.treeContext = previousTreeContext;\n              task.componentStack = previousComponentStack;\n              task.replay = segment;\n              task.debugTask = previousDebugTask;\n              switchContext(previousContext);\n              return;\n            }\n            if (\"Maximum call stack size exceeded\" === node.message) {\n              node =\n                thrownValue === SuspenseException\n                  ? getThenableStateAfterSuspending()\n                  : null;\n              node = spawnNewSuspendedReplayTask(request, task, node);\n              request.pingedTasks.push(node);\n              task.formatContext = previousFormatContext;\n              task.context = previousContext;\n              task.keyPath = previousKeyPath;\n              task.treeContext = previousTreeContext;\n              task.componentStack = previousComponentStack;\n              task.replay = segment;\n              task.debugTask = previousDebugTask;\n              switchContext(previousContext);\n              return;\n            }\n          }\n        }\n      } else {\n        var childrenLength = segment.children.length,\n          chunkLength = segment.chunks.length;\n        try {\n          return renderNodeDestructive(request, task, node, childIndex);\n        } catch (thrownValue$3) {\n          if (\n            (resetHooksState(),\n            (segment.children.length = childrenLength),\n            (segment.chunks.length = chunkLength),\n            (node =\n              thrownValue$3 === SuspenseException\n                ? getSuspendedThenable()\n                : thrownValue$3),\n            12 !== request.status && \"object\" === typeof node && null !== node)\n          ) {\n            if (\"function\" === typeof node.then) {\n              segment = node;\n              node =\n                thrownValue$3 === SuspenseException\n                  ? getThenableStateAfterSuspending()\n                  : null;\n              request = spawnNewSuspendedRenderTask(request, task, node).ping;\n              segment.then(request, request);\n              task.formatContext = previousFormatContext;\n              task.context = previousContext;\n              task.keyPath = previousKeyPath;\n              task.treeContext = previousTreeContext;\n              task.componentStack = previousComponentStack;\n              task.debugTask = previousDebugTask;\n              switchContext(previousContext);\n              return;\n            }\n            if (\"Maximum call stack size exceeded\" === node.message) {\n              segment =\n                thrownValue$3 === SuspenseException\n                  ? getThenableStateAfterSuspending()\n                  : null;\n              segment = spawnNewSuspendedRenderTask(request, task, segment);\n              request.pingedTasks.push(segment);\n              task.formatContext = previousFormatContext;\n              task.context = previousContext;\n              task.keyPath = previousKeyPath;\n              task.treeContext = previousTreeContext;\n              task.componentStack = previousComponentStack;\n              task.debugTask = previousDebugTask;\n              switchContext(previousContext);\n              return;\n            }\n          }\n        }\n      }\n      task.formatContext = previousFormatContext;\n      task.context = previousContext;\n      task.keyPath = previousKeyPath;\n      task.treeContext = previousTreeContext;\n      switchContext(previousContext);\n      throw node;\n    }\n    function abortTaskSoft(task) {\n      var boundary = task.blockedBoundary,\n        segment = task.blockedSegment;\n      null !== segment &&\n        ((segment.status = ABORTED),\n        finishedTask(this, boundary, task.row, segment));\n    }\n    function abortRemainingReplayNodes(\n      request$jscomp$0,\n      boundary,\n      nodes,\n      slots,\n      error$jscomp$0,\n      errorDigest$jscomp$0,\n      errorInfo$jscomp$0,\n      aborted\n    ) {\n      for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n        if (4 === node.length)\n          abortRemainingReplayNodes(\n            request$jscomp$0,\n            boundary,\n            node[2],\n            node[3],\n            error$jscomp$0,\n            errorDigest$jscomp$0,\n            errorInfo$jscomp$0,\n            aborted\n          );\n        else {\n          var request = request$jscomp$0;\n          node = node[5];\n          var error = error$jscomp$0,\n            errorDigest = errorDigest$jscomp$0,\n            errorInfo = errorInfo$jscomp$0,\n            wasAborted = aborted,\n            resumedBoundary = createSuspenseBoundary(\n              request,\n              null,\n              new Set(),\n              null,\n              null\n            );\n          resumedBoundary.parentFlushed = !0;\n          resumedBoundary.rootSegmentID = node;\n          resumedBoundary.status = CLIENT_RENDERED;\n          encodeErrorForBoundary(\n            resumedBoundary,\n            errorDigest,\n            error,\n            errorInfo,\n            wasAborted\n          );\n          resumedBoundary.parentFlushed &&\n            request.clientRenderedBoundaries.push(resumedBoundary);\n        }\n      }\n      nodes.length = 0;\n      if (null !== slots) {\n        if (null === boundary)\n          throw Error(\n            \"We should not have any resumable nodes in the shell. This is a bug in React.\"\n          );\n        boundary.status !== CLIENT_RENDERED &&\n          ((boundary.status = CLIENT_RENDERED),\n          encodeErrorForBoundary(\n            boundary,\n            errorDigest$jscomp$0,\n            error$jscomp$0,\n            errorInfo$jscomp$0,\n            aborted\n          ),\n          boundary.parentFlushed &&\n            request$jscomp$0.clientRenderedBoundaries.push(boundary));\n        if (\"object\" === typeof slots)\n          for (var index in slots) delete slots[index];\n      }\n    }\n    function abortTask(task, request, error) {\n      var boundary = task.blockedBoundary,\n        segment = task.blockedSegment;\n      if (null !== segment) {\n        if (6 === segment.status) return;\n        segment.status = ABORTED;\n      }\n      var errorInfo = getThrownInfo(task.componentStack),\n        node = task.node;\n      null !== node &&\n        \"object\" === typeof node &&\n        pushHaltedAwaitOnComponentStack(task, node._debugInfo);\n      if (null === boundary) {\n        if (13 !== request.status && request.status !== CLOSED) {\n          boundary = task.replay;\n          if (null === boundary) {\n            null !== request.trackedPostpones && null !== segment\n              ? ((boundary = request.trackedPostpones),\n                logRecoverableError(request, error, errorInfo, task.debugTask),\n                trackPostpone(request, boundary, task, segment),\n                finishedTask(request, null, task.row, segment))\n              : (logRecoverableError(request, error, errorInfo, task.debugTask),\n                fatalError(request, error, errorInfo, task.debugTask));\n            return;\n          }\n          boundary.pendingTasks--;\n          0 === boundary.pendingTasks &&\n            0 < boundary.nodes.length &&\n            ((segment = logRecoverableError(request, error, errorInfo, null)),\n            abortRemainingReplayNodes(\n              request,\n              null,\n              boundary.nodes,\n              boundary.slots,\n              error,\n              segment,\n              errorInfo,\n              !0\n            ));\n          request.pendingRootTasks--;\n          0 === request.pendingRootTasks && completeShell(request);\n        }\n      } else {\n        node = request.trackedPostpones;\n        if (boundary.status !== CLIENT_RENDERED) {\n          if (null !== node && null !== segment)\n            return (\n              logRecoverableError(request, error, errorInfo, task.debugTask),\n              trackPostpone(request, node, task, segment),\n              boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {\n                return abortTask(fallbackTask, request, error);\n              }),\n              boundary.fallbackAbortableTasks.clear(),\n              finishedTask(request, boundary, task.row, segment)\n            );\n          boundary.status = CLIENT_RENDERED;\n          segment = logRecoverableError(\n            request,\n            error,\n            errorInfo,\n            task.debugTask\n          );\n          boundary.status = CLIENT_RENDERED;\n          encodeErrorForBoundary(boundary, segment, error, errorInfo, !0);\n          untrackBoundary(request, boundary);\n          boundary.parentFlushed &&\n            request.clientRenderedBoundaries.push(boundary);\n        }\n        boundary.pendingTasks--;\n        errorInfo = boundary.row;\n        null !== errorInfo &&\n          0 === --errorInfo.pendingTasks &&\n          finishSuspenseListRow(request, errorInfo);\n        boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {\n          return abortTask(fallbackTask, request, error);\n        });\n        boundary.fallbackAbortableTasks.clear();\n      }\n      task = task.row;\n      null !== task &&\n        0 === --task.pendingTasks &&\n        finishSuspenseListRow(request, task);\n      request.allPendingTasks--;\n      0 === request.allPendingTasks && completeAll(request);\n    }\n    function safelyEmitEarlyPreloads(request, shellComplete) {\n      try {\n        var renderState = request.renderState,\n          onHeaders = renderState.onHeaders;\n        if (onHeaders) {\n          var headers = renderState.headers;\n          if (headers) {\n            renderState.headers = null;\n            var linkHeader = headers.preconnects;\n            headers.fontPreloads &&\n              (linkHeader && (linkHeader += \", \"),\n              (linkHeader += headers.fontPreloads));\n            headers.highImagePreloads &&\n              (linkHeader && (linkHeader += \", \"),\n              (linkHeader += headers.highImagePreloads));\n            if (!shellComplete) {\n              var queueIter = renderState.styles.values(),\n                queueStep = queueIter.next();\n              b: for (\n                ;\n                0 < headers.remainingCapacity && !queueStep.done;\n                queueStep = queueIter.next()\n              )\n                for (\n                  var sheetIter = queueStep.value.sheets.values(),\n                    sheetStep = sheetIter.next();\n                  0 < headers.remainingCapacity && !sheetStep.done;\n                  sheetStep = sheetIter.next()\n                ) {\n                  var sheet = sheetStep.value,\n                    props = sheet.props,\n                    key = props.href,\n                    props$jscomp$0 = sheet.props;\n                  var header = getPreloadAsHeader(\n                    props$jscomp$0.href,\n                    \"style\",\n                    {\n                      crossOrigin: props$jscomp$0.crossOrigin,\n                      integrity: props$jscomp$0.integrity,\n                      nonce: props$jscomp$0.nonce,\n                      type: props$jscomp$0.type,\n                      fetchPriority: props$jscomp$0.fetchPriority,\n                      referrerPolicy: props$jscomp$0.referrerPolicy,\n                      media: props$jscomp$0.media\n                    }\n                  );\n                  if (0 <= (headers.remainingCapacity -= header.length + 2))\n                    (renderState.resets.style[key] = PRELOAD_NO_CREDS),\n                      linkHeader && (linkHeader += \", \"),\n                      (linkHeader += header),\n                      (renderState.resets.style[key] =\n                        \"string\" === typeof props.crossOrigin ||\n                        \"string\" === typeof props.integrity\n                          ? [props.crossOrigin, props.integrity]\n                          : PRELOAD_NO_CREDS);\n                  else break b;\n                }\n            }\n            linkHeader ? onHeaders({ Link: linkHeader }) : onHeaders({});\n          }\n        }\n      } catch (error) {\n        logRecoverableError(request, error, {}, null);\n      }\n    }\n    function completeShell(request) {\n      null === request.trackedPostpones && safelyEmitEarlyPreloads(request, !0);\n      null === request.trackedPostpones && preparePreamble(request);\n      request.onShellError = noop;\n      request = request.onShellReady;\n      request();\n    }\n    function completeAll(request) {\n      safelyEmitEarlyPreloads(\n        request,\n        null === request.trackedPostpones\n          ? !0\n          : null === request.completedRootSegment ||\n              request.completedRootSegment.status !== POSTPONED\n      );\n      preparePreamble(request);\n      request = request.onAllReady;\n      request();\n    }\n    function queueCompletedSegment(boundary, segment) {\n      if (\n        0 === segment.chunks.length &&\n        1 === segment.children.length &&\n        null === segment.children[0].boundary &&\n        -1 === segment.children[0].id\n      ) {\n        var childSegment = segment.children[0];\n        childSegment.id = segment.id;\n        childSegment.parentFlushed = !0;\n        (childSegment.status !== COMPLETED &&\n          childSegment.status !== ABORTED &&\n          childSegment.status !== ERRORED) ||\n          queueCompletedSegment(boundary, childSegment);\n      } else boundary.completedSegments.push(segment);\n    }\n    function finishedTask(request, boundary, row, segment) {\n      null !== row &&\n        (0 === --row.pendingTasks\n          ? finishSuspenseListRow(request, row)\n          : row.together && tryToResolveTogetherRow(request, row));\n      request.allPendingTasks--;\n      if (null === boundary) {\n        if (null !== segment && segment.parentFlushed) {\n          if (null !== request.completedRootSegment)\n            throw Error(\n              \"There can only be one root segment. This is a bug in React.\"\n            );\n          request.completedRootSegment = segment;\n        }\n        request.pendingRootTasks--;\n        0 === request.pendingRootTasks && completeShell(request);\n      } else if ((boundary.pendingTasks--, boundary.status !== CLIENT_RENDERED))\n        if (0 === boundary.pendingTasks)\n          if (\n            (boundary.status === PENDING && (boundary.status = COMPLETED),\n            null !== segment &&\n              segment.parentFlushed &&\n              (segment.status === COMPLETED || segment.status === ABORTED) &&\n              queueCompletedSegment(boundary, segment),\n            boundary.parentFlushed &&\n              request.completedBoundaries.push(boundary),\n            boundary.status === COMPLETED)\n          )\n            (row = boundary.row),\n              null !== row &&\n                hoistHoistables(row.hoistables, boundary.contentState),\n              isEligibleForOutlining(request, boundary) ||\n                (boundary.fallbackAbortableTasks.forEach(\n                  abortTaskSoft,\n                  request\n                ),\n                boundary.fallbackAbortableTasks.clear(),\n                null !== row &&\n                  0 === --row.pendingTasks &&\n                  finishSuspenseListRow(request, row)),\n              0 === request.pendingRootTasks &&\n                null === request.trackedPostpones &&\n                null !== boundary.contentPreamble &&\n                preparePreamble(request);\n          else {\n            if (\n              boundary.status === POSTPONED &&\n              ((boundary = boundary.row), null !== boundary)\n            ) {\n              if (null !== request.trackedPostpones) {\n                row = request.trackedPostpones;\n                var postponedRow = boundary.next;\n                if (\n                  null !== postponedRow &&\n                  ((segment = postponedRow.boundaries), null !== segment)\n                )\n                  for (\n                    postponedRow.boundaries = null, postponedRow = 0;\n                    postponedRow < segment.length;\n                    postponedRow++\n                  ) {\n                    var postponedBoundary = segment[postponedRow];\n                    trackPostponedBoundary(request, row, postponedBoundary);\n                    finishedTask(request, postponedBoundary, null, null);\n                  }\n              }\n              0 === --boundary.pendingTasks &&\n                finishSuspenseListRow(request, boundary);\n            }\n          }\n        else\n          null === segment ||\n            !segment.parentFlushed ||\n            (segment.status !== COMPLETED && segment.status !== ABORTED) ||\n            (queueCompletedSegment(boundary, segment),\n            1 === boundary.completedSegments.length &&\n              boundary.parentFlushed &&\n              request.partialBoundaries.push(boundary)),\n            (boundary = boundary.row),\n            null !== boundary &&\n              boundary.together &&\n              tryToResolveTogetherRow(request, boundary);\n      0 === request.allPendingTasks && completeAll(request);\n    }\n    function performWork(request$jscomp$2) {\n      if (\n        request$jscomp$2.status !== CLOSED &&\n        13 !== request$jscomp$2.status\n      ) {\n        var prevContext = currentActiveSnapshot,\n          prevDispatcher = ReactSharedInternals.H;\n        ReactSharedInternals.H = HooksDispatcher;\n        var prevAsyncDispatcher = ReactSharedInternals.A;\n        ReactSharedInternals.A = DefaultAsyncDispatcher;\n        var prevRequest = currentRequest;\n        currentRequest = request$jscomp$2;\n        var prevGetCurrentStackImpl = ReactSharedInternals.getCurrentStack;\n        ReactSharedInternals.getCurrentStack = getCurrentStackInDEV;\n        var prevResumableState = currentResumableState;\n        currentResumableState = request$jscomp$2.resumableState;\n        try {\n          var pingedTasks = request$jscomp$2.pingedTasks,\n            i;\n          for (i = 0; i < pingedTasks.length; i++) {\n            var request = request$jscomp$2,\n              task = pingedTasks[i],\n              segment = task.blockedSegment;\n            if (null === segment) {\n              var prevTaskInDEV = void 0,\n                request$jscomp$0 = request;\n              request = task;\n              if (0 !== request.replay.pendingTasks) {\n                switchContext(request.context);\n                prevTaskInDEV = currentTaskInDEV;\n                currentTaskInDEV = request;\n                try {\n                  \"number\" === typeof request.replay.slots\n                    ? resumeNode(\n                        request$jscomp$0,\n                        request,\n                        request.replay.slots,\n                        request.node,\n                        request.childIndex\n                      )\n                    : retryNode(request$jscomp$0, request);\n                  if (\n                    1 === request.replay.pendingTasks &&\n                    0 < request.replay.nodes.length\n                  )\n                    throw Error(\n                      \"Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.\"\n                    );\n                  request.replay.pendingTasks--;\n                  request.abortSet.delete(request);\n                  finishedTask(\n                    request$jscomp$0,\n                    request.blockedBoundary,\n                    request.row,\n                    null\n                  );\n                } catch (thrownValue) {\n                  resetHooksState();\n                  var x =\n                    thrownValue === SuspenseException\n                      ? getSuspendedThenable()\n                      : thrownValue;\n                  if (\n                    \"object\" === typeof x &&\n                    null !== x &&\n                    \"function\" === typeof x.then\n                  ) {\n                    var ping = request.ping;\n                    x.then(ping, ping);\n                    request.thenableState =\n                      thrownValue === SuspenseException\n                        ? getThenableStateAfterSuspending()\n                        : null;\n                  } else {\n                    request.replay.pendingTasks--;\n                    request.abortSet.delete(request);\n                    var errorInfo = getThrownInfo(request.componentStack),\n                      errorDigest = void 0,\n                      request$jscomp$1 = request$jscomp$0,\n                      boundary = request.blockedBoundary,\n                      error$jscomp$0 =\n                        12 === request$jscomp$0.status\n                          ? request$jscomp$0.fatalError\n                          : x,\n                      errorInfo$jscomp$0 = errorInfo,\n                      replayNodes = request.replay.nodes,\n                      resumeSlots = request.replay.slots;\n                    errorDigest = logRecoverableError(\n                      request$jscomp$1,\n                      error$jscomp$0,\n                      errorInfo$jscomp$0,\n                      request.debugTask\n                    );\n                    abortRemainingReplayNodes(\n                      request$jscomp$1,\n                      boundary,\n                      replayNodes,\n                      resumeSlots,\n                      error$jscomp$0,\n                      errorDigest,\n                      errorInfo$jscomp$0,\n                      !1\n                    );\n                    request$jscomp$0.pendingRootTasks--;\n                    0 === request$jscomp$0.pendingRootTasks &&\n                      completeShell(request$jscomp$0);\n                    request$jscomp$0.allPendingTasks--;\n                    0 === request$jscomp$0.allPendingTasks &&\n                      completeAll(request$jscomp$0);\n                  }\n                } finally {\n                  currentTaskInDEV = prevTaskInDEV;\n                }\n              }\n            } else if (\n              ((request$jscomp$0 = prevTaskInDEV = void 0),\n              (errorDigest = task),\n              (request$jscomp$1 = segment),\n              request$jscomp$1.status === PENDING)\n            ) {\n              request$jscomp$1.status = 6;\n              switchContext(errorDigest.context);\n              request$jscomp$0 = currentTaskInDEV;\n              currentTaskInDEV = errorDigest;\n              var childrenLength = request$jscomp$1.children.length,\n                chunkLength = request$jscomp$1.chunks.length;\n              try {\n                retryNode(request, errorDigest),\n                  pushSegmentFinale(\n                    request$jscomp$1.chunks,\n                    request.renderState,\n                    request$jscomp$1.lastPushedText,\n                    request$jscomp$1.textEmbedded\n                  ),\n                  errorDigest.abortSet.delete(errorDigest),\n                  (request$jscomp$1.status = COMPLETED),\n                  finishedTask(\n                    request,\n                    errorDigest.blockedBoundary,\n                    errorDigest.row,\n                    request$jscomp$1\n                  );\n              } catch (thrownValue) {\n                resetHooksState();\n                request$jscomp$1.children.length = childrenLength;\n                request$jscomp$1.chunks.length = chunkLength;\n                var x$jscomp$0 =\n                  thrownValue === SuspenseException\n                    ? getSuspendedThenable()\n                    : 12 === request.status\n                      ? request.fatalError\n                      : thrownValue;\n                if (\n                  12 === request.status &&\n                  null !== request.trackedPostpones\n                ) {\n                  var trackedPostpones = request.trackedPostpones,\n                    thrownInfo = getThrownInfo(errorDigest.componentStack);\n                  errorDigest.abortSet.delete(errorDigest);\n                  logRecoverableError(\n                    request,\n                    x$jscomp$0,\n                    thrownInfo,\n                    errorDigest.debugTask\n                  );\n                  trackPostpone(\n                    request,\n                    trackedPostpones,\n                    errorDigest,\n                    request$jscomp$1\n                  );\n                  finishedTask(\n                    request,\n                    errorDigest.blockedBoundary,\n                    errorDigest.row,\n                    request$jscomp$1\n                  );\n                } else if (\n                  \"object\" === typeof x$jscomp$0 &&\n                  null !== x$jscomp$0 &&\n                  \"function\" === typeof x$jscomp$0.then\n                ) {\n                  request$jscomp$1.status = PENDING;\n                  errorDigest.thenableState =\n                    thrownValue === SuspenseException\n                      ? getThenableStateAfterSuspending()\n                      : null;\n                  var ping$jscomp$0 = errorDigest.ping;\n                  x$jscomp$0.then(ping$jscomp$0, ping$jscomp$0);\n                } else {\n                  var errorInfo$jscomp$1 = getThrownInfo(\n                    errorDigest.componentStack\n                  );\n                  errorDigest.abortSet.delete(errorDigest);\n                  request$jscomp$1.status = ERRORED;\n                  var boundary$jscomp$0 = errorDigest.blockedBoundary,\n                    row = errorDigest.row,\n                    debugTask = errorDigest.debugTask;\n                  null !== row &&\n                    0 === --row.pendingTasks &&\n                    finishSuspenseListRow(request, row);\n                  request.allPendingTasks--;\n                  prevTaskInDEV = logRecoverableError(\n                    request,\n                    x$jscomp$0,\n                    errorInfo$jscomp$1,\n                    debugTask\n                  );\n                  if (null === boundary$jscomp$0)\n                    fatalError(\n                      request,\n                      x$jscomp$0,\n                      errorInfo$jscomp$1,\n                      debugTask\n                    );\n                  else if (\n                    (boundary$jscomp$0.pendingTasks--,\n                    boundary$jscomp$0.status !== CLIENT_RENDERED)\n                  ) {\n                    boundary$jscomp$0.status = CLIENT_RENDERED;\n                    encodeErrorForBoundary(\n                      boundary$jscomp$0,\n                      prevTaskInDEV,\n                      x$jscomp$0,\n                      errorInfo$jscomp$1,\n                      !1\n                    );\n                    untrackBoundary(request, boundary$jscomp$0);\n                    var boundaryRow = boundary$jscomp$0.row;\n                    null !== boundaryRow &&\n                      0 === --boundaryRow.pendingTasks &&\n                      finishSuspenseListRow(request, boundaryRow);\n                    boundary$jscomp$0.parentFlushed &&\n                      request.clientRenderedBoundaries.push(boundary$jscomp$0);\n                    0 === request.pendingRootTasks &&\n                      null === request.trackedPostpones &&\n                      null !== boundary$jscomp$0.contentPreamble &&\n                      preparePreamble(request);\n                  }\n                  0 === request.allPendingTasks && completeAll(request);\n                }\n              } finally {\n                currentTaskInDEV = request$jscomp$0;\n              }\n            }\n          }\n          pingedTasks.splice(0, i);\n          null !== request$jscomp$2.destination &&\n            flushCompletedQueues(\n              request$jscomp$2,\n              request$jscomp$2.destination\n            );\n        } catch (error) {\n          (pingedTasks = {}),\n            logRecoverableError(request$jscomp$2, error, pingedTasks, null),\n            fatalError(request$jscomp$2, error, pingedTasks, null);\n        } finally {\n          (currentResumableState = prevResumableState),\n            (ReactSharedInternals.H = prevDispatcher),\n            (ReactSharedInternals.A = prevAsyncDispatcher),\n            (ReactSharedInternals.getCurrentStack = prevGetCurrentStackImpl),\n            prevDispatcher === HooksDispatcher && switchContext(prevContext),\n            (currentRequest = prevRequest);\n        }\n      }\n    }\n    function preparePreambleFromSubtree(\n      request,\n      segment,\n      collectedPreambleSegments\n    ) {\n      segment.preambleChildren.length &&\n        collectedPreambleSegments.push(segment.preambleChildren);\n      for (var pendingPreambles = !1, i = 0; i < segment.children.length; i++)\n        pendingPreambles =\n          preparePreambleFromSegment(\n            request,\n            segment.children[i],\n            collectedPreambleSegments\n          ) || pendingPreambles;\n      return pendingPreambles;\n    }\n    function preparePreambleFromSegment(\n      request,\n      segment,\n      collectedPreambleSegments\n    ) {\n      var boundary = segment.boundary;\n      if (null === boundary)\n        return preparePreambleFromSubtree(\n          request,\n          segment,\n          collectedPreambleSegments\n        );\n      var preamble = boundary.contentPreamble,\n        fallbackPreamble = boundary.fallbackPreamble;\n      if (null === preamble || null === fallbackPreamble) return !1;\n      switch (boundary.status) {\n        case COMPLETED:\n          hoistPreambleState(request.renderState, preamble);\n          request.byteSize += boundary.byteSize;\n          segment = boundary.completedSegments[0];\n          if (!segment)\n            throw Error(\n              \"A previously unvisited boundary must have exactly one root segment. This is a bug in React.\"\n            );\n          return preparePreambleFromSubtree(\n            request,\n            segment,\n            collectedPreambleSegments\n          );\n        case POSTPONED:\n          if (null !== request.trackedPostpones) return !0;\n        case CLIENT_RENDERED:\n          if (segment.status === COMPLETED)\n            return (\n              hoistPreambleState(request.renderState, fallbackPreamble),\n              preparePreambleFromSubtree(\n                request,\n                segment,\n                collectedPreambleSegments\n              )\n            );\n        default:\n          return !0;\n      }\n    }\n    function preparePreamble(request) {\n      if (\n        request.completedRootSegment &&\n        null === request.completedPreambleSegments\n      ) {\n        var collectedPreambleSegments = [],\n          originalRequestByteSize = request.byteSize,\n          hasPendingPreambles = preparePreambleFromSegment(\n            request,\n            request.completedRootSegment,\n            collectedPreambleSegments\n          ),\n          preamble = request.renderState.preamble;\n        !1 === hasPendingPreambles ||\n        (preamble.headChunks && preamble.bodyChunks)\n          ? (request.completedPreambleSegments = collectedPreambleSegments)\n          : (request.byteSize = originalRequestByteSize);\n      }\n    }\n    function flushSubtree(request, destination, segment, hoistableState) {\n      segment.parentFlushed = !0;\n      switch (segment.status) {\n        case PENDING:\n          segment.id = request.nextSegmentId++;\n        case POSTPONED:\n          return (\n            (hoistableState = segment.id),\n            (segment.lastPushedText = !1),\n            (segment.textEmbedded = !1),\n            (request = request.renderState),\n            destination.push(placeholder1),\n            destination.push(request.placeholderPrefix),\n            (request = hoistableState.toString(16)),\n            destination.push(request),\n            destination.push(placeholder2)\n          );\n        case COMPLETED:\n          segment.status = FLUSHED;\n          var r = !0,\n            chunks = segment.chunks,\n            chunkIdx = 0;\n          segment = segment.children;\n          for (var childIdx = 0; childIdx < segment.length; childIdx++) {\n            for (r = segment[childIdx]; chunkIdx < r.index; chunkIdx++)\n              destination.push(chunks[chunkIdx]);\n            r = flushSegment(request, destination, r, hoistableState);\n          }\n          for (; chunkIdx < chunks.length - 1; chunkIdx++)\n            destination.push(chunks[chunkIdx]);\n          chunkIdx < chunks.length && (r = destination.push(chunks[chunkIdx]));\n          return r;\n        case ABORTED:\n          return !0;\n        default:\n          throw Error(\n            \"Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.\"\n          );\n      }\n    }\n    function flushSegment(request, destination, segment, hoistableState) {\n      var boundary = segment.boundary;\n      if (null === boundary)\n        return flushSubtree(request, destination, segment, hoistableState);\n      boundary.parentFlushed = !0;\n      if (boundary.status === CLIENT_RENDERED) {\n        var row = boundary.row;\n        null !== row &&\n          0 === --row.pendingTasks &&\n          finishSuspenseListRow(request, row);\n        if (!request.renderState.generateStaticMarkup) {\n          var errorDigest = boundary.errorDigest,\n            errorMessage = boundary.errorMessage;\n          row = boundary.errorStack;\n          boundary = boundary.errorComponentStack;\n          destination.push(startClientRenderedSuspenseBoundary);\n          destination.push(clientRenderedSuspenseBoundaryError1);\n          errorDigest &&\n            (destination.push(clientRenderedSuspenseBoundaryError1A),\n            (errorDigest = escapeTextForBrowser(errorDigest)),\n            destination.push(errorDigest),\n            destination.push(\n              clientRenderedSuspenseBoundaryErrorAttrInterstitial\n            ));\n          errorMessage &&\n            (destination.push(clientRenderedSuspenseBoundaryError1B),\n            (errorMessage = escapeTextForBrowser(errorMessage)),\n            destination.push(errorMessage),\n            destination.push(\n              clientRenderedSuspenseBoundaryErrorAttrInterstitial\n            ));\n          row &&\n            (destination.push(clientRenderedSuspenseBoundaryError1C),\n            (row = escapeTextForBrowser(row)),\n            destination.push(row),\n            destination.push(\n              clientRenderedSuspenseBoundaryErrorAttrInterstitial\n            ));\n          boundary &&\n            (destination.push(clientRenderedSuspenseBoundaryError1D),\n            (row = escapeTextForBrowser(boundary)),\n            destination.push(row),\n            destination.push(\n              clientRenderedSuspenseBoundaryErrorAttrInterstitial\n            ));\n          destination.push(clientRenderedSuspenseBoundaryError2);\n        }\n        flushSubtree(request, destination, segment, hoistableState);\n        request = request.renderState.generateStaticMarkup\n          ? !0\n          : destination.push(endSuspenseBoundary);\n        return request;\n      }\n      if (boundary.status !== COMPLETED)\n        return (\n          boundary.status === PENDING &&\n            (boundary.rootSegmentID = request.nextSegmentId++),\n          0 < boundary.completedSegments.length &&\n            request.partialBoundaries.push(boundary),\n          writeStartPendingSuspenseBoundary(\n            destination,\n            request.renderState,\n            boundary.rootSegmentID\n          ),\n          hoistableState &&\n            hoistHoistables(hoistableState, boundary.fallbackState),\n          flushSubtree(request, destination, segment, hoistableState),\n          destination.push(endSuspenseBoundary)\n        );\n      if (\n        !flushingPartialBoundaries &&\n        isEligibleForOutlining(request, boundary) &&\n        flushedByteSize + boundary.byteSize > request.progressiveChunkSize\n      )\n        return (\n          (boundary.rootSegmentID = request.nextSegmentId++),\n          request.completedBoundaries.push(boundary),\n          writeStartPendingSuspenseBoundary(\n            destination,\n            request.renderState,\n            boundary.rootSegmentID\n          ),\n          flushSubtree(request, destination, segment, hoistableState),\n          destination.push(endSuspenseBoundary)\n        );\n      flushedByteSize += boundary.byteSize;\n      hoistableState && hoistHoistables(hoistableState, boundary.contentState);\n      segment = boundary.row;\n      null !== segment &&\n        isEligibleForOutlining(request, boundary) &&\n        0 === --segment.pendingTasks &&\n        finishSuspenseListRow(request, segment);\n      request.renderState.generateStaticMarkup ||\n        destination.push(startCompletedSuspenseBoundary);\n      segment = boundary.completedSegments;\n      if (1 !== segment.length)\n        throw Error(\n          \"A previously unvisited boundary must have exactly one root segment. This is a bug in React.\"\n        );\n      flushSegment(request, destination, segment[0], hoistableState);\n      request = request.renderState.generateStaticMarkup\n        ? !0\n        : destination.push(endSuspenseBoundary);\n      return request;\n    }\n    function flushSegmentContainer(\n      request,\n      destination,\n      segment,\n      hoistableState\n    ) {\n      writeStartSegment(\n        destination,\n        request.renderState,\n        segment.parentFormatContext,\n        segment.id\n      );\n      flushSegment(request, destination, segment, hoistableState);\n      return writeEndSegment(destination, segment.parentFormatContext);\n    }\n    function flushCompletedBoundary(request, destination, boundary) {\n      flushedByteSize = boundary.byteSize;\n      for (\n        var completedSegments = boundary.completedSegments, i = 0;\n        i < completedSegments.length;\n        i++\n      )\n        flushPartiallyCompletedSegment(\n          request,\n          destination,\n          boundary,\n          completedSegments[i]\n        );\n      completedSegments.length = 0;\n      completedSegments = boundary.row;\n      null !== completedSegments &&\n        isEligibleForOutlining(request, boundary) &&\n        0 === --completedSegments.pendingTasks &&\n        finishSuspenseListRow(request, completedSegments);\n      writeHoistablesForBoundary(\n        destination,\n        boundary.contentState,\n        request.renderState\n      );\n      completedSegments = request.resumableState;\n      request = request.renderState;\n      i = boundary.rootSegmentID;\n      boundary = boundary.contentState;\n      var requiresStyleInsertion = request.stylesToHoist;\n      request.stylesToHoist = !1;\n      destination.push(request.startInlineScript);\n      destination.push(endOfStartTag);\n      requiresStyleInsertion\n        ? ((completedSegments.instructions & SentClientRenderFunction) ===\n            NothingSent &&\n            ((completedSegments.instructions |= SentClientRenderFunction),\n            destination.push(clientRenderScriptFunctionOnly)),\n          (completedSegments.instructions & SentCompleteBoundaryFunction) ===\n            NothingSent &&\n            ((completedSegments.instructions |= SentCompleteBoundaryFunction),\n            destination.push(completeBoundaryScriptFunctionOnly)),\n          (completedSegments.instructions & SentStyleInsertionFunction) ===\n          NothingSent\n            ? ((completedSegments.instructions |= SentStyleInsertionFunction),\n              destination.push(completeBoundaryWithStylesScript1FullPartial))\n            : destination.push(completeBoundaryWithStylesScript1Partial))\n        : ((completedSegments.instructions & SentCompleteBoundaryFunction) ===\n            NothingSent &&\n            ((completedSegments.instructions |= SentCompleteBoundaryFunction),\n            destination.push(completeBoundaryScriptFunctionOnly)),\n          destination.push(completeBoundaryScript1Partial));\n      completedSegments = i.toString(16);\n      destination.push(request.boundaryPrefix);\n      destination.push(completedSegments);\n      destination.push(completeBoundaryScript2);\n      destination.push(request.segmentPrefix);\n      destination.push(completedSegments);\n      requiresStyleInsertion\n        ? (destination.push(completeBoundaryScript3a),\n          writeStyleResourceDependenciesInJS(destination, boundary))\n        : destination.push(completeBoundaryScript3b);\n      boundary = destination.push(completeBoundaryScriptEnd);\n      return writeBootstrap(destination, request) && boundary;\n    }\n    function flushPartiallyCompletedSegment(\n      request,\n      destination,\n      boundary,\n      segment\n    ) {\n      if (segment.status === FLUSHED) return !0;\n      var hoistableState = boundary.contentState,\n        segmentID = segment.id;\n      if (-1 === segmentID) {\n        if (-1 === (segment.id = boundary.rootSegmentID))\n          throw Error(\n            \"A root segment ID must have been assigned by now. This is a bug in React.\"\n          );\n        return flushSegmentContainer(\n          request,\n          destination,\n          segment,\n          hoistableState\n        );\n      }\n      if (segmentID === boundary.rootSegmentID)\n        return flushSegmentContainer(\n          request,\n          destination,\n          segment,\n          hoistableState\n        );\n      flushSegmentContainer(request, destination, segment, hoistableState);\n      boundary = request.resumableState;\n      request = request.renderState;\n      destination.push(request.startInlineScript);\n      destination.push(endOfStartTag);\n      (boundary.instructions & SentCompleteSegmentFunction) === NothingSent\n        ? ((boundary.instructions |= SentCompleteSegmentFunction),\n          destination.push(completeSegmentScript1Full))\n        : destination.push(completeSegmentScript1Partial);\n      destination.push(request.segmentPrefix);\n      segmentID = segmentID.toString(16);\n      destination.push(segmentID);\n      destination.push(completeSegmentScript2);\n      destination.push(request.placeholderPrefix);\n      destination.push(segmentID);\n      destination = destination.push(completeSegmentScriptEnd);\n      return destination;\n    }\n    function flushCompletedQueues(request, destination) {\n      try {\n        if (!(0 < request.pendingRootTasks)) {\n          var i,\n            completedRootSegment = request.completedRootSegment;\n          if (null !== completedRootSegment) {\n            if (completedRootSegment.status === POSTPONED) return;\n            var completedPreambleSegments = request.completedPreambleSegments;\n            if (null === completedPreambleSegments) return;\n            flushedByteSize = request.byteSize;\n            var resumableState = request.resumableState,\n              renderState = request.renderState,\n              preamble = renderState.preamble,\n              htmlChunks = preamble.htmlChunks,\n              headChunks = preamble.headChunks,\n              i$jscomp$0;\n            if (htmlChunks) {\n              for (i$jscomp$0 = 0; i$jscomp$0 < htmlChunks.length; i$jscomp$0++)\n                destination.push(htmlChunks[i$jscomp$0]);\n              if (headChunks)\n                for (\n                  i$jscomp$0 = 0;\n                  i$jscomp$0 < headChunks.length;\n                  i$jscomp$0++\n                )\n                  destination.push(headChunks[i$jscomp$0]);\n              else {\n                var chunk = startChunkForTag(\"head\");\n                destination.push(chunk);\n                destination.push(endOfStartTag);\n              }\n            } else if (headChunks)\n              for (i$jscomp$0 = 0; i$jscomp$0 < headChunks.length; i$jscomp$0++)\n                destination.push(headChunks[i$jscomp$0]);\n            var charsetChunks = renderState.charsetChunks;\n            for (\n              i$jscomp$0 = 0;\n              i$jscomp$0 < charsetChunks.length;\n              i$jscomp$0++\n            )\n              destination.push(charsetChunks[i$jscomp$0]);\n            charsetChunks.length = 0;\n            renderState.preconnects.forEach(flushResource, destination);\n            renderState.preconnects.clear();\n            var viewportChunks = renderState.viewportChunks;\n            for (\n              i$jscomp$0 = 0;\n              i$jscomp$0 < viewportChunks.length;\n              i$jscomp$0++\n            )\n              destination.push(viewportChunks[i$jscomp$0]);\n            viewportChunks.length = 0;\n            renderState.fontPreloads.forEach(flushResource, destination);\n            renderState.fontPreloads.clear();\n            renderState.highImagePreloads.forEach(flushResource, destination);\n            renderState.highImagePreloads.clear();\n            currentlyFlushingRenderState = renderState;\n            renderState.styles.forEach(flushStylesInPreamble, destination);\n            currentlyFlushingRenderState = null;\n            var importMapChunks = renderState.importMapChunks;\n            for (\n              i$jscomp$0 = 0;\n              i$jscomp$0 < importMapChunks.length;\n              i$jscomp$0++\n            )\n              destination.push(importMapChunks[i$jscomp$0]);\n            importMapChunks.length = 0;\n            renderState.bootstrapScripts.forEach(flushResource, destination);\n            renderState.scripts.forEach(flushResource, destination);\n            renderState.scripts.clear();\n            renderState.bulkPreloads.forEach(flushResource, destination);\n            renderState.bulkPreloads.clear();\n            resumableState.instructions |= SentCompletedShellId;\n            var hoistableChunks = renderState.hoistableChunks;\n            for (\n              i$jscomp$0 = 0;\n              i$jscomp$0 < hoistableChunks.length;\n              i$jscomp$0++\n            )\n              destination.push(hoistableChunks[i$jscomp$0]);\n            for (\n              resumableState = hoistableChunks.length = 0;\n              resumableState < completedPreambleSegments.length;\n              resumableState++\n            ) {\n              var segments = completedPreambleSegments[resumableState];\n              for (\n                renderState = 0;\n                renderState < segments.length;\n                renderState++\n              )\n                flushSegment(request, destination, segments[renderState], null);\n            }\n            var preamble$jscomp$0 = request.renderState.preamble,\n              headChunks$jscomp$0 = preamble$jscomp$0.headChunks;\n            if (preamble$jscomp$0.htmlChunks || headChunks$jscomp$0) {\n              var chunk$jscomp$0 = endChunkForTag(\"head\");\n              destination.push(chunk$jscomp$0);\n            }\n            var bodyChunks = preamble$jscomp$0.bodyChunks;\n            if (bodyChunks)\n              for (\n                completedPreambleSegments = 0;\n                completedPreambleSegments < bodyChunks.length;\n                completedPreambleSegments++\n              )\n                destination.push(bodyChunks[completedPreambleSegments]);\n            flushSegment(request, destination, completedRootSegment, null);\n            request.completedRootSegment = null;\n            var renderState$jscomp$0 = request.renderState;\n            if (\n              0 !== request.allPendingTasks ||\n              0 !== request.clientRenderedBoundaries.length ||\n              0 !== request.completedBoundaries.length ||\n              (null !== request.trackedPostpones &&\n                (0 !== request.trackedPostpones.rootNodes.length ||\n                  null !== request.trackedPostpones.rootSlots))\n            ) {\n              var resumableState$jscomp$0 = request.resumableState;\n              if (\n                (resumableState$jscomp$0.instructions & SentMarkShellTime) ===\n                NothingSent\n              ) {\n                resumableState$jscomp$0.instructions |= SentMarkShellTime;\n                destination.push(renderState$jscomp$0.startInlineScript);\n                if (\n                  (resumableState$jscomp$0.instructions &\n                    SentCompletedShellId) ===\n                  NothingSent\n                ) {\n                  resumableState$jscomp$0.instructions |= SentCompletedShellId;\n                  var shellId = \"_\" + resumableState$jscomp$0.idPrefix + \"R_\";\n                  destination.push(completedShellIdAttributeStart);\n                  var chunk$jscomp$1 = escapeTextForBrowser(shellId);\n                  destination.push(chunk$jscomp$1);\n                  destination.push(attributeEnd);\n                }\n                destination.push(endOfStartTag);\n                destination.push(shellTimeRuntimeScript);\n                destination.push(endInlineScript);\n              }\n            }\n            writeBootstrap(destination, renderState$jscomp$0);\n          }\n          var renderState$jscomp$1 = request.renderState;\n          completedRootSegment = 0;\n          var viewportChunks$jscomp$0 = renderState$jscomp$1.viewportChunks;\n          for (\n            completedRootSegment = 0;\n            completedRootSegment < viewportChunks$jscomp$0.length;\n            completedRootSegment++\n          )\n            destination.push(viewportChunks$jscomp$0[completedRootSegment]);\n          viewportChunks$jscomp$0.length = 0;\n          renderState$jscomp$1.preconnects.forEach(flushResource, destination);\n          renderState$jscomp$1.preconnects.clear();\n          renderState$jscomp$1.fontPreloads.forEach(flushResource, destination);\n          renderState$jscomp$1.fontPreloads.clear();\n          renderState$jscomp$1.highImagePreloads.forEach(\n            flushResource,\n            destination\n          );\n          renderState$jscomp$1.highImagePreloads.clear();\n          renderState$jscomp$1.styles.forEach(preloadLateStyles, destination);\n          renderState$jscomp$1.scripts.forEach(flushResource, destination);\n          renderState$jscomp$1.scripts.clear();\n          renderState$jscomp$1.bulkPreloads.forEach(flushResource, destination);\n          renderState$jscomp$1.bulkPreloads.clear();\n          var hoistableChunks$jscomp$0 = renderState$jscomp$1.hoistableChunks;\n          for (\n            completedRootSegment = 0;\n            completedRootSegment < hoistableChunks$jscomp$0.length;\n            completedRootSegment++\n          )\n            destination.push(hoistableChunks$jscomp$0[completedRootSegment]);\n          hoistableChunks$jscomp$0.length = 0;\n          var clientRenderedBoundaries = request.clientRenderedBoundaries;\n          for (i = 0; i < clientRenderedBoundaries.length; i++) {\n            var boundary = clientRenderedBoundaries[i];\n            renderState$jscomp$1 = destination;\n            var resumableState$jscomp$1 = request.resumableState,\n              renderState$jscomp$2 = request.renderState,\n              id = boundary.rootSegmentID,\n              errorDigest = boundary.errorDigest,\n              errorMessage = boundary.errorMessage,\n              errorStack = boundary.errorStack,\n              errorComponentStack = boundary.errorComponentStack;\n            renderState$jscomp$1.push(renderState$jscomp$2.startInlineScript);\n            renderState$jscomp$1.push(endOfStartTag);\n            (resumableState$jscomp$1.instructions &\n              SentClientRenderFunction) ===\n            NothingSent\n              ? ((resumableState$jscomp$1.instructions |=\n                  SentClientRenderFunction),\n                renderState$jscomp$1.push(clientRenderScript1Full))\n              : renderState$jscomp$1.push(clientRenderScript1Partial);\n            renderState$jscomp$1.push(renderState$jscomp$2.boundaryPrefix);\n            var chunk$jscomp$2 = id.toString(16);\n            renderState$jscomp$1.push(chunk$jscomp$2);\n            renderState$jscomp$1.push(clientRenderScript1A);\n            if (\n              errorDigest ||\n              errorMessage ||\n              errorStack ||\n              errorComponentStack\n            ) {\n              renderState$jscomp$1.push(clientRenderErrorScriptArgInterstitial);\n              var chunk$jscomp$3 = escapeJSStringsForInstructionScripts(\n                errorDigest || \"\"\n              );\n              renderState$jscomp$1.push(chunk$jscomp$3);\n            }\n            if (errorMessage || errorStack || errorComponentStack) {\n              renderState$jscomp$1.push(clientRenderErrorScriptArgInterstitial);\n              var chunk$jscomp$4 = escapeJSStringsForInstructionScripts(\n                errorMessage || \"\"\n              );\n              renderState$jscomp$1.push(chunk$jscomp$4);\n            }\n            if (errorStack || errorComponentStack) {\n              renderState$jscomp$1.push(clientRenderErrorScriptArgInterstitial);\n              var chunk$jscomp$5 = escapeJSStringsForInstructionScripts(\n                errorStack || \"\"\n              );\n              renderState$jscomp$1.push(chunk$jscomp$5);\n            }\n            if (errorComponentStack) {\n              renderState$jscomp$1.push(clientRenderErrorScriptArgInterstitial);\n              var chunk$jscomp$6 =\n                escapeJSStringsForInstructionScripts(errorComponentStack);\n              renderState$jscomp$1.push(chunk$jscomp$6);\n            }\n            var JSCompiler_inline_result = renderState$jscomp$1.push(\n              clientRenderScriptEnd\n            );\n            if (!JSCompiler_inline_result) {\n              request.destination = null;\n              i++;\n              clientRenderedBoundaries.splice(0, i);\n              return;\n            }\n          }\n          clientRenderedBoundaries.splice(0, i);\n          var completedBoundaries = request.completedBoundaries;\n          for (i = 0; i < completedBoundaries.length; i++)\n            if (\n              !flushCompletedBoundary(\n                request,\n                destination,\n                completedBoundaries[i]\n              )\n            ) {\n              request.destination = null;\n              i++;\n              completedBoundaries.splice(0, i);\n              return;\n            }\n          completedBoundaries.splice(0, i);\n          flushingPartialBoundaries = !0;\n          var partialBoundaries = request.partialBoundaries;\n          for (i = 0; i < partialBoundaries.length; i++) {\n            a: {\n              clientRenderedBoundaries = request;\n              boundary = destination;\n              var boundary$jscomp$0 = partialBoundaries[i];\n              flushedByteSize = boundary$jscomp$0.byteSize;\n              var completedSegments = boundary$jscomp$0.completedSegments;\n              for (\n                JSCompiler_inline_result = 0;\n                JSCompiler_inline_result < completedSegments.length;\n                JSCompiler_inline_result++\n              )\n                if (\n                  !flushPartiallyCompletedSegment(\n                    clientRenderedBoundaries,\n                    boundary,\n                    boundary$jscomp$0,\n                    completedSegments[JSCompiler_inline_result]\n                  )\n                ) {\n                  JSCompiler_inline_result++;\n                  completedSegments.splice(0, JSCompiler_inline_result);\n                  var JSCompiler_inline_result$jscomp$0 = !1;\n                  break a;\n                }\n              completedSegments.splice(0, JSCompiler_inline_result);\n              var row = boundary$jscomp$0.row;\n              null !== row &&\n                row.together &&\n                1 === boundary$jscomp$0.pendingTasks &&\n                (1 === row.pendingTasks\n                  ? unblockSuspenseListRow(\n                      clientRenderedBoundaries,\n                      row,\n                      row.hoistables\n                    )\n                  : row.pendingTasks--);\n              JSCompiler_inline_result$jscomp$0 = writeHoistablesForBoundary(\n                boundary,\n                boundary$jscomp$0.contentState,\n                clientRenderedBoundaries.renderState\n              );\n            }\n            if (!JSCompiler_inline_result$jscomp$0) {\n              request.destination = null;\n              i++;\n              partialBoundaries.splice(0, i);\n              return;\n            }\n          }\n          partialBoundaries.splice(0, i);\n          flushingPartialBoundaries = !1;\n          var largeBoundaries = request.completedBoundaries;\n          for (i = 0; i < largeBoundaries.length; i++)\n            if (\n              !flushCompletedBoundary(request, destination, largeBoundaries[i])\n            ) {\n              request.destination = null;\n              i++;\n              largeBoundaries.splice(0, i);\n              return;\n            }\n          largeBoundaries.splice(0, i);\n        }\n      } finally {\n        (flushingPartialBoundaries = !1),\n          0 === request.allPendingTasks &&\n            0 === request.clientRenderedBoundaries.length &&\n            0 === request.completedBoundaries.length &&\n            ((request.flushScheduled = !1),\n            (i = request.resumableState),\n            i.hasBody &&\n              ((partialBoundaries = endChunkForTag(\"body\")),\n              destination.push(partialBoundaries)),\n            i.hasHtml && ((i = endChunkForTag(\"html\")), destination.push(i)),\n            0 !== request.abortableTasks.size &&\n              console.error(\n                \"There was still abortable task at the root when we closed. This is a bug in React.\"\n              ),\n            (request.status = CLOSED),\n            destination.push(null),\n            (request.destination = null));\n      }\n    }\n    function startWork(request) {\n      request.flushScheduled = null !== request.destination;\n      performWork(request);\n      10 === request.status && (request.status = 11);\n      null === request.trackedPostpones &&\n        safelyEmitEarlyPreloads(request, 0 === request.pendingRootTasks);\n    }\n    function enqueueFlush(request) {\n      if (\n        !1 === request.flushScheduled &&\n        0 === request.pingedTasks.length &&\n        null !== request.destination\n      ) {\n        request.flushScheduled = !0;\n        var destination = request.destination;\n        destination\n          ? flushCompletedQueues(request, destination)\n          : (request.flushScheduled = !1);\n      }\n    }\n    function startFlowing(request, destination) {\n      if (13 === request.status)\n        (request.status = CLOSED), destination.destroy(request.fatalError);\n      else if (request.status !== CLOSED && null === request.destination) {\n        request.destination = destination;\n        try {\n          flushCompletedQueues(request, destination);\n        } catch (error) {\n          (destination = {}),\n            logRecoverableError(request, error, destination, null),\n            fatalError(request, error, destination, null);\n        }\n      }\n    }\n    function abort(request, reason) {\n      if (11 === request.status || 10 === request.status) request.status = 12;\n      try {\n        var abortableTasks = request.abortableTasks;\n        if (0 < abortableTasks.size) {\n          var error =\n            void 0 === reason\n              ? Error(\"The render was aborted by the server without a reason.\")\n              : \"object\" === typeof reason &&\n                  null !== reason &&\n                  \"function\" === typeof reason.then\n                ? Error(\"The render was aborted by the server with a promise.\")\n                : reason;\n          request.fatalError = error;\n          abortableTasks.forEach(function (task) {\n            var prevTaskInDEV = currentTaskInDEV,\n              prevGetCurrentStackImpl = ReactSharedInternals.getCurrentStack;\n            currentTaskInDEV = task;\n            ReactSharedInternals.getCurrentStack = getCurrentStackInDEV;\n            try {\n              abortTask(task, request, error);\n            } finally {\n              (currentTaskInDEV = prevTaskInDEV),\n                (ReactSharedInternals.getCurrentStack =\n                  prevGetCurrentStackImpl);\n            }\n          });\n          abortableTasks.clear();\n        }\n        null !== request.destination &&\n          flushCompletedQueues(request, request.destination);\n      } catch (error$4) {\n        (reason = {}),\n          logRecoverableError(request, error$4, reason, null),\n          fatalError(request, error$4, reason, null);\n      }\n    }\n    function addToReplayParent(node, parentKeyPath, trackedPostpones) {\n      if (null === parentKeyPath) trackedPostpones.rootNodes.push(node);\n      else {\n        var workingMap = trackedPostpones.workingMap,\n          parentNode = workingMap.get(parentKeyPath);\n        void 0 === parentNode &&\n          ((parentNode = [parentKeyPath[1], parentKeyPath[2], [], null]),\n          workingMap.set(parentKeyPath, parentNode),\n          addToReplayParent(parentNode, parentKeyPath[0], trackedPostpones));\n        parentNode[2].push(node);\n      }\n    }\n    function onError() {}\n    function renderToStringImpl(\n      children,\n      options,\n      generateStaticMarkup,\n      abortReason\n    ) {\n      var didFatal = !1,\n        fatalError = null,\n        result = \"\",\n        readyToStream = !1;\n      options = createResumableState(\n        options ? options.identifierPrefix : void 0\n      );\n      children = createRequest(\n        children,\n        options,\n        createRenderState(options, generateStaticMarkup),\n        createFormatContext(ROOT_HTML_MODE, null, 0, null),\n        Infinity,\n        onError,\n        void 0,\n        function () {\n          readyToStream = !0;\n        },\n        void 0,\n        void 0,\n        void 0\n      );\n      startWork(children);\n      abort(children, abortReason);\n      startFlowing(children, {\n        push: function (chunk) {\n          null !== chunk && (result += chunk);\n          return !0;\n        },\n        destroy: function (error) {\n          didFatal = !0;\n          fatalError = error;\n        }\n      });\n      if (didFatal && fatalError !== abortReason) throw fatalError;\n      if (!readyToStream)\n        throw Error(\n          \"A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.\"\n        );\n      return result;\n    }\n    var React = __webpack_require__(/*! react */ \"./node_modules/react/index.js\"),\n      ReactDOM = __webpack_require__(/*! react-dom */ \"./node_modules/react-dom/index.js\"),\n      REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n      REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n      REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\n      REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\n      REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\"),\n      REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\n      REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\n      REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\n      REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\n      REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"),\n      REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\n      REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\n      REACT_SCOPE_TYPE = Symbol.for(\"react.scope\"),\n      REACT_ACTIVITY_TYPE = Symbol.for(\"react.activity\"),\n      REACT_LEGACY_HIDDEN_TYPE = Symbol.for(\"react.legacy_hidden\"),\n      REACT_MEMO_CACHE_SENTINEL = Symbol.for(\"react.memo_cache_sentinel\"),\n      REACT_VIEW_TRANSITION_TYPE = Symbol.for(\"react.view_transition\"),\n      MAYBE_ITERATOR_SYMBOL = Symbol.iterator,\n      isArrayImpl = Array.isArray,\n      jsxPropsParents = new WeakMap(),\n      jsxChildrenParents = new WeakMap(),\n      CLIENT_REFERENCE_TAG = Symbol.for(\"react.client.reference\"),\n      assign = Object.assign,\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      VALID_ATTRIBUTE_NAME_REGEX = RegExp(\n        \"^[:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD][:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]*$\"\n      ),\n      illegalAttributeNameCache = {},\n      validatedAttributeNameCache = {},\n      unitlessNumbers = new Set(\n        \"animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp\".split(\n          \" \"\n        )\n      ),\n      aliases = new Map([\n        [\"acceptCharset\", \"accept-charset\"],\n        [\"htmlFor\", \"for\"],\n        [\"httpEquiv\", \"http-equiv\"],\n        [\"crossOrigin\", \"crossorigin\"],\n        [\"accentHeight\", \"accent-height\"],\n        [\"alignmentBaseline\", \"alignment-baseline\"],\n        [\"arabicForm\", \"arabic-form\"],\n        [\"baselineShift\", \"baseline-shift\"],\n        [\"capHeight\", \"cap-height\"],\n        [\"clipPath\", \"clip-path\"],\n        [\"clipRule\", \"clip-rule\"],\n        [\"colorInterpolation\", \"color-interpolation\"],\n        [\"colorInterpolationFilters\", \"color-interpolation-filters\"],\n        [\"colorProfile\", \"color-profile\"],\n        [\"colorRendering\", \"color-rendering\"],\n        [\"dominantBaseline\", \"dominant-baseline\"],\n        [\"enableBackground\", \"enable-background\"],\n        [\"fillOpacity\", \"fill-opacity\"],\n        [\"fillRule\", \"fill-rule\"],\n        [\"floodColor\", \"flood-color\"],\n        [\"floodOpacity\", \"flood-opacity\"],\n        [\"fontFamily\", \"font-family\"],\n        [\"fontSize\", \"font-size\"],\n        [\"fontSizeAdjust\", \"font-size-adjust\"],\n        [\"fontStretch\", \"font-stretch\"],\n        [\"fontStyle\", \"font-style\"],\n        [\"fontVariant\", \"font-variant\"],\n        [\"fontWeight\", \"font-weight\"],\n        [\"glyphName\", \"glyph-name\"],\n        [\"glyphOrientationHorizontal\", \"glyph-orientation-horizontal\"],\n        [\"glyphOrientationVertical\", \"glyph-orientation-vertical\"],\n        [\"horizAdvX\", \"horiz-adv-x\"],\n        [\"horizOriginX\", \"horiz-origin-x\"],\n        [\"imageRendering\", \"image-rendering\"],\n        [\"letterSpacing\", \"letter-spacing\"],\n        [\"lightingColor\", \"lighting-color\"],\n        [\"markerEnd\", \"marker-end\"],\n        [\"markerMid\", \"marker-mid\"],\n        [\"markerStart\", \"marker-start\"],\n        [\"overlinePosition\", \"overline-position\"],\n        [\"overlineThickness\", \"overline-thickness\"],\n        [\"paintOrder\", \"paint-order\"],\n        [\"panose-1\", \"panose-1\"],\n        [\"pointerEvents\", \"pointer-events\"],\n        [\"renderingIntent\", \"rendering-intent\"],\n        [\"shapeRendering\", \"shape-rendering\"],\n        [\"stopColor\", \"stop-color\"],\n        [\"stopOpacity\", \"stop-opacity\"],\n        [\"strikethroughPosition\", \"strikethrough-position\"],\n        [\"strikethroughThickness\", \"strikethrough-thickness\"],\n        [\"strokeDasharray\", \"stroke-dasharray\"],\n        [\"strokeDashoffset\", \"stroke-dashoffset\"],\n        [\"strokeLinecap\", \"stroke-linecap\"],\n        [\"strokeLinejoin\", \"stroke-linejoin\"],\n        [\"strokeMiterlimit\", \"stroke-miterlimit\"],\n        [\"strokeOpacity\", \"stroke-opacity\"],\n        [\"strokeWidth\", \"stroke-width\"],\n        [\"textAnchor\", \"text-anchor\"],\n        [\"textDecoration\", \"text-decoration\"],\n        [\"textRendering\", \"text-rendering\"],\n        [\"transformOrigin\", \"transform-origin\"],\n        [\"underlinePosition\", \"underline-position\"],\n        [\"underlineThickness\", \"underline-thickness\"],\n        [\"unicodeBidi\", \"unicode-bidi\"],\n        [\"unicodeRange\", \"unicode-range\"],\n        [\"unitsPerEm\", \"units-per-em\"],\n        [\"vAlphabetic\", \"v-alphabetic\"],\n        [\"vHanging\", \"v-hanging\"],\n        [\"vIdeographic\", \"v-ideographic\"],\n        [\"vMathematical\", \"v-mathematical\"],\n        [\"vectorEffect\", \"vector-effect\"],\n        [\"vertAdvY\", \"vert-adv-y\"],\n        [\"vertOriginX\", \"vert-origin-x\"],\n        [\"vertOriginY\", \"vert-origin-y\"],\n        [\"wordSpacing\", \"word-spacing\"],\n        [\"writingMode\", \"writing-mode\"],\n        [\"xmlnsXlink\", \"xmlns:xlink\"],\n        [\"xHeight\", \"x-height\"]\n      ]),\n      hasReadOnlyValue = {\n        button: !0,\n        checkbox: !0,\n        image: !0,\n        hidden: !0,\n        radio: !0,\n        reset: !0,\n        submit: !0\n      },\n      ariaProperties = {\n        \"aria-current\": 0,\n        \"aria-description\": 0,\n        \"aria-details\": 0,\n        \"aria-disabled\": 0,\n        \"aria-hidden\": 0,\n        \"aria-invalid\": 0,\n        \"aria-keyshortcuts\": 0,\n        \"aria-label\": 0,\n        \"aria-roledescription\": 0,\n        \"aria-autocomplete\": 0,\n        \"aria-checked\": 0,\n        \"aria-expanded\": 0,\n        \"aria-haspopup\": 0,\n        \"aria-level\": 0,\n        \"aria-modal\": 0,\n        \"aria-multiline\": 0,\n        \"aria-multiselectable\": 0,\n        \"aria-orientation\": 0,\n        \"aria-placeholder\": 0,\n        \"aria-pressed\": 0,\n        \"aria-readonly\": 0,\n        \"aria-required\": 0,\n        \"aria-selected\": 0,\n        \"aria-sort\": 0,\n        \"aria-valuemax\": 0,\n        \"aria-valuemin\": 0,\n        \"aria-valuenow\": 0,\n        \"aria-valuetext\": 0,\n        \"aria-atomic\": 0,\n        \"aria-busy\": 0,\n        \"aria-live\": 0,\n        \"aria-relevant\": 0,\n        \"aria-dropeffect\": 0,\n        \"aria-grabbed\": 0,\n        \"aria-activedescendant\": 0,\n        \"aria-colcount\": 0,\n        \"aria-colindex\": 0,\n        \"aria-colspan\": 0,\n        \"aria-controls\": 0,\n        \"aria-describedby\": 0,\n        \"aria-errormessage\": 0,\n        \"aria-flowto\": 0,\n        \"aria-labelledby\": 0,\n        \"aria-owns\": 0,\n        \"aria-posinset\": 0,\n        \"aria-rowcount\": 0,\n        \"aria-rowindex\": 0,\n        \"aria-rowspan\": 0,\n        \"aria-setsize\": 0,\n        \"aria-braillelabel\": 0,\n        \"aria-brailleroledescription\": 0,\n        \"aria-colindextext\": 0,\n        \"aria-rowindextext\": 0\n      },\n      warnedProperties$1 = {},\n      rARIA$1 = RegExp(\n        \"^(aria)-[:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]*$\"\n      ),\n      rARIACamel$1 = RegExp(\n        \"^(aria)[A-Z][:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]*$\"\n      ),\n      didWarnValueNull = !1,\n      possibleStandardNames = {\n        accept: \"accept\",\n        acceptcharset: \"acceptCharset\",\n        \"accept-charset\": \"acceptCharset\",\n        accesskey: \"accessKey\",\n        action: \"action\",\n        allowfullscreen: \"allowFullScreen\",\n        alt: \"alt\",\n        as: \"as\",\n        async: \"async\",\n        autocapitalize: \"autoCapitalize\",\n        autocomplete: \"autoComplete\",\n        autocorrect: \"autoCorrect\",\n        autofocus: \"autoFocus\",\n        autoplay: \"autoPlay\",\n        autosave: \"autoSave\",\n        capture: \"capture\",\n        cellpadding: \"cellPadding\",\n        cellspacing: \"cellSpacing\",\n        challenge: \"challenge\",\n        charset: \"charSet\",\n        checked: \"checked\",\n        children: \"children\",\n        cite: \"cite\",\n        class: \"className\",\n        classid: \"classID\",\n        classname: \"className\",\n        cols: \"cols\",\n        colspan: \"colSpan\",\n        content: \"content\",\n        contenteditable: \"contentEditable\",\n        contextmenu: \"contextMenu\",\n        controls: \"controls\",\n        controlslist: \"controlsList\",\n        coords: \"coords\",\n        crossorigin: \"crossOrigin\",\n        dangerouslysetinnerhtml: \"dangerouslySetInnerHTML\",\n        data: \"data\",\n        datetime: \"dateTime\",\n        default: \"default\",\n        defaultchecked: \"defaultChecked\",\n        defaultvalue: \"defaultValue\",\n        defer: \"defer\",\n        dir: \"dir\",\n        disabled: \"disabled\",\n        disablepictureinpicture: \"disablePictureInPicture\",\n        disableremoteplayback: \"disableRemotePlayback\",\n        download: \"download\",\n        draggable: \"draggable\",\n        enctype: \"encType\",\n        enterkeyhint: \"enterKeyHint\",\n        fetchpriority: \"fetchPriority\",\n        for: \"htmlFor\",\n        form: \"form\",\n        formmethod: \"formMethod\",\n        formaction: \"formAction\",\n        formenctype: \"formEncType\",\n        formnovalidate: \"formNoValidate\",\n        formtarget: \"formTarget\",\n        frameborder: \"frameBorder\",\n        headers: \"headers\",\n        height: \"height\",\n        hidden: \"hidden\",\n        high: \"high\",\n        href: \"href\",\n        hreflang: \"hrefLang\",\n        htmlfor: \"htmlFor\",\n        httpequiv: \"httpEquiv\",\n        \"http-equiv\": \"httpEquiv\",\n        icon: \"icon\",\n        id: \"id\",\n        imagesizes: \"imageSizes\",\n        imagesrcset: \"imageSrcSet\",\n        inert: \"inert\",\n        innerhtml: \"innerHTML\",\n        inputmode: \"inputMode\",\n        integrity: \"integrity\",\n        is: \"is\",\n        itemid: \"itemID\",\n        itemprop: \"itemProp\",\n        itemref: \"itemRef\",\n        itemscope: \"itemScope\",\n        itemtype: \"itemType\",\n        keyparams: \"keyParams\",\n        keytype: \"keyType\",\n        kind: \"kind\",\n        label: \"label\",\n        lang: \"lang\",\n        list: \"list\",\n        loop: \"loop\",\n        low: \"low\",\n        manifest: \"manifest\",\n        marginwidth: \"marginWidth\",\n        marginheight: \"marginHeight\",\n        max: \"max\",\n        maxlength: \"maxLength\",\n        media: \"media\",\n        mediagroup: \"mediaGroup\",\n        method: \"method\",\n        min: \"min\",\n        minlength: \"minLength\",\n        multiple: \"multiple\",\n        muted: \"muted\",\n        name: \"name\",\n        nomodule: \"noModule\",\n        nonce: \"nonce\",\n        novalidate: \"noValidate\",\n        open: \"open\",\n        optimum: \"optimum\",\n        pattern: \"pattern\",\n        placeholder: \"placeholder\",\n        playsinline: \"playsInline\",\n        poster: \"poster\",\n        preload: \"preload\",\n        profile: \"profile\",\n        radiogroup: \"radioGroup\",\n        readonly: \"readOnly\",\n        referrerpolicy: \"referrerPolicy\",\n        rel: \"rel\",\n        required: \"required\",\n        reversed: \"reversed\",\n        role: \"role\",\n        rows: \"rows\",\n        rowspan: \"rowSpan\",\n        sandbox: \"sandbox\",\n        scope: \"scope\",\n        scoped: \"scoped\",\n        scrolling: \"scrolling\",\n        seamless: \"seamless\",\n        selected: \"selected\",\n        shape: \"shape\",\n        size: \"size\",\n        sizes: \"sizes\",\n        span: \"span\",\n        spellcheck: \"spellCheck\",\n        src: \"src\",\n        srcdoc: \"srcDoc\",\n        srclang: \"srcLang\",\n        srcset: \"srcSet\",\n        start: \"start\",\n        step: \"step\",\n        style: \"style\",\n        summary: \"summary\",\n        tabindex: \"tabIndex\",\n        target: \"target\",\n        title: \"title\",\n        type: \"type\",\n        usemap: \"useMap\",\n        value: \"value\",\n        width: \"width\",\n        wmode: \"wmode\",\n        wrap: \"wrap\",\n        about: \"about\",\n        accentheight: \"accentHeight\",\n        \"accent-height\": \"accentHeight\",\n        accumulate: \"accumulate\",\n        additive: \"additive\",\n        alignmentbaseline: \"alignmentBaseline\",\n        \"alignment-baseline\": \"alignmentBaseline\",\n        allowreorder: \"allowReorder\",\n        alphabetic: \"alphabetic\",\n        amplitude: \"amplitude\",\n        arabicform: \"arabicForm\",\n        \"arabic-form\": \"arabicForm\",\n        ascent: \"ascent\",\n        attributename: \"attributeName\",\n        attributetype: \"attributeType\",\n        autoreverse: \"autoReverse\",\n        azimuth: \"azimuth\",\n        basefrequency: \"baseFrequency\",\n        baselineshift: \"baselineShift\",\n        \"baseline-shift\": \"baselineShift\",\n        baseprofile: \"baseProfile\",\n        bbox: \"bbox\",\n        begin: \"begin\",\n        bias: \"bias\",\n        by: \"by\",\n        calcmode: \"calcMode\",\n        capheight: \"capHeight\",\n        \"cap-height\": \"capHeight\",\n        clip: \"clip\",\n        clippath: \"clipPath\",\n        \"clip-path\": \"clipPath\",\n        clippathunits: \"clipPathUnits\",\n        cliprule: \"clipRule\",\n        \"clip-rule\": \"clipRule\",\n        color: \"color\",\n        colorinterpolation: \"colorInterpolation\",\n        \"color-interpolation\": \"colorInterpolation\",\n        colorinterpolationfilters: \"colorInterpolationFilters\",\n        \"color-interpolation-filters\": \"colorInterpolationFilters\",\n        colorprofile: \"colorProfile\",\n        \"color-profile\": \"colorProfile\",\n        colorrendering: \"colorRendering\",\n        \"color-rendering\": \"colorRendering\",\n        contentscripttype: \"contentScriptType\",\n        contentstyletype: \"contentStyleType\",\n        cursor: \"cursor\",\n        cx: \"cx\",\n        cy: \"cy\",\n        d: \"d\",\n        datatype: \"datatype\",\n        decelerate: \"decelerate\",\n        descent: \"descent\",\n        diffuseconstant: \"diffuseConstant\",\n        direction: \"direction\",\n        display: \"display\",\n        divisor: \"divisor\",\n        dominantbaseline: \"dominantBaseline\",\n        \"dominant-baseline\": \"dominantBaseline\",\n        dur: \"dur\",\n        dx: \"dx\",\n        dy: \"dy\",\n        edgemode: \"edgeMode\",\n        elevation: \"elevation\",\n        enablebackground: \"enableBackground\",\n        \"enable-background\": \"enableBackground\",\n        end: \"end\",\n        exponent: \"exponent\",\n        externalresourcesrequired: \"externalResourcesRequired\",\n        fill: \"fill\",\n        fillopacity: \"fillOpacity\",\n        \"fill-opacity\": \"fillOpacity\",\n        fillrule: \"fillRule\",\n        \"fill-rule\": \"fillRule\",\n        filter: \"filter\",\n        filterres: \"filterRes\",\n        filterunits: \"filterUnits\",\n        floodopacity: \"floodOpacity\",\n        \"flood-opacity\": \"floodOpacity\",\n        floodcolor: \"floodColor\",\n        \"flood-color\": \"floodColor\",\n        focusable: \"focusable\",\n        fontfamily: \"fontFamily\",\n        \"font-family\": \"fontFamily\",\n        fontsize: \"fontSize\",\n        \"font-size\": \"fontSize\",\n        fontsizeadjust: \"fontSizeAdjust\",\n        \"font-size-adjust\": \"fontSizeAdjust\",\n        fontstretch: \"fontStretch\",\n        \"font-stretch\": \"fontStretch\",\n        fontstyle: \"fontStyle\",\n        \"font-style\": \"fontStyle\",\n        fontvariant: \"fontVariant\",\n        \"font-variant\": \"fontVariant\",\n        fontweight: \"fontWeight\",\n        \"font-weight\": \"fontWeight\",\n        format: \"format\",\n        from: \"from\",\n        fx: \"fx\",\n        fy: \"fy\",\n        g1: \"g1\",\n        g2: \"g2\",\n        glyphname: \"glyphName\",\n        \"glyph-name\": \"glyphName\",\n        glyphorientationhorizontal: \"glyphOrientationHorizontal\",\n        \"glyph-orientation-horizontal\": \"glyphOrientationHorizontal\",\n        glyphorientationvertical: \"glyphOrientationVertical\",\n        \"glyph-orientation-vertical\": \"glyphOrientationVertical\",\n        glyphref: \"glyphRef\",\n        gradienttransform: \"gradientTransform\",\n        gradientunits: \"gradientUnits\",\n        hanging: \"hanging\",\n        horizadvx: \"horizAdvX\",\n        \"horiz-adv-x\": \"horizAdvX\",\n        horizoriginx: \"horizOriginX\",\n        \"horiz-origin-x\": \"horizOriginX\",\n        ideographic: \"ideographic\",\n        imagerendering: \"imageRendering\",\n        \"image-rendering\": \"imageRendering\",\n        in2: \"in2\",\n        in: \"in\",\n        inlist: \"inlist\",\n        intercept: \"intercept\",\n        k1: \"k1\",\n        k2: \"k2\",\n        k3: \"k3\",\n        k4: \"k4\",\n        k: \"k\",\n        kernelmatrix: \"kernelMatrix\",\n        kernelunitlength: \"kernelUnitLength\",\n        kerning: \"kerning\",\n        keypoints: \"keyPoints\",\n        keysplines: \"keySplines\",\n        keytimes: \"keyTimes\",\n        lengthadjust: \"lengthAdjust\",\n        letterspacing: \"letterSpacing\",\n        \"letter-spacing\": \"letterSpacing\",\n        lightingcolor: \"lightingColor\",\n        \"lighting-color\": \"lightingColor\",\n        limitingconeangle: \"limitingConeAngle\",\n        local: \"local\",\n        markerend: \"markerEnd\",\n        \"marker-end\": \"markerEnd\",\n        markerheight: \"markerHeight\",\n        markermid: \"markerMid\",\n        \"marker-mid\": \"markerMid\",\n        markerstart: \"markerStart\",\n        \"marker-start\": \"markerStart\",\n        markerunits: \"markerUnits\",\n        markerwidth: \"markerWidth\",\n        mask: \"mask\",\n        maskcontentunits: \"maskContentUnits\",\n        maskunits: \"maskUnits\",\n        mathematical: \"mathematical\",\n        mode: \"mode\",\n        numoctaves: \"numOctaves\",\n        offset: \"offset\",\n        opacity: \"opacity\",\n        operator: \"operator\",\n        order: \"order\",\n        orient: \"orient\",\n        orientation: \"orientation\",\n        origin: \"origin\",\n        overflow: \"overflow\",\n        overlineposition: \"overlinePosition\",\n        \"overline-position\": \"overlinePosition\",\n        overlinethickness: \"overlineThickness\",\n        \"overline-thickness\": \"overlineThickness\",\n        paintorder: \"paintOrder\",\n        \"paint-order\": \"paintOrder\",\n        panose1: \"panose1\",\n        \"panose-1\": \"panose1\",\n        pathlength: \"pathLength\",\n        patterncontentunits: \"patternContentUnits\",\n        patterntransform: \"patternTransform\",\n        patternunits: \"patternUnits\",\n        pointerevents: \"pointerEvents\",\n        \"pointer-events\": \"pointerEvents\",\n        points: \"points\",\n        pointsatx: \"pointsAtX\",\n        pointsaty: \"pointsAtY\",\n        pointsatz: \"pointsAtZ\",\n        popover: \"popover\",\n        popovertarget: \"popoverTarget\",\n        popovertargetaction: \"popoverTargetAction\",\n        prefix: \"prefix\",\n        preservealpha: \"preserveAlpha\",\n        preserveaspectratio: \"preserveAspectRatio\",\n        primitiveunits: \"primitiveUnits\",\n        property: \"property\",\n        r: \"r\",\n        radius: \"radius\",\n        refx: \"refX\",\n        refy: \"refY\",\n        renderingintent: \"renderingIntent\",\n        \"rendering-intent\": \"renderingIntent\",\n        repeatcount: \"repeatCount\",\n        repeatdur: \"repeatDur\",\n        requiredextensions: \"requiredExtensions\",\n        requiredfeatures: \"requiredFeatures\",\n        resource: \"resource\",\n        restart: \"restart\",\n        result: \"result\",\n        results: \"results\",\n        rotate: \"rotate\",\n        rx: \"rx\",\n        ry: \"ry\",\n        scale: \"scale\",\n        security: \"security\",\n        seed: \"seed\",\n        shaperendering: \"shapeRendering\",\n        \"shape-rendering\": \"shapeRendering\",\n        slope: \"slope\",\n        spacing: \"spacing\",\n        specularconstant: \"specularConstant\",\n        specularexponent: \"specularExponent\",\n        speed: \"speed\",\n        spreadmethod: \"spreadMethod\",\n        startoffset: \"startOffset\",\n        stddeviation: \"stdDeviation\",\n        stemh: \"stemh\",\n        stemv: \"stemv\",\n        stitchtiles: \"stitchTiles\",\n        stopcolor: \"stopColor\",\n        \"stop-color\": \"stopColor\",\n        stopopacity: \"stopOpacity\",\n        \"stop-opacity\": \"stopOpacity\",\n        strikethroughposition: \"strikethroughPosition\",\n        \"strikethrough-position\": \"strikethroughPosition\",\n        strikethroughthickness: \"strikethroughThickness\",\n        \"strikethrough-thickness\": \"strikethroughThickness\",\n        string: \"string\",\n        stroke: \"stroke\",\n        strokedasharray: \"strokeDasharray\",\n        \"stroke-dasharray\": \"strokeDasharray\",\n        strokedashoffset: \"strokeDashoffset\",\n        \"stroke-dashoffset\": \"strokeDashoffset\",\n        strokelinecap: \"strokeLinecap\",\n        \"stroke-linecap\": \"strokeLinecap\",\n        strokelinejoin: \"strokeLinejoin\",\n        \"stroke-linejoin\": \"strokeLinejoin\",\n        strokemiterlimit: \"strokeMiterlimit\",\n        \"stroke-miterlimit\": \"strokeMiterlimit\",\n        strokewidth: \"strokeWidth\",\n        \"stroke-width\": \"strokeWidth\",\n        strokeopacity: \"strokeOpacity\",\n        \"stroke-opacity\": \"strokeOpacity\",\n        suppresscontenteditablewarning: \"suppressContentEditableWarning\",\n        suppresshydrationwarning: \"suppressHydrationWarning\",\n        surfacescale: \"surfaceScale\",\n        systemlanguage: \"systemLanguage\",\n        tablevalues: \"tableValues\",\n        targetx: \"targetX\",\n        targety: \"targetY\",\n        textanchor: \"textAnchor\",\n        \"text-anchor\": \"textAnchor\",\n        textdecoration: \"textDecoration\",\n        \"text-decoration\": \"textDecoration\",\n        textlength: \"textLength\",\n        textrendering: \"textRendering\",\n        \"text-rendering\": \"textRendering\",\n        to: \"to\",\n        transform: \"transform\",\n        transformorigin: \"transformOrigin\",\n        \"transform-origin\": \"transformOrigin\",\n        typeof: \"typeof\",\n        u1: \"u1\",\n        u2: \"u2\",\n        underlineposition: \"underlinePosition\",\n        \"underline-position\": \"underlinePosition\",\n        underlinethickness: \"underlineThickness\",\n        \"underline-thickness\": \"underlineThickness\",\n        unicode: \"unicode\",\n        unicodebidi: \"unicodeBidi\",\n        \"unicode-bidi\": \"unicodeBidi\",\n        unicoderange: \"unicodeRange\",\n        \"unicode-range\": \"unicodeRange\",\n        unitsperem: \"unitsPerEm\",\n        \"units-per-em\": \"unitsPerEm\",\n        unselectable: \"unselectable\",\n        valphabetic: \"vAlphabetic\",\n        \"v-alphabetic\": \"vAlphabetic\",\n        values: \"values\",\n        vectoreffect: \"vectorEffect\",\n        \"vector-effect\": \"vectorEffect\",\n        version: \"version\",\n        vertadvy: \"vertAdvY\",\n        \"vert-adv-y\": \"vertAdvY\",\n        vertoriginx: \"vertOriginX\",\n        \"vert-origin-x\": \"vertOriginX\",\n        vertoriginy: \"vertOriginY\",\n        \"vert-origin-y\": \"vertOriginY\",\n        vhanging: \"vHanging\",\n        \"v-hanging\": \"vHanging\",\n        videographic: \"vIdeographic\",\n        \"v-ideographic\": \"vIdeographic\",\n        viewbox: \"viewBox\",\n        viewtarget: \"viewTarget\",\n        visibility: \"visibility\",\n        vmathematical: \"vMathematical\",\n        \"v-mathematical\": \"vMathematical\",\n        vocab: \"vocab\",\n        widths: \"widths\",\n        wordspacing: \"wordSpacing\",\n        \"word-spacing\": \"wordSpacing\",\n        writingmode: \"writingMode\",\n        \"writing-mode\": \"writingMode\",\n        x1: \"x1\",\n        x2: \"x2\",\n        x: \"x\",\n        xchannelselector: \"xChannelSelector\",\n        xheight: \"xHeight\",\n        \"x-height\": \"xHeight\",\n        xlinkactuate: \"xlinkActuate\",\n        \"xlink:actuate\": \"xlinkActuate\",\n        xlinkarcrole: \"xlinkArcrole\",\n        \"xlink:arcrole\": \"xlinkArcrole\",\n        xlinkhref: \"xlinkHref\",\n        \"xlink:href\": \"xlinkHref\",\n        xlinkrole: \"xlinkRole\",\n        \"xlink:role\": \"xlinkRole\",\n        xlinkshow: \"xlinkShow\",\n        \"xlink:show\": \"xlinkShow\",\n        xlinktitle: \"xlinkTitle\",\n        \"xlink:title\": \"xlinkTitle\",\n        xlinktype: \"xlinkType\",\n        \"xlink:type\": \"xlinkType\",\n        xmlbase: \"xmlBase\",\n        \"xml:base\": \"xmlBase\",\n        xmllang: \"xmlLang\",\n        \"xml:lang\": \"xmlLang\",\n        xmlns: \"xmlns\",\n        \"xml:space\": \"xmlSpace\",\n        xmlnsxlink: \"xmlnsXlink\",\n        \"xmlns:xlink\": \"xmlnsXlink\",\n        xmlspace: \"xmlSpace\",\n        y1: \"y1\",\n        y2: \"y2\",\n        y: \"y\",\n        ychannelselector: \"yChannelSelector\",\n        z: \"z\",\n        zoomandpan: \"zoomAndPan\"\n      },\n      warnedProperties = {},\n      EVENT_NAME_REGEX = /^on./,\n      INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/,\n      rARIA = RegExp(\n        \"^(aria)-[:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]*$\"\n      ),\n      rARIACamel = RegExp(\n        \"^(aria)[A-Z][:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]*$\"\n      ),\n      badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/,\n      msPattern$1 = /^-ms-/,\n      hyphenPattern = /-(.)/g,\n      badStyleValueWithSemicolonPattern = /;\\s*$/,\n      warnedStyleNames = {},\n      warnedStyleValues = {},\n      warnedForNaNValue = !1,\n      warnedForInfinityValue = !1,\n      matchHtmlRegExp = /[\"'&<>]/,\n      uppercasePattern = /([A-Z])/g,\n      msPattern = /^ms-/,\n      isJavaScriptProtocol =\n        /^[\\u0000-\\u001F ]*j[\\r\\n\\t]*a[\\r\\n\\t]*v[\\r\\n\\t]*a[\\r\\n\\t]*s[\\r\\n\\t]*c[\\r\\n\\t]*r[\\r\\n\\t]*i[\\r\\n\\t]*p[\\r\\n\\t]*t[\\r\\n\\t]*:/i,\n      ReactSharedInternals =\n        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n      ReactDOMSharedInternals =\n        ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n      NotPending = Object.freeze({\n        pending: !1,\n        data: null,\n        method: null,\n        action: null\n      }),\n      previousDispatcher = ReactDOMSharedInternals.d;\n    ReactDOMSharedInternals.d = {\n      f: previousDispatcher.f,\n      r: previousDispatcher.r,\n      D: function (href) {\n        var request = currentRequest ? currentRequest : null;\n        if (request) {\n          var resumableState = request.resumableState,\n            renderState = request.renderState;\n          if (\"string\" === typeof href && href) {\n            if (!resumableState.dnsResources.hasOwnProperty(href)) {\n              resumableState.dnsResources[href] = EXISTS;\n              resumableState = renderState.headers;\n              var header, JSCompiler_temp;\n              if (\n                (JSCompiler_temp =\n                  resumableState && 0 < resumableState.remainingCapacity)\n              )\n                JSCompiler_temp =\n                  ((header =\n                    \"<\" +\n                    escapeHrefForLinkHeaderURLContext(href) +\n                    \">; rel=dns-prefetch\"),\n                  0 <= (resumableState.remainingCapacity -= header.length + 2));\n              JSCompiler_temp\n                ? ((renderState.resets.dns[href] = EXISTS),\n                  resumableState.preconnects &&\n                    (resumableState.preconnects += \", \"),\n                  (resumableState.preconnects += header))\n                : ((header = []),\n                  pushLinkImpl(header, { href: href, rel: \"dns-prefetch\" }),\n                  renderState.preconnects.add(header));\n            }\n            enqueueFlush(request);\n          }\n        } else previousDispatcher.D(href);\n      },\n      C: function (href, crossOrigin) {\n        var request = currentRequest ? currentRequest : null;\n        if (request) {\n          var resumableState = request.resumableState,\n            renderState = request.renderState;\n          if (\"string\" === typeof href && href) {\n            var bucket =\n              \"use-credentials\" === crossOrigin\n                ? \"credentials\"\n                : \"string\" === typeof crossOrigin\n                  ? \"anonymous\"\n                  : \"default\";\n            if (!resumableState.connectResources[bucket].hasOwnProperty(href)) {\n              resumableState.connectResources[bucket][href] = EXISTS;\n              resumableState = renderState.headers;\n              var header, JSCompiler_temp;\n              if (\n                (JSCompiler_temp =\n                  resumableState && 0 < resumableState.remainingCapacity)\n              ) {\n                JSCompiler_temp =\n                  \"<\" +\n                  escapeHrefForLinkHeaderURLContext(href) +\n                  \">; rel=preconnect\";\n                if (\"string\" === typeof crossOrigin) {\n                  var escapedCrossOrigin =\n                    escapeStringForLinkHeaderQuotedParamValueContext(\n                      crossOrigin,\n                      \"crossOrigin\"\n                    );\n                  JSCompiler_temp +=\n                    '; crossorigin=\"' + escapedCrossOrigin + '\"';\n                }\n                JSCompiler_temp =\n                  ((header = JSCompiler_temp),\n                  0 <= (resumableState.remainingCapacity -= header.length + 2));\n              }\n              JSCompiler_temp\n                ? ((renderState.resets.connect[bucket][href] = EXISTS),\n                  resumableState.preconnects &&\n                    (resumableState.preconnects += \", \"),\n                  (resumableState.preconnects += header))\n                : ((bucket = []),\n                  pushLinkImpl(bucket, {\n                    rel: \"preconnect\",\n                    href: href,\n                    crossOrigin: crossOrigin\n                  }),\n                  renderState.preconnects.add(bucket));\n            }\n            enqueueFlush(request);\n          }\n        } else previousDispatcher.C(href, crossOrigin);\n      },\n      L: function (href, as, options) {\n        var request = currentRequest ? currentRequest : null;\n        if (request) {\n          var resumableState = request.resumableState,\n            renderState = request.renderState;\n          if (as && href) {\n            switch (as) {\n              case \"image\":\n                if (options) {\n                  var imageSrcSet = options.imageSrcSet;\n                  var imageSizes = options.imageSizes;\n                  var fetchPriority = options.fetchPriority;\n                }\n                var key = imageSrcSet\n                  ? imageSrcSet + \"\\n\" + (imageSizes || \"\")\n                  : href;\n                if (resumableState.imageResources.hasOwnProperty(key)) return;\n                resumableState.imageResources[key] = PRELOAD_NO_CREDS;\n                resumableState = renderState.headers;\n                var header;\n                resumableState &&\n                0 < resumableState.remainingCapacity &&\n                \"string\" !== typeof imageSrcSet &&\n                \"high\" === fetchPriority &&\n                ((header = getPreloadAsHeader(href, as, options)),\n                0 <= (resumableState.remainingCapacity -= header.length + 2))\n                  ? ((renderState.resets.image[key] = PRELOAD_NO_CREDS),\n                    resumableState.highImagePreloads &&\n                      (resumableState.highImagePreloads += \", \"),\n                    (resumableState.highImagePreloads += header))\n                  : ((resumableState = []),\n                    pushLinkImpl(\n                      resumableState,\n                      assign(\n                        {\n                          rel: \"preload\",\n                          href: imageSrcSet ? void 0 : href,\n                          as: as\n                        },\n                        options\n                      )\n                    ),\n                    \"high\" === fetchPriority\n                      ? renderState.highImagePreloads.add(resumableState)\n                      : (renderState.bulkPreloads.add(resumableState),\n                        renderState.preloads.images.set(key, resumableState)));\n                break;\n              case \"style\":\n                if (resumableState.styleResources.hasOwnProperty(href)) return;\n                imageSrcSet = [];\n                pushLinkImpl(\n                  imageSrcSet,\n                  assign({ rel: \"preload\", href: href, as: as }, options)\n                );\n                resumableState.styleResources[href] =\n                  !options ||\n                  (\"string\" !== typeof options.crossOrigin &&\n                    \"string\" !== typeof options.integrity)\n                    ? PRELOAD_NO_CREDS\n                    : [options.crossOrigin, options.integrity];\n                renderState.preloads.stylesheets.set(href, imageSrcSet);\n                renderState.bulkPreloads.add(imageSrcSet);\n                break;\n              case \"script\":\n                if (resumableState.scriptResources.hasOwnProperty(href)) return;\n                imageSrcSet = [];\n                renderState.preloads.scripts.set(href, imageSrcSet);\n                renderState.bulkPreloads.add(imageSrcSet);\n                pushLinkImpl(\n                  imageSrcSet,\n                  assign({ rel: \"preload\", href: href, as: as }, options)\n                );\n                resumableState.scriptResources[href] =\n                  !options ||\n                  (\"string\" !== typeof options.crossOrigin &&\n                    \"string\" !== typeof options.integrity)\n                    ? PRELOAD_NO_CREDS\n                    : [options.crossOrigin, options.integrity];\n                break;\n              default:\n                if (resumableState.unknownResources.hasOwnProperty(as)) {\n                  if (\n                    ((imageSrcSet = resumableState.unknownResources[as]),\n                    imageSrcSet.hasOwnProperty(href))\n                  )\n                    return;\n                } else\n                  (imageSrcSet = {}),\n                    (resumableState.unknownResources[as] = imageSrcSet);\n                imageSrcSet[href] = PRELOAD_NO_CREDS;\n                if (\n                  (resumableState = renderState.headers) &&\n                  0 < resumableState.remainingCapacity &&\n                  \"font\" === as &&\n                  ((key = getPreloadAsHeader(href, as, options)),\n                  0 <= (resumableState.remainingCapacity -= key.length + 2))\n                )\n                  (renderState.resets.font[href] = PRELOAD_NO_CREDS),\n                    resumableState.fontPreloads &&\n                      (resumableState.fontPreloads += \", \"),\n                    (resumableState.fontPreloads += key);\n                else\n                  switch (\n                    ((resumableState = []),\n                    (href = assign(\n                      { rel: \"preload\", href: href, as: as },\n                      options\n                    )),\n                    pushLinkImpl(resumableState, href),\n                    as)\n                  ) {\n                    case \"font\":\n                      renderState.fontPreloads.add(resumableState);\n                      break;\n                    default:\n                      renderState.bulkPreloads.add(resumableState);\n                  }\n            }\n            enqueueFlush(request);\n          }\n        } else previousDispatcher.L(href, as, options);\n      },\n      m: function (href, options) {\n        var request = currentRequest ? currentRequest : null;\n        if (request) {\n          var resumableState = request.resumableState,\n            renderState = request.renderState;\n          if (href) {\n            var as =\n              options && \"string\" === typeof options.as ? options.as : \"script\";\n            switch (as) {\n              case \"script\":\n                if (resumableState.moduleScriptResources.hasOwnProperty(href))\n                  return;\n                as = [];\n                resumableState.moduleScriptResources[href] =\n                  !options ||\n                  (\"string\" !== typeof options.crossOrigin &&\n                    \"string\" !== typeof options.integrity)\n                    ? PRELOAD_NO_CREDS\n                    : [options.crossOrigin, options.integrity];\n                renderState.preloads.moduleScripts.set(href, as);\n                break;\n              default:\n                if (resumableState.moduleUnknownResources.hasOwnProperty(as)) {\n                  var resources = resumableState.unknownResources[as];\n                  if (resources.hasOwnProperty(href)) return;\n                } else\n                  (resources = {}),\n                    (resumableState.moduleUnknownResources[as] = resources);\n                as = [];\n                resources[href] = PRELOAD_NO_CREDS;\n            }\n            pushLinkImpl(\n              as,\n              assign({ rel: \"modulepreload\", href: href }, options)\n            );\n            renderState.bulkPreloads.add(as);\n            enqueueFlush(request);\n          }\n        } else previousDispatcher.m(href, options);\n      },\n      X: function (src, options) {\n        var request = currentRequest ? currentRequest : null;\n        if (request) {\n          var resumableState = request.resumableState,\n            renderState = request.renderState;\n          if (src) {\n            var resourceState = resumableState.scriptResources.hasOwnProperty(\n              src\n            )\n              ? resumableState.scriptResources[src]\n              : void 0;\n            resourceState !== EXISTS &&\n              ((resumableState.scriptResources[src] = EXISTS),\n              (options = assign({ src: src, async: !0 }, options)),\n              resourceState &&\n                (2 === resourceState.length &&\n                  adoptPreloadCredentials(options, resourceState),\n                (src = renderState.preloads.scripts.get(src))) &&\n                (src.length = 0),\n              (src = []),\n              renderState.scripts.add(src),\n              pushScriptImpl(src, options),\n              enqueueFlush(request));\n          }\n        } else previousDispatcher.X(src, options);\n      },\n      S: function (href, precedence, options) {\n        var request = currentRequest ? currentRequest : null;\n        if (request) {\n          var resumableState = request.resumableState,\n            renderState = request.renderState;\n          if (href) {\n            precedence = precedence || \"default\";\n            var styleQueue = renderState.styles.get(precedence),\n              resourceState = resumableState.styleResources.hasOwnProperty(href)\n                ? resumableState.styleResources[href]\n                : void 0;\n            resourceState !== EXISTS &&\n              ((resumableState.styleResources[href] = EXISTS),\n              styleQueue ||\n                ((styleQueue = {\n                  precedence: escapeTextForBrowser(precedence),\n                  rules: [],\n                  hrefs: [],\n                  sheets: new Map()\n                }),\n                renderState.styles.set(precedence, styleQueue)),\n              (precedence = {\n                state: PENDING$1,\n                props: assign(\n                  {\n                    rel: \"stylesheet\",\n                    href: href,\n                    \"data-precedence\": precedence\n                  },\n                  options\n                )\n              }),\n              resourceState &&\n                (2 === resourceState.length &&\n                  adoptPreloadCredentials(precedence.props, resourceState),\n                (renderState = renderState.preloads.stylesheets.get(href)) &&\n                0 < renderState.length\n                  ? (renderState.length = 0)\n                  : (precedence.state = PRELOADED)),\n              styleQueue.sheets.set(href, precedence),\n              enqueueFlush(request));\n          }\n        } else previousDispatcher.S(href, precedence, options);\n      },\n      M: function (src, options) {\n        var request = currentRequest ? currentRequest : null;\n        if (request) {\n          var resumableState = request.resumableState,\n            renderState = request.renderState;\n          if (src) {\n            var resourceState =\n              resumableState.moduleScriptResources.hasOwnProperty(src)\n                ? resumableState.moduleScriptResources[src]\n                : void 0;\n            resourceState !== EXISTS &&\n              ((resumableState.moduleScriptResources[src] = EXISTS),\n              (options = assign(\n                { src: src, type: \"module\", async: !0 },\n                options\n              )),\n              resourceState &&\n                (2 === resourceState.length &&\n                  adoptPreloadCredentials(options, resourceState),\n                (src = renderState.preloads.moduleScripts.get(src))) &&\n                (src.length = 0),\n              (src = []),\n              renderState.scripts.add(src),\n              pushScriptImpl(src, options),\n              enqueueFlush(request));\n          }\n        } else previousDispatcher.M(src, options);\n      }\n    };\n    var NothingSent = 0,\n      SentCompleteSegmentFunction = 1,\n      SentCompleteBoundaryFunction = 2,\n      SentClientRenderFunction = 4,\n      SentStyleInsertionFunction = 8,\n      SentCompletedShellId = 32,\n      SentMarkShellTime = 64,\n      EXISTS = null,\n      PRELOAD_NO_CREDS = [];\n    Object.freeze(PRELOAD_NO_CREDS);\n    var currentlyFlushingRenderState = null,\n      endInlineScript = \"\\x3c/script>\",\n      scriptRegex = /(<\\/|<)(s)(cript)/gi;\n    var didWarnForNewBooleanPropsWithEmptyValue = {};\n    var ROOT_HTML_MODE = 0,\n      HTML_HTML_MODE = 1,\n      HTML_MODE = 2,\n      HTML_HEAD_MODE = 3,\n      SVG_MODE = 4,\n      MATHML_MODE = 5,\n      HTML_TABLE_MODE = 6,\n      HTML_TABLE_BODY_MODE = 7,\n      HTML_TABLE_ROW_MODE = 8,\n      HTML_COLGROUP_MODE = 9,\n      styleNameCache = new Map(),\n      styleAttributeStart = ' style=\"',\n      styleAssign = \":\",\n      styleSeparator = \";\",\n      attributeSeparator = \" \",\n      attributeAssign = '=\"',\n      attributeEnd = '\"',\n      attributeEmptyString = '=\"\"',\n      actionJavaScriptURL = escapeTextForBrowser(\n        \"javascript:throw new Error('React form unexpectedly submitted.')\"\n      ),\n      endOfStartTag = \">\",\n      endOfStartTagSelfClosing = \"/>\",\n      didWarnDefaultInputValue = !1,\n      didWarnDefaultChecked = !1,\n      didWarnDefaultSelectValue = !1,\n      didWarnDefaultTextareaValue = !1,\n      didWarnInvalidOptionChildren = !1,\n      didWarnInvalidOptionInnerHTML = !1,\n      didWarnSelectedSetOnOption = !1,\n      didWarnFormActionType = !1,\n      didWarnFormActionName = !1,\n      didWarnFormActionTarget = !1,\n      didWarnFormActionMethod = !1,\n      formReplayingRuntimeScript =\n        'addEventListener(\"submit\",function(a){if(!a.defaultPrevented){var c=a.target,d=a.submitter,e=c.action,b=d;if(d){var f=d.getAttribute(\"formAction\");null!=f&&(e=f,b=null)}\"javascript:throw new Error(\\'React form unexpectedly submitted.\\')\"===e&&(a.preventDefault(),b?(a=document.createElement(\"input\"),a.name=b.name,a.value=b.value,b.parentNode.insertBefore(a,b),b=new FormData(c),a.parentNode.removeChild(a)):b=new FormData(c),a=c.ownerDocument||c,(a.$$reactFormReplay=a.$$reactFormReplay||[]).push(c,d,b))}});',\n      styleRegex = /(<\\/|<)(s)(tyle)/gi,\n      leadingNewline = \"\\n\",\n      VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\\.\\-\\d]*$/,\n      validatedTagCache = new Map(),\n      endTagCache = new Map(),\n      shellTimeRuntimeScript =\n        \"requestAnimationFrame(function(){$RT=performance.now()});\",\n      placeholder1 = '<template id=\"',\n      placeholder2 = '\"></template>',\n      startCompletedSuspenseBoundary = \"\\x3c!--$--\\x3e\",\n      startPendingSuspenseBoundary1 = '\\x3c!--$?--\\x3e<template id=\"',\n      startPendingSuspenseBoundary2 = '\"></template>',\n      startClientRenderedSuspenseBoundary = \"\\x3c!--$!--\\x3e\",\n      endSuspenseBoundary = \"\\x3c!--/$--\\x3e\",\n      clientRenderedSuspenseBoundaryError1 = \"<template\",\n      clientRenderedSuspenseBoundaryErrorAttrInterstitial = '\"',\n      clientRenderedSuspenseBoundaryError1A = ' data-dgst=\"',\n      clientRenderedSuspenseBoundaryError1B = ' data-msg=\"',\n      clientRenderedSuspenseBoundaryError1C = ' data-stck=\"',\n      clientRenderedSuspenseBoundaryError1D = ' data-cstck=\"',\n      clientRenderedSuspenseBoundaryError2 = \"></template>\",\n      startSegmentHTML = '<div hidden id=\"',\n      startSegmentHTML2 = '\">',\n      endSegmentHTML = \"</div>\",\n      startSegmentSVG = '<svg aria-hidden=\"true\" style=\"display:none\" id=\"',\n      startSegmentSVG2 = '\">',\n      endSegmentSVG = \"</svg>\",\n      startSegmentMathML = '<math aria-hidden=\"true\" style=\"display:none\" id=\"',\n      startSegmentMathML2 = '\">',\n      endSegmentMathML = \"</math>\",\n      startSegmentTable = '<table hidden id=\"',\n      startSegmentTable2 = '\">',\n      endSegmentTable = \"</table>\",\n      startSegmentTableBody = '<table hidden><tbody id=\"',\n      startSegmentTableBody2 = '\">',\n      endSegmentTableBody = \"</tbody></table>\",\n      startSegmentTableRow = '<table hidden><tr id=\"',\n      startSegmentTableRow2 = '\">',\n      endSegmentTableRow = \"</tr></table>\",\n      startSegmentColGroup = '<table hidden><colgroup id=\"',\n      startSegmentColGroup2 = '\">',\n      endSegmentColGroup = \"</colgroup></table>\",\n      completeSegmentScript1Full =\n        '$RS=function(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS(\"',\n      completeSegmentScript1Partial = '$RS(\"',\n      completeSegmentScript2 = '\",\"',\n      completeSegmentScriptEnd = '\")\\x3c/script>',\n      completeBoundaryScriptFunctionOnly =\n        '$RB=[];$RV=function(a){$RT=performance.now();for(var b=0;b<a.length;b+=2){var c=a[b],e=a[b+1];null!==e.parentNode&&e.parentNode.removeChild(e);var f=c.parentNode;if(f){var g=c.previousSibling,h=0;do{if(c&&8===c.nodeType){var d=c.data;if(\"/$\"===d||\"/&\"===d)if(0===h)break;else h--;else\"$\"!==d&&\"$?\"!==d&&\"$~\"!==d&&\"$!\"!==d&&\"&\"!==d||h++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;e.firstChild;)f.insertBefore(e.firstChild,c);g.data=\"$\";g._reactRetry&&requestAnimationFrame(g._reactRetry)}}a.length=0};\\n$RC=function(a,b){if(b=document.getElementById(b))(a=document.getElementById(a))?(a.previousSibling.data=\"$~\",$RB.push(a,b),2===$RB.length&&(\"number\"!==typeof $RT?requestAnimationFrame($RV.bind(null,$RB)):(a=performance.now(),setTimeout($RV.bind(null,$RB),2300>a&&2E3<a?2300-a:$RT+300-a)))):b.parentNode.removeChild(b)};',\n      completeBoundaryScript1Partial = '$RC(\"',\n      completeBoundaryWithStylesScript1FullPartial =\n        '$RM=new Map;$RR=function(n,w,p){function u(q){this._p=null;q()}for(var r=new Map,t=document,h,b,e=t.querySelectorAll(\"link[data-precedence],style[data-precedence]\"),v=[],k=0;b=e[k++];)\"not all\"===b.getAttribute(\"media\")?v.push(b):(\"LINK\"===b.tagName&&$RM.set(b.getAttribute(\"href\"),b),r.set(b.dataset.precedence,h=b));e=0;b=[];var l,a;for(k=!0;;){if(k){var f=p[e++];if(!f){k=!1;e=0;continue}var c=!1,m=0;var d=f[m++];if(a=$RM.get(d)){var g=a._p;c=!0}else{a=t.createElement(\"link\");a.href=d;a.rel=\\n\"stylesheet\";for(a.dataset.precedence=l=f[m++];g=f[m++];)a.setAttribute(g,f[m++]);g=a._p=new Promise(function(q,x){a.onload=u.bind(a,q);a.onerror=u.bind(a,x)});$RM.set(d,a)}d=a.getAttribute(\"media\");!g||d&&!matchMedia(d).matches||b.push(g);if(c)continue}else{a=v[e++];if(!a)break;l=a.getAttribute(\"data-precedence\");a.removeAttribute(\"media\")}c=r.get(l)||h;c===h&&(h=a);r.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=t.head,c.insertBefore(a,c.firstChild))}if(p=document.getElementById(n))p.previousSibling.data=\\n\"$~\";Promise.all(b).then($RC.bind(null,n,w),$RX.bind(null,n,\"CSS failed to load\"))};$RR(\"',\n      completeBoundaryWithStylesScript1Partial = '$RR(\"',\n      completeBoundaryScript2 = '\",\"',\n      completeBoundaryScript3a = '\",',\n      completeBoundaryScript3b = '\"',\n      completeBoundaryScriptEnd = \")\\x3c/script>\",\n      clientRenderScriptFunctionOnly =\n        '$RX=function(b,c,d,e,f){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data=\"$!\",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),f&&(a.cstck=f),b._reactRetry&&b._reactRetry())};',\n      clientRenderScript1Full =\n        '$RX=function(b,c,d,e,f){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data=\"$!\",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),f&&(a.cstck=f),b._reactRetry&&b._reactRetry())};;$RX(\"',\n      clientRenderScript1Partial = '$RX(\"',\n      clientRenderScript1A = '\"',\n      clientRenderErrorScriptArgInterstitial = \",\",\n      clientRenderScriptEnd = \")\\x3c/script>\",\n      regexForJSStringsInInstructionScripts = /[<\\u2028\\u2029]/g,\n      regexForJSStringsInScripts = /[&><\\u2028\\u2029]/g,\n      lateStyleTagResourceOpen1 = ' media=\"not all\" data-precedence=\"',\n      lateStyleTagResourceOpen2 = '\" data-href=\"',\n      lateStyleTagResourceOpen3 = '\">',\n      lateStyleTagTemplateClose = \"</style>\",\n      currentlyRenderingBoundaryHasStylesToHoist = !1,\n      destinationHasCapacity = !0,\n      stylesheetFlushingQueue = [],\n      styleTagResourceOpen1 = ' data-precedence=\"',\n      styleTagResourceOpen2 = '\" data-href=\"',\n      spaceSeparator = \" \",\n      styleTagResourceOpen3 = '\">',\n      styleTagResourceClose = \"</style>\",\n      completedShellIdAttributeStart = ' id=\"',\n      arrayFirstOpenBracket = \"[\",\n      arraySubsequentOpenBracket = \",[\",\n      arrayInterstitial = \",\",\n      arrayCloseBracket = \"]\",\n      PENDING$1 = 0,\n      PRELOADED = 1,\n      PREAMBLE = 2,\n      LATE = 3,\n      regexForHrefInLinkHeaderURLContext = /[<>\\r\\n]/g,\n      regexForLinkHeaderQuotedParamValueContext = /[\"';,\\r\\n]/g,\n      doctypeChunk = \"\",\n      bind = Function.prototype.bind,\n      REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n      emptyContextObject = {};\n    Object.freeze(emptyContextObject);\n    var rendererSigil = {};\n    var currentActiveSnapshot = null,\n      didWarnAboutNoopUpdateForComponent = {},\n      didWarnAboutDeprecatedWillMount = {};\n    var didWarnAboutUninitializedState = new Set();\n    var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();\n    var didWarnAboutLegacyLifecyclesAndDerivedState = new Set();\n    var didWarnAboutDirectlyAssigningPropsToState = new Set();\n    var didWarnAboutUndefinedDerivedState = new Set();\n    var didWarnAboutContextTypes$1 = new Set();\n    var didWarnAboutChildContextTypes = new Set();\n    var didWarnAboutInvalidateContextType = new Set();\n    var didWarnOnInvalidCallback = new Set();\n    var classComponentUpdater = {\n        enqueueSetState: function (inst, payload, callback) {\n          var internals = inst._reactInternals;\n          null === internals.queue\n            ? warnNoop(inst, \"setState\")\n            : (internals.queue.push(payload),\n              void 0 !== callback &&\n                null !== callback &&\n                warnOnInvalidCallback(callback));\n        },\n        enqueueReplaceState: function (inst, payload, callback) {\n          inst = inst._reactInternals;\n          inst.replace = !0;\n          inst.queue = [payload];\n          void 0 !== callback &&\n            null !== callback &&\n            warnOnInvalidCallback(callback);\n        },\n        enqueueForceUpdate: function (inst, callback) {\n          null === inst._reactInternals.queue\n            ? warnNoop(inst, \"forceUpdate\")\n            : void 0 !== callback &&\n              null !== callback &&\n              warnOnInvalidCallback(callback);\n        }\n      },\n      emptyTreeContext = { id: 1, overflow: \"\" },\n      clz32 = Math.clz32 ? Math.clz32 : clz32Fallback,\n      log = Math.log,\n      LN2 = Math.LN2,\n      SuspenseException = Error(\n        \"Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\\n\\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`.\"\n      ),\n      suspendedThenable = null,\n      objectIs = \"function\" === typeof Object.is ? Object.is : is,\n      currentlyRenderingComponent = null,\n      currentlyRenderingTask = null,\n      currentlyRenderingRequest = null,\n      currentlyRenderingKeyPath = null,\n      firstWorkInProgressHook = null,\n      workInProgressHook = null,\n      isReRender = !1,\n      didScheduleRenderPhaseUpdate = !1,\n      localIdCounter = 0,\n      actionStateCounter = 0,\n      actionStateMatchingIndex = -1,\n      thenableIndexCounter = 0,\n      thenableState = null,\n      renderPhaseUpdates = null,\n      numberOfReRenders = 0,\n      isInHookUserCodeInDev = !1,\n      currentHookNameInDev,\n      HooksDispatcher = {\n        readContext: readContext,\n        use: function (usable) {\n          if (null !== usable && \"object\" === typeof usable) {\n            if (\"function\" === typeof usable.then)\n              return unwrapThenable(usable);\n            if (usable.$$typeof === REACT_CONTEXT_TYPE)\n              return readContext(usable);\n          }\n          throw Error(\n            \"An unsupported type was passed to use(): \" + String(usable)\n          );\n        },\n        useContext: function (context) {\n          currentHookNameInDev = \"useContext\";\n          resolveCurrentlyRenderingComponent();\n          return context._currentValue2;\n        },\n        useMemo: useMemo,\n        useReducer: useReducer,\n        useRef: function (initialValue) {\n          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();\n          workInProgressHook = createWorkInProgressHook();\n          var previousRef = workInProgressHook.memoizedState;\n          return null === previousRef\n            ? ((initialValue = { current: initialValue }),\n              Object.seal(initialValue),\n              (workInProgressHook.memoizedState = initialValue))\n            : previousRef;\n        },\n        useState: function (initialState) {\n          currentHookNameInDev = \"useState\";\n          return useReducer(basicStateReducer, initialState);\n        },\n        useInsertionEffect: noop,\n        useLayoutEffect: noop,\n        useCallback: function (callback, deps) {\n          return useMemo(function () {\n            return callback;\n          }, deps);\n        },\n        useImperativeHandle: noop,\n        useEffect: noop,\n        useDebugValue: noop,\n        useDeferredValue: function (value, initialValue) {\n          resolveCurrentlyRenderingComponent();\n          return void 0 !== initialValue ? initialValue : value;\n        },\n        useTransition: function () {\n          resolveCurrentlyRenderingComponent();\n          return [!1, unsupportedStartTransition];\n        },\n        useId: function () {\n          var treeId = currentlyRenderingTask.treeContext;\n          var overflow = treeId.overflow;\n          treeId = treeId.id;\n          treeId =\n            (treeId & ~(1 << (32 - clz32(treeId) - 1))).toString(32) + overflow;\n          var resumableState = currentResumableState;\n          if (null === resumableState)\n            throw Error(\n              \"Invalid hook call. Hooks can only be called inside of the body of a function component.\"\n            );\n          overflow = localIdCounter++;\n          treeId = \"_\" + resumableState.idPrefix + \"R_\" + treeId;\n          0 < overflow && (treeId += \"H\" + overflow.toString(32));\n          return treeId + \"_\";\n        },\n        useSyncExternalStore: function (\n          subscribe,\n          getSnapshot,\n          getServerSnapshot\n        ) {\n          if (void 0 === getServerSnapshot)\n            throw Error(\n              \"Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.\"\n            );\n          return getServerSnapshot();\n        },\n        useOptimistic: function (passthrough) {\n          resolveCurrentlyRenderingComponent();\n          return [passthrough, unsupportedSetOptimisticState];\n        },\n        useActionState: useActionState,\n        useFormState: useActionState,\n        useHostTransitionStatus: function () {\n          resolveCurrentlyRenderingComponent();\n          return NotPending;\n        },\n        useMemoCache: function (size) {\n          for (var data = Array(size), i = 0; i < size; i++)\n            data[i] = REACT_MEMO_CACHE_SENTINEL;\n          return data;\n        },\n        useCacheRefresh: function () {\n          return unsupportedRefresh;\n        },\n        useEffectEvent: function () {\n          return throwOnUseEffectEventCall;\n        }\n      },\n      currentResumableState = null,\n      currentTaskInDEV = null,\n      DefaultAsyncDispatcher = {\n        getCacheForType: function () {\n          throw Error(\"Not implemented.\");\n        },\n        cacheSignal: function () {\n          throw Error(\"Not implemented.\");\n        },\n        getOwner: function () {\n          return null === currentTaskInDEV\n            ? null\n            : currentTaskInDEV.componentStack;\n        }\n      },\n      disabledDepth = 0,\n      prevLog,\n      prevInfo,\n      prevWarn,\n      prevError,\n      prevGroup,\n      prevGroupCollapsed,\n      prevGroupEnd;\n    disabledLog.__reactDisabledLog = !0;\n    var prefix,\n      suffix,\n      reentry = !1;\n    var componentFrameCache = new (\n      \"function\" === typeof WeakMap ? WeakMap : Map\n    )();\n    var callComponent = {\n        react_stack_bottom_frame: function (Component, props, secondArg) {\n          return Component(props, secondArg);\n        }\n      },\n      callComponentInDEV =\n        callComponent.react_stack_bottom_frame.bind(callComponent),\n      callRender = {\n        react_stack_bottom_frame: function (instance) {\n          return instance.render();\n        }\n      },\n      callRenderInDEV = callRender.react_stack_bottom_frame.bind(callRender),\n      callLazyInit = {\n        react_stack_bottom_frame: function (lazy) {\n          var init = lazy._init;\n          return init(lazy._payload);\n        }\n      },\n      callLazyInitInDEV =\n        callLazyInit.react_stack_bottom_frame.bind(callLazyInit),\n      lastResetTime = 0;\n    if (\n      \"object\" === typeof performance &&\n      \"function\" === typeof performance.now\n    ) {\n      var localPerformance = performance;\n      var getCurrentTime = function () {\n        return localPerformance.now();\n      };\n    } else {\n      var localDate = Date;\n      getCurrentTime = function () {\n        return localDate.now();\n      };\n    }\n    var CLIENT_RENDERED = 4,\n      PENDING = 0,\n      COMPLETED = 1,\n      FLUSHED = 2,\n      ABORTED = 3,\n      ERRORED = 4,\n      POSTPONED = 5,\n      CLOSED = 14,\n      currentRequest = null,\n      didWarnAboutBadClass = {},\n      didWarnAboutContextTypes = {},\n      didWarnAboutContextTypeOnFunctionComponent = {},\n      didWarnAboutGetDerivedStateOnFunctionComponent = {},\n      didWarnAboutReassigningProps = !1,\n      didWarnAboutGenerators = !1,\n      didWarnAboutMaps = !1,\n      flushedByteSize = 0,\n      flushingPartialBoundaries = !1;\n    exports.renderToStaticMarkup = function (children, options) {\n      return renderToStringImpl(\n        children,\n        options,\n        !0,\n        'The server used \"renderToStaticMarkup\" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to \"renderToReadableStream\" which supports Suspense on the server'\n      );\n    };\n    exports.renderToString = function (children, options) {\n      return renderToStringImpl(\n        children,\n        options,\n        !1,\n        'The server used \"renderToString\" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to \"renderToReadableStream\" which supports Suspense on the server'\n      );\n    };\n    exports.version = \"19.2.0\";\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2Nqcy9yZWFjdC1kb20tc2VydmVyLWxlZ2FjeS5icm93c2VyLmRldmVsb3BtZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7QUFDYixLQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxJQUFJO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDBCQUEwQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDZDQUE2QztBQUNuRSxzQkFBc0IsNENBQTRDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLElBQUk7QUFDdEM7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLHlCQUF5Qiw2QkFBNkI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxpQkFBaUI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Ysc0JBQXNCO0FBQ3RCO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixjQUFjO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0pBQWtKLGlCQUFpQjtBQUNuSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtKQUFrSixpQkFBaUIsbURBQW1ELG1CQUFtQixXQUFXLCtCQUErQjtBQUNuUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEYsR0FBRztBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxxQkFBcUI7QUFDdkQ7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsd0JBQXdCO0FBQ3hCLDRCQUE0QixXQUFXLGVBQWUsbUJBQW1CO0FBQ3pFLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUIsMkJBQTJCO0FBQzNCLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrSEFBa0gsOEJBQThCO0FBQ2hKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxZQUFZO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwwQkFBMEI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc2ZBQXNmLFdBQVcsMExBQTBMLFNBQVMsV0FBVyxFQUFFO0FBQ2p0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsWUFBWTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw0QkFBNEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELHNCQUFzQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0NBQW9DO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDJCQUEyQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsYUFBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNEQUFzRDtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsaUJBQWlCO0FBQ2pCLHFCQUFxQixXQUFXLGVBQWUsbUJBQW1CO0FBQ2xFLG1CQUFtQjtBQUNuQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsaUJBQWlCLCtCQUErQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyw0QkFBNEI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHFCQUFxQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0Esd0JBQXdCLFdBQVcsZ0JBQWdCO0FBQ25ELHlCQUF5QixXQUFXLGlCQUFpQjtBQUNyRCx5QkFBeUIsV0FBVyxpQkFBaUI7QUFDckQsMEJBQTBCLFdBQVcsa0JBQWtCO0FBQ3ZELDBCQUEwQixXQUFXLGtCQUFrQjtBQUN2RCxtQ0FBbUMsV0FBVywyQkFBMkI7QUFDekUsNkJBQTZCLFdBQVcscUJBQXFCO0FBQzdELFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx1QkFBdUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdDQUFnQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsYUFBYTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx1QkFBdUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHVCQUF1QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixRQUFRO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixzQkFBc0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHVCQUF1QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaURBQWlEO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMscUNBQXFDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMEJBQTBCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsa0JBQWtCLGdCQUFnQjtBQUN2RTtBQUNBO0FBQ0EsUUFBUTtBQUNSLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix3QkFBd0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLDZCQUE2QjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDJCQUEyQjtBQUM1RCx3Q0FBd0Msb0JBQW9CO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw4QkFBOEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdDQUFnQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxtQ0FBbUMsZ0NBQWdDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxQ0FBcUM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdDQUFnQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsOEJBQThCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDRCQUE0QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyw0Q0FBTztBQUMvQixpQkFBaUIsbUJBQU8sQ0FBQyxvREFBVztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUMsMkJBQTJCO0FBQzNCLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxpQ0FBaUM7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG9DQUFvQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG9DQUFvQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0NBQW9DO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0NBQWtDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxxQkFBcUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUNBQXFDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyx3QkFBd0IsNENBQTRDLE1BQU0sbUNBQW1DLHNCQUFzQixrVkFBa1YsRUFBRTtBQUN0Z0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHNCQUFzQixFQUFFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw2QkFBNkIsNkJBQTZCLGdDQUFnQyxhQUFhLDJDQUEyQyw2QkFBNkI7QUFDMU07QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0JBQWdCLHNCQUFzQixZQUFZLFdBQVcsTUFBTSxvQkFBb0IsaURBQWlELG1CQUFtQixNQUFNLDRCQUE0QixHQUFHLHNCQUFzQixhQUFhLHFDQUFxQyxTQUFTLHdEQUF3RCxnQkFBZ0IsaUJBQWlCLElBQUksU0FBUyxLQUFLLGFBQWEsZ0NBQWdDLFdBQVcscURBQXFELFlBQVksb0JBQW9CLDhTQUE4UztBQUN2MEI7QUFDQTtBQUNBLHFCQUFxQixvQkFBb0IsY0FBYyxhQUFhLElBQUksK0dBQStHLFNBQVMsdUlBQXVJLElBQUksS0FBSyxRQUFRLFVBQVUsRUFBRSxNQUFNLGFBQWEsT0FBTyxLQUFLLElBQUksU0FBUyxhQUFhLGFBQWEsaUJBQWlCLFdBQVcsS0FBSyxLQUFLLDBCQUEwQixTQUFTLHFCQUFxQixrQ0FBa0MsU0FBUywwQkFBMEIsaUNBQWlDLHFCQUFxQixzQkFBc0IsRUFBRSxhQUFhLDBCQUEwQix5Q0FBeUMsY0FBYyxLQUFLLFNBQVMsWUFBWSxvQ0FBb0MsMkJBQTJCLGNBQWMsYUFBYSxXQUFXLHVGQUF1Riw4REFBOEQsK0VBQStFO0FBQzVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsaUNBQWlDLHlJQUF5STtBQUMzTTtBQUNBLGlDQUFpQyxpQ0FBaUMsMElBQTBJO0FBQzVNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDJCQUEyQixxQkFBcUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsdUJBQXVCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSw4Q0FBOEMsVUFBVTtBQUN4RDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLG1DQUFtQztBQUNuQyxxREFBcUQ7QUFDckQseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDRCQUE0QjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksc0JBQXNCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxlQUFlO0FBQ25CLEdBQUciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TU1IvLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2Nqcy9yZWFjdC1kb20tc2VydmVyLWxlZ2FjeS5icm93c2VyLmRldmVsb3BtZW50LmpzP2YyMmMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtZG9tLXNlcnZlci1sZWdhY3kuYnJvd3Nlci5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuLypcblxuXG4gSlMgSW1wbGVtZW50YXRpb24gb2YgTXVybXVySGFzaDMgKHIxMzYpIChhcyBvZiBNYXkgMjAsIDIwMTEpXG5cbiBDb3B5cmlnaHQgKGMpIDIwMTEgR2FyeSBDb3VydFxuIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuIFNPRlRXQVJFLlxuKi9cblwidXNlIHN0cmljdFwiO1xuXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gc3R5bGVSZXBsYWNlcihtYXRjaCwgcHJlZml4LCBzLCBzdWZmaXgpIHtcbiAgICAgIHJldHVybiBcIlwiICsgcHJlZml4ICsgKFwic1wiID09PSBzID8gXCJcXFxcNzMgXCIgOiBcIlxcXFw1MyBcIikgKyBzdWZmaXg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjcmlwdFJlcGxhY2VyKG1hdGNoLCBwcmVmaXgsIHMsIHN1ZmZpeCkge1xuICAgICAgcmV0dXJuIFwiXCIgKyBwcmVmaXggKyAoXCJzXCIgPT09IHMgPyBcIlxcXFx1MDA3M1wiIDogXCJcXFxcdTAwNTNcIikgKyBzdWZmaXg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICAgICAgaWYgKG51bGwgPT09IG1heWJlSXRlcmFibGUgfHwgXCJvYmplY3RcIiAhPT0gdHlwZW9mIG1heWJlSXRlcmFibGUpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgbWF5YmVJdGVyYWJsZSA9XG4gICAgICAgIChNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdKSB8fFxuICAgICAgICBtYXliZUl0ZXJhYmxlW1wiQEBpdGVyYXRvclwiXTtcbiAgICAgIHJldHVybiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBtYXliZUl0ZXJhYmxlID8gbWF5YmVJdGVyYWJsZSA6IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9iamVjdE5hbWUob2JqZWN0KSB7XG4gICAgICBvYmplY3QgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KTtcbiAgICAgIHJldHVybiBvYmplY3Quc2xpY2UoOCwgb2JqZWN0Lmxlbmd0aCAtIDEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZUtleUZvckVycm9yTWVzc2FnZShrZXkpIHtcbiAgICAgIHZhciBlbmNvZGVkS2V5ID0gSlNPTi5zdHJpbmdpZnkoa2V5KTtcbiAgICAgIHJldHVybiAnXCInICsga2V5ICsgJ1wiJyA9PT0gZW5jb2RlZEtleSA/IGtleSA6IGVuY29kZWRLZXk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlVmFsdWVGb3JFcnJvck1lc3NhZ2UodmFsdWUpIHtcbiAgICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAxMCA+PSB2YWx1ZS5sZW5ndGggPyB2YWx1ZSA6IHZhbHVlLnNsaWNlKDAsIDEwKSArIFwiLi4uXCJcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgaWYgKGlzQXJyYXlJbXBsKHZhbHVlKSkgcmV0dXJuIFwiWy4uLl1cIjtcbiAgICAgICAgICBpZiAobnVsbCAhPT0gdmFsdWUgJiYgdmFsdWUuJCR0eXBlb2YgPT09IENMSUVOVF9SRUZFUkVOQ0VfVEFHKVxuICAgICAgICAgICAgcmV0dXJuIFwiY2xpZW50XCI7XG4gICAgICAgICAgdmFsdWUgPSBvYmplY3ROYW1lKHZhbHVlKTtcbiAgICAgICAgICByZXR1cm4gXCJPYmplY3RcIiA9PT0gdmFsdWUgPyBcInsuLi59XCIgOiB2YWx1ZTtcbiAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgcmV0dXJuIHZhbHVlLiQkdHlwZW9mID09PSBDTElFTlRfUkVGRVJFTkNFX1RBR1xuICAgICAgICAgICAgPyBcImNsaWVudFwiXG4gICAgICAgICAgICA6ICh2YWx1ZSA9IHZhbHVlLmRpc3BsYXlOYW1lIHx8IHZhbHVlLm5hbWUpXG4gICAgICAgICAgICAgID8gXCJmdW5jdGlvbiBcIiArIHZhbHVlXG4gICAgICAgICAgICAgIDogXCJmdW5jdGlvblwiO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZUVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgdHlwZSkgcmV0dXJuIHR5cGU7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlTGlzdFwiO1xuICAgICAgfVxuICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiB0eXBlKVxuICAgICAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVFbGVtZW50VHlwZSh0eXBlLnJlbmRlcik7XG4gICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVFbGVtZW50VHlwZSh0eXBlLnR5cGUpO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgdmFyIHBheWxvYWQgPSB0eXBlLl9wYXlsb2FkO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVFbGVtZW50VHlwZSh0eXBlKHBheWxvYWQpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZU9iamVjdEZvckVycm9yTWVzc2FnZShvYmplY3RPckFycmF5LCBleHBhbmRlZE5hbWUpIHtcbiAgICAgIHZhciBvYmpLaW5kID0gb2JqZWN0TmFtZShvYmplY3RPckFycmF5KTtcbiAgICAgIGlmIChcIk9iamVjdFwiICE9PSBvYmpLaW5kICYmIFwiQXJyYXlcIiAhPT0gb2JqS2luZCkgcmV0dXJuIG9iaktpbmQ7XG4gICAgICB2YXIgc3RhcnQgPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gMDtcbiAgICAgIGlmIChpc0FycmF5SW1wbChvYmplY3RPckFycmF5KSlcbiAgICAgICAgaWYgKGpzeENoaWxkcmVuUGFyZW50cy5oYXMob2JqZWN0T3JBcnJheSkpIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IGpzeENoaWxkcmVuUGFyZW50cy5nZXQob2JqZWN0T3JBcnJheSk7XG4gICAgICAgICAgb2JqS2luZCA9IFwiPFwiICsgZGVzY3JpYmVFbGVtZW50VHlwZSh0eXBlKSArIFwiPlwiO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0T3JBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gb2JqZWN0T3JBcnJheVtpXTtcbiAgICAgICAgICAgIHZhbHVlID1cbiAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHZhbHVlXG4gICAgICAgICAgICAgICAgPyB2YWx1ZVxuICAgICAgICAgICAgICAgIDogXCJvYmplY3RcIiA9PT0gdHlwZW9mIHZhbHVlICYmIG51bGwgIT09IHZhbHVlXG4gICAgICAgICAgICAgICAgICA/IFwie1wiICsgZGVzY3JpYmVPYmplY3RGb3JFcnJvck1lc3NhZ2UodmFsdWUpICsgXCJ9XCJcbiAgICAgICAgICAgICAgICAgIDogXCJ7XCIgKyBkZXNjcmliZVZhbHVlRm9yRXJyb3JNZXNzYWdlKHZhbHVlKSArIFwifVwiO1xuICAgICAgICAgICAgXCJcIiArIGkgPT09IGV4cGFuZGVkTmFtZVxuICAgICAgICAgICAgICA/ICgoc3RhcnQgPSBvYmpLaW5kLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgKGxlbmd0aCA9IHZhbHVlLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgKG9iaktpbmQgKz0gdmFsdWUpKVxuICAgICAgICAgICAgICA6IChvYmpLaW5kID1cbiAgICAgICAgICAgICAgICAgIDE1ID4gdmFsdWUubGVuZ3RoICYmIDQwID4gb2JqS2luZC5sZW5ndGggKyB2YWx1ZS5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgPyBvYmpLaW5kICsgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgOiBvYmpLaW5kICsgXCJ7Li4ufVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb2JqS2luZCArPSBcIjwvXCIgKyBkZXNjcmliZUVsZW1lbnRUeXBlKHR5cGUpICsgXCI+XCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2JqS2luZCA9IFwiW1wiO1xuICAgICAgICAgIGZvciAodHlwZSA9IDA7IHR5cGUgPCBvYmplY3RPckFycmF5Lmxlbmd0aDsgdHlwZSsrKVxuICAgICAgICAgICAgMCA8IHR5cGUgJiYgKG9iaktpbmQgKz0gXCIsIFwiKSxcbiAgICAgICAgICAgICAgKGkgPSBvYmplY3RPckFycmF5W3R5cGVdKSxcbiAgICAgICAgICAgICAgKGkgPVxuICAgICAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBpICYmIG51bGwgIT09IGlcbiAgICAgICAgICAgICAgICAgID8gZGVzY3JpYmVPYmplY3RGb3JFcnJvck1lc3NhZ2UoaSlcbiAgICAgICAgICAgICAgICAgIDogZGVzY3JpYmVWYWx1ZUZvckVycm9yTWVzc2FnZShpKSksXG4gICAgICAgICAgICAgIFwiXCIgKyB0eXBlID09PSBleHBhbmRlZE5hbWVcbiAgICAgICAgICAgICAgICA/ICgoc3RhcnQgPSBvYmpLaW5kLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgICAobGVuZ3RoID0gaS5sZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgKG9iaktpbmQgKz0gaSkpXG4gICAgICAgICAgICAgICAgOiAob2JqS2luZCA9XG4gICAgICAgICAgICAgICAgICAgIDEwID4gaS5sZW5ndGggJiYgNDAgPiBvYmpLaW5kLmxlbmd0aCArIGkubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgPyBvYmpLaW5kICsgaVxuICAgICAgICAgICAgICAgICAgICAgIDogb2JqS2luZCArIFwiLi4uXCIpO1xuICAgICAgICAgIG9iaktpbmQgKz0gXCJdXCI7XG4gICAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG9iamVjdE9yQXJyYXkuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSlcbiAgICAgICAgb2JqS2luZCA9IFwiPFwiICsgZGVzY3JpYmVFbGVtZW50VHlwZShvYmplY3RPckFycmF5LnR5cGUpICsgXCIvPlwiO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChvYmplY3RPckFycmF5LiQkdHlwZW9mID09PSBDTElFTlRfUkVGRVJFTkNFX1RBRykgcmV0dXJuIFwiY2xpZW50XCI7XG4gICAgICAgIGlmIChqc3hQcm9wc1BhcmVudHMuaGFzKG9iamVjdE9yQXJyYXkpKSB7XG4gICAgICAgICAgb2JqS2luZCA9IGpzeFByb3BzUGFyZW50cy5nZXQob2JqZWN0T3JBcnJheSk7XG4gICAgICAgICAgb2JqS2luZCA9IFwiPFwiICsgKGRlc2NyaWJlRWxlbWVudFR5cGUob2JqS2luZCkgfHwgXCIuLi5cIik7XG4gICAgICAgICAgdHlwZSA9IE9iamVjdC5rZXlzKG9iamVjdE9yQXJyYXkpO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0eXBlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBvYmpLaW5kICs9IFwiIFwiO1xuICAgICAgICAgICAgdmFsdWUgPSB0eXBlW2ldO1xuICAgICAgICAgICAgb2JqS2luZCArPSBkZXNjcmliZUtleUZvckVycm9yTWVzc2FnZSh2YWx1ZSkgKyBcIj1cIjtcbiAgICAgICAgICAgIHZhciBfdmFsdWUyID0gb2JqZWN0T3JBcnJheVt2YWx1ZV07XG4gICAgICAgICAgICB2YXIgX3N1YnN0cjIgPVxuICAgICAgICAgICAgICB2YWx1ZSA9PT0gZXhwYW5kZWROYW1lICYmXG4gICAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBfdmFsdWUyICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IF92YWx1ZTJcbiAgICAgICAgICAgICAgICA/IGRlc2NyaWJlT2JqZWN0Rm9yRXJyb3JNZXNzYWdlKF92YWx1ZTIpXG4gICAgICAgICAgICAgICAgOiBkZXNjcmliZVZhbHVlRm9yRXJyb3JNZXNzYWdlKF92YWx1ZTIpO1xuICAgICAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIF92YWx1ZTIgJiYgKF9zdWJzdHIyID0gXCJ7XCIgKyBfc3Vic3RyMiArIFwifVwiKTtcbiAgICAgICAgICAgIHZhbHVlID09PSBleHBhbmRlZE5hbWVcbiAgICAgICAgICAgICAgPyAoKHN0YXJ0ID0gb2JqS2luZC5sZW5ndGgpLFxuICAgICAgICAgICAgICAgIChsZW5ndGggPSBfc3Vic3RyMi5sZW5ndGgpLFxuICAgICAgICAgICAgICAgIChvYmpLaW5kICs9IF9zdWJzdHIyKSlcbiAgICAgICAgICAgICAgOiAob2JqS2luZCA9XG4gICAgICAgICAgICAgICAgICAxMCA+IF9zdWJzdHIyLmxlbmd0aCAmJiA0MCA+IG9iaktpbmQubGVuZ3RoICsgX3N1YnN0cjIubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgID8gb2JqS2luZCArIF9zdWJzdHIyXG4gICAgICAgICAgICAgICAgICAgIDogb2JqS2luZCArIFwiLi4uXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvYmpLaW5kICs9IFwiPlwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9iaktpbmQgPSBcIntcIjtcbiAgICAgICAgICB0eXBlID0gT2JqZWN0LmtleXMob2JqZWN0T3JBcnJheSk7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IHR5cGUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAwIDwgaSAmJiAob2JqS2luZCArPSBcIiwgXCIpLFxuICAgICAgICAgICAgICAodmFsdWUgPSB0eXBlW2ldKSxcbiAgICAgICAgICAgICAgKG9iaktpbmQgKz0gZGVzY3JpYmVLZXlGb3JFcnJvck1lc3NhZ2UodmFsdWUpICsgXCI6IFwiKSxcbiAgICAgICAgICAgICAgKF92YWx1ZTIgPSBvYmplY3RPckFycmF5W3ZhbHVlXSksXG4gICAgICAgICAgICAgIChfdmFsdWUyID1cbiAgICAgICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgX3ZhbHVlMiAmJiBudWxsICE9PSBfdmFsdWUyXG4gICAgICAgICAgICAgICAgICA/IGRlc2NyaWJlT2JqZWN0Rm9yRXJyb3JNZXNzYWdlKF92YWx1ZTIpXG4gICAgICAgICAgICAgICAgICA6IGRlc2NyaWJlVmFsdWVGb3JFcnJvck1lc3NhZ2UoX3ZhbHVlMikpLFxuICAgICAgICAgICAgICB2YWx1ZSA9PT0gZXhwYW5kZWROYW1lXG4gICAgICAgICAgICAgICAgPyAoKHN0YXJ0ID0gb2JqS2luZC5sZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgKGxlbmd0aCA9IF92YWx1ZTIubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgIChvYmpLaW5kICs9IF92YWx1ZTIpKVxuICAgICAgICAgICAgICAgIDogKG9iaktpbmQgPVxuICAgICAgICAgICAgICAgICAgICAxMCA+IF92YWx1ZTIubGVuZ3RoICYmIDQwID4gb2JqS2luZC5sZW5ndGggKyBfdmFsdWUyLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgID8gb2JqS2luZCArIF92YWx1ZTJcbiAgICAgICAgICAgICAgICAgICAgICA6IG9iaktpbmQgKyBcIi4uLlwiKTtcbiAgICAgICAgICBvYmpLaW5kICs9IFwifVwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdm9pZCAwID09PSBleHBhbmRlZE5hbWVcbiAgICAgICAgPyBvYmpLaW5kXG4gICAgICAgIDogLTEgPCBzdGFydCAmJiAwIDwgbGVuZ3RoXG4gICAgICAgICAgPyAoKG9iamVjdE9yQXJyYXkgPSBcIiBcIi5yZXBlYXQoc3RhcnQpICsgXCJeXCIucmVwZWF0KGxlbmd0aCkpLFxuICAgICAgICAgICAgXCJcXG4gIFwiICsgb2JqS2luZCArIFwiXFxuICBcIiArIG9iamVjdE9yQXJyYXkpXG4gICAgICAgICAgOiBcIlxcbiAgXCIgKyBvYmpLaW5kO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtdXJtdXJoYXNoM18zMl9nYyhrZXksIHNlZWQpIHtcbiAgICAgIHZhciByZW1haW5kZXIgPSBrZXkubGVuZ3RoICYgMztcbiAgICAgIHZhciBieXRlcyA9IGtleS5sZW5ndGggLSByZW1haW5kZXI7XG4gICAgICB2YXIgaDEgPSBzZWVkO1xuICAgICAgZm9yIChzZWVkID0gMDsgc2VlZCA8IGJ5dGVzOyApIHtcbiAgICAgICAgdmFyIGsxID1cbiAgICAgICAgICAoa2V5LmNoYXJDb2RlQXQoc2VlZCkgJiAyNTUpIHxcbiAgICAgICAgICAoKGtleS5jaGFyQ29kZUF0KCsrc2VlZCkgJiAyNTUpIDw8IDgpIHxcbiAgICAgICAgICAoKGtleS5jaGFyQ29kZUF0KCsrc2VlZCkgJiAyNTUpIDw8IDE2KSB8XG4gICAgICAgICAgKChrZXkuY2hhckNvZGVBdCgrK3NlZWQpICYgMjU1KSA8PCAyNCk7XG4gICAgICAgICsrc2VlZDtcbiAgICAgICAgazEgPVxuICAgICAgICAgICgzNDMyOTE4MzUzICogKGsxICYgNjU1MzUpICtcbiAgICAgICAgICAgICgoKDM0MzI5MTgzNTMgKiAoazEgPj4+IDE2KSkgJiA2NTUzNSkgPDwgMTYpKSAmXG4gICAgICAgICAgNDI5NDk2NzI5NTtcbiAgICAgICAgazEgPSAoazEgPDwgMTUpIHwgKGsxID4+PiAxNyk7XG4gICAgICAgIGsxID1cbiAgICAgICAgICAoNDYxODQ1OTA3ICogKGsxICYgNjU1MzUpICtcbiAgICAgICAgICAgICgoKDQ2MTg0NTkwNyAqIChrMSA+Pj4gMTYpKSAmIDY1NTM1KSA8PCAxNikpICZcbiAgICAgICAgICA0Mjk0OTY3Mjk1O1xuICAgICAgICBoMSBePSBrMTtcbiAgICAgICAgaDEgPSAoaDEgPDwgMTMpIHwgKGgxID4+PiAxOSk7XG4gICAgICAgIGgxID1cbiAgICAgICAgICAoNSAqIChoMSAmIDY1NTM1KSArICgoKDUgKiAoaDEgPj4+IDE2KSkgJiA2NTUzNSkgPDwgMTYpKSAmIDQyOTQ5NjcyOTU7XG4gICAgICAgIGgxID0gKGgxICYgNjU1MzUpICsgMjc0OTIgKyAoKCgoaDEgPj4+IDE2KSArIDU4OTY0KSAmIDY1NTM1KSA8PCAxNik7XG4gICAgICB9XG4gICAgICBrMSA9IDA7XG4gICAgICBzd2l0Y2ggKHJlbWFpbmRlcikge1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgazEgXj0gKGtleS5jaGFyQ29kZUF0KHNlZWQgKyAyKSAmIDI1NSkgPDwgMTY7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBrMSBePSAoa2V5LmNoYXJDb2RlQXQoc2VlZCArIDEpICYgMjU1KSA8PCA4O1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgKGsxIF49IGtleS5jaGFyQ29kZUF0KHNlZWQpICYgMjU1KSxcbiAgICAgICAgICAgIChrMSA9XG4gICAgICAgICAgICAgICgzNDMyOTE4MzUzICogKGsxICYgNjU1MzUpICtcbiAgICAgICAgICAgICAgICAoKCgzNDMyOTE4MzUzICogKGsxID4+PiAxNikpICYgNjU1MzUpIDw8IDE2KSkgJlxuICAgICAgICAgICAgICA0Mjk0OTY3Mjk1KSxcbiAgICAgICAgICAgIChrMSA9IChrMSA8PCAxNSkgfCAoazEgPj4+IDE3KSksXG4gICAgICAgICAgICAoaDEgXj1cbiAgICAgICAgICAgICAgKDQ2MTg0NTkwNyAqIChrMSAmIDY1NTM1KSArXG4gICAgICAgICAgICAgICAgKCgoNDYxODQ1OTA3ICogKGsxID4+PiAxNikpICYgNjU1MzUpIDw8IDE2KSkgJlxuICAgICAgICAgICAgICA0Mjk0OTY3Mjk1KTtcbiAgICAgIH1cbiAgICAgIGgxIF49IGtleS5sZW5ndGg7XG4gICAgICBoMSBePSBoMSA+Pj4gMTY7XG4gICAgICBoMSA9XG4gICAgICAgICgyMjQ2ODIyNTA3ICogKGgxICYgNjU1MzUpICtcbiAgICAgICAgICAoKCgyMjQ2ODIyNTA3ICogKGgxID4+PiAxNikpICYgNjU1MzUpIDw8IDE2KSkgJlxuICAgICAgICA0Mjk0OTY3Mjk1O1xuICAgICAgaDEgXj0gaDEgPj4+IDEzO1xuICAgICAgaDEgPVxuICAgICAgICAoMzI2NjQ4OTkwOSAqIChoMSAmIDY1NTM1KSArXG4gICAgICAgICAgKCgoMzI2NjQ4OTkwOSAqIChoMSA+Pj4gMTYpKSAmIDY1NTM1KSA8PCAxNikpICZcbiAgICAgICAgNDI5NDk2NzI5NTtcbiAgICAgIHJldHVybiAoaDEgXiAoaDEgPj4+IDE2KSkgPj4+IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHR5cGVOYW1lKHZhbHVlKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgU3ltYm9sICYmXG4gICAgICAgICAgU3ltYm9sLnRvU3RyaW5nVGFnICYmXG4gICAgICAgICAgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSkgfHxcbiAgICAgICAgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fFxuICAgICAgICBcIk9iamVjdFwiXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSksICExO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gITA7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIFwiXCIgKyB2YWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbih2YWx1ZSwgYXR0cmlidXRlTmFtZSkge1xuICAgICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJUaGUgcHJvdmlkZWQgYCVzYCBhdHRyaWJ1dGUgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4gVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIHVzaW5nIGl0IGhlcmUuXCIsXG4gICAgICAgICAgICBhdHRyaWJ1dGVOYW1lLFxuICAgICAgICAgICAgdHlwZU5hbWUodmFsdWUpXG4gICAgICAgICAgKSxcbiAgICAgICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpXG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrQ1NTUHJvcGVydHlTdHJpbmdDb2VyY2lvbih2YWx1ZSwgcHJvcE5hbWUpIHtcbiAgICAgIGlmICh3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiVGhlIHByb3ZpZGVkIGAlc2AgQ1NTIHByb3BlcnR5IGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSB1c2luZyBpdCBoZXJlLlwiLFxuICAgICAgICAgICAgcHJvcE5hbWUsXG4gICAgICAgICAgICB0eXBlTmFtZSh2YWx1ZSlcbiAgICAgICAgICApLFxuICAgICAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSlcbiAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tIdG1sU3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgICAgIGlmICh3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiVGhlIHByb3ZpZGVkIEhUTUwgbWFya3VwIHVzZXMgYSB2YWx1ZSBvZiB1bnN1cHBvcnRlZCB0eXBlICVzLiBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgdXNpbmcgaXQgaGVyZS5cIixcbiAgICAgICAgICAgIHR5cGVOYW1lKHZhbHVlKVxuICAgICAgICAgICksXG4gICAgICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKVxuICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0F0dHJpYnV0ZU5hbWVTYWZlKGF0dHJpYnV0ZU5hbWUpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZSwgYXR0cmlidXRlTmFtZSkpXG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUsIGF0dHJpYnV0ZU5hbWUpKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICBpZiAoVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVgudGVzdChhdHRyaWJ1dGVOYW1lKSlcbiAgICAgICAgcmV0dXJuICh2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGVbYXR0cmlidXRlTmFtZV0gPSAhMCk7XG4gICAgICBpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdID0gITA7XG4gICAgICBjb25zb2xlLmVycm9yKFwiSW52YWxpZCBhdHRyaWJ1dGUgbmFtZTogYCVzYFwiLCBhdHRyaWJ1dGVOYW1lKTtcbiAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tDb250cm9sbGVkVmFsdWVQcm9wcyh0YWdOYW1lLCBwcm9wcykge1xuICAgICAgaGFzUmVhZE9ubHlWYWx1ZVtwcm9wcy50eXBlXSB8fFxuICAgICAgICBwcm9wcy5vbkNoYW5nZSB8fFxuICAgICAgICBwcm9wcy5vbklucHV0IHx8XG4gICAgICAgIHByb3BzLnJlYWRPbmx5IHx8XG4gICAgICAgIHByb3BzLmRpc2FibGVkIHx8XG4gICAgICAgIG51bGwgPT0gcHJvcHMudmFsdWUgfHxcbiAgICAgICAgKFwic2VsZWN0XCIgPT09IHRhZ05hbWVcbiAgICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiWW91IHByb3ZpZGVkIGEgYHZhbHVlYCBwcm9wIHRvIGEgZm9ybSBmaWVsZCB3aXRob3V0IGFuIGBvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgdGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdFZhbHVlYC4gT3RoZXJ3aXNlLCBzZXQgYG9uQ2hhbmdlYC5cIlxuICAgICAgICAgICAgKVxuICAgICAgICAgIDogY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJZb3UgcHJvdmlkZWQgYSBgdmFsdWVgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gYG9uQ2hhbmdlYCBoYW5kbGVyLiBUaGlzIHdpbGwgcmVuZGVyIGEgcmVhZC1vbmx5IGZpZWxkLiBJZiB0aGUgZmllbGQgc2hvdWxkIGJlIG11dGFibGUgdXNlIGBkZWZhdWx0VmFsdWVgLiBPdGhlcndpc2UsIHNldCBlaXRoZXIgYG9uQ2hhbmdlYCBvciBgcmVhZE9ubHlgLlwiXG4gICAgICAgICAgICApKTtcbiAgICAgIHByb3BzLm9uQ2hhbmdlIHx8XG4gICAgICAgIHByb3BzLnJlYWRPbmx5IHx8XG4gICAgICAgIHByb3BzLmRpc2FibGVkIHx8XG4gICAgICAgIG51bGwgPT0gcHJvcHMuY2hlY2tlZCB8fFxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiWW91IHByb3ZpZGVkIGEgYGNoZWNrZWRgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gYG9uQ2hhbmdlYCBoYW5kbGVyLiBUaGlzIHdpbGwgcmVuZGVyIGEgcmVhZC1vbmx5IGZpZWxkLiBJZiB0aGUgZmllbGQgc2hvdWxkIGJlIG11dGFibGUgdXNlIGBkZWZhdWx0Q2hlY2tlZGAuIE90aGVyd2lzZSwgc2V0IGVpdGhlciBgb25DaGFuZ2VgIG9yIGByZWFkT25seWAuXCJcbiAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0eSQxKHRhZ05hbWUsIG5hbWUpIHtcbiAgICAgIGlmIChcbiAgICAgICAgaGFzT3duUHJvcGVydHkuY2FsbCh3YXJuZWRQcm9wZXJ0aWVzJDEsIG5hbWUpICYmXG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXVxuICAgICAgKVxuICAgICAgICByZXR1cm4gITA7XG4gICAgICBpZiAockFSSUFDYW1lbCQxLnRlc3QobmFtZSkpIHtcbiAgICAgICAgdGFnTmFtZSA9IFwiYXJpYS1cIiArIG5hbWUuc2xpY2UoNCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdGFnTmFtZSA9IGFyaWFQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KHRhZ05hbWUpID8gdGFnTmFtZSA6IG51bGw7XG4gICAgICAgIGlmIChudWxsID09IHRhZ05hbWUpXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiSW52YWxpZCBBUklBIGF0dHJpYnV0ZSBgJXNgLiBBUklBIGF0dHJpYnV0ZXMgZm9sbG93IHRoZSBwYXR0ZXJuIGFyaWEtKiBhbmQgbXVzdCBiZSBsb3dlcmNhc2UuXCIsXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICAod2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gITApXG4gICAgICAgICAgKTtcbiAgICAgICAgaWYgKG5hbWUgIT09IHRhZ05hbWUpXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiSW52YWxpZCBBUklBIGF0dHJpYnV0ZSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD9cIixcbiAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgdGFnTmFtZVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICh3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSAhMClcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHJBUklBJDEudGVzdChuYW1lKSkge1xuICAgICAgICB0YWdOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB0YWdOYW1lID0gYXJpYVByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkodGFnTmFtZSkgPyB0YWdOYW1lIDogbnVsbDtcbiAgICAgICAgaWYgKG51bGwgPT0gdGFnTmFtZSkgcmV0dXJuICh3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSAhMCksICExO1xuICAgICAgICBuYW1lICE9PSB0YWdOYW1lICYmXG4gICAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIlVua25vd24gQVJJQSBhdHRyaWJ1dGUgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/XCIsXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgdGFnTmFtZVxuICAgICAgICAgICksXG4gICAgICAgICAgKHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9ICEwKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gITA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyQyKHR5cGUsIHByb3BzKSB7XG4gICAgICB2YXIgaW52YWxpZFByb3BzID0gW10sXG4gICAgICAgIGtleTtcbiAgICAgIGZvciAoa2V5IGluIHByb3BzKVxuICAgICAgICB2YWxpZGF0ZVByb3BlcnR5JDEodHlwZSwga2V5KSB8fCBpbnZhbGlkUHJvcHMucHVzaChrZXkpO1xuICAgICAgcHJvcHMgPSBpbnZhbGlkUHJvcHNcbiAgICAgICAgLm1hcChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgIHJldHVybiBcImBcIiArIHByb3AgKyBcImBcIjtcbiAgICAgICAgfSlcbiAgICAgICAgLmpvaW4oXCIsIFwiKTtcbiAgICAgIDEgPT09IGludmFsaWRQcm9wcy5sZW5ndGhcbiAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJJbnZhbGlkIGFyaWEgcHJvcCAlcyBvbiA8JXM+IHRhZy4gRm9yIGRldGFpbHMsIHNlZSBodHRwczovL3JlYWN0LmRldi9saW5rL2ludmFsaWQtYXJpYS1wcm9wc1wiLFxuICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICB0eXBlXG4gICAgICAgICAgKVxuICAgICAgICA6IDEgPCBpbnZhbGlkUHJvcHMubGVuZ3RoICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiSW52YWxpZCBhcmlhIHByb3BzICVzIG9uIDwlcz4gdGFnLiBGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvaW52YWxpZC1hcmlhLXByb3BzXCIsXG4gICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgIHR5cGVcbiAgICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnR5KHRhZ05hbWUsIG5hbWUsIHZhbHVlLCBldmVudFJlZ2lzdHJ5KSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh3YXJuZWRQcm9wZXJ0aWVzLCBuYW1lKSAmJiB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdKVxuICAgICAgICByZXR1cm4gITA7XG4gICAgICB2YXIgbG93ZXJDYXNlZE5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAoXCJvbmZvY3VzaW5cIiA9PT0gbG93ZXJDYXNlZE5hbWUgfHwgXCJvbmZvY3Vzb3V0XCIgPT09IGxvd2VyQ2FzZWROYW1lKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIlJlYWN0IHVzZXMgb25Gb2N1cyBhbmQgb25CbHVyIGluc3RlYWQgb2Ygb25Gb2N1c0luIGFuZCBvbkZvY3VzT3V0LiBBbGwgUmVhY3QgZXZlbnRzIGFyZSBub3JtYWxpemVkIHRvIGJ1YmJsZSwgc28gb25Gb2N1c0luIGFuZCBvbkZvY3VzT3V0IGFyZSBub3QgbmVlZGVkL3N1cHBvcnRlZCBieSBSZWFjdC5cIlxuICAgICAgICAgICksXG4gICAgICAgICAgKHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSAhMClcbiAgICAgICAgKTtcbiAgICAgIGlmIChcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdmFsdWUgJiZcbiAgICAgICAgKChcImZvcm1cIiA9PT0gdGFnTmFtZSAmJiBcImFjdGlvblwiID09PSBuYW1lKSB8fFxuICAgICAgICAgIChcImlucHV0XCIgPT09IHRhZ05hbWUgJiYgXCJmb3JtQWN0aW9uXCIgPT09IG5hbWUpIHx8XG4gICAgICAgICAgKFwiYnV0dG9uXCIgPT09IHRhZ05hbWUgJiYgXCJmb3JtQWN0aW9uXCIgPT09IG5hbWUpKVxuICAgICAgKVxuICAgICAgICByZXR1cm4gITA7XG4gICAgICBpZiAobnVsbCAhPSBldmVudFJlZ2lzdHJ5KSB7XG4gICAgICAgIHRhZ05hbWUgPSBldmVudFJlZ2lzdHJ5LnBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXM7XG4gICAgICAgIGlmIChldmVudFJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMuaGFzT3duUHJvcGVydHkobmFtZSkpXG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICBldmVudFJlZ2lzdHJ5ID0gdGFnTmFtZS5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSlcbiAgICAgICAgICA/IHRhZ05hbWVbbG93ZXJDYXNlZE5hbWVdXG4gICAgICAgICAgOiBudWxsO1xuICAgICAgICBpZiAobnVsbCAhPSBldmVudFJlZ2lzdHJ5KVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIkludmFsaWQgZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD9cIixcbiAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgZXZlbnRSZWdpc3RyeVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICh3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gITApXG4gICAgICAgICAgKTtcbiAgICAgICAgaWYgKEVWRU5UX05BTUVfUkVHRVgudGVzdChuYW1lKSlcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJVbmtub3duIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgYCVzYC4gSXQgd2lsbCBiZSBpZ25vcmVkLlwiLFxuICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgKHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSAhMClcbiAgICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmIChFVkVOVF9OQU1FX1JFR0VYLnRlc3QobmFtZSkpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgSU5WQUxJRF9FVkVOVF9OQU1FX1JFR0VYLnRlc3QobmFtZSkgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiSW52YWxpZCBldmVudCBoYW5kbGVyIHByb3BlcnR5IGAlc2AuIFJlYWN0IGV2ZW50cyB1c2UgdGhlIGNhbWVsQ2FzZSBuYW1pbmcgY29udmVudGlvbiwgZm9yIGV4YW1wbGUgYG9uQ2xpY2tgLlwiLFxuICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICApLFxuICAgICAgICAgICh3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gITApXG4gICAgICAgICk7XG4gICAgICBpZiAockFSSUEudGVzdChuYW1lKSB8fCByQVJJQUNhbWVsLnRlc3QobmFtZSkpIHJldHVybiAhMDtcbiAgICAgIGlmIChcImlubmVyaHRtbFwiID09PSBsb3dlckNhc2VkTmFtZSlcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJEaXJlY3RseSBzZXR0aW5nIHByb3BlcnR5IGBpbm5lckhUTUxgIGlzIG5vdCBwZXJtaXR0ZWQuIEZvciBtb3JlIGluZm9ybWF0aW9uLCBsb29rdXAgZG9jdW1lbnRhdGlvbiBvbiBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLlwiXG4gICAgICAgICAgKSxcbiAgICAgICAgICAod2FybmVkUHJvcGVydGllc1tuYW1lXSA9ICEwKVxuICAgICAgICApO1xuICAgICAgaWYgKFwiYXJpYVwiID09PSBsb3dlckNhc2VkTmFtZSlcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJUaGUgYGFyaWFgIGF0dHJpYnV0ZSBpcyByZXNlcnZlZCBmb3IgZnV0dXJlIHVzZSBpbiBSZWFjdC4gUGFzcyBpbmRpdmlkdWFsIGBhcmlhLWAgYXR0cmlidXRlcyBpbnN0ZWFkLlwiXG4gICAgICAgICAgKSxcbiAgICAgICAgICAod2FybmVkUHJvcGVydGllc1tuYW1lXSA9ICEwKVxuICAgICAgICApO1xuICAgICAgaWYgKFxuICAgICAgICBcImlzXCIgPT09IGxvd2VyQ2FzZWROYW1lICYmXG4gICAgICAgIG51bGwgIT09IHZhbHVlICYmXG4gICAgICAgIHZvaWQgMCAhPT0gdmFsdWUgJiZcbiAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIHZhbHVlXG4gICAgICApXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiUmVjZWl2ZWQgYSBgJXNgIGZvciBhIHN0cmluZyBhdHRyaWJ1dGUgYGlzYC4gSWYgdGhpcyBpcyBleHBlY3RlZCwgY2FzdCB0aGUgdmFsdWUgdG8gYSBzdHJpbmcuXCIsXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWVcbiAgICAgICAgICApLFxuICAgICAgICAgICh3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gITApXG4gICAgICAgICk7XG4gICAgICBpZiAoXCJudW1iZXJcIiA9PT0gdHlwZW9mIHZhbHVlICYmIGlzTmFOKHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJSZWNlaXZlZCBOYU4gZm9yIHRoZSBgJXNgIGF0dHJpYnV0ZS4gSWYgdGhpcyBpcyBleHBlY3RlZCwgY2FzdCB0aGUgdmFsdWUgdG8gYSBzdHJpbmcuXCIsXG4gICAgICAgICAgICBuYW1lXG4gICAgICAgICAgKSxcbiAgICAgICAgICAod2FybmVkUHJvcGVydGllc1tuYW1lXSA9ICEwKVxuICAgICAgICApO1xuICAgICAgaWYgKHBvc3NpYmxlU3RhbmRhcmROYW1lcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICgobG93ZXJDYXNlZE5hbWUgPSBwb3NzaWJsZVN0YW5kYXJkTmFtZXNbbG93ZXJDYXNlZE5hbWVdKSxcbiAgICAgICAgICBsb3dlckNhc2VkTmFtZSAhPT0gbmFtZSlcbiAgICAgICAgKVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIkludmFsaWQgRE9NIHByb3BlcnR5IGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgP1wiLFxuICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICBsb3dlckNhc2VkTmFtZVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICh3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gITApXG4gICAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAobmFtZSAhPT0gbG93ZXJDYXNlZE5hbWUpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiUmVhY3QgZG9lcyBub3QgcmVjb2duaXplIHRoZSBgJXNgIHByb3Agb24gYSBET00gZWxlbWVudC4gSWYgeW91IGludGVudGlvbmFsbHkgd2FudCBpdCB0byBhcHBlYXIgaW4gdGhlIERPTSBhcyBhIGN1c3RvbSBhdHRyaWJ1dGUsIHNwZWxsIGl0IGFzIGxvd2VyY2FzZSBgJXNgIGluc3RlYWQuIElmIHlvdSBhY2NpZGVudGFsbHkgcGFzc2VkIGl0IGZyb20gYSBwYXJlbnQgY29tcG9uZW50LCByZW1vdmUgaXQgZnJvbSB0aGUgRE9NIGVsZW1lbnQuXCIsXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgbG93ZXJDYXNlZE5hbWVcbiAgICAgICAgICApLFxuICAgICAgICAgICh3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gITApXG4gICAgICAgICk7XG4gICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICBjYXNlIFwic3R5bGVcIjpcbiAgICAgICAgY2FzZSBcInN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZ1wiOlxuICAgICAgICBjYXNlIFwic3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nXCI6XG4gICAgICAgIGNhc2UgXCJkZWZhdWx0VmFsdWVcIjpcbiAgICAgICAgY2FzZSBcImRlZmF1bHRDaGVja2VkXCI6XG4gICAgICAgIGNhc2UgXCJpbm5lckhUTUxcIjpcbiAgICAgICAgY2FzZSBcInJlZlwiOlxuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgY2FzZSBcImlubmVyVGV4dFwiOlxuICAgICAgICBjYXNlIFwidGV4dENvbnRlbnRcIjpcbiAgICAgICAgICByZXR1cm4gITA7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICAgICAgY2FzZSBcImF1dG9Gb2N1c1wiOlxuICAgICAgICAgICAgY2FzZSBcImNoZWNrZWRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJtdWx0aXBsZVwiOlxuICAgICAgICAgICAgY2FzZSBcIm11dGVkXCI6XG4gICAgICAgICAgICBjYXNlIFwic2VsZWN0ZWRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJjb250ZW50RWRpdGFibGVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJzcGVsbENoZWNrXCI6XG4gICAgICAgICAgICBjYXNlIFwiZHJhZ2dhYmxlXCI6XG4gICAgICAgICAgICBjYXNlIFwidmFsdWVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJhdXRvUmV2ZXJzZVwiOlxuICAgICAgICAgICAgY2FzZSBcImV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJmb2N1c2FibGVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJwcmVzZXJ2ZUFscGhhXCI6XG4gICAgICAgICAgICBjYXNlIFwiYWxsb3dGdWxsU2NyZWVuXCI6XG4gICAgICAgICAgICBjYXNlIFwiYXN5bmNcIjpcbiAgICAgICAgICAgIGNhc2UgXCJhdXRvUGxheVwiOlxuICAgICAgICAgICAgY2FzZSBcImNvbnRyb2xzXCI6XG4gICAgICAgICAgICBjYXNlIFwiZGVmYXVsdFwiOlxuICAgICAgICAgICAgY2FzZSBcImRlZmVyXCI6XG4gICAgICAgICAgICBjYXNlIFwiZGlzYWJsZWRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJkaXNhYmxlUGljdHVyZUluUGljdHVyZVwiOlxuICAgICAgICAgICAgY2FzZSBcImRpc2FibGVSZW1vdGVQbGF5YmFja1wiOlxuICAgICAgICAgICAgY2FzZSBcImZvcm1Ob1ZhbGlkYXRlXCI6XG4gICAgICAgICAgICBjYXNlIFwiaGlkZGVuXCI6XG4gICAgICAgICAgICBjYXNlIFwibG9vcFwiOlxuICAgICAgICAgICAgY2FzZSBcIm5vTW9kdWxlXCI6XG4gICAgICAgICAgICBjYXNlIFwibm9WYWxpZGF0ZVwiOlxuICAgICAgICAgICAgY2FzZSBcIm9wZW5cIjpcbiAgICAgICAgICAgIGNhc2UgXCJwbGF5c0lubGluZVwiOlxuICAgICAgICAgICAgY2FzZSBcInJlYWRPbmx5XCI6XG4gICAgICAgICAgICBjYXNlIFwicmVxdWlyZWRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJyZXZlcnNlZFwiOlxuICAgICAgICAgICAgY2FzZSBcInNjb3BlZFwiOlxuICAgICAgICAgICAgY2FzZSBcInNlYW1sZXNzXCI6XG4gICAgICAgICAgICBjYXNlIFwiaXRlbVNjb3BlXCI6XG4gICAgICAgICAgICBjYXNlIFwiY2FwdHVyZVwiOlxuICAgICAgICAgICAgY2FzZSBcImRvd25sb2FkXCI6XG4gICAgICAgICAgICBjYXNlIFwiaW5lcnRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgbG93ZXJDYXNlZE5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCkuc2xpY2UoMCwgNSk7XG4gICAgICAgICAgICAgIGlmIChcImRhdGEtXCIgPT09IGxvd2VyQ2FzZWROYW1lIHx8IFwiYXJpYS1cIiA9PT0gbG93ZXJDYXNlZE5hbWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgJ1JlY2VpdmVkIGAlc2AgZm9yIGEgbm9uLWJvb2xlYW4gYXR0cmlidXRlIGAlc2AuXFxuXFxuSWYgeW91IHdhbnQgdG8gd3JpdGUgaXQgdG8gdGhlIERPTSwgcGFzcyBhIHN0cmluZyBpbnN0ZWFkOiAlcz1cIiVzXCIgb3IgJXM9e3ZhbHVlLnRvU3RyaW5nKCl9LicsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIDogY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgJ1JlY2VpdmVkIGAlc2AgZm9yIGEgbm9uLWJvb2xlYW4gYXR0cmlidXRlIGAlc2AuXFxuXFxuSWYgeW91IHdhbnQgdG8gd3JpdGUgaXQgdG8gdGhlIERPTSwgcGFzcyBhIHN0cmluZyBpbnN0ZWFkOiAlcz1cIiVzXCIgb3IgJXM9e3ZhbHVlLnRvU3RyaW5nKCl9LlxcblxcbklmIHlvdSB1c2VkIHRvIGNvbmRpdGlvbmFsbHkgb21pdCBpdCB3aXRoICVzPXtjb25kaXRpb24gJiYgdmFsdWV9LCBwYXNzICVzPXtjb25kaXRpb24gPyB2YWx1ZSA6IHVuZGVmaW5lZH0gaW5zdGVhZC4nLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJldHVybiAod2FybmVkUHJvcGVydGllc1tuYW1lXSA9ICEwKTtcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICBjYXNlIFwic3ltYm9sXCI6XG4gICAgICAgICAgcmV0dXJuICh3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gITApLCAhMTtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgIGlmIChcImZhbHNlXCIgPT09IHZhbHVlIHx8IFwidHJ1ZVwiID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJjaGVja2VkXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJzZWxlY3RlZFwiOlxuICAgICAgICAgICAgICBjYXNlIFwibXVsdGlwbGVcIjpcbiAgICAgICAgICAgICAgY2FzZSBcIm11dGVkXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJhbGxvd0Z1bGxTY3JlZW5cIjpcbiAgICAgICAgICAgICAgY2FzZSBcImFzeW5jXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJhdXRvUGxheVwiOlxuICAgICAgICAgICAgICBjYXNlIFwiY29udHJvbHNcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImRlZmF1bHRcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImRlZmVyXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJkaXNhYmxlZFwiOlxuICAgICAgICAgICAgICBjYXNlIFwiZGlzYWJsZVBpY3R1cmVJblBpY3R1cmVcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImRpc2FibGVSZW1vdGVQbGF5YmFja1wiOlxuICAgICAgICAgICAgICBjYXNlIFwiZm9ybU5vVmFsaWRhdGVcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImhpZGRlblwiOlxuICAgICAgICAgICAgICBjYXNlIFwibG9vcFwiOlxuICAgICAgICAgICAgICBjYXNlIFwibm9Nb2R1bGVcIjpcbiAgICAgICAgICAgICAgY2FzZSBcIm5vVmFsaWRhdGVcIjpcbiAgICAgICAgICAgICAgY2FzZSBcIm9wZW5cIjpcbiAgICAgICAgICAgICAgY2FzZSBcInBsYXlzSW5saW5lXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJyZWFkT25seVwiOlxuICAgICAgICAgICAgICBjYXNlIFwicmVxdWlyZWRcIjpcbiAgICAgICAgICAgICAgY2FzZSBcInJldmVyc2VkXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJzY29wZWRcIjpcbiAgICAgICAgICAgICAgY2FzZSBcInNlYW1sZXNzXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJpdGVtU2NvcGVcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImluZXJ0XCI6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJSZWNlaXZlZCB0aGUgc3RyaW5nIGAlc2AgZm9yIHRoZSBib29sZWFuIGF0dHJpYnV0ZSBgJXNgLiAlcyBEaWQgeW91IG1lYW4gJXM9eyVzfT9cIixcbiAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgIFwiZmFsc2VcIiA9PT0gdmFsdWVcbiAgICAgICAgICAgICAgICA/IFwiVGhlIGJyb3dzZXIgd2lsbCBpbnRlcnByZXQgaXQgYXMgYSB0cnV0aHkgdmFsdWUuXCJcbiAgICAgICAgICAgICAgICA6ICdBbHRob3VnaCB0aGlzIHdvcmtzLCBpdCB3aWxsIG5vdCB3b3JrIGFzIGV4cGVjdGVkIGlmIHlvdSBwYXNzIHRoZSBzdHJpbmcgXCJmYWxzZVwiLicsXG4gICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9ICEwO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAhMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gd2FyblVua25vd25Qcm9wZXJ0aWVzKHR5cGUsIHByb3BzLCBldmVudFJlZ2lzdHJ5KSB7XG4gICAgICB2YXIgdW5rbm93blByb3BzID0gW10sXG4gICAgICAgIGtleTtcbiAgICAgIGZvciAoa2V5IGluIHByb3BzKVxuICAgICAgICB2YWxpZGF0ZVByb3BlcnR5KHR5cGUsIGtleSwgcHJvcHNba2V5XSwgZXZlbnRSZWdpc3RyeSkgfHxcbiAgICAgICAgICB1bmtub3duUHJvcHMucHVzaChrZXkpO1xuICAgICAgcHJvcHMgPSB1bmtub3duUHJvcHNcbiAgICAgICAgLm1hcChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgIHJldHVybiBcImBcIiArIHByb3AgKyBcImBcIjtcbiAgICAgICAgfSlcbiAgICAgICAgLmpvaW4oXCIsIFwiKTtcbiAgICAgIDEgPT09IHVua25vd25Qcm9wcy5sZW5ndGhcbiAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJJbnZhbGlkIHZhbHVlIGZvciBwcm9wICVzIG9uIDwlcz4gdGFnLiBFaXRoZXIgcmVtb3ZlIGl0IGZyb20gdGhlIGVsZW1lbnQsIG9yIHBhc3MgYSBzdHJpbmcgb3IgbnVtYmVyIHZhbHVlIHRvIGtlZXAgaXQgaW4gdGhlIERPTS4gRm9yIGRldGFpbHMsIHNlZSBodHRwczovL3JlYWN0LmRldi9saW5rL2F0dHJpYnV0ZS1iZWhhdmlvciBcIixcbiAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgdHlwZVxuICAgICAgICAgIClcbiAgICAgICAgOiAxIDwgdW5rbm93blByb3BzLmxlbmd0aCAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkludmFsaWQgdmFsdWVzIGZvciBwcm9wcyAlcyBvbiA8JXM+IHRhZy4gRWl0aGVyIHJlbW92ZSB0aGVtIGZyb20gdGhlIGVsZW1lbnQsIG9yIHBhc3MgYSBzdHJpbmcgb3IgbnVtYmVyIHZhbHVlIHRvIGtlZXAgdGhlbSBpbiB0aGUgRE9NLiBGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvYXR0cmlidXRlLWJlaGF2aW9yIFwiLFxuICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICB0eXBlXG4gICAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2FtZWxpemUoc3RyaW5nKSB7XG4gICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoaHlwaGVuUGF0dGVybiwgZnVuY3Rpb24gKF8sIGNoYXJhY3Rlcikge1xuICAgICAgICByZXR1cm4gY2hhcmFjdGVyLnRvVXBwZXJDYXNlKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZXNjYXBlVGV4dEZvckJyb3dzZXIodGV4dCkge1xuICAgICAgaWYgKFxuICAgICAgICBcImJvb2xlYW5cIiA9PT0gdHlwZW9mIHRleHQgfHxcbiAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIHRleHQgfHxcbiAgICAgICAgXCJiaWdpbnRcIiA9PT0gdHlwZW9mIHRleHRcbiAgICAgIClcbiAgICAgICAgcmV0dXJuIFwiXCIgKyB0ZXh0O1xuICAgICAgY2hlY2tIdG1sU3RyaW5nQ29lcmNpb24odGV4dCk7XG4gICAgICB0ZXh0ID0gXCJcIiArIHRleHQ7XG4gICAgICB2YXIgbWF0Y2ggPSBtYXRjaEh0bWxSZWdFeHAuZXhlYyh0ZXh0KTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICB2YXIgaHRtbCA9IFwiXCIsXG4gICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgbGFzdEluZGV4ID0gMDtcbiAgICAgICAgZm9yIChpbmRleCA9IG1hdGNoLmluZGV4OyBpbmRleCA8IHRleHQubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgc3dpdGNoICh0ZXh0LmNoYXJDb2RlQXQoaW5kZXgpKSB7XG4gICAgICAgICAgICBjYXNlIDM0OlxuICAgICAgICAgICAgICBtYXRjaCA9IFwiJnF1b3Q7XCI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzODpcbiAgICAgICAgICAgICAgbWF0Y2ggPSBcIiZhbXA7XCI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzOTpcbiAgICAgICAgICAgICAgbWF0Y2ggPSBcIiYjeDI3O1wiO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNjA6XG4gICAgICAgICAgICAgIG1hdGNoID0gXCImbHQ7XCI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA2MjpcbiAgICAgICAgICAgICAgbWF0Y2ggPSBcIiZndDtcIjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGFzdEluZGV4ICE9PSBpbmRleCAmJiAoaHRtbCArPSB0ZXh0LnNsaWNlKGxhc3RJbmRleCwgaW5kZXgpKTtcbiAgICAgICAgICBsYXN0SW5kZXggPSBpbmRleCArIDE7XG4gICAgICAgICAgaHRtbCArPSBtYXRjaDtcbiAgICAgICAgfVxuICAgICAgICB0ZXh0ID0gbGFzdEluZGV4ICE9PSBpbmRleCA/IGh0bWwgKyB0ZXh0LnNsaWNlKGxhc3RJbmRleCwgaW5kZXgpIDogaHRtbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBzYW5pdGl6ZVVSTCh1cmwpIHtcbiAgICAgIHJldHVybiBpc0phdmFTY3JpcHRQcm90b2NvbC50ZXN0KFwiXCIgKyB1cmwpXG4gICAgICAgID8gXCJqYXZhc2NyaXB0OnRocm93IG5ldyBFcnJvcignUmVhY3QgaGFzIGJsb2NrZWQgYSBqYXZhc2NyaXB0OiBVUkwgYXMgYSBzZWN1cml0eSBwcmVjYXV0aW9uLicpXCJcbiAgICAgICAgOiB1cmw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVzY2FwZUVudGlyZUlubGluZVNjcmlwdENvbnRlbnQoc2NyaXB0VGV4dCkge1xuICAgICAgY2hlY2tIdG1sU3RyaW5nQ29lcmNpb24oc2NyaXB0VGV4dCk7XG4gICAgICByZXR1cm4gKFwiXCIgKyBzY3JpcHRUZXh0KS5yZXBsYWNlKHNjcmlwdFJlZ2V4LCBzY3JpcHRSZXBsYWNlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlc3VtYWJsZVN0YXRlKFxuICAgICAgaWRlbnRpZmllclByZWZpeCxcbiAgICAgIGV4dGVybmFsUnVudGltZUNvbmZpZyxcbiAgICAgIGJvb3RzdHJhcFNjcmlwdENvbnRlbnQsXG4gICAgICBib290c3RyYXBTY3JpcHRzLFxuICAgICAgYm9vdHN0cmFwTW9kdWxlc1xuICAgICkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaWRQcmVmaXg6IHZvaWQgMCA9PT0gaWRlbnRpZmllclByZWZpeCA/IFwiXCIgOiBpZGVudGlmaWVyUHJlZml4LFxuICAgICAgICBuZXh0Rm9ybUlEOiAwLFxuICAgICAgICBzdHJlYW1pbmdGb3JtYXQ6IDAsXG4gICAgICAgIGJvb3RzdHJhcFNjcmlwdENvbnRlbnQ6IGJvb3RzdHJhcFNjcmlwdENvbnRlbnQsXG4gICAgICAgIGJvb3RzdHJhcFNjcmlwdHM6IGJvb3RzdHJhcFNjcmlwdHMsXG4gICAgICAgIGJvb3RzdHJhcE1vZHVsZXM6IGJvb3RzdHJhcE1vZHVsZXMsXG4gICAgICAgIGluc3RydWN0aW9uczogTm90aGluZ1NlbnQsXG4gICAgICAgIGhhc0JvZHk6ICExLFxuICAgICAgICBoYXNIdG1sOiAhMSxcbiAgICAgICAgdW5rbm93blJlc291cmNlczoge30sXG4gICAgICAgIGRuc1Jlc291cmNlczoge30sXG4gICAgICAgIGNvbm5lY3RSZXNvdXJjZXM6IHsgZGVmYXVsdDoge30sIGFub255bW91czoge30sIGNyZWRlbnRpYWxzOiB7fSB9LFxuICAgICAgICBpbWFnZVJlc291cmNlczoge30sXG4gICAgICAgIHN0eWxlUmVzb3VyY2VzOiB7fSxcbiAgICAgICAgc2NyaXB0UmVzb3VyY2VzOiB7fSxcbiAgICAgICAgbW9kdWxlVW5rbm93blJlc291cmNlczoge30sXG4gICAgICAgIG1vZHVsZVNjcmlwdFJlc291cmNlczoge31cbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZvcm1hdENvbnRleHQoXG4gICAgICBpbnNlcnRpb25Nb2RlLFxuICAgICAgc2VsZWN0ZWRWYWx1ZSxcbiAgICAgIHRhZ1Njb3BlLFxuICAgICAgdmlld1RyYW5zaXRpb25cbiAgICApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGluc2VydGlvbk1vZGU6IGluc2VydGlvbk1vZGUsXG4gICAgICAgIHNlbGVjdGVkVmFsdWU6IHNlbGVjdGVkVmFsdWUsXG4gICAgICAgIHRhZ1Njb3BlOiB0YWdTY29wZSxcbiAgICAgICAgdmlld1RyYW5zaXRpb246IHZpZXdUcmFuc2l0aW9uXG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRDaGlsZEZvcm1hdENvbnRleHQocGFyZW50Q29udGV4dCwgdHlwZSwgcHJvcHMpIHtcbiAgICAgIHZhciBzdWJ0cmVlU2NvcGUgPSBwYXJlbnRDb250ZXh0LnRhZ1Njb3BlICYgLTI1O1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJub3NjcmlwdFwiOlxuICAgICAgICAgIHJldHVybiBjcmVhdGVGb3JtYXRDb250ZXh0KEhUTUxfTU9ERSwgbnVsbCwgc3VidHJlZVNjb3BlIHwgMSwgbnVsbCk7XG4gICAgICAgIGNhc2UgXCJzZWxlY3RcIjpcbiAgICAgICAgICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChcbiAgICAgICAgICAgIEhUTUxfTU9ERSxcbiAgICAgICAgICAgIG51bGwgIT0gcHJvcHMudmFsdWUgPyBwcm9wcy52YWx1ZSA6IHByb3BzLmRlZmF1bHRWYWx1ZSxcbiAgICAgICAgICAgIHN1YnRyZWVTY29wZSxcbiAgICAgICAgICAgIG51bGxcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIFwic3ZnXCI6XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoU1ZHX01PREUsIG51bGwsIHN1YnRyZWVTY29wZSwgbnVsbCk7XG4gICAgICAgIGNhc2UgXCJwaWN0dXJlXCI6XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoSFRNTF9NT0RFLCBudWxsLCBzdWJ0cmVlU2NvcGUgfCAyLCBudWxsKTtcbiAgICAgICAgY2FzZSBcIm1hdGhcIjpcbiAgICAgICAgICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChNQVRITUxfTU9ERSwgbnVsbCwgc3VidHJlZVNjb3BlLCBudWxsKTtcbiAgICAgICAgY2FzZSBcImZvcmVpZ25PYmplY3RcIjpcbiAgICAgICAgICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChIVE1MX01PREUsIG51bGwsIHN1YnRyZWVTY29wZSwgbnVsbCk7XG4gICAgICAgIGNhc2UgXCJ0YWJsZVwiOlxuICAgICAgICAgIHJldHVybiBjcmVhdGVGb3JtYXRDb250ZXh0KEhUTUxfVEFCTEVfTU9ERSwgbnVsbCwgc3VidHJlZVNjb3BlLCBudWxsKTtcbiAgICAgICAgY2FzZSBcInRoZWFkXCI6XG4gICAgICAgIGNhc2UgXCJ0Ym9keVwiOlxuICAgICAgICBjYXNlIFwidGZvb3RcIjpcbiAgICAgICAgICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChcbiAgICAgICAgICAgIEhUTUxfVEFCTEVfQk9EWV9NT0RFLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHN1YnRyZWVTY29wZSxcbiAgICAgICAgICAgIG51bGxcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIFwiY29sZ3JvdXBcIjpcbiAgICAgICAgICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChcbiAgICAgICAgICAgIEhUTUxfQ09MR1JPVVBfTU9ERSxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBzdWJ0cmVlU2NvcGUsXG4gICAgICAgICAgICBudWxsXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBcInRyXCI6XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoXG4gICAgICAgICAgICBIVE1MX1RBQkxFX1JPV19NT0RFLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHN1YnRyZWVTY29wZSxcbiAgICAgICAgICAgIG51bGxcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIFwiaGVhZFwiOlxuICAgICAgICAgIGlmIChwYXJlbnRDb250ZXh0Lmluc2VydGlvbk1vZGUgPCBIVE1MX01PREUpXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChcbiAgICAgICAgICAgICAgSFRNTF9IRUFEX01PREUsXG4gICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgIHN1YnRyZWVTY29wZSxcbiAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImh0bWxcIjpcbiAgICAgICAgICBpZiAocGFyZW50Q29udGV4dC5pbnNlcnRpb25Nb2RlID09PSBST09UX0hUTUxfTU9ERSlcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVGb3JtYXRDb250ZXh0KFxuICAgICAgICAgICAgICBIVE1MX0hUTUxfTU9ERSxcbiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgc3VidHJlZVNjb3BlLFxuICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcmVudENvbnRleHQuaW5zZXJ0aW9uTW9kZSA+PSBIVE1MX1RBQkxFX01PREUgfHxcbiAgICAgICAgcGFyZW50Q29udGV4dC5pbnNlcnRpb25Nb2RlIDwgSFRNTF9NT0RFXG4gICAgICAgID8gY3JlYXRlRm9ybWF0Q29udGV4dChIVE1MX01PREUsIG51bGwsIHN1YnRyZWVTY29wZSwgbnVsbClcbiAgICAgICAgOiBwYXJlbnRDb250ZXh0LnRhZ1Njb3BlICE9PSBzdWJ0cmVlU2NvcGVcbiAgICAgICAgICA/IGNyZWF0ZUZvcm1hdENvbnRleHQoXG4gICAgICAgICAgICAgIHBhcmVudENvbnRleHQuaW5zZXJ0aW9uTW9kZSxcbiAgICAgICAgICAgICAgcGFyZW50Q29udGV4dC5zZWxlY3RlZFZhbHVlLFxuICAgICAgICAgICAgICBzdWJ0cmVlU2NvcGUsXG4gICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgIClcbiAgICAgICAgICA6IHBhcmVudENvbnRleHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFN1c3BlbnNlVmlld1RyYW5zaXRpb24ocGFyZW50Vmlld1RyYW5zaXRpb24pIHtcbiAgICAgIHJldHVybiBudWxsID09PSBwYXJlbnRWaWV3VHJhbnNpdGlvblxuICAgICAgICA/IG51bGxcbiAgICAgICAgOiB7XG4gICAgICAgICAgICB1cGRhdGU6IHBhcmVudFZpZXdUcmFuc2l0aW9uLnVwZGF0ZSxcbiAgICAgICAgICAgIGVudGVyOiBcIm5vbmVcIixcbiAgICAgICAgICAgIGV4aXQ6IFwibm9uZVwiLFxuICAgICAgICAgICAgc2hhcmU6IHBhcmVudFZpZXdUcmFuc2l0aW9uLnVwZGF0ZSxcbiAgICAgICAgICAgIG5hbWU6IHBhcmVudFZpZXdUcmFuc2l0aW9uLmF1dG9OYW1lLFxuICAgICAgICAgICAgYXV0b05hbWU6IHBhcmVudFZpZXdUcmFuc2l0aW9uLmF1dG9OYW1lLFxuICAgICAgICAgICAgbmFtZUlkeDogMFxuICAgICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFN1c3BlbnNlRmFsbGJhY2tGb3JtYXRDb250ZXh0KHJlc3VtYWJsZVN0YXRlLCBwYXJlbnRDb250ZXh0KSB7XG4gICAgICBwYXJlbnRDb250ZXh0LnRhZ1Njb3BlICYgMzIgJiYgKHJlc3VtYWJsZVN0YXRlLmluc3RydWN0aW9ucyB8PSAxMjgpO1xuICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoXG4gICAgICAgIHBhcmVudENvbnRleHQuaW5zZXJ0aW9uTW9kZSxcbiAgICAgICAgcGFyZW50Q29udGV4dC5zZWxlY3RlZFZhbHVlLFxuICAgICAgICBwYXJlbnRDb250ZXh0LnRhZ1Njb3BlIHwgMTIsXG4gICAgICAgIGdldFN1c3BlbnNlVmlld1RyYW5zaXRpb24ocGFyZW50Q29udGV4dC52aWV3VHJhbnNpdGlvbilcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFN1c3BlbnNlQ29udGVudEZvcm1hdENvbnRleHQocmVzdW1hYmxlU3RhdGUsIHBhcmVudENvbnRleHQpIHtcbiAgICAgIHJlc3VtYWJsZVN0YXRlID0gZ2V0U3VzcGVuc2VWaWV3VHJhbnNpdGlvbihwYXJlbnRDb250ZXh0LnZpZXdUcmFuc2l0aW9uKTtcbiAgICAgIHZhciBzdWJ0cmVlU2NvcGUgPSBwYXJlbnRDb250ZXh0LnRhZ1Njb3BlIHwgMTY7XG4gICAgICBudWxsICE9PSByZXN1bWFibGVTdGF0ZSAmJlxuICAgICAgICBcIm5vbmVcIiAhPT0gcmVzdW1hYmxlU3RhdGUuc2hhcmUgJiZcbiAgICAgICAgKHN1YnRyZWVTY29wZSB8PSA2NCk7XG4gICAgICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChcbiAgICAgICAgcGFyZW50Q29udGV4dC5pbnNlcnRpb25Nb2RlLFxuICAgICAgICBwYXJlbnRDb250ZXh0LnNlbGVjdGVkVmFsdWUsXG4gICAgICAgIHN1YnRyZWVTY29wZSxcbiAgICAgICAgcmVzdW1hYmxlU3RhdGVcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hTdHlsZUF0dHJpYnV0ZSh0YXJnZXQsIHN0eWxlKSB7XG4gICAgICBpZiAoXCJvYmplY3RcIiAhPT0gdHlwZW9mIHN0eWxlKVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIlRoZSBgc3R5bGVgIHByb3AgZXhwZWN0cyBhIG1hcHBpbmcgZnJvbSBzdHlsZSBwcm9wZXJ0aWVzIHRvIHZhbHVlcywgbm90IGEgc3RyaW5nLiBGb3IgZXhhbXBsZSwgc3R5bGU9e3ttYXJnaW5SaWdodDogc3BhY2luZyArICdlbSd9fSB3aGVuIHVzaW5nIEpTWC5cIlxuICAgICAgICApO1xuICAgICAgdmFyIGlzRmlyc3QgPSAhMCxcbiAgICAgICAgc3R5bGVOYW1lO1xuICAgICAgZm9yIChzdHlsZU5hbWUgaW4gc3R5bGUpXG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHN0eWxlLCBzdHlsZU5hbWUpKSB7XG4gICAgICAgICAgdmFyIHN0eWxlVmFsdWUgPSBzdHlsZVtzdHlsZU5hbWVdO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIG51bGwgIT0gc3R5bGVWYWx1ZSAmJlxuICAgICAgICAgICAgXCJib29sZWFuXCIgIT09IHR5cGVvZiBzdHlsZVZhbHVlICYmXG4gICAgICAgICAgICBcIlwiICE9PSBzdHlsZVZhbHVlXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAoMCA9PT0gc3R5bGVOYW1lLmluZGV4T2YoXCItLVwiKSkge1xuICAgICAgICAgICAgICB2YXIgbmFtZUNodW5rID0gZXNjYXBlVGV4dEZvckJyb3dzZXIoc3R5bGVOYW1lKTtcbiAgICAgICAgICAgICAgY2hlY2tDU1NQcm9wZXJ0eVN0cmluZ0NvZXJjaW9uKHN0eWxlVmFsdWUsIHN0eWxlTmFtZSk7XG4gICAgICAgICAgICAgIHN0eWxlVmFsdWUgPSBlc2NhcGVUZXh0Rm9yQnJvd3NlcigoXCJcIiArIHN0eWxlVmFsdWUpLnRyaW0oKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuYW1lQ2h1bmsgPSBzdHlsZU5hbWU7XG4gICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHN0eWxlVmFsdWU7XG4gICAgICAgICAgICAgIGlmICgtMSA8IG5hbWVDaHVuay5pbmRleE9mKFwiLVwiKSkge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gbmFtZUNodW5rO1xuICAgICAgICAgICAgICAgICh3YXJuZWRTdHlsZU5hbWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmXG4gICAgICAgICAgICAgICAgICB3YXJuZWRTdHlsZU5hbWVzW25hbWVdKSB8fFxuICAgICAgICAgICAgICAgICAgKCh3YXJuZWRTdHlsZU5hbWVzW25hbWVdID0gITApLFxuICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJVbnN1cHBvcnRlZCBzdHlsZSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzP1wiLFxuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBjYW1lbGl6ZShuYW1lLnJlcGxhY2UobXNQYXR0ZXJuJDEsIFwibXMtXCIpKVxuICAgICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuLnRlc3QobmFtZUNodW5rKSlcbiAgICAgICAgICAgICAgICAobmFtZSA9IG5hbWVDaHVuayksXG4gICAgICAgICAgICAgICAgICAod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJlxuICAgICAgICAgICAgICAgICAgICB3YXJuZWRTdHlsZU5hbWVzW25hbWVdKSB8fFxuICAgICAgICAgICAgICAgICAgICAoKHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0gPSAhMCksXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgXCJVbnN1cHBvcnRlZCB2ZW5kb3ItcHJlZml4ZWQgc3R5bGUgcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiAlcz9cIixcbiAgICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgIG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpXG4gICAgICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgICBlbHNlIGlmIChiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gbmFtZUNodW5rO1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSRqc2NvbXAkMCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICh3YXJuZWRTdHlsZVZhbHVlcy5oYXNPd25Qcm9wZXJ0eSh2YWx1ZSRqc2NvbXAkMCkgJiZcbiAgICAgICAgICAgICAgICAgIHdhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlJGpzY29tcCQwXSkgfHxcbiAgICAgICAgICAgICAgICAgICgod2FybmVkU3R5bGVWYWx1ZXNbdmFsdWUkanNjb21wJDBdID0gITApLFxuICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgJ1N0eWxlIHByb3BlcnR5IHZhbHVlcyBzaG91bGRuXFwndCBjb250YWluIGEgc2VtaWNvbG9uLiBUcnkgXCIlczogJXNcIiBpbnN0ZWFkLicsXG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlJGpzY29tcCQwLnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgICAgICAgYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuLFxuICAgICAgICAgICAgICAgICAgICAgIFwiXCJcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIHZhbHVlICYmXG4gICAgICAgICAgICAgICAgKGlzTmFOKHZhbHVlKVxuICAgICAgICAgICAgICAgICAgPyB3YXJuZWRGb3JOYU5WYWx1ZSB8fFxuICAgICAgICAgICAgICAgICAgICAoKHdhcm5lZEZvck5hTlZhbHVlID0gITApLFxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgIFwiYE5hTmAgaXMgYW4gaW52YWxpZCB2YWx1ZSBmb3IgdGhlIGAlc2AgY3NzIHN0eWxlIHByb3BlcnR5LlwiLFxuICAgICAgICAgICAgICAgICAgICAgIG5hbWVDaHVua1xuICAgICAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgICAgICAgOiBpc0Zpbml0ZSh2YWx1ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgd2FybmVkRm9ySW5maW5pdHlWYWx1ZSB8fFxuICAgICAgICAgICAgICAgICAgICAoKHdhcm5lZEZvckluZmluaXR5VmFsdWUgPSAhMCksXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgXCJgSW5maW5pdHlgIGlzIGFuIGludmFsaWQgdmFsdWUgZm9yIHRoZSBgJXNgIGNzcyBzdHlsZSBwcm9wZXJ0eS5cIixcbiAgICAgICAgICAgICAgICAgICAgICBuYW1lQ2h1bmtcbiAgICAgICAgICAgICAgICAgICAgKSkpO1xuICAgICAgICAgICAgICBuYW1lQ2h1bmsgPSBzdHlsZU5hbWU7XG4gICAgICAgICAgICAgIHZhbHVlID0gc3R5bGVOYW1lQ2FjaGUuZ2V0KG5hbWVDaHVuayk7XG4gICAgICAgICAgICAgIHZvaWQgMCAhPT0gdmFsdWVcbiAgICAgICAgICAgICAgICA/IChuYW1lQ2h1bmsgPSB2YWx1ZSlcbiAgICAgICAgICAgICAgICA6ICgodmFsdWUgPSBlc2NhcGVUZXh0Rm9yQnJvd3NlcihcbiAgICAgICAgICAgICAgICAgICAgbmFtZUNodW5rXG4gICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UodXBwZXJjYXNlUGF0dGVybiwgXCItJDFcIilcbiAgICAgICAgICAgICAgICAgICAgICAudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKG1zUGF0dGVybiwgXCItbXMtXCIpXG4gICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAgIHN0eWxlTmFtZUNhY2hlLnNldChuYW1lQ2h1bmssIHZhbHVlKSxcbiAgICAgICAgICAgICAgICAgIChuYW1lQ2h1bmsgPSB2YWx1ZSkpO1xuICAgICAgICAgICAgICBcIm51bWJlclwiID09PSB0eXBlb2Ygc3R5bGVWYWx1ZVxuICAgICAgICAgICAgICAgID8gKHN0eWxlVmFsdWUgPVxuICAgICAgICAgICAgICAgICAgICAwID09PSBzdHlsZVZhbHVlIHx8IHVuaXRsZXNzTnVtYmVycy5oYXMoc3R5bGVOYW1lKVxuICAgICAgICAgICAgICAgICAgICAgID8gXCJcIiArIHN0eWxlVmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICA6IHN0eWxlVmFsdWUgKyBcInB4XCIpXG4gICAgICAgICAgICAgICAgOiAoY2hlY2tDU1NQcm9wZXJ0eVN0cmluZ0NvZXJjaW9uKHN0eWxlVmFsdWUsIHN0eWxlTmFtZSksXG4gICAgICAgICAgICAgICAgICAoc3R5bGVWYWx1ZSA9IGVzY2FwZVRleHRGb3JCcm93c2VyKFxuICAgICAgICAgICAgICAgICAgICAoXCJcIiArIHN0eWxlVmFsdWUpLnRyaW0oKVxuICAgICAgICAgICAgICAgICAgKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXNGaXJzdFxuICAgICAgICAgICAgICA/ICgoaXNGaXJzdCA9ICExKSxcbiAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChcbiAgICAgICAgICAgICAgICAgIHN0eWxlQXR0cmlidXRlU3RhcnQsXG4gICAgICAgICAgICAgICAgICBuYW1lQ2h1bmssXG4gICAgICAgICAgICAgICAgICBzdHlsZUFzc2lnbixcbiAgICAgICAgICAgICAgICAgIHN0eWxlVmFsdWVcbiAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgICA6IHRhcmdldC5wdXNoKHN0eWxlU2VwYXJhdG9yLCBuYW1lQ2h1bmssIHN0eWxlQXNzaWduLCBzdHlsZVZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGlzRmlyc3QgfHwgdGFyZ2V0LnB1c2goYXR0cmlidXRlRW5kKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaEJvb2xlYW5BdHRyaWJ1dGUodGFyZ2V0LCBuYW1lLCB2YWx1ZSkge1xuICAgICAgdmFsdWUgJiZcbiAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgdmFsdWUgJiZcbiAgICAgICAgXCJzeW1ib2xcIiAhPT0gdHlwZW9mIHZhbHVlICYmXG4gICAgICAgIHRhcmdldC5wdXNoKGF0dHJpYnV0ZVNlcGFyYXRvciwgbmFtZSwgYXR0cmlidXRlRW1wdHlTdHJpbmcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoU3RyaW5nQXR0cmlidXRlKHRhcmdldCwgbmFtZSwgdmFsdWUpIHtcbiAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHZhbHVlICYmXG4gICAgICAgIFwic3ltYm9sXCIgIT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICBcImJvb2xlYW5cIiAhPT0gdHlwZW9mIHZhbHVlICYmXG4gICAgICAgIHRhcmdldC5wdXNoKFxuICAgICAgICAgIGF0dHJpYnV0ZVNlcGFyYXRvcixcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIGF0dHJpYnV0ZUFzc2lnbixcbiAgICAgICAgICBlc2NhcGVUZXh0Rm9yQnJvd3Nlcih2YWx1ZSksXG4gICAgICAgICAgYXR0cmlidXRlRW5kXG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hBZGRpdGlvbmFsRm9ybUZpZWxkKHZhbHVlLCBrZXkpIHtcbiAgICAgIHRoaXMucHVzaCgnPGlucHV0IHR5cGU9XCJoaWRkZW5cIicpO1xuICAgICAgdmFsaWRhdGVBZGRpdGlvbmFsRm9ybUZpZWxkKHZhbHVlKTtcbiAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGhpcywgXCJuYW1lXCIsIGtleSk7XG4gICAgICBwdXNoU3RyaW5nQXR0cmlidXRlKHRoaXMsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgdGhpcy5wdXNoKGVuZE9mU3RhcnRUYWdTZWxmQ2xvc2luZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlQWRkaXRpb25hbEZvcm1GaWVsZCh2YWx1ZSkge1xuICAgICAgaWYgKFwic3RyaW5nXCIgIT09IHR5cGVvZiB2YWx1ZSlcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJGaWxlL0Jsb2IgZmllbGRzIGFyZSBub3QgeWV0IHN1cHBvcnRlZCBpbiBwcm9ncmVzc2l2ZSBmb3Jtcy4gV2lsbCBmYWxsYmFjayB0byBjbGllbnQgaHlkcmF0aW9uLlwiXG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEN1c3RvbUZvcm1GaWVsZHMocmVzdW1hYmxlU3RhdGUsIGZvcm1BY3Rpb24pIHtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBmb3JtQWN0aW9uLiQkRk9STV9BQ1RJT04pIHtcbiAgICAgICAgdmFyIGlkID0gcmVzdW1hYmxlU3RhdGUubmV4dEZvcm1JRCsrO1xuICAgICAgICByZXN1bWFibGVTdGF0ZSA9IHJlc3VtYWJsZVN0YXRlLmlkUHJlZml4ICsgaWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIGN1c3RvbUZpZWxkcyA9IGZvcm1BY3Rpb24uJCRGT1JNX0FDVElPTihyZXN1bWFibGVTdGF0ZSk7XG4gICAgICAgICAgaWYgKGN1c3RvbUZpZWxkcykge1xuICAgICAgICAgICAgdmFyIGZvcm1EYXRhID0gY3VzdG9tRmllbGRzLmRhdGE7XG4gICAgICAgICAgICBudWxsICE9IGZvcm1EYXRhICYmIGZvcm1EYXRhLmZvckVhY2godmFsaWRhdGVBZGRpdGlvbmFsRm9ybUZpZWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGN1c3RvbUZpZWxkcztcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiB4ICYmXG4gICAgICAgICAgICBudWxsICE9PSB4ICYmXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB4LnRoZW5cbiAgICAgICAgICApXG4gICAgICAgICAgICB0aHJvdyB4O1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkZhaWxlZCB0byBzZXJpYWxpemUgYW4gYWN0aW9uIGZvciBwcm9ncmVzc2l2ZSBlbmhhbmNlbWVudDpcXG4lc1wiLFxuICAgICAgICAgICAgeFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoRm9ybUFjdGlvbkF0dHJpYnV0ZShcbiAgICAgIHRhcmdldCxcbiAgICAgIHJlc3VtYWJsZVN0YXRlLFxuICAgICAgcmVuZGVyU3RhdGUsXG4gICAgICBmb3JtQWN0aW9uLFxuICAgICAgZm9ybUVuY1R5cGUsXG4gICAgICBmb3JtTWV0aG9kLFxuICAgICAgZm9ybVRhcmdldCxcbiAgICAgIG5hbWVcbiAgICApIHtcbiAgICAgIHZhciBmb3JtRGF0YSA9IG51bGw7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZm9ybUFjdGlvbikge1xuICAgICAgICBudWxsID09PSBuYW1lIHx8XG4gICAgICAgICAgZGlkV2FybkZvcm1BY3Rpb25OYW1lIHx8XG4gICAgICAgICAgKChkaWRXYXJuRm9ybUFjdGlvbk5hbWUgPSAhMCksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICdDYW5ub3Qgc3BlY2lmeSBhIFwibmFtZVwiIHByb3AgZm9yIGEgYnV0dG9uIHRoYXQgc3BlY2lmaWVzIGEgZnVuY3Rpb24gYXMgYSBmb3JtQWN0aW9uLiBSZWFjdCBuZWVkcyBpdCB0byBlbmNvZGUgd2hpY2ggYWN0aW9uIHNob3VsZCBiZSBpbnZva2VkLiBJdCB3aWxsIGdldCBvdmVycmlkZGVuLidcbiAgICAgICAgICApKTtcbiAgICAgICAgKG51bGwgPT09IGZvcm1FbmNUeXBlICYmIG51bGwgPT09IGZvcm1NZXRob2QpIHx8XG4gICAgICAgICAgZGlkV2FybkZvcm1BY3Rpb25NZXRob2QgfHxcbiAgICAgICAgICAoKGRpZFdhcm5Gb3JtQWN0aW9uTWV0aG9kID0gITApLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkNhbm5vdCBzcGVjaWZ5IGEgZm9ybUVuY1R5cGUgb3IgZm9ybU1ldGhvZCBmb3IgYSBidXR0b24gdGhhdCBzcGVjaWZpZXMgYSBmdW5jdGlvbiBhcyBhIGZvcm1BY3Rpb24uIFJlYWN0IHByb3ZpZGVzIHRob3NlIGF1dG9tYXRpY2FsbHkuIFRoZXkgd2lsbCBnZXQgb3ZlcnJpZGRlbi5cIlxuICAgICAgICAgICkpO1xuICAgICAgICBudWxsID09PSBmb3JtVGFyZ2V0IHx8XG4gICAgICAgICAgZGlkV2FybkZvcm1BY3Rpb25UYXJnZXQgfHxcbiAgICAgICAgICAoKGRpZFdhcm5Gb3JtQWN0aW9uVGFyZ2V0ID0gITApLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkNhbm5vdCBzcGVjaWZ5IGEgZm9ybVRhcmdldCBmb3IgYSBidXR0b24gdGhhdCBzcGVjaWZpZXMgYSBmdW5jdGlvbiBhcyBhIGZvcm1BY3Rpb24uIFRoZSBmdW5jdGlvbiB3aWxsIGFsd2F5cyBiZSBleGVjdXRlZCBpbiB0aGUgc2FtZSB3aW5kb3cuXCJcbiAgICAgICAgICApKTtcbiAgICAgICAgdmFyIGN1c3RvbUZpZWxkcyA9IGdldEN1c3RvbUZvcm1GaWVsZHMocmVzdW1hYmxlU3RhdGUsIGZvcm1BY3Rpb24pO1xuICAgICAgICBudWxsICE9PSBjdXN0b21GaWVsZHNcbiAgICAgICAgICA/ICgobmFtZSA9IGN1c3RvbUZpZWxkcy5uYW1lKSxcbiAgICAgICAgICAgIChmb3JtQWN0aW9uID0gY3VzdG9tRmllbGRzLmFjdGlvbiB8fCBcIlwiKSxcbiAgICAgICAgICAgIChmb3JtRW5jVHlwZSA9IGN1c3RvbUZpZWxkcy5lbmNUeXBlKSxcbiAgICAgICAgICAgIChmb3JtTWV0aG9kID0gY3VzdG9tRmllbGRzLm1ldGhvZCksXG4gICAgICAgICAgICAoZm9ybVRhcmdldCA9IGN1c3RvbUZpZWxkcy50YXJnZXQpLFxuICAgICAgICAgICAgKGZvcm1EYXRhID0gY3VzdG9tRmllbGRzLmRhdGEpKVxuICAgICAgICAgIDogKHRhcmdldC5wdXNoKFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVTZXBhcmF0b3IsXG4gICAgICAgICAgICAgIFwiZm9ybUFjdGlvblwiLFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVBc3NpZ24sXG4gICAgICAgICAgICAgIGFjdGlvbkphdmFTY3JpcHRVUkwsXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZUVuZFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIChmb3JtVGFyZ2V0ID0gZm9ybU1ldGhvZCA9IGZvcm1FbmNUeXBlID0gZm9ybUFjdGlvbiA9IG5hbWUgPSBudWxsKSxcbiAgICAgICAgICAgIGluamVjdEZvcm1SZXBsYXlpbmdSdW50aW1lKHJlc3VtYWJsZVN0YXRlLCByZW5kZXJTdGF0ZSkpO1xuICAgICAgfVxuICAgICAgbnVsbCAhPSBuYW1lICYmIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgICBudWxsICE9IGZvcm1BY3Rpb24gJiYgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIFwiZm9ybUFjdGlvblwiLCBmb3JtQWN0aW9uKTtcbiAgICAgIG51bGwgIT0gZm9ybUVuY1R5cGUgJiYgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIFwiZm9ybUVuY1R5cGVcIiwgZm9ybUVuY1R5cGUpO1xuICAgICAgbnVsbCAhPSBmb3JtTWV0aG9kICYmIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBcImZvcm1NZXRob2RcIiwgZm9ybU1ldGhvZCk7XG4gICAgICBudWxsICE9IGZvcm1UYXJnZXQgJiYgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIFwiZm9ybVRhcmdldFwiLCBmb3JtVGFyZ2V0KTtcbiAgICAgIHJldHVybiBmb3JtRGF0YTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIG5hbWUsIHZhbHVlKSB7XG4gICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgY2FzZSBcImNsYXNzTmFtZVwiOlxuICAgICAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCBcImNsYXNzXCIsIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInRhYkluZGV4XCI6XG4gICAgICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsIFwidGFiaW5kZXhcIiwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZGlyXCI6XG4gICAgICAgIGNhc2UgXCJyb2xlXCI6XG4gICAgICAgIGNhc2UgXCJ2aWV3Qm94XCI6XG4gICAgICAgIGNhc2UgXCJ3aWR0aFwiOlxuICAgICAgICBjYXNlIFwiaGVpZ2h0XCI6XG4gICAgICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInN0eWxlXCI6XG4gICAgICAgICAgcHVzaFN0eWxlQXR0cmlidXRlKHRhcmdldCwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic3JjXCI6XG4gICAgICAgIGNhc2UgXCJocmVmXCI6XG4gICAgICAgICAgaWYgKFwiXCIgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICBcInNyY1wiID09PSBuYW1lXG4gICAgICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICdBbiBlbXB0eSBzdHJpbmcgKFwiXCIpIHdhcyBwYXNzZWQgdG8gdGhlICVzIGF0dHJpYnV0ZS4gVGhpcyBtYXkgY2F1c2UgdGhlIGJyb3dzZXIgdG8gZG93bmxvYWQgdGhlIHdob2xlIHBhZ2UgYWdhaW4gb3ZlciB0aGUgbmV0d29yay4gVG8gZml4IHRoaXMsIGVpdGhlciBkbyBub3QgcmVuZGVyIHRoZSBlbGVtZW50IGF0IGFsbCBvciBwYXNzIG51bGwgdG8gJXMgaW5zdGVhZCBvZiBhbiBlbXB0eSBzdHJpbmcuJyxcbiAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICA6IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAnQW4gZW1wdHkgc3RyaW5nIChcIlwiKSB3YXMgcGFzc2VkIHRvIHRoZSAlcyBhdHRyaWJ1dGUuIFRvIGZpeCB0aGlzLCBlaXRoZXIgZG8gbm90IHJlbmRlciB0aGUgZWxlbWVudCBhdCBhbGwgb3IgcGFzcyBudWxsIHRvICVzIGluc3RlYWQgb2YgYW4gZW1wdHkgc3RyaW5nLicsXG4gICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJhY3Rpb25cIjpcbiAgICAgICAgY2FzZSBcImZvcm1BY3Rpb25cIjpcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBudWxsID09IHZhbHVlIHx8XG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB2YWx1ZSB8fFxuICAgICAgICAgICAgXCJzeW1ib2xcIiA9PT0gdHlwZW9mIHZhbHVlIHx8XG4gICAgICAgICAgICBcImJvb2xlYW5cIiA9PT0gdHlwZW9mIHZhbHVlXG4gICAgICAgICAgKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbih2YWx1ZSwgbmFtZSk7XG4gICAgICAgICAgdmFsdWUgPSBzYW5pdGl6ZVVSTChcIlwiICsgdmFsdWUpO1xuICAgICAgICAgIHRhcmdldC5wdXNoKFxuICAgICAgICAgICAgYXR0cmlidXRlU2VwYXJhdG9yLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZUFzc2lnbixcbiAgICAgICAgICAgIGVzY2FwZVRleHRGb3JCcm93c2VyKHZhbHVlKSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZUVuZFxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJkZWZhdWx0VmFsdWVcIjpcbiAgICAgICAgY2FzZSBcImRlZmF1bHRDaGVja2VkXCI6XG4gICAgICAgIGNhc2UgXCJpbm5lckhUTUxcIjpcbiAgICAgICAgY2FzZSBcInN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZ1wiOlxuICAgICAgICBjYXNlIFwic3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nXCI6XG4gICAgICAgIGNhc2UgXCJyZWZcIjpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImF1dG9Gb2N1c1wiOlxuICAgICAgICBjYXNlIFwibXVsdGlwbGVcIjpcbiAgICAgICAgY2FzZSBcIm11dGVkXCI6XG4gICAgICAgICAgcHVzaEJvb2xlYW5BdHRyaWJ1dGUodGFyZ2V0LCBuYW1lLnRvTG93ZXJDYXNlKCksIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInhsaW5rSHJlZlwiOlxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHZhbHVlIHx8XG4gICAgICAgICAgICBcInN5bWJvbFwiID09PSB0eXBlb2YgdmFsdWUgfHxcbiAgICAgICAgICAgIFwiYm9vbGVhblwiID09PSB0eXBlb2YgdmFsdWVcbiAgICAgICAgICApXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlLCBuYW1lKTtcbiAgICAgICAgICB2YWx1ZSA9IHNhbml0aXplVVJMKFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgdGFyZ2V0LnB1c2goXG4gICAgICAgICAgICBhdHRyaWJ1dGVTZXBhcmF0b3IsXG4gICAgICAgICAgICBcInhsaW5rOmhyZWZcIixcbiAgICAgICAgICAgIGF0dHJpYnV0ZUFzc2lnbixcbiAgICAgICAgICAgIGVzY2FwZVRleHRGb3JCcm93c2VyKHZhbHVlKSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZUVuZFxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJjb250ZW50RWRpdGFibGVcIjpcbiAgICAgICAgY2FzZSBcInNwZWxsQ2hlY2tcIjpcbiAgICAgICAgY2FzZSBcImRyYWdnYWJsZVwiOlxuICAgICAgICBjYXNlIFwidmFsdWVcIjpcbiAgICAgICAgY2FzZSBcImF1dG9SZXZlcnNlXCI6XG4gICAgICAgIGNhc2UgXCJleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkXCI6XG4gICAgICAgIGNhc2UgXCJmb2N1c2FibGVcIjpcbiAgICAgICAgY2FzZSBcInByZXNlcnZlQWxwaGFcIjpcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICAgICAgXCJzeW1ib2xcIiAhPT0gdHlwZW9mIHZhbHVlICYmXG4gICAgICAgICAgICB0YXJnZXQucHVzaChcbiAgICAgICAgICAgICAgYXR0cmlidXRlU2VwYXJhdG9yLFxuICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVBc3NpZ24sXG4gICAgICAgICAgICAgIGVzY2FwZVRleHRGb3JCcm93c2VyKHZhbHVlKSxcbiAgICAgICAgICAgICAgYXR0cmlidXRlRW5kXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiaW5lcnRcIjpcbiAgICAgICAgICBcIlwiICE9PSB2YWx1ZSB8fFxuICAgICAgICAgICAgZGlkV2FybkZvck5ld0Jvb2xlYW5Qcm9wc1dpdGhFbXB0eVZhbHVlW25hbWVdIHx8XG4gICAgICAgICAgICAoKGRpZFdhcm5Gb3JOZXdCb29sZWFuUHJvcHNXaXRoRW1wdHlWYWx1ZVtuYW1lXSA9ICEwKSxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVjZWl2ZWQgYW4gZW1wdHkgc3RyaW5nIGZvciBhIGJvb2xlYW4gYXR0cmlidXRlIGAlc2AuIFRoaXMgd2lsbCB0cmVhdCB0aGUgYXR0cmlidXRlIGFzIGlmIGl0IHdlcmUgZmFsc2UuIEVpdGhlciBwYXNzIGBmYWxzZWAgdG8gc2lsZW5jZSB0aGlzIHdhcm5pbmcsIG9yIHBhc3MgYHRydWVgIGlmIHlvdSB1c2VkIGFuIGVtcHR5IHN0cmluZyBpbiBlYXJsaWVyIHZlcnNpb25zIG9mIFJlYWN0IHRvIGluZGljYXRlIHRoaXMgYXR0cmlidXRlIGlzIHRydWUuXCIsXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICkpO1xuICAgICAgICBjYXNlIFwiYWxsb3dGdWxsU2NyZWVuXCI6XG4gICAgICAgIGNhc2UgXCJhc3luY1wiOlxuICAgICAgICBjYXNlIFwiYXV0b1BsYXlcIjpcbiAgICAgICAgY2FzZSBcImNvbnRyb2xzXCI6XG4gICAgICAgIGNhc2UgXCJkZWZhdWx0XCI6XG4gICAgICAgIGNhc2UgXCJkZWZlclwiOlxuICAgICAgICBjYXNlIFwiZGlzYWJsZWRcIjpcbiAgICAgICAgY2FzZSBcImRpc2FibGVQaWN0dXJlSW5QaWN0dXJlXCI6XG4gICAgICAgIGNhc2UgXCJkaXNhYmxlUmVtb3RlUGxheWJhY2tcIjpcbiAgICAgICAgY2FzZSBcImZvcm1Ob1ZhbGlkYXRlXCI6XG4gICAgICAgIGNhc2UgXCJoaWRkZW5cIjpcbiAgICAgICAgY2FzZSBcImxvb3BcIjpcbiAgICAgICAgY2FzZSBcIm5vTW9kdWxlXCI6XG4gICAgICAgIGNhc2UgXCJub1ZhbGlkYXRlXCI6XG4gICAgICAgIGNhc2UgXCJvcGVuXCI6XG4gICAgICAgIGNhc2UgXCJwbGF5c0lubGluZVwiOlxuICAgICAgICBjYXNlIFwicmVhZE9ubHlcIjpcbiAgICAgICAgY2FzZSBcInJlcXVpcmVkXCI6XG4gICAgICAgIGNhc2UgXCJyZXZlcnNlZFwiOlxuICAgICAgICBjYXNlIFwic2NvcGVkXCI6XG4gICAgICAgIGNhc2UgXCJzZWFtbGVzc1wiOlxuICAgICAgICBjYXNlIFwiaXRlbVNjb3BlXCI6XG4gICAgICAgICAgdmFsdWUgJiZcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHZhbHVlICYmXG4gICAgICAgICAgICBcInN5bWJvbFwiICE9PSB0eXBlb2YgdmFsdWUgJiZcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKGF0dHJpYnV0ZVNlcGFyYXRvciwgbmFtZSwgYXR0cmlidXRlRW1wdHlTdHJpbmcpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiY2FwdHVyZVwiOlxuICAgICAgICBjYXNlIFwiZG93bmxvYWRcIjpcbiAgICAgICAgICAhMCA9PT0gdmFsdWVcbiAgICAgICAgICAgID8gdGFyZ2V0LnB1c2goYXR0cmlidXRlU2VwYXJhdG9yLCBuYW1lLCBhdHRyaWJ1dGVFbXB0eVN0cmluZylcbiAgICAgICAgICAgIDogITEgIT09IHZhbHVlICYmXG4gICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHZhbHVlICYmXG4gICAgICAgICAgICAgIFwic3ltYm9sXCIgIT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICAgICAgICB0YXJnZXQucHVzaChcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVTZXBhcmF0b3IsXG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVBc3NpZ24sXG4gICAgICAgICAgICAgICAgZXNjYXBlVGV4dEZvckJyb3dzZXIodmFsdWUpLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUVuZFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiY29sc1wiOlxuICAgICAgICBjYXNlIFwicm93c1wiOlxuICAgICAgICBjYXNlIFwic2l6ZVwiOlxuICAgICAgICBjYXNlIFwic3BhblwiOlxuICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHZhbHVlICYmXG4gICAgICAgICAgICBcInN5bWJvbFwiICE9PSB0eXBlb2YgdmFsdWUgJiZcbiAgICAgICAgICAgICFpc05hTih2YWx1ZSkgJiZcbiAgICAgICAgICAgIDEgPD0gdmFsdWUgJiZcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVTZXBhcmF0b3IsXG4gICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZUFzc2lnbixcbiAgICAgICAgICAgICAgZXNjYXBlVGV4dEZvckJyb3dzZXIodmFsdWUpLFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVFbmRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJyb3dTcGFuXCI6XG4gICAgICAgIGNhc2UgXCJzdGFydFwiOlxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHZhbHVlIHx8XG4gICAgICAgICAgICBcInN5bWJvbFwiID09PSB0eXBlb2YgdmFsdWUgfHxcbiAgICAgICAgICAgIGlzTmFOKHZhbHVlKSB8fFxuICAgICAgICAgICAgdGFyZ2V0LnB1c2goXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZVNlcGFyYXRvcixcbiAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgYXR0cmlidXRlQXNzaWduLFxuICAgICAgICAgICAgICBlc2NhcGVUZXh0Rm9yQnJvd3Nlcih2YWx1ZSksXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZUVuZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInhsaW5rQWN0dWF0ZVwiOlxuICAgICAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCBcInhsaW5rOmFjdHVhdGVcIiwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwieGxpbmtBcmNyb2xlXCI6XG4gICAgICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsIFwieGxpbms6YXJjcm9sZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ4bGlua1JvbGVcIjpcbiAgICAgICAgICBwdXNoU3RyaW5nQXR0cmlidXRlKHRhcmdldCwgXCJ4bGluazpyb2xlXCIsIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInhsaW5rU2hvd1wiOlxuICAgICAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCBcInhsaW5rOnNob3dcIiwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwieGxpbmtUaXRsZVwiOlxuICAgICAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCBcInhsaW5rOnRpdGxlXCIsIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInhsaW5rVHlwZVwiOlxuICAgICAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCBcInhsaW5rOnR5cGVcIiwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwieG1sQmFzZVwiOlxuICAgICAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCBcInhtbDpiYXNlXCIsIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInhtbExhbmdcIjpcbiAgICAgICAgICBwdXNoU3RyaW5nQXR0cmlidXRlKHRhcmdldCwgXCJ4bWw6bGFuZ1wiLCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ4bWxTcGFjZVwiOlxuICAgICAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCBcInhtbDpzcGFjZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgISgyIDwgbmFtZS5sZW5ndGgpIHx8XG4gICAgICAgICAgICAoXCJvXCIgIT09IG5hbWVbMF0gJiYgXCJPXCIgIT09IG5hbWVbMF0pIHx8XG4gICAgICAgICAgICAoXCJuXCIgIT09IG5hbWVbMV0gJiYgXCJOXCIgIT09IG5hbWVbMV0pXG4gICAgICAgICAgKVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAoKG5hbWUgPSBhbGlhc2VzLmdldChuYW1lKSB8fCBuYW1lKSwgaXNBdHRyaWJ1dGVOYW1lU2FmZShuYW1lKSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgICAgICAgICAgdmFyIHByZWZpeCA9IG5hbWUudG9Mb3dlckNhc2UoKS5zbGljZSgwLCA1KTtcbiAgICAgICAgICAgICAgICAgIGlmIChcImRhdGEtXCIgIT09IHByZWZpeCAmJiBcImFyaWEtXCIgIT09IHByZWZpeCkgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRhcmdldC5wdXNoKFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZVNlcGFyYXRvcixcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUFzc2lnbixcbiAgICAgICAgICAgICAgICBlc2NhcGVUZXh0Rm9yQnJvd3Nlcih2YWx1ZSksXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlRW5kXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hJbm5lckhUTUwodGFyZ2V0LCBpbm5lckhUTUwsIGNoaWxkcmVuKSB7XG4gICAgICBpZiAobnVsbCAhPSBpbm5lckhUTUwpIHtcbiAgICAgICAgaWYgKG51bGwgIT0gY2hpbGRyZW4pXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIkNhbiBvbmx5IHNldCBvbmUgb2YgYGNoaWxkcmVuYCBvciBgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgaWYgKFwib2JqZWN0XCIgIT09IHR5cGVvZiBpbm5lckhUTUwgfHwgIShcIl9faHRtbFwiIGluIGlubmVySFRNTCkpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcImBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAgbXVzdCBiZSBpbiB0aGUgZm9ybSBge19faHRtbDogLi4ufWAuIFBsZWFzZSB2aXNpdCBodHRwczovL3JlYWN0LmRldi9saW5rL2Rhbmdlcm91c2x5LXNldC1pbm5lci1odG1sIGZvciBtb3JlIGluZm9ybWF0aW9uLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgaW5uZXJIVE1MID0gaW5uZXJIVE1MLl9faHRtbDtcbiAgICAgICAgbnVsbCAhPT0gaW5uZXJIVE1MICYmXG4gICAgICAgICAgdm9pZCAwICE9PSBpbm5lckhUTUwgJiZcbiAgICAgICAgICAoY2hlY2tIdG1sU3RyaW5nQ29lcmNpb24oaW5uZXJIVE1MKSwgdGFyZ2V0LnB1c2goXCJcIiArIGlubmVySFRNTCkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja1NlbGVjdFByb3AocHJvcHMsIHByb3BOYW1lKSB7XG4gICAgICB2YXIgdmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBudWxsICE9IHZhbHVlICYmXG4gICAgICAgICgodmFsdWUgPSBpc0FycmF5SW1wbCh2YWx1ZSkpLFxuICAgICAgICBwcm9wcy5tdWx0aXBsZSAmJiAhdmFsdWVcbiAgICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiVGhlIGAlc2AgcHJvcCBzdXBwbGllZCB0byA8c2VsZWN0PiBtdXN0IGJlIGFuIGFycmF5IGlmIGBtdWx0aXBsZWAgaXMgdHJ1ZS5cIixcbiAgICAgICAgICAgICAgcHJvcE5hbWVcbiAgICAgICAgICAgIClcbiAgICAgICAgICA6ICFwcm9wcy5tdWx0aXBsZSAmJlxuICAgICAgICAgICAgdmFsdWUgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiVGhlIGAlc2AgcHJvcCBzdXBwbGllZCB0byA8c2VsZWN0PiBtdXN0IGJlIGEgc2NhbGFyIHZhbHVlIGlmIGBtdWx0aXBsZWAgaXMgZmFsc2UuXCIsXG4gICAgICAgICAgICAgIHByb3BOYW1lXG4gICAgICAgICAgICApKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmxhdHRlbk9wdGlvbkNoaWxkcmVuKGNoaWxkcmVuKSB7XG4gICAgICB2YXIgY29udGVudCA9IFwiXCI7XG4gICAgICBSZWFjdC5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgbnVsbCAhPSBjaGlsZCAmJlxuICAgICAgICAgICgoY29udGVudCArPSBjaGlsZCksXG4gICAgICAgICAgZGlkV2FybkludmFsaWRPcHRpb25DaGlsZHJlbiB8fFxuICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGNoaWxkIHx8XG4gICAgICAgICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgY2hpbGQgfHxcbiAgICAgICAgICAgIFwiYmlnaW50XCIgPT09IHR5cGVvZiBjaGlsZCB8fFxuICAgICAgICAgICAgKChkaWRXYXJuSW52YWxpZE9wdGlvbkNoaWxkcmVuID0gITApLFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJDYW5ub3QgaW5mZXIgdGhlIG9wdGlvbiB2YWx1ZSBvZiBjb21wbGV4IGNoaWxkcmVuLiBQYXNzIGEgYHZhbHVlYCBwcm9wIG9yIHVzZSBhIHBsYWluIHN0cmluZyBhcyBjaGlsZHJlbiB0byA8b3B0aW9uPi5cIlxuICAgICAgICAgICAgKSkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW5qZWN0Rm9ybVJlcGxheWluZ1J1bnRpbWUocmVzdW1hYmxlU3RhdGUsIHJlbmRlclN0YXRlKSB7XG4gICAgICBpZiAoKHJlc3VtYWJsZVN0YXRlLmluc3RydWN0aW9ucyAmIDE2KSA9PT0gTm90aGluZ1NlbnQpIHtcbiAgICAgICAgcmVzdW1hYmxlU3RhdGUuaW5zdHJ1Y3Rpb25zIHw9IDE2O1xuICAgICAgICB2YXIgcHJlYW1ibGUgPSByZW5kZXJTdGF0ZS5wcmVhbWJsZSxcbiAgICAgICAgICBib290c3RyYXBDaHVua3MgPSByZW5kZXJTdGF0ZS5ib290c3RyYXBDaHVua3M7XG4gICAgICAgIChwcmVhbWJsZS5odG1sQ2h1bmtzIHx8IHByZWFtYmxlLmhlYWRDaHVua3MpICYmXG4gICAgICAgIDAgPT09IGJvb3RzdHJhcENodW5rcy5sZW5ndGhcbiAgICAgICAgICA/IChib290c3RyYXBDaHVua3MucHVzaChyZW5kZXJTdGF0ZS5zdGFydElubGluZVNjcmlwdCksXG4gICAgICAgICAgICBwdXNoQ29tcGxldGVkU2hlbGxJZEF0dHJpYnV0ZShib290c3RyYXBDaHVua3MsIHJlc3VtYWJsZVN0YXRlKSxcbiAgICAgICAgICAgIGJvb3RzdHJhcENodW5rcy5wdXNoKFxuICAgICAgICAgICAgICBlbmRPZlN0YXJ0VGFnLFxuICAgICAgICAgICAgICBmb3JtUmVwbGF5aW5nUnVudGltZVNjcmlwdCxcbiAgICAgICAgICAgICAgZW5kSW5saW5lU2NyaXB0XG4gICAgICAgICAgICApKVxuICAgICAgICAgIDogYm9vdHN0cmFwQ2h1bmtzLnVuc2hpZnQoXG4gICAgICAgICAgICAgIHJlbmRlclN0YXRlLnN0YXJ0SW5saW5lU2NyaXB0LFxuICAgICAgICAgICAgICBlbmRPZlN0YXJ0VGFnLFxuICAgICAgICAgICAgICBmb3JtUmVwbGF5aW5nUnVudGltZVNjcmlwdCxcbiAgICAgICAgICAgICAgZW5kSW5saW5lU2NyaXB0XG4gICAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoTGlua0ltcGwodGFyZ2V0LCBwcm9wcykge1xuICAgICAgdGFyZ2V0LnB1c2goc3RhcnRDaHVua0ZvclRhZyhcImxpbmtcIikpO1xuICAgICAgZm9yICh2YXIgcHJvcEtleSBpbiBwcm9wcylcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuICAgICAgICAgIGlmIChudWxsICE9IHByb3BWYWx1ZSlcbiAgICAgICAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICBcImxpbmsgaXMgYSBzZWxmLWNsb3NpbmcgdGFnIGFuZCBtdXN0IG5laXRoZXIgaGF2ZSBgY2hpbGRyZW5gIG5vciB1c2UgYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC5cIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIHRhcmdldC5wdXNoKGVuZE9mU3RhcnRUYWdTZWxmQ2xvc2luZyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZXNjYXBlU3R5bGVUZXh0Q29udGVudChzdHlsZVRleHQpIHtcbiAgICAgIGNoZWNrSHRtbFN0cmluZ0NvZXJjaW9uKHN0eWxlVGV4dCk7XG4gICAgICByZXR1cm4gKFwiXCIgKyBzdHlsZVRleHQpLnJlcGxhY2Uoc3R5bGVSZWdleCwgc3R5bGVSZXBsYWNlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hTZWxmQ2xvc2luZyh0YXJnZXQsIHByb3BzLCB0YWcpIHtcbiAgICAgIHRhcmdldC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcodGFnKSk7XG4gICAgICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKVxuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkpIHtcbiAgICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG4gICAgICAgICAgaWYgKG51bGwgIT0gcHJvcFZhbHVlKVxuICAgICAgICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgIHRhZyArXG4gICAgICAgICAgICAgICAgICAgIFwiIGlzIGEgc2VsZi1jbG9zaW5nIHRhZyBhbmQgbXVzdCBuZWl0aGVyIGhhdmUgYGNoaWxkcmVuYCBub3IgdXNlIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB0YXJnZXQucHVzaChlbmRPZlN0YXJ0VGFnU2VsZkNsb3NpbmcpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hUaXRsZUltcGwodGFyZ2V0LCBwcm9wcykge1xuICAgICAgdGFyZ2V0LnB1c2goc3RhcnRDaHVua0ZvclRhZyhcInRpdGxlXCIpKTtcbiAgICAgIHZhciBjaGlsZHJlbiA9IG51bGwsXG4gICAgICAgIGlubmVySFRNTCA9IG51bGwsXG4gICAgICAgIHByb3BLZXk7XG4gICAgICBmb3IgKHByb3BLZXkgaW4gcHJvcHMpXG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5KSkge1xuICAgICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcbiAgICAgICAgICBpZiAobnVsbCAhPSBwcm9wVmFsdWUpXG4gICAgICAgICAgICBzd2l0Y2ggKHByb3BLZXkpIHtcbiAgICAgICAgICAgICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4gPSBwcm9wVmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICAgICAgICAgIGlubmVySFRNTCA9IHByb3BWYWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgdGFyZ2V0LnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gICAgICBwcm9wcyA9IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pXG4gICAgICAgID8gMiA+IGNoaWxkcmVuLmxlbmd0aFxuICAgICAgICAgID8gY2hpbGRyZW5bMF1cbiAgICAgICAgICA6IG51bGxcbiAgICAgICAgOiBjaGlsZHJlbjtcbiAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHByb3BzICYmXG4gICAgICAgIFwic3ltYm9sXCIgIT09IHR5cGVvZiBwcm9wcyAmJlxuICAgICAgICBudWxsICE9PSBwcm9wcyAmJlxuICAgICAgICB2b2lkIDAgIT09IHByb3BzICYmXG4gICAgICAgIHRhcmdldC5wdXNoKGVzY2FwZVRleHRGb3JCcm93c2VyKFwiXCIgKyBwcm9wcykpO1xuICAgICAgcHVzaElubmVySFRNTCh0YXJnZXQsIGlubmVySFRNTCwgY2hpbGRyZW4pO1xuICAgICAgdGFyZ2V0LnB1c2goZW5kQ2h1bmtGb3JUYWcoXCJ0aXRsZVwiKSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaFNjcmlwdEltcGwodGFyZ2V0LCBwcm9wcykge1xuICAgICAgdGFyZ2V0LnB1c2goc3RhcnRDaHVua0ZvclRhZyhcInNjcmlwdFwiKSk7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBudWxsLFxuICAgICAgICBpbm5lckhUTUwgPSBudWxsLFxuICAgICAgICBwcm9wS2V5O1xuICAgICAgZm9yIChwcm9wS2V5IGluIHByb3BzKVxuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkpIHtcbiAgICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG4gICAgICAgICAgaWYgKG51bGwgIT0gcHJvcFZhbHVlKVxuICAgICAgICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICAgIGNoaWxkcmVuID0gcHJvcFZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICBpbm5lckhUTUwgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIHRhcmdldC5wdXNoKGVuZE9mU3RhcnRUYWcpO1xuICAgICAgbnVsbCAhPSBjaGlsZHJlbiAmJlxuICAgICAgICBcInN0cmluZ1wiICE9PSB0eXBlb2YgY2hpbGRyZW4gJiZcbiAgICAgICAgKChwcm9wcyA9XG4gICAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIGNoaWxkcmVuXG4gICAgICAgICAgICA/IFwiYSBudW1iZXIgZm9yIGNoaWxkcmVuXCJcbiAgICAgICAgICAgIDogQXJyYXkuaXNBcnJheShjaGlsZHJlbilcbiAgICAgICAgICAgICAgPyBcImFuIGFycmF5IGZvciBjaGlsZHJlblwiXG4gICAgICAgICAgICAgIDogXCJzb21ldGhpbmcgdW5leHBlY3RlZCBmb3IgY2hpbGRyZW5cIiksXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJBIHNjcmlwdCBlbGVtZW50IHdhcyByZW5kZXJlZCB3aXRoICVzLiBJZiBzY3JpcHQgZWxlbWVudCBoYXMgY2hpbGRyZW4gaXQgbXVzdCBiZSBhIHNpbmdsZSBzdHJpbmcuIENvbnNpZGVyIHVzaW5nIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIG9yIHBhc3NpbmcgYSBwbGFpbiBzdHJpbmcgYXMgY2hpbGRyZW4uXCIsXG4gICAgICAgICAgcHJvcHNcbiAgICAgICAgKSk7XG4gICAgICBwdXNoSW5uZXJIVE1MKHRhcmdldCwgaW5uZXJIVE1MLCBjaGlsZHJlbik7XG4gICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgY2hpbGRyZW4gJiZcbiAgICAgICAgdGFyZ2V0LnB1c2goZXNjYXBlRW50aXJlSW5saW5lU2NyaXB0Q29udGVudChjaGlsZHJlbikpO1xuICAgICAgdGFyZ2V0LnB1c2goZW5kQ2h1bmtGb3JUYWcoXCJzY3JpcHRcIikpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hTdGFydFNpbmdsZXRvbkVsZW1lbnQodGFyZ2V0LCBwcm9wcywgdGFnKSB7XG4gICAgICB0YXJnZXQucHVzaChzdGFydENodW5rRm9yVGFnKHRhZykpO1xuICAgICAgdmFyIGlubmVySFRNTCA9ICh0YWcgPSBudWxsKSxcbiAgICAgICAgcHJvcEtleTtcbiAgICAgIGZvciAocHJvcEtleSBpbiBwcm9wcylcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuICAgICAgICAgIGlmIChudWxsICE9IHByb3BWYWx1ZSlcbiAgICAgICAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgICB0YWcgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICAgICAgICAgIGlubmVySFRNTCA9IHByb3BWYWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgdGFyZ2V0LnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gICAgICBwdXNoSW5uZXJIVE1MKHRhcmdldCwgaW5uZXJIVE1MLCB0YWcpO1xuICAgICAgcmV0dXJuIHRhZztcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaFN0YXJ0R2VuZXJpY0VsZW1lbnQodGFyZ2V0LCBwcm9wcywgdGFnKSB7XG4gICAgICB0YXJnZXQucHVzaChzdGFydENodW5rRm9yVGFnKHRhZykpO1xuICAgICAgdmFyIGlubmVySFRNTCA9ICh0YWcgPSBudWxsKSxcbiAgICAgICAgcHJvcEtleTtcbiAgICAgIGZvciAocHJvcEtleSBpbiBwcm9wcylcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuICAgICAgICAgIGlmIChudWxsICE9IHByb3BWYWx1ZSlcbiAgICAgICAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgICB0YWcgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICAgICAgICAgIGlubmVySFRNTCA9IHByb3BWYWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgdGFyZ2V0LnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gICAgICBwdXNoSW5uZXJIVE1MKHRhcmdldCwgaW5uZXJIVE1MLCB0YWcpO1xuICAgICAgcmV0dXJuIFwic3RyaW5nXCIgPT09IHR5cGVvZiB0YWdcbiAgICAgICAgPyAodGFyZ2V0LnB1c2goZXNjYXBlVGV4dEZvckJyb3dzZXIodGFnKSksIG51bGwpXG4gICAgICAgIDogdGFnO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdGFydENodW5rRm9yVGFnKHRhZykge1xuICAgICAgdmFyIHRhZ1N0YXJ0Q2h1bmsgPSB2YWxpZGF0ZWRUYWdDYWNoZS5nZXQodGFnKTtcbiAgICAgIGlmICh2b2lkIDAgPT09IHRhZ1N0YXJ0Q2h1bmspIHtcbiAgICAgICAgaWYgKCFWQUxJRF9UQUdfUkVHRVgudGVzdCh0YWcpKSB0aHJvdyBFcnJvcihcIkludmFsaWQgdGFnOiBcIiArIHRhZyk7XG4gICAgICAgIHRhZ1N0YXJ0Q2h1bmsgPSBcIjxcIiArIHRhZztcbiAgICAgICAgdmFsaWRhdGVkVGFnQ2FjaGUuc2V0KHRhZywgdGFnU3RhcnRDaHVuayk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFnU3RhcnRDaHVuaztcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaFN0YXJ0SW5zdGFuY2UoXG4gICAgICB0YXJnZXQkanNjb21wJDAsXG4gICAgICB0eXBlLFxuICAgICAgcHJvcHMsXG4gICAgICByZXN1bWFibGVTdGF0ZSxcbiAgICAgIHJlbmRlclN0YXRlLFxuICAgICAgcHJlYW1ibGVTdGF0ZSxcbiAgICAgIGhvaXN0YWJsZVN0YXRlLFxuICAgICAgZm9ybWF0Q29udGV4dCxcbiAgICAgIHRleHRFbWJlZGRlZFxuICAgICkge1xuICAgICAgdmFsaWRhdGVQcm9wZXJ0aWVzJDIodHlwZSwgcHJvcHMpO1xuICAgICAgKFwiaW5wdXRcIiAhPT0gdHlwZSAmJiBcInRleHRhcmVhXCIgIT09IHR5cGUgJiYgXCJzZWxlY3RcIiAhPT0gdHlwZSkgfHxcbiAgICAgICAgbnVsbCA9PSBwcm9wcyB8fFxuICAgICAgICBudWxsICE9PSBwcm9wcy52YWx1ZSB8fFxuICAgICAgICBkaWRXYXJuVmFsdWVOdWxsIHx8XG4gICAgICAgICgoZGlkV2FyblZhbHVlTnVsbCA9ICEwKSxcbiAgICAgICAgXCJzZWxlY3RcIiA9PT0gdHlwZSAmJiBwcm9wcy5tdWx0aXBsZVxuICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJgdmFsdWVgIHByb3Agb24gYCVzYCBzaG91bGQgbm90IGJlIG51bGwuIENvbnNpZGVyIHVzaW5nIGFuIGVtcHR5IGFycmF5IHdoZW4gYG11bHRpcGxlYCBpcyBzZXQgdG8gYHRydWVgIHRvIGNsZWFyIHRoZSBjb21wb25lbnQgb3IgYHVuZGVmaW5lZGAgZm9yIHVuY29udHJvbGxlZCBjb21wb25lbnRzLlwiLFxuICAgICAgICAgICAgICB0eXBlXG4gICAgICAgICAgICApXG4gICAgICAgICAgOiBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcImB2YWx1ZWAgcHJvcCBvbiBgJXNgIHNob3VsZCBub3QgYmUgbnVsbC4gQ29uc2lkZXIgdXNpbmcgYW4gZW1wdHkgc3RyaW5nIHRvIGNsZWFyIHRoZSBjb21wb25lbnQgb3IgYHVuZGVmaW5lZGAgZm9yIHVuY29udHJvbGxlZCBjb21wb25lbnRzLlwiLFxuICAgICAgICAgICAgICB0eXBlXG4gICAgICAgICAgICApKTtcbiAgICAgIGI6IGlmICgtMSA9PT0gdHlwZS5pbmRleE9mKFwiLVwiKSkgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICExO1xuICAgICAgZWxzZVxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwiYW5ub3RhdGlvbi14bWxcIjpcbiAgICAgICAgICBjYXNlIFwiY29sb3ItcHJvZmlsZVwiOlxuICAgICAgICAgIGNhc2UgXCJmb250LWZhY2VcIjpcbiAgICAgICAgICBjYXNlIFwiZm9udC1mYWNlLXNyY1wiOlxuICAgICAgICAgIGNhc2UgXCJmb250LWZhY2UtdXJpXCI6XG4gICAgICAgICAgY2FzZSBcImZvbnQtZmFjZS1mb3JtYXRcIjpcbiAgICAgICAgICBjYXNlIFwiZm9udC1mYWNlLW5hbWVcIjpcbiAgICAgICAgICBjYXNlIFwibWlzc2luZy1nbHlwaFwiOlxuICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITE7XG4gICAgICAgICAgICBicmVhayBiO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAhMDtcbiAgICAgICAgfVxuICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0IHx8XG4gICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBwcm9wcy5pcyB8fFxuICAgICAgICB3YXJuVW5rbm93blByb3BlcnRpZXModHlwZSwgcHJvcHMsIG51bGwpO1xuICAgICAgIXByb3BzLnN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZyAmJlxuICAgICAgICBwcm9wcy5jb250ZW50RWRpdGFibGUgJiZcbiAgICAgICAgbnVsbCAhPSBwcm9wcy5jaGlsZHJlbiAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiQSBjb21wb25lbnQgaXMgYGNvbnRlbnRFZGl0YWJsZWAgYW5kIGNvbnRhaW5zIGBjaGlsZHJlbmAgbWFuYWdlZCBieSBSZWFjdC4gSXQgaXMgbm93IHlvdXIgcmVzcG9uc2liaWxpdHkgdG8gZ3VhcmFudGVlIHRoYXQgbm9uZSBvZiB0aG9zZSBub2RlcyBhcmUgdW5leHBlY3RlZGx5IG1vZGlmaWVkIG9yIGR1cGxpY2F0ZWQuIFRoaXMgaXMgcHJvYmFibHkgbm90IGludGVudGlvbmFsLlwiXG4gICAgICAgICk7XG4gICAgICBmb3JtYXRDb250ZXh0Lmluc2VydGlvbk1vZGUgIT09IFNWR19NT0RFICYmXG4gICAgICAgIGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSAhPT0gTUFUSE1MX01PREUgJiZcbiAgICAgICAgLTEgPT09IHR5cGUuaW5kZXhPZihcIi1cIikgJiZcbiAgICAgICAgdHlwZS50b0xvd2VyQ2FzZSgpICE9PSB0eXBlICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCI8JXMgLz4gaXMgdXNpbmcgaW5jb3JyZWN0IGNhc2luZy4gVXNlIFBhc2NhbENhc2UgZm9yIFJlYWN0IGNvbXBvbmVudHMsIG9yIGxvd2VyY2FzZSBmb3IgSFRNTCBlbGVtZW50cy5cIixcbiAgICAgICAgICB0eXBlXG4gICAgICAgICk7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcImRpdlwiOlxuICAgICAgICBjYXNlIFwic3BhblwiOlxuICAgICAgICBjYXNlIFwic3ZnXCI6XG4gICAgICAgIGNhc2UgXCJwYXRoXCI6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJhXCI6XG4gICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goc3RhcnRDaHVua0ZvclRhZyhcImFcIikpO1xuICAgICAgICAgIHZhciBjaGlsZHJlbiA9IG51bGwsXG4gICAgICAgICAgICBpbm5lckhUTUwgPSBudWxsLFxuICAgICAgICAgICAgcHJvcEtleTtcbiAgICAgICAgICBmb3IgKHByb3BLZXkgaW4gcHJvcHMpXG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkpIHtcbiAgICAgICAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuICAgICAgICAgICAgICBpZiAobnVsbCAhPSBwcm9wVmFsdWUpXG4gICAgICAgICAgICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4gPSBwcm9wVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgICAgICAgICAgIGlubmVySFRNTCA9IHByb3BWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiaHJlZlwiOlxuICAgICAgICAgICAgICAgICAgICBcIlwiID09PSBwcm9wVmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICA/IHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0JGpzY29tcCQwLCBcImhyZWZcIiwgXCJcIilcbiAgICAgICAgICAgICAgICAgICAgICA6IHB1c2hBdHRyaWJ1dGUodGFyZ2V0JGpzY29tcCQwLCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0JGpzY29tcCQwLCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChlbmRPZlN0YXJ0VGFnKTtcbiAgICAgICAgICBwdXNoSW5uZXJIVE1MKHRhcmdldCRqc2NvbXAkMCwgaW5uZXJIVE1MLCBjaGlsZHJlbik7XG4gICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBjaGlsZHJlbikge1xuICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goZXNjYXBlVGV4dEZvckJyb3dzZXIoY2hpbGRyZW4pKTtcbiAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDAgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDAgPSBjaGlsZHJlbjtcbiAgICAgICAgICByZXR1cm4gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwO1xuICAgICAgICBjYXNlIFwiZ1wiOlxuICAgICAgICBjYXNlIFwicFwiOlxuICAgICAgICBjYXNlIFwibGlcIjpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInNlbGVjdFwiOlxuICAgICAgICAgIGNoZWNrQ29udHJvbGxlZFZhbHVlUHJvcHMoXCJzZWxlY3RcIiwgcHJvcHMpO1xuICAgICAgICAgIGNoZWNrU2VsZWN0UHJvcChwcm9wcywgXCJ2YWx1ZVwiKTtcbiAgICAgICAgICBjaGVja1NlbGVjdFByb3AocHJvcHMsIFwiZGVmYXVsdFZhbHVlXCIpO1xuICAgICAgICAgIHZvaWQgMCA9PT0gcHJvcHMudmFsdWUgfHxcbiAgICAgICAgICAgIHZvaWQgMCA9PT0gcHJvcHMuZGVmYXVsdFZhbHVlIHx8XG4gICAgICAgICAgICBkaWRXYXJuRGVmYXVsdFNlbGVjdFZhbHVlIHx8XG4gICAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJTZWxlY3QgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgc2VsZWN0IGVsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9jb250cm9sbGVkLWNvbXBvbmVudHNcIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIChkaWRXYXJuRGVmYXVsdFNlbGVjdFZhbHVlID0gITApKTtcbiAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChzdGFydENodW5rRm9yVGFnKFwic2VsZWN0XCIpKTtcbiAgICAgICAgICB2YXIgY2hpbGRyZW4kanNjb21wJDAgPSBudWxsLFxuICAgICAgICAgICAgaW5uZXJIVE1MJGpzY29tcCQwID0gbnVsbCxcbiAgICAgICAgICAgIHByb3BLZXkkanNjb21wJDA7XG4gICAgICAgICAgZm9yIChwcm9wS2V5JGpzY29tcCQwIGluIHByb3BzKVxuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkkanNjb21wJDApKSB7XG4gICAgICAgICAgICAgIHZhciBwcm9wVmFsdWUkanNjb21wJDAgPSBwcm9wc1twcm9wS2V5JGpzY29tcCQwXTtcbiAgICAgICAgICAgICAgaWYgKG51bGwgIT0gcHJvcFZhbHVlJGpzY29tcCQwKVxuICAgICAgICAgICAgICAgIHN3aXRjaCAocHJvcEtleSRqc2NvbXAkMCkge1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuJGpzY29tcCQwID0gcHJvcFZhbHVlJGpzY29tcCQwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICAgICAgICAgICAgICBpbm5lckhUTUwkanNjb21wJDAgPSBwcm9wVmFsdWUkanNjb21wJDA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImRlZmF1bHRWYWx1ZVwiOlxuICAgICAgICAgICAgICAgICAgY2FzZSBcInZhbHVlXCI6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZShcbiAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcEtleSRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wVmFsdWUkanNjb21wJDBcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gICAgICAgICAgcHVzaElubmVySFRNTCh0YXJnZXQkanNjb21wJDAsIGlubmVySFRNTCRqc2NvbXAkMCwgY2hpbGRyZW4kanNjb21wJDApO1xuICAgICAgICAgIHJldHVybiBjaGlsZHJlbiRqc2NvbXAkMDtcbiAgICAgICAgY2FzZSBcIm9wdGlvblwiOlxuICAgICAgICAgIHZhciBzZWxlY3RlZFZhbHVlID0gZm9ybWF0Q29udGV4dC5zZWxlY3RlZFZhbHVlO1xuICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoXCJvcHRpb25cIikpO1xuICAgICAgICAgIHZhciBjaGlsZHJlbiRqc2NvbXAkMSA9IG51bGwsXG4gICAgICAgICAgICB2YWx1ZSA9IG51bGwsXG4gICAgICAgICAgICBzZWxlY3RlZCA9IG51bGwsXG4gICAgICAgICAgICBpbm5lckhUTUwkanNjb21wJDEgPSBudWxsLFxuICAgICAgICAgICAgcHJvcEtleSRqc2NvbXAkMTtcbiAgICAgICAgICBmb3IgKHByb3BLZXkkanNjb21wJDEgaW4gcHJvcHMpXG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSRqc2NvbXAkMSkpIHtcbiAgICAgICAgICAgICAgdmFyIHByb3BWYWx1ZSRqc2NvbXAkMSA9IHByb3BzW3Byb3BLZXkkanNjb21wJDFdO1xuICAgICAgICAgICAgICBpZiAobnVsbCAhPSBwcm9wVmFsdWUkanNjb21wJDEpXG4gICAgICAgICAgICAgICAgc3dpdGNoIChwcm9wS2V5JGpzY29tcCQxKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4kanNjb21wJDEgPSBwcm9wVmFsdWUkanNjb21wJDE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcInNlbGVjdGVkXCI6XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkID0gcHJvcFZhbHVlJGpzY29tcCQxO1xuICAgICAgICAgICAgICAgICAgICBkaWRXYXJuU2VsZWN0ZWRTZXRPbk9wdGlvbiB8fFxuICAgICAgICAgICAgICAgICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJVc2UgdGhlIGBkZWZhdWx0VmFsdWVgIG9yIGB2YWx1ZWAgcHJvcHMgb24gPHNlbGVjdD4gaW5zdGVhZCBvZiBzZXR0aW5nIGBzZWxlY3RlZGAgb24gPG9wdGlvbj4uXCJcbiAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgIChkaWRXYXJuU2VsZWN0ZWRTZXRPbk9wdGlvbiA9ICEwKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgICAgICAgICAgIGlubmVySFRNTCRqc2NvbXAkMSA9IHByb3BWYWx1ZSRqc2NvbXAkMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwidmFsdWVcIjpcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwcm9wVmFsdWUkanNjb21wJDE7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBwdXNoQXR0cmlidXRlKFxuICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQxLFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BWYWx1ZSRqc2NvbXAkMVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobnVsbCAhPSBzZWxlY3RlZFZhbHVlKSB7XG4gICAgICAgICAgICBpZiAobnVsbCAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbih2YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICAgICAgICAgICAgdmFyIHN0cmluZ1ZhbHVlID0gXCJcIiArIHZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgIG51bGwgPT09IGlubmVySFRNTCRqc2NvbXAkMSB8fFxuICAgICAgICAgICAgICAgIGRpZFdhcm5JbnZhbGlkT3B0aW9uSW5uZXJIVE1MIHx8XG4gICAgICAgICAgICAgICAgKChkaWRXYXJuSW52YWxpZE9wdGlvbklubmVySFRNTCA9ICEwKSxcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJQYXNzIGEgYHZhbHVlYCBwcm9wIGlmIHlvdSBzZXQgZGFuZ2Vyb3VzbHlJbm5lckhUTUwgc28gUmVhY3Qga25vd3Mgd2hpY2ggdmFsdWUgc2hvdWxkIGJlIHNlbGVjdGVkLlwiXG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgKHN0cmluZ1ZhbHVlID0gZmxhdHRlbk9wdGlvbkNoaWxkcmVuKGNoaWxkcmVuJGpzY29tcCQxKSk7XG4gICAgICAgICAgICBpZiAoaXNBcnJheUltcGwoc2VsZWN0ZWRWYWx1ZSkpXG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZWN0ZWRWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgIChjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHNlbGVjdGVkVmFsdWVbaV0sIFwidmFsdWVcIiksXG4gICAgICAgICAgICAgICAgICBcIlwiICsgc2VsZWN0ZWRWYWx1ZVtpXSA9PT0gc3RyaW5nVmFsdWUpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaCgnIHNlbGVjdGVkPVwiXCInKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHNlbGVjdGVkVmFsdWUsIFwic2VsZWN0LnZhbHVlXCIpLFxuICAgICAgICAgICAgICAgIFwiXCIgKyBzZWxlY3RlZFZhbHVlID09PSBzdHJpbmdWYWx1ZSAmJlxuICAgICAgICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goJyBzZWxlY3RlZD1cIlwiJyk7XG4gICAgICAgICAgfSBlbHNlIHNlbGVjdGVkICYmIHRhcmdldCRqc2NvbXAkMC5wdXNoKCcgc2VsZWN0ZWQ9XCJcIicpO1xuICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKGVuZE9mU3RhcnRUYWcpO1xuICAgICAgICAgIHB1c2hJbm5lckhUTUwodGFyZ2V0JGpzY29tcCQwLCBpbm5lckhUTUwkanNjb21wJDEsIGNoaWxkcmVuJGpzY29tcCQxKTtcbiAgICAgICAgICByZXR1cm4gY2hpbGRyZW4kanNjb21wJDE7XG4gICAgICAgIGNhc2UgXCJ0ZXh0YXJlYVwiOlxuICAgICAgICAgIGNoZWNrQ29udHJvbGxlZFZhbHVlUHJvcHMoXCJ0ZXh0YXJlYVwiLCBwcm9wcyk7XG4gICAgICAgICAgdm9pZCAwID09PSBwcm9wcy52YWx1ZSB8fFxuICAgICAgICAgICAgdm9pZCAwID09PSBwcm9wcy5kZWZhdWx0VmFsdWUgfHxcbiAgICAgICAgICAgIGRpZFdhcm5EZWZhdWx0VGV4dGFyZWFWYWx1ZSB8fFxuICAgICAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiVGV4dGFyZWEgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgdGV4dGFyZWEgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9jb250cm9sbGVkLWNvbXBvbmVudHNcIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIChkaWRXYXJuRGVmYXVsdFRleHRhcmVhVmFsdWUgPSAhMCkpO1xuICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoXCJ0ZXh0YXJlYVwiKSk7XG4gICAgICAgICAgdmFyIHZhbHVlJGpzY29tcCQwID0gbnVsbCxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZSA9IG51bGwsXG4gICAgICAgICAgICBjaGlsZHJlbiRqc2NvbXAkMiA9IG51bGwsXG4gICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQyO1xuICAgICAgICAgIGZvciAocHJvcEtleSRqc2NvbXAkMiBpbiBwcm9wcylcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5JGpzY29tcCQyKSkge1xuICAgICAgICAgICAgICB2YXIgcHJvcFZhbHVlJGpzY29tcCQyID0gcHJvcHNbcHJvcEtleSRqc2NvbXAkMl07XG4gICAgICAgICAgICAgIGlmIChudWxsICE9IHByb3BWYWx1ZSRqc2NvbXAkMilcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHByb3BLZXkkanNjb21wJDIpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbiRqc2NvbXAkMiA9IHByb3BWYWx1ZSRqc2NvbXAkMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwidmFsdWVcIjpcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUkanNjb21wJDAgPSBwcm9wVmFsdWUkanNjb21wJDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImRlZmF1bHRWYWx1ZVwiOlxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWUgPSBwcm9wVmFsdWUkanNjb21wJDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgIFwiYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBkb2VzIG5vdCBtYWtlIHNlbnNlIG9uIDx0ZXh0YXJlYT4uXCJcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHB1c2hBdHRyaWJ1dGUoXG4gICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BLZXkkanNjb21wJDIsXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcFZhbHVlJGpzY29tcCQyXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIG51bGwgPT09IHZhbHVlJGpzY29tcCQwICYmXG4gICAgICAgICAgICBudWxsICE9PSBkZWZhdWx0VmFsdWUgJiZcbiAgICAgICAgICAgICh2YWx1ZSRqc2NvbXAkMCA9IGRlZmF1bHRWYWx1ZSk7XG4gICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gICAgICAgICAgaWYgKG51bGwgIT0gY2hpbGRyZW4kanNjb21wJDIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiVXNlIHRoZSBgZGVmYXVsdFZhbHVlYCBvciBgdmFsdWVgIHByb3BzIGluc3RlYWQgb2Ygc2V0dGluZyBjaGlsZHJlbiBvbiA8dGV4dGFyZWE+LlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKG51bGwgIT0gdmFsdWUkanNjb21wJDApXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiSWYgeW91IHN1cHBseSBgZGVmYXVsdFZhbHVlYCBvbiBhIDx0ZXh0YXJlYT4sIGRvIG5vdCBwYXNzIGNoaWxkcmVuLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoaXNBcnJheUltcGwoY2hpbGRyZW4kanNjb21wJDIpKSB7XG4gICAgICAgICAgICAgIGlmICgxIDwgY2hpbGRyZW4kanNjb21wJDIubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiPHRleHRhcmVhPiBjYW4gb25seSBoYXZlIGF0IG1vc3Qgb25lIGNoaWxkLlwiKTtcbiAgICAgICAgICAgICAgY2hlY2tIdG1sU3RyaW5nQ29lcmNpb24oY2hpbGRyZW4kanNjb21wJDJbMF0pO1xuICAgICAgICAgICAgICB2YWx1ZSRqc2NvbXAkMCA9IFwiXCIgKyBjaGlsZHJlbiRqc2NvbXAkMlswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoZWNrSHRtbFN0cmluZ0NvZXJjaW9uKGNoaWxkcmVuJGpzY29tcCQyKTtcbiAgICAgICAgICAgIHZhbHVlJGpzY29tcCQwID0gXCJcIiArIGNoaWxkcmVuJGpzY29tcCQyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgdmFsdWUkanNjb21wJDAgJiZcbiAgICAgICAgICAgIFwiXFxuXCIgPT09IHZhbHVlJGpzY29tcCQwWzBdICYmXG4gICAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChsZWFkaW5nTmV3bGluZSk7XG4gICAgICAgICAgbnVsbCAhPT0gdmFsdWUkanNjb21wJDAgJiZcbiAgICAgICAgICAgIChjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlJGpzY29tcCQwLCBcInZhbHVlXCIpLFxuICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goZXNjYXBlVGV4dEZvckJyb3dzZXIoXCJcIiArIHZhbHVlJGpzY29tcCQwKSkpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjYXNlIFwiaW5wdXRcIjpcbiAgICAgICAgICBjaGVja0NvbnRyb2xsZWRWYWx1ZVByb3BzKFwiaW5wdXRcIiwgcHJvcHMpO1xuICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoXCJpbnB1dFwiKSk7XG4gICAgICAgICAgdmFyIG5hbWUgPSBudWxsLFxuICAgICAgICAgICAgZm9ybUFjdGlvbiA9IG51bGwsXG4gICAgICAgICAgICBmb3JtRW5jVHlwZSA9IG51bGwsXG4gICAgICAgICAgICBmb3JtTWV0aG9kID0gbnVsbCxcbiAgICAgICAgICAgIGZvcm1UYXJnZXQgPSBudWxsLFxuICAgICAgICAgICAgdmFsdWUkanNjb21wJDEgPSBudWxsLFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlJGpzY29tcCQwID0gbnVsbCxcbiAgICAgICAgICAgIGNoZWNrZWQgPSBudWxsLFxuICAgICAgICAgICAgZGVmYXVsdENoZWNrZWQgPSBudWxsLFxuICAgICAgICAgICAgcHJvcEtleSRqc2NvbXAkMztcbiAgICAgICAgICBmb3IgKHByb3BLZXkkanNjb21wJDMgaW4gcHJvcHMpXG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSRqc2NvbXAkMykpIHtcbiAgICAgICAgICAgICAgdmFyIHByb3BWYWx1ZSRqc2NvbXAkMyA9IHByb3BzW3Byb3BLZXkkanNjb21wJDNdO1xuICAgICAgICAgICAgICBpZiAobnVsbCAhPSBwcm9wVmFsdWUkanNjb21wJDMpXG4gICAgICAgICAgICAgICAgc3dpdGNoIChwcm9wS2V5JGpzY29tcCQzKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICBcImlucHV0IGlzIGEgc2VsZi1jbG9zaW5nIHRhZyBhbmQgbXVzdCBuZWl0aGVyIGhhdmUgYGNoaWxkcmVuYCBub3IgdXNlIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuXCJcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJuYW1lXCI6XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBwcm9wVmFsdWUkanNjb21wJDM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImZvcm1BY3Rpb25cIjpcbiAgICAgICAgICAgICAgICAgICAgZm9ybUFjdGlvbiA9IHByb3BWYWx1ZSRqc2NvbXAkMztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZm9ybUVuY1R5cGVcIjpcbiAgICAgICAgICAgICAgICAgICAgZm9ybUVuY1R5cGUgPSBwcm9wVmFsdWUkanNjb21wJDM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImZvcm1NZXRob2RcIjpcbiAgICAgICAgICAgICAgICAgICAgZm9ybU1ldGhvZCA9IHByb3BWYWx1ZSRqc2NvbXAkMztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZm9ybVRhcmdldFwiOlxuICAgICAgICAgICAgICAgICAgICBmb3JtVGFyZ2V0ID0gcHJvcFZhbHVlJGpzY29tcCQzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJkZWZhdWx0Q2hlY2tlZFwiOlxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0Q2hlY2tlZCA9IHByb3BWYWx1ZSRqc2NvbXAkMztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZGVmYXVsdFZhbHVlXCI6XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZSRqc2NvbXAkMCA9IHByb3BWYWx1ZSRqc2NvbXAkMztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiY2hlY2tlZFwiOlxuICAgICAgICAgICAgICAgICAgICBjaGVja2VkID0gcHJvcFZhbHVlJGpzY29tcCQzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJ2YWx1ZVwiOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSRqc2NvbXAkMSA9IHByb3BWYWx1ZSRqc2NvbXAkMztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBwdXNoQXR0cmlidXRlKFxuICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQzLFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BWYWx1ZSRqc2NvbXAkM1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICBudWxsID09PSBmb3JtQWN0aW9uIHx8XG4gICAgICAgICAgICBcImltYWdlXCIgPT09IHByb3BzLnR5cGUgfHxcbiAgICAgICAgICAgIFwic3VibWl0XCIgPT09IHByb3BzLnR5cGUgfHxcbiAgICAgICAgICAgIGRpZFdhcm5Gb3JtQWN0aW9uVHlwZSB8fFxuICAgICAgICAgICAgKChkaWRXYXJuRm9ybUFjdGlvblR5cGUgPSAhMCksXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAnQW4gaW5wdXQgY2FuIG9ubHkgc3BlY2lmeSBhIGZvcm1BY3Rpb24gYWxvbmcgd2l0aCB0eXBlPVwic3VibWl0XCIgb3IgdHlwZT1cImltYWdlXCIuJ1xuICAgICAgICAgICAgKSk7XG4gICAgICAgICAgdmFyIGZvcm1EYXRhID0gcHVzaEZvcm1BY3Rpb25BdHRyaWJ1dGUoXG4gICAgICAgICAgICB0YXJnZXQkanNjb21wJDAsXG4gICAgICAgICAgICByZXN1bWFibGVTdGF0ZSxcbiAgICAgICAgICAgIHJlbmRlclN0YXRlLFxuICAgICAgICAgICAgZm9ybUFjdGlvbixcbiAgICAgICAgICAgIGZvcm1FbmNUeXBlLFxuICAgICAgICAgICAgZm9ybU1ldGhvZCxcbiAgICAgICAgICAgIGZvcm1UYXJnZXQsXG4gICAgICAgICAgICBuYW1lXG4gICAgICAgICAgKTtcbiAgICAgICAgICBudWxsID09PSBjaGVja2VkIHx8XG4gICAgICAgICAgICBudWxsID09PSBkZWZhdWx0Q2hlY2tlZCB8fFxuICAgICAgICAgICAgZGlkV2FybkRlZmF1bHRDaGVja2VkIHx8XG4gICAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCIlcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCBjaGVja2VkIGFuZCBkZWZhdWx0Q2hlY2tlZCBwcm9wcy4gSW5wdXQgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgKHNwZWNpZnkgZWl0aGVyIHRoZSBjaGVja2VkIHByb3AsIG9yIHRoZSBkZWZhdWx0Q2hlY2tlZCBwcm9wLCBidXQgbm90IGJvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0IGVsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9jb250cm9sbGVkLWNvbXBvbmVudHNcIixcbiAgICAgICAgICAgICAgXCJBIGNvbXBvbmVudFwiLFxuICAgICAgICAgICAgICBwcm9wcy50eXBlXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgKGRpZFdhcm5EZWZhdWx0Q2hlY2tlZCA9ICEwKSk7XG4gICAgICAgICAgbnVsbCA9PT0gdmFsdWUkanNjb21wJDEgfHxcbiAgICAgICAgICAgIG51bGwgPT09IGRlZmF1bHRWYWx1ZSRqc2NvbXAkMCB8fFxuICAgICAgICAgICAgZGlkV2FybkRlZmF1bHRJbnB1dFZhbHVlIHx8XG4gICAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCIlcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCB2YWx1ZSBhbmQgZGVmYXVsdFZhbHVlIHByb3BzLiBJbnB1dCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCBib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCBlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86IGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvY29udHJvbGxlZC1jb21wb25lbnRzXCIsXG4gICAgICAgICAgICAgIFwiQSBjb21wb25lbnRcIixcbiAgICAgICAgICAgICAgcHJvcHMudHlwZVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIChkaWRXYXJuRGVmYXVsdElucHV0VmFsdWUgPSAhMCkpO1xuICAgICAgICAgIG51bGwgIT09IGNoZWNrZWRcbiAgICAgICAgICAgID8gcHVzaEJvb2xlYW5BdHRyaWJ1dGUodGFyZ2V0JGpzY29tcCQwLCBcImNoZWNrZWRcIiwgY2hlY2tlZClcbiAgICAgICAgICAgIDogbnVsbCAhPT0gZGVmYXVsdENoZWNrZWQgJiZcbiAgICAgICAgICAgICAgcHVzaEJvb2xlYW5BdHRyaWJ1dGUodGFyZ2V0JGpzY29tcCQwLCBcImNoZWNrZWRcIiwgZGVmYXVsdENoZWNrZWQpO1xuICAgICAgICAgIG51bGwgIT09IHZhbHVlJGpzY29tcCQxXG4gICAgICAgICAgICA/IHB1c2hBdHRyaWJ1dGUodGFyZ2V0JGpzY29tcCQwLCBcInZhbHVlXCIsIHZhbHVlJGpzY29tcCQxKVxuICAgICAgICAgICAgOiBudWxsICE9PSBkZWZhdWx0VmFsdWUkanNjb21wJDAgJiZcbiAgICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQkanNjb21wJDAsIFwidmFsdWVcIiwgZGVmYXVsdFZhbHVlJGpzY29tcCQwKTtcbiAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChlbmRPZlN0YXJ0VGFnU2VsZkNsb3NpbmcpO1xuICAgICAgICAgIG51bGwgIT0gZm9ybURhdGEgJiZcbiAgICAgICAgICAgIGZvcm1EYXRhLmZvckVhY2gocHVzaEFkZGl0aW9uYWxGb3JtRmllbGQsIHRhcmdldCRqc2NvbXAkMCk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNhc2UgXCJidXR0b25cIjpcbiAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChzdGFydENodW5rRm9yVGFnKFwiYnV0dG9uXCIpKTtcbiAgICAgICAgICB2YXIgY2hpbGRyZW4kanNjb21wJDMgPSBudWxsLFxuICAgICAgICAgICAgaW5uZXJIVE1MJGpzY29tcCQyID0gbnVsbCxcbiAgICAgICAgICAgIG5hbWUkanNjb21wJDAgPSBudWxsLFxuICAgICAgICAgICAgZm9ybUFjdGlvbiRqc2NvbXAkMCA9IG51bGwsXG4gICAgICAgICAgICBmb3JtRW5jVHlwZSRqc2NvbXAkMCA9IG51bGwsXG4gICAgICAgICAgICBmb3JtTWV0aG9kJGpzY29tcCQwID0gbnVsbCxcbiAgICAgICAgICAgIGZvcm1UYXJnZXQkanNjb21wJDAgPSBudWxsLFxuICAgICAgICAgICAgcHJvcEtleSRqc2NvbXAkNDtcbiAgICAgICAgICBmb3IgKHByb3BLZXkkanNjb21wJDQgaW4gcHJvcHMpXG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSRqc2NvbXAkNCkpIHtcbiAgICAgICAgICAgICAgdmFyIHByb3BWYWx1ZSRqc2NvbXAkNCA9IHByb3BzW3Byb3BLZXkkanNjb21wJDRdO1xuICAgICAgICAgICAgICBpZiAobnVsbCAhPSBwcm9wVmFsdWUkanNjb21wJDQpXG4gICAgICAgICAgICAgICAgc3dpdGNoIChwcm9wS2V5JGpzY29tcCQ0KSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4kanNjb21wJDMgPSBwcm9wVmFsdWUkanNjb21wJDQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgICAgICAgICAgIGlubmVySFRNTCRqc2NvbXAkMiA9IHByb3BWYWx1ZSRqc2NvbXAkNDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwibmFtZVwiOlxuICAgICAgICAgICAgICAgICAgICBuYW1lJGpzY29tcCQwID0gcHJvcFZhbHVlJGpzY29tcCQ0O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJmb3JtQWN0aW9uXCI6XG4gICAgICAgICAgICAgICAgICAgIGZvcm1BY3Rpb24kanNjb21wJDAgPSBwcm9wVmFsdWUkanNjb21wJDQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImZvcm1FbmNUeXBlXCI6XG4gICAgICAgICAgICAgICAgICAgIGZvcm1FbmNUeXBlJGpzY29tcCQwID0gcHJvcFZhbHVlJGpzY29tcCQ0O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJmb3JtTWV0aG9kXCI6XG4gICAgICAgICAgICAgICAgICAgIGZvcm1NZXRob2QkanNjb21wJDAgPSBwcm9wVmFsdWUkanNjb21wJDQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImZvcm1UYXJnZXRcIjpcbiAgICAgICAgICAgICAgICAgICAgZm9ybVRhcmdldCRqc2NvbXAkMCA9IHByb3BWYWx1ZSRqc2NvbXAkNDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBwdXNoQXR0cmlidXRlKFxuICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQ0LFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BWYWx1ZSRqc2NvbXAkNFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICBudWxsID09PSBmb3JtQWN0aW9uJGpzY29tcCQwIHx8XG4gICAgICAgICAgICBudWxsID09IHByb3BzLnR5cGUgfHxcbiAgICAgICAgICAgIFwic3VibWl0XCIgPT09IHByb3BzLnR5cGUgfHxcbiAgICAgICAgICAgIGRpZFdhcm5Gb3JtQWN0aW9uVHlwZSB8fFxuICAgICAgICAgICAgKChkaWRXYXJuRm9ybUFjdGlvblR5cGUgPSAhMCksXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAnQSBidXR0b24gY2FuIG9ubHkgc3BlY2lmeSBhIGZvcm1BY3Rpb24gYWxvbmcgd2l0aCB0eXBlPVwic3VibWl0XCIgb3Igbm8gdHlwZS4nXG4gICAgICAgICAgICApKTtcbiAgICAgICAgICB2YXIgZm9ybURhdGEkanNjb21wJDAgPSBwdXNoRm9ybUFjdGlvbkF0dHJpYnV0ZShcbiAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLFxuICAgICAgICAgICAgcmVuZGVyU3RhdGUsXG4gICAgICAgICAgICBmb3JtQWN0aW9uJGpzY29tcCQwLFxuICAgICAgICAgICAgZm9ybUVuY1R5cGUkanNjb21wJDAsXG4gICAgICAgICAgICBmb3JtTWV0aG9kJGpzY29tcCQwLFxuICAgICAgICAgICAgZm9ybVRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgIG5hbWUkanNjb21wJDBcbiAgICAgICAgICApO1xuICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKGVuZE9mU3RhcnRUYWcpO1xuICAgICAgICAgIG51bGwgIT0gZm9ybURhdGEkanNjb21wJDAgJiZcbiAgICAgICAgICAgIGZvcm1EYXRhJGpzY29tcCQwLmZvckVhY2gocHVzaEFkZGl0aW9uYWxGb3JtRmllbGQsIHRhcmdldCRqc2NvbXAkMCk7XG4gICAgICAgICAgcHVzaElubmVySFRNTCh0YXJnZXQkanNjb21wJDAsIGlubmVySFRNTCRqc2NvbXAkMiwgY2hpbGRyZW4kanNjb21wJDMpO1xuICAgICAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgY2hpbGRyZW4kanNjb21wJDMpIHtcbiAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKGVzY2FwZVRleHRGb3JCcm93c2VyKGNoaWxkcmVuJGpzY29tcCQzKSk7XG4gICAgICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQxID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2UgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQxID0gY2hpbGRyZW4kanNjb21wJDM7XG4gICAgICAgICAgcmV0dXJuIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMTtcbiAgICAgICAgY2FzZSBcImZvcm1cIjpcbiAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChzdGFydENodW5rRm9yVGFnKFwiZm9ybVwiKSk7XG4gICAgICAgICAgdmFyIGNoaWxkcmVuJGpzY29tcCQ0ID0gbnVsbCxcbiAgICAgICAgICAgIGlubmVySFRNTCRqc2NvbXAkMyA9IG51bGwsXG4gICAgICAgICAgICBmb3JtQWN0aW9uJGpzY29tcCQxID0gbnVsbCxcbiAgICAgICAgICAgIGZvcm1FbmNUeXBlJGpzY29tcCQxID0gbnVsbCxcbiAgICAgICAgICAgIGZvcm1NZXRob2QkanNjb21wJDEgPSBudWxsLFxuICAgICAgICAgICAgZm9ybVRhcmdldCRqc2NvbXAkMSA9IG51bGwsXG4gICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQ1O1xuICAgICAgICAgIGZvciAocHJvcEtleSRqc2NvbXAkNSBpbiBwcm9wcylcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5JGpzY29tcCQ1KSkge1xuICAgICAgICAgICAgICB2YXIgcHJvcFZhbHVlJGpzY29tcCQ1ID0gcHJvcHNbcHJvcEtleSRqc2NvbXAkNV07XG4gICAgICAgICAgICAgIGlmIChudWxsICE9IHByb3BWYWx1ZSRqc2NvbXAkNSlcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHByb3BLZXkkanNjb21wJDUpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbiRqc2NvbXAkNCA9IHByb3BWYWx1ZSRqc2NvbXAkNTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJIVE1MJGpzY29tcCQzID0gcHJvcFZhbHVlJGpzY29tcCQ1O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJhY3Rpb25cIjpcbiAgICAgICAgICAgICAgICAgICAgZm9ybUFjdGlvbiRqc2NvbXAkMSA9IHByb3BWYWx1ZSRqc2NvbXAkNTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZW5jVHlwZVwiOlxuICAgICAgICAgICAgICAgICAgICBmb3JtRW5jVHlwZSRqc2NvbXAkMSA9IHByb3BWYWx1ZSRqc2NvbXAkNTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwibWV0aG9kXCI6XG4gICAgICAgICAgICAgICAgICAgIGZvcm1NZXRob2QkanNjb21wJDEgPSBwcm9wVmFsdWUkanNjb21wJDU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcInRhcmdldFwiOlxuICAgICAgICAgICAgICAgICAgICBmb3JtVGFyZ2V0JGpzY29tcCQxID0gcHJvcFZhbHVlJGpzY29tcCQ1O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHB1c2hBdHRyaWJ1dGUoXG4gICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BLZXkkanNjb21wJDUsXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcFZhbHVlJGpzY29tcCQ1XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIHZhciBmb3JtRGF0YSRqc2NvbXAkMSA9IG51bGwsXG4gICAgICAgICAgICBmb3JtQWN0aW9uTmFtZSA9IG51bGw7XG4gICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGZvcm1BY3Rpb24kanNjb21wJDEpIHtcbiAgICAgICAgICAgIChudWxsID09PSBmb3JtRW5jVHlwZSRqc2NvbXAkMSAmJiBudWxsID09PSBmb3JtTWV0aG9kJGpzY29tcCQxKSB8fFxuICAgICAgICAgICAgICBkaWRXYXJuRm9ybUFjdGlvbk1ldGhvZCB8fFxuICAgICAgICAgICAgICAoKGRpZFdhcm5Gb3JtQWN0aW9uTWV0aG9kID0gITApLFxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiQ2Fubm90IHNwZWNpZnkgYSBlbmNUeXBlIG9yIG1ldGhvZCBmb3IgYSBmb3JtIHRoYXQgc3BlY2lmaWVzIGEgZnVuY3Rpb24gYXMgdGhlIGFjdGlvbi4gUmVhY3QgcHJvdmlkZXMgdGhvc2UgYXV0b21hdGljYWxseS4gVGhleSB3aWxsIGdldCBvdmVycmlkZGVuLlwiXG4gICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgbnVsbCA9PT0gZm9ybVRhcmdldCRqc2NvbXAkMSB8fFxuICAgICAgICAgICAgICBkaWRXYXJuRm9ybUFjdGlvblRhcmdldCB8fFxuICAgICAgICAgICAgICAoKGRpZFdhcm5Gb3JtQWN0aW9uVGFyZ2V0ID0gITApLFxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiQ2Fubm90IHNwZWNpZnkgYSB0YXJnZXQgZm9yIGEgZm9ybSB0aGF0IHNwZWNpZmllcyBhIGZ1bmN0aW9uIGFzIHRoZSBhY3Rpb24uIFRoZSBmdW5jdGlvbiB3aWxsIGFsd2F5cyBiZSBleGVjdXRlZCBpbiB0aGUgc2FtZSB3aW5kb3cuXCJcbiAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICB2YXIgY3VzdG9tRmllbGRzID0gZ2V0Q3VzdG9tRm9ybUZpZWxkcyhcbiAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUsXG4gICAgICAgICAgICAgIGZvcm1BY3Rpb24kanNjb21wJDFcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBudWxsICE9PSBjdXN0b21GaWVsZHNcbiAgICAgICAgICAgICAgPyAoKGZvcm1BY3Rpb24kanNjb21wJDEgPSBjdXN0b21GaWVsZHMuYWN0aW9uIHx8IFwiXCIpLFxuICAgICAgICAgICAgICAgIChmb3JtRW5jVHlwZSRqc2NvbXAkMSA9IGN1c3RvbUZpZWxkcy5lbmNUeXBlKSxcbiAgICAgICAgICAgICAgICAoZm9ybU1ldGhvZCRqc2NvbXAkMSA9IGN1c3RvbUZpZWxkcy5tZXRob2QpLFxuICAgICAgICAgICAgICAgIChmb3JtVGFyZ2V0JGpzY29tcCQxID0gY3VzdG9tRmllbGRzLnRhcmdldCksXG4gICAgICAgICAgICAgICAgKGZvcm1EYXRhJGpzY29tcCQxID0gY3VzdG9tRmllbGRzLmRhdGEpLFxuICAgICAgICAgICAgICAgIChmb3JtQWN0aW9uTmFtZSA9IGN1c3RvbUZpZWxkcy5uYW1lKSlcbiAgICAgICAgICAgICAgOiAodGFyZ2V0JGpzY29tcCQwLnB1c2goXG4gICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVTZXBhcmF0b3IsXG4gICAgICAgICAgICAgICAgICBcImFjdGlvblwiLFxuICAgICAgICAgICAgICAgICAgYXR0cmlidXRlQXNzaWduLFxuICAgICAgICAgICAgICAgICAgYWN0aW9uSmF2YVNjcmlwdFVSTCxcbiAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUVuZFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgKGZvcm1UYXJnZXQkanNjb21wJDEgPVxuICAgICAgICAgICAgICAgICAgZm9ybU1ldGhvZCRqc2NvbXAkMSA9XG4gICAgICAgICAgICAgICAgICBmb3JtRW5jVHlwZSRqc2NvbXAkMSA9XG4gICAgICAgICAgICAgICAgICBmb3JtQWN0aW9uJGpzY29tcCQxID1cbiAgICAgICAgICAgICAgICAgICAgbnVsbCksXG4gICAgICAgICAgICAgICAgaW5qZWN0Rm9ybVJlcGxheWluZ1J1bnRpbWUocmVzdW1hYmxlU3RhdGUsIHJlbmRlclN0YXRlKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG51bGwgIT0gZm9ybUFjdGlvbiRqc2NvbXAkMSAmJlxuICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQkanNjb21wJDAsIFwiYWN0aW9uXCIsIGZvcm1BY3Rpb24kanNjb21wJDEpO1xuICAgICAgICAgIG51bGwgIT0gZm9ybUVuY1R5cGUkanNjb21wJDEgJiZcbiAgICAgICAgICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0JGpzY29tcCQwLCBcImVuY1R5cGVcIiwgZm9ybUVuY1R5cGUkanNjb21wJDEpO1xuICAgICAgICAgIG51bGwgIT0gZm9ybU1ldGhvZCRqc2NvbXAkMSAmJlxuICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQkanNjb21wJDAsIFwibWV0aG9kXCIsIGZvcm1NZXRob2QkanNjb21wJDEpO1xuICAgICAgICAgIG51bGwgIT0gZm9ybVRhcmdldCRqc2NvbXAkMSAmJlxuICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQkanNjb21wJDAsIFwidGFyZ2V0XCIsIGZvcm1UYXJnZXQkanNjb21wJDEpO1xuICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKGVuZE9mU3RhcnRUYWcpO1xuICAgICAgICAgIG51bGwgIT09IGZvcm1BY3Rpb25OYW1lICYmXG4gICAgICAgICAgICAodGFyZ2V0JGpzY29tcCQwLnB1c2goJzxpbnB1dCB0eXBlPVwiaGlkZGVuXCInKSxcbiAgICAgICAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0JGpzY29tcCQwLCBcIm5hbWVcIiwgZm9ybUFjdGlvbk5hbWUpLFxuICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goZW5kT2ZTdGFydFRhZ1NlbGZDbG9zaW5nKSxcbiAgICAgICAgICAgIG51bGwgIT0gZm9ybURhdGEkanNjb21wJDEgJiZcbiAgICAgICAgICAgICAgZm9ybURhdGEkanNjb21wJDEuZm9yRWFjaChcbiAgICAgICAgICAgICAgICBwdXNoQWRkaXRpb25hbEZvcm1GaWVsZCxcbiAgICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDBcbiAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgcHVzaElubmVySFRNTCh0YXJnZXQkanNjb21wJDAsIGlubmVySFRNTCRqc2NvbXAkMywgY2hpbGRyZW4kanNjb21wJDQpO1xuICAgICAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgY2hpbGRyZW4kanNjb21wJDQpIHtcbiAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKGVzY2FwZVRleHRGb3JCcm93c2VyKGNoaWxkcmVuJGpzY29tcCQ0KSk7XG4gICAgICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQyID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2UgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQyID0gY2hpbGRyZW4kanNjb21wJDQ7XG4gICAgICAgICAgcmV0dXJuIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMjtcbiAgICAgICAgY2FzZSBcIm1lbnVpdGVtXCI6XG4gICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goc3RhcnRDaHVua0ZvclRhZyhcIm1lbnVpdGVtXCIpKTtcbiAgICAgICAgICBmb3IgKHZhciBwcm9wS2V5JGpzY29tcCQ2IGluIHByb3BzKVxuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkkanNjb21wJDYpKSB7XG4gICAgICAgICAgICAgIHZhciBwcm9wVmFsdWUkanNjb21wJDYgPSBwcm9wc1twcm9wS2V5JGpzY29tcCQ2XTtcbiAgICAgICAgICAgICAgaWYgKG51bGwgIT0gcHJvcFZhbHVlJGpzY29tcCQ2KVxuICAgICAgICAgICAgICAgIHN3aXRjaCAocHJvcEtleSRqc2NvbXAkNikge1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgXCJtZW51aXRlbXMgY2Fubm90IGhhdmUgYGNoaWxkcmVuYCBub3IgYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC5cIlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZShcbiAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcEtleSRqc2NvbXAkNixcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wVmFsdWUkanNjb21wJDZcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChzdGFydENodW5rRm9yVGFnKFwib2JqZWN0XCIpKTtcbiAgICAgICAgICB2YXIgY2hpbGRyZW4kanNjb21wJDUgPSBudWxsLFxuICAgICAgICAgICAgaW5uZXJIVE1MJGpzY29tcCQ0ID0gbnVsbCxcbiAgICAgICAgICAgIHByb3BLZXkkanNjb21wJDc7XG4gICAgICAgICAgZm9yIChwcm9wS2V5JGpzY29tcCQ3IGluIHByb3BzKVxuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkkanNjb21wJDcpKSB7XG4gICAgICAgICAgICAgIHZhciBwcm9wVmFsdWUkanNjb21wJDcgPSBwcm9wc1twcm9wS2V5JGpzY29tcCQ3XTtcbiAgICAgICAgICAgICAgaWYgKG51bGwgIT0gcHJvcFZhbHVlJGpzY29tcCQ3KVxuICAgICAgICAgICAgICAgIHN3aXRjaCAocHJvcEtleSRqc2NvbXAkNykge1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuJGpzY29tcCQ1ID0gcHJvcFZhbHVlJGpzY29tcCQ3O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICAgICAgICAgICAgICBpbm5lckhUTUwkanNjb21wJDQgPSBwcm9wVmFsdWUkanNjb21wJDc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImRhdGFcIjpcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbihwcm9wVmFsdWUkanNjb21wJDcsIFwiZGF0YVwiKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNhbml0aXplZFZhbHVlID0gc2FuaXRpemVVUkwoXCJcIiArIHByb3BWYWx1ZSRqc2NvbXAkNyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcIlwiID09PSBzYW5pdGl6ZWRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAnQW4gZW1wdHkgc3RyaW5nIChcIlwiKSB3YXMgcGFzc2VkIHRvIHRoZSAlcyBhdHRyaWJ1dGUuIFRvIGZpeCB0aGlzLCBlaXRoZXIgZG8gbm90IHJlbmRlciB0aGUgZWxlbWVudCBhdCBhbGwgb3IgcGFzcyBudWxsIHRvICVzIGluc3RlYWQgb2YgYW4gZW1wdHkgc3RyaW5nLicsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQ3LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcEtleSRqc2NvbXAkN1xuICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlU2VwYXJhdG9yLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZGF0YVwiLFxuICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUFzc2lnbixcbiAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVUZXh0Rm9yQnJvd3NlcihzYW5pdGl6ZWRWYWx1ZSksXG4gICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlRW5kXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZShcbiAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcEtleSRqc2NvbXAkNyxcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wVmFsdWUkanNjb21wJDdcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gICAgICAgICAgcHVzaElubmVySFRNTCh0YXJnZXQkanNjb21wJDAsIGlubmVySFRNTCRqc2NvbXAkNCwgY2hpbGRyZW4kanNjb21wJDUpO1xuICAgICAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgY2hpbGRyZW4kanNjb21wJDUpIHtcbiAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKGVzY2FwZVRleHRGb3JCcm93c2VyKGNoaWxkcmVuJGpzY29tcCQ1KSk7XG4gICAgICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQzID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2UgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQzID0gY2hpbGRyZW4kanNjb21wJDU7XG4gICAgICAgICAgcmV0dXJuIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMztcbiAgICAgICAgY2FzZSBcInRpdGxlXCI6XG4gICAgICAgICAgdmFyIG5vc2NyaXB0VGFnSW5TY29wZSA9IGZvcm1hdENvbnRleHQudGFnU2NvcGUgJiAxLFxuICAgICAgICAgICAgaXNGYWxsYmFjayA9IGZvcm1hdENvbnRleHQudGFnU2NvcGUgJiA0O1xuICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBcImNoaWxkcmVuXCIpKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4kanNjb21wJDYgPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgICAgICAgICAgY2hpbGQgPSBBcnJheS5pc0FycmF5KGNoaWxkcmVuJGpzY29tcCQ2KVxuICAgICAgICAgICAgICAgID8gMiA+IGNoaWxkcmVuJGpzY29tcCQ2Lmxlbmd0aFxuICAgICAgICAgICAgICAgICAgPyBjaGlsZHJlbiRqc2NvbXAkNlswXVxuICAgICAgICAgICAgICAgICAgOiBudWxsXG4gICAgICAgICAgICAgICAgOiBjaGlsZHJlbiRqc2NvbXAkNjtcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkoY2hpbGRyZW4kanNjb21wJDYpICYmIDEgPCBjaGlsZHJlbiRqc2NvbXAkNi5sZW5ndGhcbiAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJSZWFjdCBleHBlY3RzIHRoZSBgY2hpbGRyZW5gIHByb3Agb2YgPHRpdGxlPiB0YWdzIHRvIGJlIGEgc3RyaW5nLCBudW1iZXIsIGJpZ2ludCwgb3Igb2JqZWN0IHdpdGggYSBub3ZlbCBgdG9TdHJpbmdgIG1ldGhvZCBidXQgZm91bmQgYW4gQXJyYXkgd2l0aCBsZW5ndGggJXMgaW5zdGVhZC4gQnJvd3NlcnMgdHJlYXQgYWxsIGNoaWxkIE5vZGVzIG9mIDx0aXRsZT4gdGFncyBhcyBUZXh0IGNvbnRlbnQgYW5kIFJlYWN0IGV4cGVjdHMgdG8gYmUgYWJsZSB0byBjb252ZXJ0IGBjaGlsZHJlbmAgb2YgPHRpdGxlPiB0YWdzIHRvIGEgc2luZ2xlIHN0cmluZyB2YWx1ZSB3aGljaCBpcyB3aHkgQXJyYXlzIG9mIGxlbmd0aCBncmVhdGVyIHRoYW4gMSBhcmUgbm90IHN1cHBvcnRlZC4gV2hlbiB1c2luZyBKU1ggaXQgY2FuIGJlIGNvbW1vbiB0byBjb21iaW5lIHRleHQgbm9kZXMgYW5kIHZhbHVlIG5vZGVzLiBGb3IgZXhhbXBsZTogPHRpdGxlPmhlbGxvIHtuYW1lT2ZVc2VyfTwvdGl0bGU+LiBXaGlsZSBub3QgaW1tZWRpYXRlbHkgYXBwYXJlbnQsIGBjaGlsZHJlbmAgaW4gdGhpcyBjYXNlIGlzIGFuIEFycmF5IHdpdGggbGVuZ3RoIDIuIElmIHlvdXIgYGNoaWxkcmVuYCBwcm9wIGlzIHVzaW5nIHRoaXMgZm9ybSB0cnkgcmV3cml0aW5nIGl0IHVzaW5nIGEgdGVtcGxhdGUgc3RyaW5nOiA8dGl0bGU+e2BoZWxsbyAke25hbWVPZlVzZXJ9YH08L3RpdGxlPi5cIixcbiAgICAgICAgICAgICAgICAgIGNoaWxkcmVuJGpzY29tcCQ2Lmxlbmd0aFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgOiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBjaGlsZCB8fCBcInN5bWJvbFwiID09PSB0eXBlb2YgY2hpbGRcbiAgICAgICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiUmVhY3QgZXhwZWN0IGNoaWxkcmVuIG9mIDx0aXRsZT4gdGFncyB0byBiZSBhIHN0cmluZywgbnVtYmVyLCBiaWdpbnQsIG9yIG9iamVjdCB3aXRoIGEgbm92ZWwgYHRvU3RyaW5nYCBtZXRob2QgYnV0IGZvdW5kICVzIGluc3RlYWQuIEJyb3dzZXJzIHRyZWF0IGFsbCBjaGlsZCBOb2RlcyBvZiA8dGl0bGU+IHRhZ3MgYXMgVGV4dCBjb250ZW50IGFuZCBSZWFjdCBleHBlY3RzIHRvIGJlIGFibGUgdG8gY29udmVydCBjaGlsZHJlbiBvZiA8dGl0bGU+IHRhZ3MgdG8gYSBzaW5nbGUgc3RyaW5nIHZhbHVlLlwiLFxuICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBjaGlsZCA/IFwiYSBGdW5jdGlvblwiIDogXCJhIFN5Ym1vbFwiXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgOiBjaGlsZCAmJlxuICAgICAgICAgICAgICAgICAgY2hpbGQudG9TdHJpbmcgPT09IHt9LnRvU3RyaW5nICYmXG4gICAgICAgICAgICAgICAgICAobnVsbCAhPSBjaGlsZC4kJHR5cGVvZlxuICAgICAgICAgICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlJlYWN0IGV4cGVjdHMgdGhlIGBjaGlsZHJlbmAgcHJvcCBvZiA8dGl0bGU+IHRhZ3MgdG8gYmUgYSBzdHJpbmcsIG51bWJlciwgYmlnaW50LCBvciBvYmplY3Qgd2l0aCBhIG5vdmVsIGB0b1N0cmluZ2AgbWV0aG9kIGJ1dCBmb3VuZCBhbiBvYmplY3QgdGhhdCBhcHBlYXJzIHRvIGJlIGEgUmVhY3QgZWxlbWVudCB3aGljaCBuZXZlciBpbXBsZW1lbnRzIGEgc3VpdGFibGUgYHRvU3RyaW5nYCBtZXRob2QuIEJyb3dzZXJzIHRyZWF0IGFsbCBjaGlsZCBOb2RlcyBvZiA8dGl0bGU+IHRhZ3MgYXMgVGV4dCBjb250ZW50IGFuZCBSZWFjdCBleHBlY3RzIHRvIGJlIGFibGUgdG8gY29udmVydCBjaGlsZHJlbiBvZiA8dGl0bGU+IHRhZ3MgdG8gYSBzaW5nbGUgc3RyaW5nIHZhbHVlIHdoaWNoIGlzIHdoeSByZW5kZXJpbmcgUmVhY3QgZWxlbWVudHMgaXMgbm90IHN1cHBvcnRlZC4gSWYgdGhlIGBjaGlsZHJlbmAgb2YgPHRpdGxlPiBpcyBhIFJlYWN0IENvbXBvbmVudCB0cnkgbW92aW5nIHRoZSA8dGl0bGU+IHRhZyBpbnRvIHRoYXQgY29tcG9uZW50LiBJZiB0aGUgYGNoaWxkcmVuYCBvZiA8dGl0bGU+IGlzIHNvbWUgSFRNTCBtYXJrdXAgY2hhbmdlIGl0IHRvIGJlIFRleHQgb25seSB0byBiZSB2YWxpZCBIVE1MLlwiXG4gICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICA6IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlJlYWN0IGV4cGVjdHMgdGhlIGBjaGlsZHJlbmAgcHJvcCBvZiA8dGl0bGU+IHRhZ3MgdG8gYmUgYSBzdHJpbmcsIG51bWJlciwgYmlnaW50LCBvciBvYmplY3Qgd2l0aCBhIG5vdmVsIGB0b1N0cmluZ2AgbWV0aG9kIGJ1dCBmb3VuZCBhbiBvYmplY3QgdGhhdCBkb2VzIG5vdCBpbXBsZW1lbnQgYSBzdWl0YWJsZSBgdG9TdHJpbmdgIG1ldGhvZC4gQnJvd3NlcnMgdHJlYXQgYWxsIGNoaWxkIE5vZGVzIG9mIDx0aXRsZT4gdGFncyBhcyBUZXh0IGNvbnRlbnQgYW5kIFJlYWN0IGV4cGVjdHMgdG8gYmUgYWJsZSB0byBjb252ZXJ0IGNoaWxkcmVuIG9mIDx0aXRsZT4gdGFncyB0byBhIHNpbmdsZSBzdHJpbmcgdmFsdWUuIFVzaW5nIHRoZSBkZWZhdWx0IGB0b1N0cmluZ2AgbWV0aG9kIGF2YWlsYWJsZSBvbiBldmVyeSBvYmplY3QgaXMgYWxtb3N0IGNlcnRhaW5seSBhbiBlcnJvci4gQ29uc2lkZXIgd2hldGhlciB0aGUgYGNoaWxkcmVuYCBvZiB0aGlzIDx0aXRsZT4gaXMgYW4gb2JqZWN0IGluIGVycm9yIGFuZCBjaGFuZ2UgaXQgdG8gYSBzdHJpbmcgb3IgbnVtYmVyIHZhbHVlIGlmIHNvLiBPdGhlcndpc2UgaW1wbGVtZW50IGEgYHRvU3RyaW5nYCBtZXRob2QgdGhhdCBSZWFjdCBjYW4gdXNlIHRvIHByb2R1Y2UgYSB2YWxpZCA8dGl0bGU+LlwiXG4gICAgICAgICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSA9PT0gU1ZHX01PREUgfHxcbiAgICAgICAgICAgIG5vc2NyaXB0VGFnSW5TY29wZSB8fFxuICAgICAgICAgICAgbnVsbCAhPSBwcm9wcy5pdGVtUHJvcFxuICAgICAgICAgIClcbiAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDQgPSBwdXNoVGl0bGVJbXBsKFxuICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAsXG4gICAgICAgICAgICAgIHByb3BzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGlzRmFsbGJhY2tcbiAgICAgICAgICAgICAgPyAoSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQ0ID0gbnVsbClcbiAgICAgICAgICAgICAgOiAocHVzaFRpdGxlSW1wbChyZW5kZXJTdGF0ZS5ob2lzdGFibGVDaHVua3MsIHByb3BzKSxcbiAgICAgICAgICAgICAgICAoSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQ0ID0gdm9pZCAwKSk7XG4gICAgICAgICAgcmV0dXJuIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkNDtcbiAgICAgICAgY2FzZSBcImxpbmtcIjpcbiAgICAgICAgICB2YXIgbm9zY3JpcHRUYWdJblNjb3BlJGpzY29tcCQwID0gZm9ybWF0Q29udGV4dC50YWdTY29wZSAmIDEsXG4gICAgICAgICAgICBpc0ZhbGxiYWNrJGpzY29tcCQwID0gZm9ybWF0Q29udGV4dC50YWdTY29wZSAmIDQsXG4gICAgICAgICAgICByZWwgPSBwcm9wcy5yZWwsXG4gICAgICAgICAgICBocmVmID0gcHJvcHMuaHJlZixcbiAgICAgICAgICAgIHByZWNlZGVuY2UgPSBwcm9wcy5wcmVjZWRlbmNlO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSA9PT0gU1ZHX01PREUgfHxcbiAgICAgICAgICAgIG5vc2NyaXB0VGFnSW5TY29wZSRqc2NvbXAkMCB8fFxuICAgICAgICAgICAgbnVsbCAhPSBwcm9wcy5pdGVtUHJvcCB8fFxuICAgICAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIHJlbCB8fFxuICAgICAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIGhyZWYgfHxcbiAgICAgICAgICAgIFwiXCIgPT09IGhyZWZcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIFwic3R5bGVzaGVldFwiID09PSByZWwgJiZcbiAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHByb3BzLnByZWNlZGVuY2UgJiZcbiAgICAgICAgICAgICAgKChcInN0cmluZ1wiID09PSB0eXBlb2YgaHJlZiAmJiBocmVmKSB8fFxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAnUmVhY3QgZW5jb3VudGVyZWQgYSBgPGxpbmsgcmVsPVwic3R5bGVzaGVldFwiIC4uLi8+YCB3aXRoIGEgYHByZWNlZGVuY2VgIHByb3AgYW5kIGV4cGVjdGVkIHRoZSBgaHJlZmAgcHJvcCB0byBiZSBhIG5vbi1lbXB0eSBzdHJpbmcgYnV0IGVjb3VudGVyZWQgJXMgaW5zdGVhZC4gSWYgeW91ciBpbnRlbnQgd2FzIHRvIGhhdmUgUmVhY3QgaG9pc3QgYW5kIGRlZHVwbGNpYXRlIHRoaXMgc3R5bGVzaGVldCB1c2luZyB0aGUgYHByZWNlZGVuY2VgIHByb3AgZW5zdXJlIHRoZXJlIGlzIGEgbm9uLWVtcHR5IHN0cmluZyBgaHJlZmAgcHJvcCBhcyB3ZWxsLCBvdGhlcndpc2UgcmVtb3ZlIHRoZSBgcHJlY2VkZW5jZWAgcHJvcC4nLFxuICAgICAgICAgICAgICAgICAgbnVsbCA9PT0gaHJlZlxuICAgICAgICAgICAgICAgICAgICA/IFwiYG51bGxgXCJcbiAgICAgICAgICAgICAgICAgICAgOiB2b2lkIDAgPT09IGhyZWZcbiAgICAgICAgICAgICAgICAgICAgICA/IFwiYHVuZGVmaW5lZGBcIlxuICAgICAgICAgICAgICAgICAgICAgIDogXCJcIiA9PT0gaHJlZlxuICAgICAgICAgICAgICAgICAgICAgICAgPyBcImFuIGVtcHR5IHN0cmluZ1wiXG4gICAgICAgICAgICAgICAgICAgICAgICA6ICdzb21ldGhpbmcgd2l0aCB0eXBlIFwiJyArIHR5cGVvZiBocmVmICsgJ1wiJ1xuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgcHVzaExpbmtJbXBsKHRhcmdldCRqc2NvbXAkMCwgcHJvcHMpO1xuICAgICAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkNSA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIGlmIChcInN0eWxlc2hlZXRcIiA9PT0gcHJvcHMucmVsKVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBcInN0cmluZ1wiICE9PSB0eXBlb2YgcHJlY2VkZW5jZSB8fFxuICAgICAgICAgICAgICBudWxsICE9IHByb3BzLmRpc2FibGVkIHx8XG4gICAgICAgICAgICAgIHByb3BzLm9uTG9hZCB8fFxuICAgICAgICAgICAgICBwcm9wcy5vbkVycm9yXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBwcmVjZWRlbmNlKVxuICAgICAgICAgICAgICAgIGlmIChudWxsICE9IHByb3BzLmRpc2FibGVkKVxuICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgJ1JlYWN0IGVuY291bnRlcmVkIGEgYDxsaW5rIHJlbD1cInN0eWxlc2hlZXRcIiAuLi4vPmAgd2l0aCBhIGBwcmVjZWRlbmNlYCBwcm9wIGFuZCBhIGBkaXNhYmxlZGAgcHJvcC4gVGhlIHByZXNlbmNlIG9mIHRoZSBgZGlzYWJsZWRgIHByb3AgaW5kaWNhdGVzIGFuIGludGVudCB0byBtYW5hZ2UgdGhlIHN0eWxlc2hlZXQgYWN0aXZlIHN0YXRlIGZyb20geW91ciBmcm9tIHlvdXIgQ29tcG9uZW50IGNvZGUgYW5kIFJlYWN0IHdpbGwgbm90IGhvaXN0IG9yIGRlZHVwbGljYXRlIHRoaXMgc3R5bGVzaGVldC4gSWYgeW91ciBpbnRlbnQgd2FzIHRvIGhhdmUgUmVhY3QgaG9pc3QgYW5kIGRlZHVwbGNpYXRlIHRoaXMgc3R5bGVzaGVldCB1c2luZyB0aGUgYHByZWNlZGVuY2VgIHByb3AgcmVtb3ZlIHRoZSBgZGlzYWJsZWRgIHByb3AsIG90aGVyd2lzZSByZW1vdmUgdGhlIGBwcmVjZWRlbmNlYCBwcm9wLidcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocHJvcHMub25Mb2FkIHx8IHByb3BzLm9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBwcm9wRGVzY3JpcHRpb24gPVxuICAgICAgICAgICAgICAgICAgICBwcm9wcy5vbkxvYWQgJiYgcHJvcHMub25FcnJvclxuICAgICAgICAgICAgICAgICAgICAgID8gXCJgb25Mb2FkYCBhbmQgYG9uRXJyb3JgIHByb3BzXCJcbiAgICAgICAgICAgICAgICAgICAgICA6IHByb3BzLm9uTG9hZFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBcImBvbkxvYWRgIHByb3BcIlxuICAgICAgICAgICAgICAgICAgICAgICAgOiBcImBvbkVycm9yYCBwcm9wXCI7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAnUmVhY3QgZW5jb3VudGVyZWQgYSBgPGxpbmsgcmVsPVwic3R5bGVzaGVldFwiIC4uLi8+YCB3aXRoIGEgYHByZWNlZGVuY2VgIHByb3AgYW5kICVzLiBUaGUgcHJlc2VuY2Ugb2YgbG9hZGluZyBhbmQgZXJyb3IgaGFuZGxlcnMgaW5kaWNhdGVzIGFuIGludGVudCB0byBtYW5hZ2UgdGhlIHN0eWxlc2hlZXQgbG9hZGluZyBzdGF0ZSBmcm9tIHlvdXIgZnJvbSB5b3VyIENvbXBvbmVudCBjb2RlIGFuZCBSZWFjdCB3aWxsIG5vdCBob2lzdCBvciBkZWR1cGxpY2F0ZSB0aGlzIHN0eWxlc2hlZXQuIElmIHlvdXIgaW50ZW50IHdhcyB0byBoYXZlIFJlYWN0IGhvaXN0IGFuZCBkZWR1cGxjaWF0ZSB0aGlzIHN0eWxlc2hlZXQgdXNpbmcgdGhlIGBwcmVjZWRlbmNlYCBwcm9wIHJlbW92ZSB0aGUgJXMsIG90aGVyd2lzZSByZW1vdmUgdGhlIGBwcmVjZWRlbmNlYCBwcm9wLicsXG4gICAgICAgICAgICAgICAgICAgIHByb3BEZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgICAgcHJvcERlc2NyaXB0aW9uXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQ1ID0gcHVzaExpbmtJbXBsKFxuICAgICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICBwcm9wc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHN0eWxlUXVldWUgPSByZW5kZXJTdGF0ZS5zdHlsZXMuZ2V0KHByZWNlZGVuY2UpLFxuICAgICAgICAgICAgICAgIHJlc291cmNlU3RhdGUgPSByZXN1bWFibGVTdGF0ZS5zdHlsZVJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShcbiAgICAgICAgICAgICAgICAgIGhyZWZcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICA/IHJlc3VtYWJsZVN0YXRlLnN0eWxlUmVzb3VyY2VzW2hyZWZdXG4gICAgICAgICAgICAgICAgICA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgaWYgKHJlc291cmNlU3RhdGUgIT09IEVYSVNUUykge1xuICAgICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLnN0eWxlUmVzb3VyY2VzW2hyZWZdID0gRVhJU1RTO1xuICAgICAgICAgICAgICAgIHN0eWxlUXVldWUgfHxcbiAgICAgICAgICAgICAgICAgICgoc3R5bGVRdWV1ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogZXNjYXBlVGV4dEZvckJyb3dzZXIocHJlY2VkZW5jZSksXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgaHJlZnM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBzaGVldHM6IG5ldyBNYXAoKVxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5zdHlsZXMuc2V0KHByZWNlZGVuY2UsIHN0eWxlUXVldWUpKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVzb3VyY2UgPSB7XG4gICAgICAgICAgICAgICAgICBzdGF0ZTogUEVORElORyQxLFxuICAgICAgICAgICAgICAgICAgcHJvcHM6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICAgICAgICAgICAgXCJkYXRhLXByZWNlZGVuY2VcIjogcHJvcHMucHJlY2VkZW5jZSxcbiAgICAgICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogbnVsbFxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChyZXNvdXJjZVN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAyID09PSByZXNvdXJjZVN0YXRlLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICBhZG9wdFByZWxvYWRDcmVkZW50aWFscyhyZXNvdXJjZS5wcm9wcywgcmVzb3VyY2VTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICB2YXIgcHJlbG9hZFJlc291cmNlID1cbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUucHJlbG9hZHMuc3R5bGVzaGVldHMuZ2V0KGhyZWYpO1xuICAgICAgICAgICAgICAgICAgcHJlbG9hZFJlc291cmNlICYmIDAgPCBwcmVsb2FkUmVzb3VyY2UubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgID8gKHByZWxvYWRSZXNvdXJjZS5sZW5ndGggPSAwKVxuICAgICAgICAgICAgICAgICAgICA6IChyZXNvdXJjZS5zdGF0ZSA9IFBSRUxPQURFRCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0eWxlUXVldWUuc2hlZXRzLnNldChocmVmLCByZXNvdXJjZSk7XG4gICAgICAgICAgICAgICAgaG9pc3RhYmxlU3RhdGUgJiYgaG9pc3RhYmxlU3RhdGUuc3R5bGVzaGVldHMuYWRkKHJlc291cmNlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdHlsZVF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9yZXNvdXJjZSA9IHN0eWxlUXVldWUuc2hlZXRzLmdldChocmVmKTtcbiAgICAgICAgICAgICAgICBfcmVzb3VyY2UgJiZcbiAgICAgICAgICAgICAgICAgIGhvaXN0YWJsZVN0YXRlICYmXG4gICAgICAgICAgICAgICAgICBob2lzdGFibGVTdGF0ZS5zdHlsZXNoZWV0cy5hZGQoX3Jlc291cmNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0ZXh0RW1iZWRkZWQgJiYgdGFyZ2V0JGpzY29tcCQwLnB1c2goXCJcXHgzYyEtLSAtLVxceDNlXCIpO1xuICAgICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHByb3BzLm9uTG9hZCB8fCBwcm9wcy5vbkVycm9yXG4gICAgICAgICAgICAgID8gKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkNSA9IHB1c2hMaW5rSW1wbChcbiAgICAgICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgIHByb3BzXG4gICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgOiAodGV4dEVtYmVkZGVkICYmIHRhcmdldCRqc2NvbXAkMC5wdXNoKFwiXFx4M2MhLS0gLS1cXHgzZVwiKSxcbiAgICAgICAgICAgICAgICAoSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQ1ID0gaXNGYWxsYmFjayRqc2NvbXAkMFxuICAgICAgICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICAgICAgICA6IHB1c2hMaW5rSW1wbChyZW5kZXJTdGF0ZS5ob2lzdGFibGVDaHVua3MsIHByb3BzKSkpO1xuICAgICAgICAgIHJldHVybiBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDU7XG4gICAgICAgIGNhc2UgXCJzY3JpcHRcIjpcbiAgICAgICAgICB2YXIgbm9zY3JpcHRUYWdJblNjb3BlJGpzY29tcCQxID0gZm9ybWF0Q29udGV4dC50YWdTY29wZSAmIDEsXG4gICAgICAgICAgICBhc3luY1Byb3AgPSBwcm9wcy5hc3luYztcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBcInN0cmluZ1wiICE9PSB0eXBlb2YgcHJvcHMuc3JjIHx8XG4gICAgICAgICAgICAhcHJvcHMuc3JjIHx8XG4gICAgICAgICAgICAhYXN5bmNQcm9wIHx8XG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBhc3luY1Byb3AgfHxcbiAgICAgICAgICAgIFwic3ltYm9sXCIgPT09IHR5cGVvZiBhc3luY1Byb3AgfHxcbiAgICAgICAgICAgIHByb3BzLm9uTG9hZCB8fFxuICAgICAgICAgICAgcHJvcHMub25FcnJvciB8fFxuICAgICAgICAgICAgZm9ybWF0Q29udGV4dC5pbnNlcnRpb25Nb2RlID09PSBTVkdfTU9ERSB8fFxuICAgICAgICAgICAgbm9zY3JpcHRUYWdJblNjb3BlJGpzY29tcCQxIHx8XG4gICAgICAgICAgICBudWxsICE9IHByb3BzLml0ZW1Qcm9wXG4gICAgICAgICAgKVxuICAgICAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkNiA9IHB1c2hTY3JpcHRJbXBsKFxuICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAsXG4gICAgICAgICAgICAgIHByb3BzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGtleSA9IHByb3BzLnNyYztcbiAgICAgICAgICAgIGlmIChcIm1vZHVsZVwiID09PSBwcm9wcy50eXBlKSB7XG4gICAgICAgICAgICAgIHZhciByZXNvdXJjZXMgPSByZXN1bWFibGVTdGF0ZS5tb2R1bGVTY3JpcHRSZXNvdXJjZXM7XG4gICAgICAgICAgICAgIHZhciBwcmVsb2FkcyA9IHJlbmRlclN0YXRlLnByZWxvYWRzLm1vZHVsZVNjcmlwdHM7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgKHJlc291cmNlcyA9IHJlc3VtYWJsZVN0YXRlLnNjcmlwdFJlc291cmNlcyksXG4gICAgICAgICAgICAgICAgKHByZWxvYWRzID0gcmVuZGVyU3RhdGUucHJlbG9hZHMuc2NyaXB0cyk7XG4gICAgICAgICAgICB2YXIgcmVzb3VyY2VTdGF0ZSRqc2NvbXAkMCA9IHJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShrZXkpXG4gICAgICAgICAgICAgID8gcmVzb3VyY2VzW2tleV1cbiAgICAgICAgICAgICAgOiB2b2lkIDA7XG4gICAgICAgICAgICBpZiAocmVzb3VyY2VTdGF0ZSRqc2NvbXAkMCAhPT0gRVhJU1RTKSB7XG4gICAgICAgICAgICAgIHJlc291cmNlc1trZXldID0gRVhJU1RTO1xuICAgICAgICAgICAgICB2YXIgc2NyaXB0UHJvcHMgPSBwcm9wcztcbiAgICAgICAgICAgICAgaWYgKHJlc291cmNlU3RhdGUkanNjb21wJDApIHtcbiAgICAgICAgICAgICAgICAyID09PSByZXNvdXJjZVN0YXRlJGpzY29tcCQwLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgKChzY3JpcHRQcm9wcyA9IGFzc2lnbih7fSwgcHJvcHMpKSxcbiAgICAgICAgICAgICAgICAgIGFkb3B0UHJlbG9hZENyZWRlbnRpYWxzKHNjcmlwdFByb3BzLCByZXNvdXJjZVN0YXRlJGpzY29tcCQwKSk7XG4gICAgICAgICAgICAgICAgdmFyIHByZWxvYWRSZXNvdXJjZSRqc2NvbXAkMCA9IHByZWxvYWRzLmdldChrZXkpO1xuICAgICAgICAgICAgICAgIHByZWxvYWRSZXNvdXJjZSRqc2NvbXAkMCAmJlxuICAgICAgICAgICAgICAgICAgKHByZWxvYWRSZXNvdXJjZSRqc2NvbXAkMC5sZW5ndGggPSAwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgcmVzb3VyY2UkanNjb21wJDAgPSBbXTtcbiAgICAgICAgICAgICAgcmVuZGVyU3RhdGUuc2NyaXB0cy5hZGQocmVzb3VyY2UkanNjb21wJDApO1xuICAgICAgICAgICAgICBwdXNoU2NyaXB0SW1wbChyZXNvdXJjZSRqc2NvbXAkMCwgc2NyaXB0UHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGV4dEVtYmVkZGVkICYmIHRhcmdldCRqc2NvbXAkMC5wdXNoKFwiXFx4M2MhLS0gLS1cXHgzZVwiKTtcbiAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkNiA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDY7XG4gICAgICAgIGNhc2UgXCJzdHlsZVwiOlxuICAgICAgICAgIHZhciBub3NjcmlwdFRhZ0luU2NvcGUkanNjb21wJDIgPSBmb3JtYXRDb250ZXh0LnRhZ1Njb3BlICYgMTtcbiAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgXCJjaGlsZHJlblwiKSkge1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuJGpzY29tcCQ3ID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgICAgICAgICAgIGNoaWxkJGpzY29tcCQwID0gQXJyYXkuaXNBcnJheShjaGlsZHJlbiRqc2NvbXAkNylcbiAgICAgICAgICAgICAgICA/IDIgPiBjaGlsZHJlbiRqc2NvbXAkNy5sZW5ndGhcbiAgICAgICAgICAgICAgICAgID8gY2hpbGRyZW4kanNjb21wJDdbMF1cbiAgICAgICAgICAgICAgICAgIDogbnVsbFxuICAgICAgICAgICAgICAgIDogY2hpbGRyZW4kanNjb21wJDc7XG4gICAgICAgICAgICAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY2hpbGQkanNjb21wJDAgfHxcbiAgICAgICAgICAgICAgXCJzeW1ib2xcIiA9PT0gdHlwZW9mIGNoaWxkJGpzY29tcCQwIHx8XG4gICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkoY2hpbGQkanNjb21wJDApKSAmJlxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiUmVhY3QgZXhwZWN0IGNoaWxkcmVuIG9mIDxzdHlsZT4gdGFncyB0byBiZSBhIHN0cmluZywgbnVtYmVyLCBvciBvYmplY3Qgd2l0aCBhIGB0b1N0cmluZ2AgbWV0aG9kIGJ1dCBmb3VuZCAlcyBpbnN0ZWFkLiBJbiBicm93c2VycyBzdHlsZSBFbGVtZW50cyBjYW4gb25seSBoYXZlIGBUZXh0YCBOb2RlcyBhcyBjaGlsZHJlbi5cIixcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBjaGlsZCRqc2NvbXAkMFxuICAgICAgICAgICAgICAgICAgPyBcImEgRnVuY3Rpb25cIlxuICAgICAgICAgICAgICAgICAgOiBcInN5bWJvbFwiID09PSB0eXBlb2YgY2hpbGQkanNjb21wJDBcbiAgICAgICAgICAgICAgICAgICAgPyBcImEgU3libW9sXCJcbiAgICAgICAgICAgICAgICAgICAgOiBcImFuIEFycmF5XCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHByZWNlZGVuY2UkanNjb21wJDAgPSBwcm9wcy5wcmVjZWRlbmNlLFxuICAgICAgICAgICAgaHJlZiRqc2NvbXAkMCA9IHByb3BzLmhyZWYsXG4gICAgICAgICAgICBub25jZSA9IHByb3BzLm5vbmNlO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSA9PT0gU1ZHX01PREUgfHxcbiAgICAgICAgICAgIG5vc2NyaXB0VGFnSW5TY29wZSRqc2NvbXAkMiB8fFxuICAgICAgICAgICAgbnVsbCAhPSBwcm9wcy5pdGVtUHJvcCB8fFxuICAgICAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIHByZWNlZGVuY2UkanNjb21wJDAgfHxcbiAgICAgICAgICAgIFwic3RyaW5nXCIgIT09IHR5cGVvZiBocmVmJGpzY29tcCQwIHx8XG4gICAgICAgICAgICBcIlwiID09PSBocmVmJGpzY29tcCQwXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChzdGFydENodW5rRm9yVGFnKFwic3R5bGVcIikpO1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuJGpzY29tcCQ4ID0gbnVsbCxcbiAgICAgICAgICAgICAgaW5uZXJIVE1MJGpzY29tcCQ1ID0gbnVsbCxcbiAgICAgICAgICAgICAgcHJvcEtleSRqc2NvbXAkODtcbiAgICAgICAgICAgIGZvciAocHJvcEtleSRqc2NvbXAkOCBpbiBwcm9wcylcbiAgICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkkanNjb21wJDgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb3BWYWx1ZSRqc2NvbXAkOCA9IHByb3BzW3Byb3BLZXkkanNjb21wJDhdO1xuICAgICAgICAgICAgICAgIGlmIChudWxsICE9IHByb3BWYWx1ZSRqc2NvbXAkOClcbiAgICAgICAgICAgICAgICAgIHN3aXRjaCAocHJvcEtleSRqc2NvbXAkOCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbiRqc2NvbXAkOCA9IHByb3BWYWx1ZSRqc2NvbXAkODtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgICAgICAgICAgICAgaW5uZXJIVE1MJGpzY29tcCQ1ID0gcHJvcFZhbHVlJGpzY29tcCQ4O1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgIHB1c2hBdHRyaWJ1dGUoXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQ4LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcFZhbHVlJGpzY29tcCQ4XG4gICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gICAgICAgICAgICB2YXIgY2hpbGQkanNjb21wJDEgPSBBcnJheS5pc0FycmF5KGNoaWxkcmVuJGpzY29tcCQ4KVxuICAgICAgICAgICAgICA/IDIgPiBjaGlsZHJlbiRqc2NvbXAkOC5sZW5ndGhcbiAgICAgICAgICAgICAgICA/IGNoaWxkcmVuJGpzY29tcCQ4WzBdXG4gICAgICAgICAgICAgICAgOiBudWxsXG4gICAgICAgICAgICAgIDogY2hpbGRyZW4kanNjb21wJDg7XG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBjaGlsZCRqc2NvbXAkMSAmJlxuICAgICAgICAgICAgICBcInN5bWJvbFwiICE9PSB0eXBlb2YgY2hpbGQkanNjb21wJDEgJiZcbiAgICAgICAgICAgICAgbnVsbCAhPT0gY2hpbGQkanNjb21wJDEgJiZcbiAgICAgICAgICAgICAgdm9pZCAwICE9PSBjaGlsZCRqc2NvbXAkMSAmJlxuICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChlc2NhcGVTdHlsZVRleHRDb250ZW50KGNoaWxkJGpzY29tcCQxKSk7XG4gICAgICAgICAgICBwdXNoSW5uZXJIVE1MKFxuICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAsXG4gICAgICAgICAgICAgIGlubmVySFRNTCRqc2NvbXAkNSxcbiAgICAgICAgICAgICAgY2hpbGRyZW4kanNjb21wJDhcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChlbmRDaHVua0ZvclRhZyhcInN0eWxlXCIpKTtcbiAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDcgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBocmVmJGpzY29tcCQwLmluY2x1ZGVzKFwiIFwiKSAmJlxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICdSZWFjdCBleHBlY3RlZCB0aGUgYGhyZWZgIHByb3AgZm9yIGEgPHN0eWxlPiB0YWcgb3B0aW5nIGludG8gaG9pc3Rpbmcgc2VtYW50aWNzIHVzaW5nIHRoZSBgcHJlY2VkZW5jZWAgcHJvcCB0byBub3QgaGF2ZSBhbnkgc3BhY2VzIGJ1dCBlY291bnRlcmVkIHNwYWNlcyBpbnN0ZWFkLiB1c2luZyBzcGFjZXMgaW4gdGhpcyBwcm9wIHdpbGwgY2F1c2UgaHlkcmF0aW9uIG9mIHRoaXMgc3R5bGUgdG8gZmFpbCBvbiB0aGUgY2xpZW50LiBUaGUgaHJlZiBmb3IgdGhlIDxzdHlsZT4gd2hlcmUgdGhpcyBvY3VycmVkIGlzIFwiJXNcIi4nLFxuICAgICAgICAgICAgICAgIGhyZWYkanNjb21wJDBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHZhciBzdHlsZVF1ZXVlJGpzY29tcCQwID1cbiAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5zdHlsZXMuZ2V0KHByZWNlZGVuY2UkanNjb21wJDApLFxuICAgICAgICAgICAgICByZXNvdXJjZVN0YXRlJGpzY29tcCQxID1cbiAgICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZS5zdHlsZVJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShocmVmJGpzY29tcCQwKVxuICAgICAgICAgICAgICAgICAgPyByZXN1bWFibGVTdGF0ZS5zdHlsZVJlc291cmNlc1tocmVmJGpzY29tcCQwXVxuICAgICAgICAgICAgICAgICAgOiB2b2lkIDA7XG4gICAgICAgICAgICBpZiAocmVzb3VyY2VTdGF0ZSRqc2NvbXAkMSAhPT0gRVhJU1RTKSB7XG4gICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLnN0eWxlUmVzb3VyY2VzW2hyZWYkanNjb21wJDBdID0gRVhJU1RTO1xuICAgICAgICAgICAgICByZXNvdXJjZVN0YXRlJGpzY29tcCQxICYmXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICdSZWFjdCBlbmNvdW50ZXJlZCBhIGhvaXN0YWJsZSBzdHlsZSB0YWcgZm9yIHRoZSBzYW1lIGhyZWYgYXMgYSBwcmVsb2FkOiBcIiVzXCIuIFdoZW4gdXNpbmcgYSBzdHlsZSB0YWcgdG8gaW5saW5lIHN0eWxlcyB5b3Ugc2hvdWxkIG5vdCBhbHNvIHByZWxvYWQgaXQgYXMgYSBzdHlsc2hlZXQuJyxcbiAgICAgICAgICAgICAgICAgIGhyZWYkanNjb21wJDBcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBzdHlsZVF1ZXVlJGpzY29tcCQwIHx8XG4gICAgICAgICAgICAgICAgKChzdHlsZVF1ZXVlJGpzY29tcCQwID0ge1xuICAgICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogZXNjYXBlVGV4dEZvckJyb3dzZXIocHJlY2VkZW5jZSRqc2NvbXAkMCksXG4gICAgICAgICAgICAgICAgICBydWxlczogW10sXG4gICAgICAgICAgICAgICAgICBocmVmczogW10sXG4gICAgICAgICAgICAgICAgICBzaGVldHM6IG5ldyBNYXAoKVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlLnN0eWxlcy5zZXQoXG4gICAgICAgICAgICAgICAgICBwcmVjZWRlbmNlJGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgc3R5bGVRdWV1ZSRqc2NvbXAkMFxuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgICB2YXIgbm9uY2VTdHlsZSA9IHJlbmRlclN0YXRlLm5vbmNlLnN0eWxlO1xuICAgICAgICAgICAgICBpZiAobm9uY2VTdHlsZSAmJiBub25jZVN0eWxlICE9PSBub25jZSlcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgJ1JlYWN0IGVuY291bnRlcmVkIGEgc3R5bGUgdGFnIHdpdGggYHByZWNlZGVuY2VgIFwiJXNcIiBhbmQgYG5vbmNlYCBcIiVzXCIuIFdoZW4gUmVhY3QgbWFuYWdlcyBzdHlsZSBydWxlcyB1c2luZyBgcHJlY2VkZW5jZWAgaXQgd2lsbCBvbmx5IGluY2x1ZGUgcnVsZXMgaWYgdGhlIG5vbmNlIG1hdGNoZXMgdGhlIHN0eWxlIG5vbmNlIFwiJXNcIiB0aGF0IHdhcyBpbmNsdWRlZCB3aXRoIHRoaXMgcmVuZGVyLicsXG4gICAgICAgICAgICAgICAgICBwcmVjZWRlbmNlJGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgbm9uY2UsXG4gICAgICAgICAgICAgICAgICBub25jZVN0eWxlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgIW5vbmNlU3R5bGUgJiZcbiAgICAgICAgICAgICAgICAgIG5vbmNlICYmXG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAnUmVhY3QgZW5jb3VudGVyZWQgYSBzdHlsZSB0YWcgd2l0aCBgcHJlY2VkZW5jZWAgXCIlc1wiIGFuZCBgbm9uY2VgIFwiJXNcIi4gV2hlbiBSZWFjdCBtYW5hZ2VzIHN0eWxlIHJ1bGVzIHVzaW5nIGBwcmVjZWRlbmNlYCBpdCB3aWxsIG9ubHkgaW5jbHVkZSBhIG5vbmNlIGF0dHJpYnV0ZXMgaWYgeW91IGFsc28gcHJvdmlkZSB0aGUgc2FtZSBzdHlsZSBub25jZSB2YWx1ZSBhcyBhIHJlbmRlciBvcHRpb24uJyxcbiAgICAgICAgICAgICAgICAgICAgcHJlY2VkZW5jZSRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgbm9uY2VcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgc3R5bGVRdWV1ZSRqc2NvbXAkMC5ocmVmcy5wdXNoKFxuICAgICAgICAgICAgICAgICAgZXNjYXBlVGV4dEZvckJyb3dzZXIoaHJlZiRqc2NvbXAkMClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSBzdHlsZVF1ZXVlJGpzY29tcCQwLnJ1bGVzLFxuICAgICAgICAgICAgICAgICAgY2hpbGRyZW4kanNjb21wJDkgPSBudWxsLFxuICAgICAgICAgICAgICAgICAgaW5uZXJIVE1MJGpzY29tcCQ2ID0gbnVsbCxcbiAgICAgICAgICAgICAgICAgIHByb3BLZXkkanNjb21wJDk7XG4gICAgICAgICAgICAgICAgZm9yIChwcm9wS2V5JGpzY29tcCQ5IGluIHByb3BzKVxuICAgICAgICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkkanNjb21wJDkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9wVmFsdWUkanNjb21wJDkgPSBwcm9wc1twcm9wS2V5JGpzY29tcCQ5XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG51bGwgIT0gcHJvcFZhbHVlJGpzY29tcCQ5KVxuICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocHJvcEtleSRqc2NvbXAkOSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuJGpzY29tcCQ5ID0gcHJvcFZhbHVlJGpzY29tcCQ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICBpbm5lckhUTUwkanNjb21wJDYgPSBwcm9wVmFsdWUkanNjb21wJDk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjaGlsZCRqc2NvbXAkMiA9IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4kanNjb21wJDkpXG4gICAgICAgICAgICAgICAgICA/IDIgPiBjaGlsZHJlbiRqc2NvbXAkOS5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgPyBjaGlsZHJlbiRqc2NvbXAkOVswXVxuICAgICAgICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgICAgICAgICAgIDogY2hpbGRyZW4kanNjb21wJDk7XG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgY2hpbGQkanNjb21wJDIgJiZcbiAgICAgICAgICAgICAgICAgIFwic3ltYm9sXCIgIT09IHR5cGVvZiBjaGlsZCRqc2NvbXAkMiAmJlxuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gY2hpbGQkanNjb21wJDIgJiZcbiAgICAgICAgICAgICAgICAgIHZvaWQgMCAhPT0gY2hpbGQkanNjb21wJDIgJiZcbiAgICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKGVzY2FwZVN0eWxlVGV4dENvbnRlbnQoY2hpbGQkanNjb21wJDIpKTtcbiAgICAgICAgICAgICAgICBwdXNoSW5uZXJIVE1MKHRhcmdldCwgaW5uZXJIVE1MJGpzY29tcCQ2LCBjaGlsZHJlbiRqc2NvbXAkOSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0eWxlUXVldWUkanNjb21wJDAgJiZcbiAgICAgICAgICAgICAgaG9pc3RhYmxlU3RhdGUgJiZcbiAgICAgICAgICAgICAgaG9pc3RhYmxlU3RhdGUuc3R5bGVzLmFkZChzdHlsZVF1ZXVlJGpzY29tcCQwKTtcbiAgICAgICAgICAgIHRleHRFbWJlZGRlZCAmJiB0YXJnZXQkanNjb21wJDAucHVzaChcIlxceDNjIS0tIC0tXFx4M2VcIik7XG4gICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDcgPSB2b2lkIDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDc7XG4gICAgICAgIGNhc2UgXCJtZXRhXCI6XG4gICAgICAgICAgdmFyIG5vc2NyaXB0VGFnSW5TY29wZSRqc2NvbXAkMyA9IGZvcm1hdENvbnRleHQudGFnU2NvcGUgJiAxLFxuICAgICAgICAgICAgaXNGYWxsYmFjayRqc2NvbXAkMSA9IGZvcm1hdENvbnRleHQudGFnU2NvcGUgJiA0O1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSA9PT0gU1ZHX01PREUgfHxcbiAgICAgICAgICAgIG5vc2NyaXB0VGFnSW5TY29wZSRqc2NvbXAkMyB8fFxuICAgICAgICAgICAgbnVsbCAhPSBwcm9wcy5pdGVtUHJvcFxuICAgICAgICAgIClcbiAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDggPSBwdXNoU2VsZkNsb3NpbmcoXG4gICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICAgIFwibWV0YVwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRleHRFbWJlZGRlZCAmJiB0YXJnZXQkanNjb21wJDAucHVzaChcIlxceDNjIS0tIC0tXFx4M2VcIiksXG4gICAgICAgICAgICAgIChKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDggPSBpc0ZhbGxiYWNrJGpzY29tcCQxXG4gICAgICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICAgICAgOiBcInN0cmluZ1wiID09PSB0eXBlb2YgcHJvcHMuY2hhclNldFxuICAgICAgICAgICAgICAgICAgPyBwdXNoU2VsZkNsb3NpbmcocmVuZGVyU3RhdGUuY2hhcnNldENodW5rcywgcHJvcHMsIFwibWV0YVwiKVxuICAgICAgICAgICAgICAgICAgOiBcInZpZXdwb3J0XCIgPT09IHByb3BzLm5hbWVcbiAgICAgICAgICAgICAgICAgICAgPyBwdXNoU2VsZkNsb3NpbmcocmVuZGVyU3RhdGUudmlld3BvcnRDaHVua3MsIHByb3BzLCBcIm1ldGFcIilcbiAgICAgICAgICAgICAgICAgICAgOiBwdXNoU2VsZkNsb3NpbmcoXG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5ob2lzdGFibGVDaHVua3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibWV0YVwiXG4gICAgICAgICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgcmV0dXJuIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkODtcbiAgICAgICAgY2FzZSBcImxpc3RpbmdcIjpcbiAgICAgICAgY2FzZSBcInByZVwiOlxuICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcodHlwZSkpO1xuICAgICAgICAgIHZhciBjaGlsZHJlbiRqc2NvbXAkMTAgPSBudWxsLFxuICAgICAgICAgICAgaW5uZXJIVE1MJGpzY29tcCQ3ID0gbnVsbCxcbiAgICAgICAgICAgIHByb3BLZXkkanNjb21wJDEwO1xuICAgICAgICAgIGZvciAocHJvcEtleSRqc2NvbXAkMTAgaW4gcHJvcHMpXG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSRqc2NvbXAkMTApKSB7XG4gICAgICAgICAgICAgIHZhciBwcm9wVmFsdWUkanNjb21wJDEwID0gcHJvcHNbcHJvcEtleSRqc2NvbXAkMTBdO1xuICAgICAgICAgICAgICBpZiAobnVsbCAhPSBwcm9wVmFsdWUkanNjb21wJDEwKVxuICAgICAgICAgICAgICAgIHN3aXRjaCAocHJvcEtleSRqc2NvbXAkMTApIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbiRqc2NvbXAkMTAgPSBwcm9wVmFsdWUkanNjb21wJDEwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICAgICAgICAgICAgICBpbm5lckhUTUwkanNjb21wJDcgPSBwcm9wVmFsdWUkanNjb21wJDEwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHB1c2hBdHRyaWJ1dGUoXG4gICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BLZXkkanNjb21wJDEwLFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BWYWx1ZSRqc2NvbXAkMTBcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gICAgICAgICAgaWYgKG51bGwgIT0gaW5uZXJIVE1MJGpzY29tcCQ3KSB7XG4gICAgICAgICAgICBpZiAobnVsbCAhPSBjaGlsZHJlbiRqc2NvbXAkMTApXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiQ2FuIG9ubHkgc2V0IG9uZSBvZiBgY2hpbGRyZW5gIG9yIGBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAuXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgXCJvYmplY3RcIiAhPT0gdHlwZW9mIGlubmVySFRNTCRqc2NvbXAkNyB8fFxuICAgICAgICAgICAgICAhKFwiX19odG1sXCIgaW4gaW5uZXJIVE1MJGpzY29tcCQ3KVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICBcImBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAgbXVzdCBiZSBpbiB0aGUgZm9ybSBge19faHRtbDogLi4ufWAuIFBsZWFzZSB2aXNpdCBodHRwczovL3JlYWN0LmRldi9saW5rL2Rhbmdlcm91c2x5LXNldC1pbm5lci1odG1sIGZvciBtb3JlIGluZm9ybWF0aW9uLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB2YXIgaHRtbCA9IGlubmVySFRNTCRqc2NvbXAkNy5fX2h0bWw7XG4gICAgICAgICAgICBudWxsICE9PSBodG1sICYmXG4gICAgICAgICAgICAgIHZvaWQgMCAhPT0gaHRtbCAmJlxuICAgICAgICAgICAgICAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGh0bWwgJiYgMCA8IGh0bWwubGVuZ3RoICYmIFwiXFxuXCIgPT09IGh0bWxbMF1cbiAgICAgICAgICAgICAgICA/IHRhcmdldCRqc2NvbXAkMC5wdXNoKGxlYWRpbmdOZXdsaW5lLCBodG1sKVxuICAgICAgICAgICAgICAgIDogKGNoZWNrSHRtbFN0cmluZ0NvZXJjaW9uKGh0bWwpLFxuICAgICAgICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goXCJcIiArIGh0bWwpKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBjaGlsZHJlbiRqc2NvbXAkMTAgJiZcbiAgICAgICAgICAgIFwiXFxuXCIgPT09IGNoaWxkcmVuJGpzY29tcCQxMFswXSAmJlxuICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2gobGVhZGluZ05ld2xpbmUpO1xuICAgICAgICAgIHJldHVybiBjaGlsZHJlbiRqc2NvbXAkMTA7XG4gICAgICAgIGNhc2UgXCJpbWdcIjpcbiAgICAgICAgICB2YXIgcGljdHVyZU9yTm9TY3JpcHRUYWdJblNjb3BlID0gZm9ybWF0Q29udGV4dC50YWdTY29wZSAmIDMsXG4gICAgICAgICAgICBzcmMgPSBwcm9wcy5zcmMsXG4gICAgICAgICAgICBzcmNTZXQgPSBwcm9wcy5zcmNTZXQ7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIShcbiAgICAgICAgICAgICAgXCJsYXp5XCIgPT09IHByb3BzLmxvYWRpbmcgfHxcbiAgICAgICAgICAgICAgKCFzcmMgJiYgIXNyY1NldCkgfHxcbiAgICAgICAgICAgICAgKFwic3RyaW5nXCIgIT09IHR5cGVvZiBzcmMgJiYgbnVsbCAhPSBzcmMpIHx8XG4gICAgICAgICAgICAgIChcInN0cmluZ1wiICE9PSB0eXBlb2Ygc3JjU2V0ICYmIG51bGwgIT0gc3JjU2V0KSB8fFxuICAgICAgICAgICAgICBcImxvd1wiID09PSBwcm9wcy5mZXRjaFByaW9yaXR5IHx8XG4gICAgICAgICAgICAgIHBpY3R1cmVPck5vU2NyaXB0VGFnSW5TY29wZVxuICAgICAgICAgICAgKSAmJlxuICAgICAgICAgICAgKFwic3RyaW5nXCIgIT09IHR5cGVvZiBzcmMgfHxcbiAgICAgICAgICAgICAgXCI6XCIgIT09IHNyY1s0XSB8fFxuICAgICAgICAgICAgICAoXCJkXCIgIT09IHNyY1swXSAmJiBcIkRcIiAhPT0gc3JjWzBdKSB8fFxuICAgICAgICAgICAgICAoXCJhXCIgIT09IHNyY1sxXSAmJiBcIkFcIiAhPT0gc3JjWzFdKSB8fFxuICAgICAgICAgICAgICAoXCJ0XCIgIT09IHNyY1syXSAmJiBcIlRcIiAhPT0gc3JjWzJdKSB8fFxuICAgICAgICAgICAgICAoXCJhXCIgIT09IHNyY1szXSAmJiBcIkFcIiAhPT0gc3JjWzNdKSkgJiZcbiAgICAgICAgICAgIChcInN0cmluZ1wiICE9PSB0eXBlb2Ygc3JjU2V0IHx8XG4gICAgICAgICAgICAgIFwiOlwiICE9PSBzcmNTZXRbNF0gfHxcbiAgICAgICAgICAgICAgKFwiZFwiICE9PSBzcmNTZXRbMF0gJiYgXCJEXCIgIT09IHNyY1NldFswXSkgfHxcbiAgICAgICAgICAgICAgKFwiYVwiICE9PSBzcmNTZXRbMV0gJiYgXCJBXCIgIT09IHNyY1NldFsxXSkgfHxcbiAgICAgICAgICAgICAgKFwidFwiICE9PSBzcmNTZXRbMl0gJiYgXCJUXCIgIT09IHNyY1NldFsyXSkgfHxcbiAgICAgICAgICAgICAgKFwiYVwiICE9PSBzcmNTZXRbM10gJiYgXCJBXCIgIT09IHNyY1NldFszXSkpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBudWxsICE9PSBob2lzdGFibGVTdGF0ZSAmJlxuICAgICAgICAgICAgICBmb3JtYXRDb250ZXh0LnRhZ1Njb3BlICYgNjQgJiZcbiAgICAgICAgICAgICAgKGhvaXN0YWJsZVN0YXRlLnN1c3BlbnNleUltYWdlcyA9ICEwKTtcbiAgICAgICAgICAgIHZhciBzaXplcyA9IFwic3RyaW5nXCIgPT09IHR5cGVvZiBwcm9wcy5zaXplcyA/IHByb3BzLnNpemVzIDogdm9pZCAwLFxuICAgICAgICAgICAgICBrZXkkanNjb21wJDAgPSBzcmNTZXQgPyBzcmNTZXQgKyBcIlxcblwiICsgKHNpemVzIHx8IFwiXCIpIDogc3JjLFxuICAgICAgICAgICAgICBwcm9tb3RhYmxlUHJlbG9hZHMgPSByZW5kZXJTdGF0ZS5wcmVsb2Fkcy5pbWFnZXMsXG4gICAgICAgICAgICAgIHJlc291cmNlJGpzY29tcCQxID0gcHJvbW90YWJsZVByZWxvYWRzLmdldChrZXkkanNjb21wJDApO1xuICAgICAgICAgICAgaWYgKHJlc291cmNlJGpzY29tcCQxKSB7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBcImhpZ2hcIiA9PT0gcHJvcHMuZmV0Y2hQcmlvcml0eSB8fFxuICAgICAgICAgICAgICAgIDEwID4gcmVuZGVyU3RhdGUuaGlnaEltYWdlUHJlbG9hZHMuc2l6ZVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgcHJvbW90YWJsZVByZWxvYWRzLmRlbGV0ZShrZXkkanNjb21wJDApLFxuICAgICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUuaGlnaEltYWdlUHJlbG9hZHMuYWRkKHJlc291cmNlJGpzY29tcCQxKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICFyZXN1bWFibGVTdGF0ZS5pbWFnZVJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShrZXkkanNjb21wJDApXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUuaW1hZ2VSZXNvdXJjZXNba2V5JGpzY29tcCQwXSA9IFBSRUxPQURfTk9fQ1JFRFM7XG4gICAgICAgICAgICAgIHZhciBpbnB1dCA9IHByb3BzLmNyb3NzT3JpZ2luO1xuICAgICAgICAgICAgICB2YXIgY3Jvc3NPcmlnaW4gPVxuICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBpbnB1dFxuICAgICAgICAgICAgICAgICAgPyBcInVzZS1jcmVkZW50aWFsc1wiID09PSBpbnB1dFxuICAgICAgICAgICAgICAgICAgICA/IGlucHV0XG4gICAgICAgICAgICAgICAgICAgIDogXCJcIlxuICAgICAgICAgICAgICAgICAgOiB2b2lkIDA7XG4gICAgICAgICAgICAgIHZhciBoZWFkZXJzID0gcmVuZGVyU3RhdGUuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBoZWFkZXI7XG4gICAgICAgICAgICAgIGhlYWRlcnMgJiZcbiAgICAgICAgICAgICAgMCA8IGhlYWRlcnMucmVtYWluaW5nQ2FwYWNpdHkgJiZcbiAgICAgICAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIHByb3BzLnNyY1NldCAmJlxuICAgICAgICAgICAgICAoXCJoaWdoXCIgPT09IHByb3BzLmZldGNoUHJpb3JpdHkgfHxcbiAgICAgICAgICAgICAgICA1MDAgPiBoZWFkZXJzLmhpZ2hJbWFnZVByZWxvYWRzLmxlbmd0aCkgJiZcbiAgICAgICAgICAgICAgKChoZWFkZXIgPSBnZXRQcmVsb2FkQXNIZWFkZXIoc3JjLCBcImltYWdlXCIsIHtcbiAgICAgICAgICAgICAgICBpbWFnZVNyY1NldDogcHJvcHMuc3JjU2V0LFxuICAgICAgICAgICAgICAgIGltYWdlU2l6ZXM6IHByb3BzLnNpemVzLFxuICAgICAgICAgICAgICAgIGNyb3NzT3JpZ2luOiBjcm9zc09yaWdpbixcbiAgICAgICAgICAgICAgICBpbnRlZ3JpdHk6IHByb3BzLmludGVncml0eSxcbiAgICAgICAgICAgICAgICBub25jZTogcHJvcHMubm9uY2UsXG4gICAgICAgICAgICAgICAgdHlwZTogcHJvcHMudHlwZSxcbiAgICAgICAgICAgICAgICBmZXRjaFByaW9yaXR5OiBwcm9wcy5mZXRjaFByaW9yaXR5LFxuICAgICAgICAgICAgICAgIHJlZmVycmVyUG9saWN5OiBwcm9wcy5yZWZlcmVyUG9saWN5XG4gICAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgICAgMCA8PSAoaGVhZGVycy5yZW1haW5pbmdDYXBhY2l0eSAtPSBoZWFkZXIubGVuZ3RoICsgMikpXG4gICAgICAgICAgICAgICAgPyAoKHJlbmRlclN0YXRlLnJlc2V0cy5pbWFnZVtrZXkkanNjb21wJDBdID0gUFJFTE9BRF9OT19DUkVEUyksXG4gICAgICAgICAgICAgICAgICBoZWFkZXJzLmhpZ2hJbWFnZVByZWxvYWRzICYmXG4gICAgICAgICAgICAgICAgICAgIChoZWFkZXJzLmhpZ2hJbWFnZVByZWxvYWRzICs9IFwiLCBcIiksXG4gICAgICAgICAgICAgICAgICAoaGVhZGVycy5oaWdoSW1hZ2VQcmVsb2FkcyArPSBoZWFkZXIpKVxuICAgICAgICAgICAgICAgIDogKChyZXNvdXJjZSRqc2NvbXAkMSA9IFtdKSxcbiAgICAgICAgICAgICAgICAgIHB1c2hMaW5rSW1wbChyZXNvdXJjZSRqc2NvbXAkMSwge1xuICAgICAgICAgICAgICAgICAgICByZWw6IFwicHJlbG9hZFwiLFxuICAgICAgICAgICAgICAgICAgICBhczogXCJpbWFnZVwiLFxuICAgICAgICAgICAgICAgICAgICBocmVmOiBzcmNTZXQgPyB2b2lkIDAgOiBzcmMsXG4gICAgICAgICAgICAgICAgICAgIGltYWdlU3JjU2V0OiBzcmNTZXQsXG4gICAgICAgICAgICAgICAgICAgIGltYWdlU2l6ZXM6IHNpemVzLFxuICAgICAgICAgICAgICAgICAgICBjcm9zc09yaWdpbjogY3Jvc3NPcmlnaW4sXG4gICAgICAgICAgICAgICAgICAgIGludGVncml0eTogcHJvcHMuaW50ZWdyaXR5LFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBwcm9wcy50eXBlLFxuICAgICAgICAgICAgICAgICAgICBmZXRjaFByaW9yaXR5OiBwcm9wcy5mZXRjaFByaW9yaXR5LFxuICAgICAgICAgICAgICAgICAgICByZWZlcnJlclBvbGljeTogcHJvcHMucmVmZXJyZXJQb2xpY3lcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgXCJoaWdoXCIgPT09IHByb3BzLmZldGNoUHJpb3JpdHkgfHxcbiAgICAgICAgICAgICAgICAgIDEwID4gcmVuZGVyU3RhdGUuaGlnaEltYWdlUHJlbG9hZHMuc2l6ZVxuICAgICAgICAgICAgICAgICAgICA/IHJlbmRlclN0YXRlLmhpZ2hJbWFnZVByZWxvYWRzLmFkZChyZXNvdXJjZSRqc2NvbXAkMSlcbiAgICAgICAgICAgICAgICAgICAgOiAocmVuZGVyU3RhdGUuYnVsa1ByZWxvYWRzLmFkZChyZXNvdXJjZSRqc2NvbXAkMSksXG4gICAgICAgICAgICAgICAgICAgICAgcHJvbW90YWJsZVByZWxvYWRzLnNldChrZXkkanNjb21wJDAsIHJlc291cmNlJGpzY29tcCQxKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcHVzaFNlbGZDbG9zaW5nKHRhcmdldCRqc2NvbXAkMCwgcHJvcHMsIFwiaW1nXCIpO1xuICAgICAgICBjYXNlIFwiYmFzZVwiOlxuICAgICAgICBjYXNlIFwiYXJlYVwiOlxuICAgICAgICBjYXNlIFwiYnJcIjpcbiAgICAgICAgY2FzZSBcImNvbFwiOlxuICAgICAgICBjYXNlIFwiZW1iZWRcIjpcbiAgICAgICAgY2FzZSBcImhyXCI6XG4gICAgICAgIGNhc2UgXCJrZXlnZW5cIjpcbiAgICAgICAgY2FzZSBcInBhcmFtXCI6XG4gICAgICAgIGNhc2UgXCJzb3VyY2VcIjpcbiAgICAgICAgY2FzZSBcInRyYWNrXCI6XG4gICAgICAgIGNhc2UgXCJ3YnJcIjpcbiAgICAgICAgICByZXR1cm4gcHVzaFNlbGZDbG9zaW5nKHRhcmdldCRqc2NvbXAkMCwgcHJvcHMsIHR5cGUpO1xuICAgICAgICBjYXNlIFwiYW5ub3RhdGlvbi14bWxcIjpcbiAgICAgICAgY2FzZSBcImNvbG9yLXByb2ZpbGVcIjpcbiAgICAgICAgY2FzZSBcImZvbnQtZmFjZVwiOlxuICAgICAgICBjYXNlIFwiZm9udC1mYWNlLXNyY1wiOlxuICAgICAgICBjYXNlIFwiZm9udC1mYWNlLXVyaVwiOlxuICAgICAgICBjYXNlIFwiZm9udC1mYWNlLWZvcm1hdFwiOlxuICAgICAgICBjYXNlIFwiZm9udC1mYWNlLW5hbWVcIjpcbiAgICAgICAgY2FzZSBcIm1pc3NpbmctZ2x5cGhcIjpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImhlYWRcIjpcbiAgICAgICAgICBpZiAoZm9ybWF0Q29udGV4dC5pbnNlcnRpb25Nb2RlIDwgSFRNTF9NT0RFKSB7XG4gICAgICAgICAgICB2YXIgcHJlYW1ibGUgPSBwcmVhbWJsZVN0YXRlIHx8IHJlbmRlclN0YXRlLnByZWFtYmxlO1xuICAgICAgICAgICAgaWYgKHByZWFtYmxlLmhlYWRDaHVua3MpXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFwiVGhlIGA8aGVhZD5gIHRhZyBtYXkgb25seSBiZSByZW5kZXJlZCBvbmNlLlwiKTtcbiAgICAgICAgICAgIG51bGwgIT09IHByZWFtYmxlU3RhdGUgJiYgdGFyZ2V0JGpzY29tcCQwLnB1c2goXCJcXHgzYyEtLWhlYWQtLVxceDNlXCIpO1xuICAgICAgICAgICAgcHJlYW1ibGUuaGVhZENodW5rcyA9IFtdO1xuICAgICAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkOSA9IHB1c2hTdGFydFNpbmdsZXRvbkVsZW1lbnQoXG4gICAgICAgICAgICAgIHByZWFtYmxlLmhlYWRDaHVua3MsXG4gICAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgICBcImhlYWRcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkOSA9IHB1c2hTdGFydEdlbmVyaWNFbGVtZW50KFxuICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAsXG4gICAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgICBcImhlYWRcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQ5O1xuICAgICAgICBjYXNlIFwiYm9keVwiOlxuICAgICAgICAgIGlmIChmb3JtYXRDb250ZXh0Lmluc2VydGlvbk1vZGUgPCBIVE1MX01PREUpIHtcbiAgICAgICAgICAgIHZhciBwcmVhbWJsZSRqc2NvbXAkMCA9IHByZWFtYmxlU3RhdGUgfHwgcmVuZGVyU3RhdGUucHJlYW1ibGU7XG4gICAgICAgICAgICBpZiAocHJlYW1ibGUkanNjb21wJDAuYm9keUNodW5rcylcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJUaGUgYDxib2R5PmAgdGFnIG1heSBvbmx5IGJlIHJlbmRlcmVkIG9uY2UuXCIpO1xuICAgICAgICAgICAgbnVsbCAhPT0gcHJlYW1ibGVTdGF0ZSAmJiB0YXJnZXQkanNjb21wJDAucHVzaChcIlxceDNjIS0tYm9keS0tXFx4M2VcIik7XG4gICAgICAgICAgICBwcmVhbWJsZSRqc2NvbXAkMC5ib2R5Q2h1bmtzID0gW107XG4gICAgICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQxMCA9IHB1c2hTdGFydFNpbmdsZXRvbkVsZW1lbnQoXG4gICAgICAgICAgICAgIHByZWFtYmxlJGpzY29tcCQwLmJvZHlDaHVua3MsXG4gICAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgICBcImJvZHlcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMTAgPSBwdXNoU3RhcnRHZW5lcmljRWxlbWVudChcbiAgICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLFxuICAgICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgICAgXCJib2R5XCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMTA7XG4gICAgICAgIGNhc2UgXCJodG1sXCI6XG4gICAgICAgICAgaWYgKGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSA9PT0gUk9PVF9IVE1MX01PREUpIHtcbiAgICAgICAgICAgIHZhciBwcmVhbWJsZSRqc2NvbXAkMSA9IHByZWFtYmxlU3RhdGUgfHwgcmVuZGVyU3RhdGUucHJlYW1ibGU7XG4gICAgICAgICAgICBpZiAocHJlYW1ibGUkanNjb21wJDEuaHRtbENodW5rcylcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJUaGUgYDxodG1sPmAgdGFnIG1heSBvbmx5IGJlIHJlbmRlcmVkIG9uY2UuXCIpO1xuICAgICAgICAgICAgbnVsbCAhPT0gcHJlYW1ibGVTdGF0ZSAmJiB0YXJnZXQkanNjb21wJDAucHVzaChcIlxceDNjIS0taHRtbC0tXFx4M2VcIik7XG4gICAgICAgICAgICBwcmVhbWJsZSRqc2NvbXAkMS5odG1sQ2h1bmtzID0gW2RvY3R5cGVDaHVua107XG4gICAgICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQxMSA9IHB1c2hTdGFydFNpbmdsZXRvbkVsZW1lbnQoXG4gICAgICAgICAgICAgIHByZWFtYmxlJGpzY29tcCQxLmh0bWxDaHVua3MsXG4gICAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgICBcImh0bWxcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMTEgPSBwdXNoU3RhcnRHZW5lcmljRWxlbWVudChcbiAgICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLFxuICAgICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgICAgXCJodG1sXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMTE7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKC0xICE9PSB0eXBlLmluZGV4T2YoXCItXCIpKSB7XG4gICAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChzdGFydENodW5rRm9yVGFnKHR5cGUpKTtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiRqc2NvbXAkMTEgPSBudWxsLFxuICAgICAgICAgICAgICBpbm5lckhUTUwkanNjb21wJDggPSBudWxsLFxuICAgICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQxMTtcbiAgICAgICAgICAgIGZvciAocHJvcEtleSRqc2NvbXAkMTEgaW4gcHJvcHMpXG4gICAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5JGpzY29tcCQxMSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcFZhbHVlJGpzY29tcCQxMSA9IHByb3BzW3Byb3BLZXkkanNjb21wJDExXTtcbiAgICAgICAgICAgICAgICBpZiAobnVsbCAhPSBwcm9wVmFsdWUkanNjb21wJDExKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IHByb3BLZXkkanNjb21wJDExO1xuICAgICAgICAgICAgICAgICAgc3dpdGNoIChwcm9wS2V5JGpzY29tcCQxMSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbiRqc2NvbXAkMTEgPSBwcm9wVmFsdWUkanNjb21wJDExO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICAgICAgICBpbm5lckhUTUwkanNjb21wJDggPSBwcm9wVmFsdWUkanNjb21wJDExO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3R5bGVcIjpcbiAgICAgICAgICAgICAgICAgICAgICBwdXNoU3R5bGVBdHRyaWJ1dGUodGFyZ2V0JGpzY29tcCQwLCBwcm9wVmFsdWUkanNjb21wJDExKTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZ1wiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJyZWZcIjpcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImNsYXNzTmFtZVwiOlxuICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZU5hbWUgPSBcImNsYXNzXCI7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNBdHRyaWJ1dGVOYW1lU2FmZShwcm9wS2V5JGpzY29tcCQxMSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHByb3BWYWx1ZSRqc2NvbXAkMTEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIFwic3ltYm9sXCIgIT09IHR5cGVvZiBwcm9wVmFsdWUkanNjb21wJDExICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhMSAhPT0gcHJvcFZhbHVlJGpzY29tcCQxMVxuICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEwID09PSBwcm9wVmFsdWUkanNjb21wJDExKVxuICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wVmFsdWUkanNjb21wJDExID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBwcm9wVmFsdWUkanNjb21wJDExKVxuICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVTZXBhcmF0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZU5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUFzc2lnbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXNjYXBlVGV4dEZvckJyb3dzZXIocHJvcFZhbHVlJGpzY29tcCQxMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUVuZFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChlbmRPZlN0YXJ0VGFnKTtcbiAgICAgICAgICAgIHB1c2hJbm5lckhUTUwoXG4gICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgaW5uZXJIVE1MJGpzY29tcCQ4LFxuICAgICAgICAgICAgICBjaGlsZHJlbiRqc2NvbXAkMTFcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGRyZW4kanNjb21wJDExO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBwdXNoU3RhcnRHZW5lcmljRWxlbWVudCh0YXJnZXQkanNjb21wJDAsIHByb3BzLCB0eXBlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW5kQ2h1bmtGb3JUYWcodGFnKSB7XG4gICAgICB2YXIgY2h1bmsgPSBlbmRUYWdDYWNoZS5nZXQodGFnKTtcbiAgICAgIHZvaWQgMCA9PT0gY2h1bmsgJiZcbiAgICAgICAgKChjaHVuayA9IFwiPC9cIiArIHRhZyArIFwiPlwiKSwgZW5kVGFnQ2FjaGUuc2V0KHRhZywgY2h1bmspKTtcbiAgICAgIHJldHVybiBjaHVuaztcbiAgICB9XG4gICAgZnVuY3Rpb24gaG9pc3RQcmVhbWJsZVN0YXRlKHJlbmRlclN0YXRlLCBwcmVhbWJsZVN0YXRlKSB7XG4gICAgICByZW5kZXJTdGF0ZSA9IHJlbmRlclN0YXRlLnByZWFtYmxlO1xuICAgICAgbnVsbCA9PT0gcmVuZGVyU3RhdGUuaHRtbENodW5rcyAmJlxuICAgICAgICBwcmVhbWJsZVN0YXRlLmh0bWxDaHVua3MgJiZcbiAgICAgICAgKHJlbmRlclN0YXRlLmh0bWxDaHVua3MgPSBwcmVhbWJsZVN0YXRlLmh0bWxDaHVua3MpO1xuICAgICAgbnVsbCA9PT0gcmVuZGVyU3RhdGUuaGVhZENodW5rcyAmJlxuICAgICAgICBwcmVhbWJsZVN0YXRlLmhlYWRDaHVua3MgJiZcbiAgICAgICAgKHJlbmRlclN0YXRlLmhlYWRDaHVua3MgPSBwcmVhbWJsZVN0YXRlLmhlYWRDaHVua3MpO1xuICAgICAgbnVsbCA9PT0gcmVuZGVyU3RhdGUuYm9keUNodW5rcyAmJlxuICAgICAgICBwcmVhbWJsZVN0YXRlLmJvZHlDaHVua3MgJiZcbiAgICAgICAgKHJlbmRlclN0YXRlLmJvZHlDaHVua3MgPSBwcmVhbWJsZVN0YXRlLmJvZHlDaHVua3MpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3cml0ZUJvb3RzdHJhcChkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUpIHtcbiAgICAgIHJlbmRlclN0YXRlID0gcmVuZGVyU3RhdGUuYm9vdHN0cmFwQ2h1bmtzO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZW5kZXJTdGF0ZS5sZW5ndGggLSAxOyBpKyspXG4gICAgICAgIGRlc3RpbmF0aW9uLnB1c2gocmVuZGVyU3RhdGVbaV0pO1xuICAgICAgcmV0dXJuIGkgPCByZW5kZXJTdGF0ZS5sZW5ndGhcbiAgICAgICAgPyAoKGkgPSByZW5kZXJTdGF0ZVtpXSksIChyZW5kZXJTdGF0ZS5sZW5ndGggPSAwKSwgZGVzdGluYXRpb24ucHVzaChpKSlcbiAgICAgICAgOiAhMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gd3JpdGVTdGFydFBlbmRpbmdTdXNwZW5zZUJvdW5kYXJ5KGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZSwgaWQpIHtcbiAgICAgIGRlc3RpbmF0aW9uLnB1c2goc3RhcnRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeTEpO1xuICAgICAgaWYgKG51bGwgPT09IGlkKVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIkFuIElEIG11c3QgaGF2ZSBiZWVuIGFzc2lnbmVkIGJlZm9yZSB3ZSBjYW4gY29tcGxldGUgdGhlIGJvdW5kYXJ5LlwiXG4gICAgICAgICk7XG4gICAgICBkZXN0aW5hdGlvbi5wdXNoKHJlbmRlclN0YXRlLmJvdW5kYXJ5UHJlZml4KTtcbiAgICAgIHJlbmRlclN0YXRlID0gaWQudG9TdHJpbmcoMTYpO1xuICAgICAgZGVzdGluYXRpb24ucHVzaChyZW5kZXJTdGF0ZSk7XG4gICAgICByZXR1cm4gZGVzdGluYXRpb24ucHVzaChzdGFydFBlbmRpbmdTdXNwZW5zZUJvdW5kYXJ5Mik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdyaXRlU3RhcnRTZWdtZW50KGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZSwgZm9ybWF0Q29udGV4dCwgaWQpIHtcbiAgICAgIHN3aXRjaCAoZm9ybWF0Q29udGV4dC5pbnNlcnRpb25Nb2RlKSB7XG4gICAgICAgIGNhc2UgUk9PVF9IVE1MX01PREU6XG4gICAgICAgIGNhc2UgSFRNTF9IVE1MX01PREU6XG4gICAgICAgIGNhc2UgSFRNTF9IRUFEX01PREU6XG4gICAgICAgIGNhc2UgSFRNTF9NT0RFOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKHN0YXJ0U2VnbWVudEhUTUwpLFxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChyZW5kZXJTdGF0ZS5zZWdtZW50UHJlZml4KSxcbiAgICAgICAgICAgIChyZW5kZXJTdGF0ZSA9IGlkLnRvU3RyaW5nKDE2KSksXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKHJlbmRlclN0YXRlKSxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2goc3RhcnRTZWdtZW50SFRNTDIpXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBTVkdfTU9ERTpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChzdGFydFNlZ21lbnRTVkcpLFxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChyZW5kZXJTdGF0ZS5zZWdtZW50UHJlZml4KSxcbiAgICAgICAgICAgIChyZW5kZXJTdGF0ZSA9IGlkLnRvU3RyaW5nKDE2KSksXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKHJlbmRlclN0YXRlKSxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2goc3RhcnRTZWdtZW50U1ZHMilcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIE1BVEhNTF9NT0RFOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKHN0YXJ0U2VnbWVudE1hdGhNTCksXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKHJlbmRlclN0YXRlLnNlZ21lbnRQcmVmaXgpLFxuICAgICAgICAgICAgKHJlbmRlclN0YXRlID0gaWQudG9TdHJpbmcoMTYpKSxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2gocmVuZGVyU3RhdGUpLFxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChzdGFydFNlZ21lbnRNYXRoTUwyKVxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgSFRNTF9UQUJMRV9NT0RFOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKHN0YXJ0U2VnbWVudFRhYmxlKSxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2gocmVuZGVyU3RhdGUuc2VnbWVudFByZWZpeCksXG4gICAgICAgICAgICAocmVuZGVyU3RhdGUgPSBpZC50b1N0cmluZygxNikpLFxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChyZW5kZXJTdGF0ZSksXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKHN0YXJ0U2VnbWVudFRhYmxlMilcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIEhUTUxfVEFCTEVfQk9EWV9NT0RFOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKHN0YXJ0U2VnbWVudFRhYmxlQm9keSksXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKHJlbmRlclN0YXRlLnNlZ21lbnRQcmVmaXgpLFxuICAgICAgICAgICAgKHJlbmRlclN0YXRlID0gaWQudG9TdHJpbmcoMTYpKSxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2gocmVuZGVyU3RhdGUpLFxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChzdGFydFNlZ21lbnRUYWJsZUJvZHkyKVxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgSFRNTF9UQUJMRV9ST1dfTU9ERTpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChzdGFydFNlZ21lbnRUYWJsZVJvdyksXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKHJlbmRlclN0YXRlLnNlZ21lbnRQcmVmaXgpLFxuICAgICAgICAgICAgKHJlbmRlclN0YXRlID0gaWQudG9TdHJpbmcoMTYpKSxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2gocmVuZGVyU3RhdGUpLFxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChzdGFydFNlZ21lbnRUYWJsZVJvdzIpXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBIVE1MX0NPTEdST1VQX01PREU6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2goc3RhcnRTZWdtZW50Q29sR3JvdXApLFxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChyZW5kZXJTdGF0ZS5zZWdtZW50UHJlZml4KSxcbiAgICAgICAgICAgIChyZW5kZXJTdGF0ZSA9IGlkLnRvU3RyaW5nKDE2KSksXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKHJlbmRlclN0YXRlKSxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2goc3RhcnRTZWdtZW50Q29sR3JvdXAyKVxuICAgICAgICAgICk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXCJVbmtub3duIGluc2VydGlvbiBtb2RlLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gd3JpdGVFbmRTZWdtZW50KGRlc3RpbmF0aW9uLCBmb3JtYXRDb250ZXh0KSB7XG4gICAgICBzd2l0Y2ggKGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSkge1xuICAgICAgICBjYXNlIFJPT1RfSFRNTF9NT0RFOlxuICAgICAgICBjYXNlIEhUTUxfSFRNTF9NT0RFOlxuICAgICAgICBjYXNlIEhUTUxfSEVBRF9NT0RFOlxuICAgICAgICBjYXNlIEhUTUxfTU9ERTpcbiAgICAgICAgICByZXR1cm4gZGVzdGluYXRpb24ucHVzaChlbmRTZWdtZW50SFRNTCk7XG4gICAgICAgIGNhc2UgU1ZHX01PREU6XG4gICAgICAgICAgcmV0dXJuIGRlc3RpbmF0aW9uLnB1c2goZW5kU2VnbWVudFNWRyk7XG4gICAgICAgIGNhc2UgTUFUSE1MX01PREU6XG4gICAgICAgICAgcmV0dXJuIGRlc3RpbmF0aW9uLnB1c2goZW5kU2VnbWVudE1hdGhNTCk7XG4gICAgICAgIGNhc2UgSFRNTF9UQUJMRV9NT0RFOlxuICAgICAgICAgIHJldHVybiBkZXN0aW5hdGlvbi5wdXNoKGVuZFNlZ21lbnRUYWJsZSk7XG4gICAgICAgIGNhc2UgSFRNTF9UQUJMRV9CT0RZX01PREU6XG4gICAgICAgICAgcmV0dXJuIGRlc3RpbmF0aW9uLnB1c2goZW5kU2VnbWVudFRhYmxlQm9keSk7XG4gICAgICAgIGNhc2UgSFRNTF9UQUJMRV9ST1dfTU9ERTpcbiAgICAgICAgICByZXR1cm4gZGVzdGluYXRpb24ucHVzaChlbmRTZWdtZW50VGFibGVSb3cpO1xuICAgICAgICBjYXNlIEhUTUxfQ09MR1JPVVBfTU9ERTpcbiAgICAgICAgICByZXR1cm4gZGVzdGluYXRpb24ucHVzaChlbmRTZWdtZW50Q29sR3JvdXApO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IEVycm9yKFwiVW5rbm93biBpbnNlcnRpb24gbW9kZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVzY2FwZUpTU3RyaW5nc0Zvckluc3RydWN0aW9uU2NyaXB0cyhpbnB1dCkge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGlucHV0KS5yZXBsYWNlKFxuICAgICAgICByZWdleEZvckpTU3RyaW5nc0luSW5zdHJ1Y3Rpb25TY3JpcHRzLFxuICAgICAgICBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgICBzd2l0Y2ggKG1hdGNoKSB7XG4gICAgICAgICAgICBjYXNlIFwiPFwiOlxuICAgICAgICAgICAgICByZXR1cm4gXCJcXFxcdTAwM2NcIjtcbiAgICAgICAgICAgIGNhc2UgXCJcXHUyMDI4XCI6XG4gICAgICAgICAgICAgIHJldHVybiBcIlxcXFx1MjAyOFwiO1xuICAgICAgICAgICAgY2FzZSBcIlxcdTIwMjlcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIFwiXFxcXHUyMDI5XCI7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICBcImVzY2FwZUpTU3RyaW5nc0Zvckluc3RydWN0aW9uU2NyaXB0cyBlbmNvdW50ZXJlZCBhIG1hdGNoIGl0IGRvZXMgbm90IGtub3cgaG93IHRvIHJlcGxhY2UuIHRoaXMgbWVhbnMgdGhlIG1hdGNoIHJlZ2V4IGFuZCB0aGUgcmVwbGFjZW1lbnQgY2hhcmFjdGVycyBhcmUgbm8gbG9uZ2VyIGluIHN5bmMuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3RcIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZXNjYXBlSlNPYmplY3RGb3JJbnN0cnVjdGlvblNjcmlwdHMoaW5wdXQpIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShpbnB1dCkucmVwbGFjZShcbiAgICAgICAgcmVnZXhGb3JKU1N0cmluZ3NJblNjcmlwdHMsXG4gICAgICAgIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICAgIHN3aXRjaCAobWF0Y2gpIHtcbiAgICAgICAgICAgIGNhc2UgXCImXCI6XG4gICAgICAgICAgICAgIHJldHVybiBcIlxcXFx1MDAyNlwiO1xuICAgICAgICAgICAgY2FzZSBcIj5cIjpcbiAgICAgICAgICAgICAgcmV0dXJuIFwiXFxcXHUwMDNlXCI7XG4gICAgICAgICAgICBjYXNlIFwiPFwiOlxuICAgICAgICAgICAgICByZXR1cm4gXCJcXFxcdTAwM2NcIjtcbiAgICAgICAgICAgIGNhc2UgXCJcXHUyMDI4XCI6XG4gICAgICAgICAgICAgIHJldHVybiBcIlxcXFx1MjAyOFwiO1xuICAgICAgICAgICAgY2FzZSBcIlxcdTIwMjlcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIFwiXFxcXHUyMDI5XCI7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICBcImVzY2FwZUpTT2JqZWN0Rm9ySW5zdHJ1Y3Rpb25TY3JpcHRzIGVuY291bnRlcmVkIGEgbWF0Y2ggaXQgZG9lcyBub3Qga25vdyBob3cgdG8gcmVwbGFjZS4gdGhpcyBtZWFucyB0aGUgbWF0Y2ggcmVnZXggYW5kIHRoZSByZXBsYWNlbWVudCBjaGFyYWN0ZXJzIGFyZSBubyBsb25nZXIgaW4gc3luYy4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdFwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmbHVzaFN0eWxlVGFnc0xhdGVGb3JCb3VuZGFyeShzdHlsZVF1ZXVlKSB7XG4gICAgICB2YXIgcnVsZXMgPSBzdHlsZVF1ZXVlLnJ1bGVzLFxuICAgICAgICBocmVmcyA9IHN0eWxlUXVldWUuaHJlZnM7XG4gICAgICAwIDwgcnVsZXMubGVuZ3RoICYmXG4gICAgICAgIDAgPT09IGhyZWZzLmxlbmd0aCAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiUmVhY3QgZXhwZWN0ZWQgdG8gaGF2ZSBhdCBsZWFzdCBvbmUgaHJlZiBmb3IgYW4gYSBob2lzdGFibGUgc3R5bGUgYnV0IGZvdW5kIG5vbmUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgKTtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIGlmIChocmVmcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5wdXNoKGN1cnJlbnRseUZsdXNoaW5nUmVuZGVyU3RhdGUuc3RhcnRJbmxpbmVTdHlsZSk7XG4gICAgICAgIHRoaXMucHVzaChsYXRlU3R5bGVUYWdSZXNvdXJjZU9wZW4xKTtcbiAgICAgICAgdGhpcy5wdXNoKHN0eWxlUXVldWUucHJlY2VkZW5jZSk7XG4gICAgICAgIGZvciAodGhpcy5wdXNoKGxhdGVTdHlsZVRhZ1Jlc291cmNlT3BlbjIpOyBpIDwgaHJlZnMubGVuZ3RoIC0gMTsgaSsrKVxuICAgICAgICAgIHRoaXMucHVzaChocmVmc1tpXSksIHRoaXMucHVzaChzcGFjZVNlcGFyYXRvcik7XG4gICAgICAgIHRoaXMucHVzaChocmVmc1tpXSk7XG4gICAgICAgIHRoaXMucHVzaChsYXRlU3R5bGVUYWdSZXNvdXJjZU9wZW4zKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSsrKSB0aGlzLnB1c2gocnVsZXNbaV0pO1xuICAgICAgICBkZXN0aW5hdGlvbkhhc0NhcGFjaXR5ID0gdGhpcy5wdXNoKGxhdGVTdHlsZVRhZ1RlbXBsYXRlQ2xvc2UpO1xuICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdCb3VuZGFyeUhhc1N0eWxlc1RvSG9pc3QgPSAhMDtcbiAgICAgICAgcnVsZXMubGVuZ3RoID0gMDtcbiAgICAgICAgaHJlZnMubGVuZ3RoID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaGFzU3R5bGVzVG9Ib2lzdChzdHlsZXNoZWV0KSB7XG4gICAgICByZXR1cm4gc3R5bGVzaGVldC5zdGF0ZSAhPT0gUFJFQU1CTEVcbiAgICAgICAgPyAoY3VycmVudGx5UmVuZGVyaW5nQm91bmRhcnlIYXNTdHlsZXNUb0hvaXN0ID0gITApXG4gICAgICAgIDogITE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdyaXRlSG9pc3RhYmxlc0ZvckJvdW5kYXJ5KFxuICAgICAgZGVzdGluYXRpb24sXG4gICAgICBob2lzdGFibGVTdGF0ZSxcbiAgICAgIHJlbmRlclN0YXRlXG4gICAgKSB7XG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdCb3VuZGFyeUhhc1N0eWxlc1RvSG9pc3QgPSAhMTtcbiAgICAgIGRlc3RpbmF0aW9uSGFzQ2FwYWNpdHkgPSAhMDtcbiAgICAgIGN1cnJlbnRseUZsdXNoaW5nUmVuZGVyU3RhdGUgPSByZW5kZXJTdGF0ZTtcbiAgICAgIGhvaXN0YWJsZVN0YXRlLnN0eWxlcy5mb3JFYWNoKGZsdXNoU3R5bGVUYWdzTGF0ZUZvckJvdW5kYXJ5LCBkZXN0aW5hdGlvbik7XG4gICAgICBjdXJyZW50bHlGbHVzaGluZ1JlbmRlclN0YXRlID0gbnVsbDtcbiAgICAgIGhvaXN0YWJsZVN0YXRlLnN0eWxlc2hlZXRzLmZvckVhY2goaGFzU3R5bGVzVG9Ib2lzdCk7XG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdCb3VuZGFyeUhhc1N0eWxlc1RvSG9pc3QgJiZcbiAgICAgICAgKHJlbmRlclN0YXRlLnN0eWxlc1RvSG9pc3QgPSAhMCk7XG4gICAgICByZXR1cm4gZGVzdGluYXRpb25IYXNDYXBhY2l0eTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmx1c2hSZXNvdXJjZShyZXNvdXJjZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXNvdXJjZS5sZW5ndGg7IGkrKykgdGhpcy5wdXNoKHJlc291cmNlW2ldKTtcbiAgICAgIHJlc291cmNlLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZsdXNoU3R5bGVJblByZWFtYmxlKHN0eWxlc2hlZXQpIHtcbiAgICAgIHB1c2hMaW5rSW1wbChzdHlsZXNoZWV0Rmx1c2hpbmdRdWV1ZSwgc3R5bGVzaGVldC5wcm9wcyk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlc2hlZXRGbHVzaGluZ1F1ZXVlLmxlbmd0aDsgaSsrKVxuICAgICAgICB0aGlzLnB1c2goc3R5bGVzaGVldEZsdXNoaW5nUXVldWVbaV0pO1xuICAgICAgc3R5bGVzaGVldEZsdXNoaW5nUXVldWUubGVuZ3RoID0gMDtcbiAgICAgIHN0eWxlc2hlZXQuc3RhdGUgPSBQUkVBTUJMRTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmx1c2hTdHlsZXNJblByZWFtYmxlKHN0eWxlUXVldWUpIHtcbiAgICAgIHZhciBoYXNTdHlsZXNoZWV0cyA9IDAgPCBzdHlsZVF1ZXVlLnNoZWV0cy5zaXplO1xuICAgICAgc3R5bGVRdWV1ZS5zaGVldHMuZm9yRWFjaChmbHVzaFN0eWxlSW5QcmVhbWJsZSwgdGhpcyk7XG4gICAgICBzdHlsZVF1ZXVlLnNoZWV0cy5jbGVhcigpO1xuICAgICAgdmFyIHJ1bGVzID0gc3R5bGVRdWV1ZS5ydWxlcyxcbiAgICAgICAgaHJlZnMgPSBzdHlsZVF1ZXVlLmhyZWZzO1xuICAgICAgaWYgKCFoYXNTdHlsZXNoZWV0cyB8fCBocmVmcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5wdXNoKGN1cnJlbnRseUZsdXNoaW5nUmVuZGVyU3RhdGUuc3RhcnRJbmxpbmVTdHlsZSk7XG4gICAgICAgIHRoaXMucHVzaChzdHlsZVRhZ1Jlc291cmNlT3BlbjEpO1xuICAgICAgICB0aGlzLnB1c2goc3R5bGVRdWV1ZS5wcmVjZWRlbmNlKTtcbiAgICAgICAgc3R5bGVRdWV1ZSA9IDA7XG4gICAgICAgIGlmIChocmVmcy5sZW5ndGgpIHtcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgdGhpcy5wdXNoKHN0eWxlVGFnUmVzb3VyY2VPcGVuMik7XG4gICAgICAgICAgICBzdHlsZVF1ZXVlIDwgaHJlZnMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHN0eWxlUXVldWUrK1xuICAgICAgICAgIClcbiAgICAgICAgICAgIHRoaXMucHVzaChocmVmc1tzdHlsZVF1ZXVlXSksIHRoaXMucHVzaChzcGFjZVNlcGFyYXRvcik7XG4gICAgICAgICAgdGhpcy5wdXNoKGhyZWZzW3N0eWxlUXVldWVdKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnB1c2goc3R5bGVUYWdSZXNvdXJjZU9wZW4zKTtcbiAgICAgICAgZm9yIChzdHlsZVF1ZXVlID0gMDsgc3R5bGVRdWV1ZSA8IHJ1bGVzLmxlbmd0aDsgc3R5bGVRdWV1ZSsrKVxuICAgICAgICAgIHRoaXMucHVzaChydWxlc1tzdHlsZVF1ZXVlXSk7XG4gICAgICAgIHRoaXMucHVzaChzdHlsZVRhZ1Jlc291cmNlQ2xvc2UpO1xuICAgICAgICBydWxlcy5sZW5ndGggPSAwO1xuICAgICAgICBocmVmcy5sZW5ndGggPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwcmVsb2FkTGF0ZVN0eWxlKHN0eWxlc2hlZXQpIHtcbiAgICAgIGlmIChzdHlsZXNoZWV0LnN0YXRlID09PSBQRU5ESU5HJDEpIHtcbiAgICAgICAgc3R5bGVzaGVldC5zdGF0ZSA9IFBSRUxPQURFRDtcbiAgICAgICAgdmFyIHByb3BzID0gc3R5bGVzaGVldC5wcm9wcztcbiAgICAgICAgcHVzaExpbmtJbXBsKHN0eWxlc2hlZXRGbHVzaGluZ1F1ZXVlLCB7XG4gICAgICAgICAgcmVsOiBcInByZWxvYWRcIixcbiAgICAgICAgICBhczogXCJzdHlsZVwiLFxuICAgICAgICAgIGhyZWY6IHN0eWxlc2hlZXQucHJvcHMuaHJlZixcbiAgICAgICAgICBjcm9zc09yaWdpbjogcHJvcHMuY3Jvc3NPcmlnaW4sXG4gICAgICAgICAgZmV0Y2hQcmlvcml0eTogcHJvcHMuZmV0Y2hQcmlvcml0eSxcbiAgICAgICAgICBpbnRlZ3JpdHk6IHByb3BzLmludGVncml0eSxcbiAgICAgICAgICBtZWRpYTogcHJvcHMubWVkaWEsXG4gICAgICAgICAgaHJlZkxhbmc6IHByb3BzLmhyZWZMYW5nLFxuICAgICAgICAgIHJlZmVycmVyUG9saWN5OiBwcm9wcy5yZWZlcnJlclBvbGljeVxuICAgICAgICB9KTtcbiAgICAgICAgZm9yIChcbiAgICAgICAgICBzdHlsZXNoZWV0ID0gMDtcbiAgICAgICAgICBzdHlsZXNoZWV0IDwgc3R5bGVzaGVldEZsdXNoaW5nUXVldWUubGVuZ3RoO1xuICAgICAgICAgIHN0eWxlc2hlZXQrK1xuICAgICAgICApXG4gICAgICAgICAgdGhpcy5wdXNoKHN0eWxlc2hlZXRGbHVzaGluZ1F1ZXVlW3N0eWxlc2hlZXRdKTtcbiAgICAgICAgc3R5bGVzaGVldEZsdXNoaW5nUXVldWUubGVuZ3RoID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcHJlbG9hZExhdGVTdHlsZXMoc3R5bGVRdWV1ZSkge1xuICAgICAgc3R5bGVRdWV1ZS5zaGVldHMuZm9yRWFjaChwcmVsb2FkTGF0ZVN0eWxlLCB0aGlzKTtcbiAgICAgIHN0eWxlUXVldWUuc2hlZXRzLmNsZWFyKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hDb21wbGV0ZWRTaGVsbElkQXR0cmlidXRlKHRhcmdldCwgcmVzdW1hYmxlU3RhdGUpIHtcbiAgICAgIChyZXN1bWFibGVTdGF0ZS5pbnN0cnVjdGlvbnMgJiBTZW50Q29tcGxldGVkU2hlbGxJZCkgPT09IE5vdGhpbmdTZW50ICYmXG4gICAgICAgICgocmVzdW1hYmxlU3RhdGUuaW5zdHJ1Y3Rpb25zIHw9IFNlbnRDb21wbGV0ZWRTaGVsbElkKSxcbiAgICAgICAgdGFyZ2V0LnB1c2goXG4gICAgICAgICAgY29tcGxldGVkU2hlbGxJZEF0dHJpYnV0ZVN0YXJ0LFxuICAgICAgICAgIGVzY2FwZVRleHRGb3JCcm93c2VyKFwiX1wiICsgcmVzdW1hYmxlU3RhdGUuaWRQcmVmaXggKyBcIlJfXCIpLFxuICAgICAgICAgIGF0dHJpYnV0ZUVuZFxuICAgICAgICApKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd3JpdGVTdHlsZVJlc291cmNlRGVwZW5kZW5jaWVzSW5KUyhkZXN0aW5hdGlvbiwgaG9pc3RhYmxlU3RhdGUpIHtcbiAgICAgIGRlc3RpbmF0aW9uLnB1c2goYXJyYXlGaXJzdE9wZW5CcmFja2V0KTtcbiAgICAgIHZhciBuZXh0QXJyYXlPcGVuQnJhY2tDaHVuayA9IGFycmF5Rmlyc3RPcGVuQnJhY2tldDtcbiAgICAgIGhvaXN0YWJsZVN0YXRlLnN0eWxlc2hlZXRzLmZvckVhY2goZnVuY3Rpb24gKHJlc291cmNlKSB7XG4gICAgICAgIGlmIChyZXNvdXJjZS5zdGF0ZSAhPT0gUFJFQU1CTEUpXG4gICAgICAgICAgaWYgKHJlc291cmNlLnN0YXRlID09PSBMQVRFKVxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChuZXh0QXJyYXlPcGVuQnJhY2tDaHVuayksXG4gICAgICAgICAgICAgIChyZXNvdXJjZSA9IHJlc291cmNlLnByb3BzLmhyZWYpLFxuICAgICAgICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHJlc291cmNlLCBcImhyZWZcIiksXG4gICAgICAgICAgICAgIChyZXNvdXJjZSA9IGVzY2FwZUpTT2JqZWN0Rm9ySW5zdHJ1Y3Rpb25TY3JpcHRzKFwiXCIgKyByZXNvdXJjZSkpLFxuICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKHJlc291cmNlKSxcbiAgICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChhcnJheUNsb3NlQnJhY2tldCksXG4gICAgICAgICAgICAgIChuZXh0QXJyYXlPcGVuQnJhY2tDaHVuayA9IGFycmF5U3Vic2VxdWVudE9wZW5CcmFja2V0KTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2gobmV4dEFycmF5T3BlbkJyYWNrQ2h1bmspO1xuICAgICAgICAgICAgdmFyIHByZWNlZGVuY2UgPSByZXNvdXJjZS5wcm9wc1tcImRhdGEtcHJlY2VkZW5jZVwiXSxcbiAgICAgICAgICAgICAgcHJvcHMgPSByZXNvdXJjZS5wcm9wcyxcbiAgICAgICAgICAgICAgY29lcmNlZEhyZWYgPSBzYW5pdGl6ZVVSTChcIlwiICsgcmVzb3VyY2UucHJvcHMuaHJlZik7XG4gICAgICAgICAgICBjb2VyY2VkSHJlZiA9IGVzY2FwZUpTT2JqZWN0Rm9ySW5zdHJ1Y3Rpb25TY3JpcHRzKGNvZXJjZWRIcmVmKTtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2goY29lcmNlZEhyZWYpO1xuICAgICAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbihwcmVjZWRlbmNlLCBcInByZWNlZGVuY2VcIik7XG4gICAgICAgICAgICBwcmVjZWRlbmNlID0gXCJcIiArIHByZWNlZGVuY2U7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKGFycmF5SW50ZXJzdGl0aWFsKTtcbiAgICAgICAgICAgIHByZWNlZGVuY2UgPSBlc2NhcGVKU09iamVjdEZvckluc3RydWN0aW9uU2NyaXB0cyhwcmVjZWRlbmNlKTtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2gocHJlY2VkZW5jZSk7XG4gICAgICAgICAgICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKVxuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkgJiZcbiAgICAgICAgICAgICAgICAoKHByZWNlZGVuY2UgPSBwcm9wc1twcm9wS2V5XSksIG51bGwgIT0gcHJlY2VkZW5jZSlcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImhyZWZcIjpcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJyZWxcIjpcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJwcmVjZWRlbmNlXCI6XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZGF0YS1wcmVjZWRlbmNlXCI6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgXCJsaW5rIGlzIGEgc2VsZi1jbG9zaW5nIHRhZyBhbmQgbXVzdCBuZWl0aGVyIGhhdmUgYGNoaWxkcmVuYCBub3IgdXNlIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuXCJcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlU3R5bGVSZXNvdXJjZUF0dHJpYnV0ZUluSlMoXG4gICAgICAgICAgICAgICAgICAgICAgZGVzdGluYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcEtleSxcbiAgICAgICAgICAgICAgICAgICAgICBwcmVjZWRlbmNlXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChhcnJheUNsb3NlQnJhY2tldCk7XG4gICAgICAgICAgICBuZXh0QXJyYXlPcGVuQnJhY2tDaHVuayA9IGFycmF5U3Vic2VxdWVudE9wZW5CcmFja2V0O1xuICAgICAgICAgICAgcmVzb3VyY2Uuc3RhdGUgPSBMQVRFO1xuICAgICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZGVzdGluYXRpb24ucHVzaChhcnJheUNsb3NlQnJhY2tldCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdyaXRlU3R5bGVSZXNvdXJjZUF0dHJpYnV0ZUluSlMoZGVzdGluYXRpb24sIG5hbWUsIHZhbHVlKSB7XG4gICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICBjYXNlIFwic3ltYm9sXCI6XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgIGNhc2UgXCJpbm5lckhUTUxcIjpcbiAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgIGNhc2UgXCJzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmdcIjpcbiAgICAgICAgY2FzZSBcInN1cHByZXNzSHlkcmF0aW9uV2FybmluZ1wiOlxuICAgICAgICBjYXNlIFwic3R5bGVcIjpcbiAgICAgICAgY2FzZSBcInJlZlwiOlxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSBcImNsYXNzTmFtZVwiOlxuICAgICAgICAgIGF0dHJpYnV0ZU5hbWUgPSBcImNsYXNzXCI7XG4gICAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbih2YWx1ZSwgYXR0cmlidXRlTmFtZSk7XG4gICAgICAgICAgbmFtZSA9IFwiXCIgKyB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImhpZGRlblwiOlxuICAgICAgICAgIGlmICghMSA9PT0gdmFsdWUpIHJldHVybjtcbiAgICAgICAgICBuYW1lID0gXCJcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInNyY1wiOlxuICAgICAgICBjYXNlIFwiaHJlZlwiOlxuICAgICAgICAgIHZhbHVlID0gc2FuaXRpemVVUkwodmFsdWUpO1xuICAgICAgICAgIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24odmFsdWUsIGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICAgIG5hbWUgPSBcIlwiICsgdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKDIgPCBuYW1lLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAoXCJvXCIgPT09IG5hbWVbMF0gfHwgXCJPXCIgPT09IG5hbWVbMF0pICYmXG4gICAgICAgICAgICAgIChcIm5cIiA9PT0gbmFtZVsxXSB8fCBcIk5cIiA9PT0gbmFtZVsxXSkpIHx8XG4gICAgICAgICAgICAhaXNBdHRyaWJ1dGVOYW1lU2FmZShuYW1lKVxuICAgICAgICAgIClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlLCBhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgICBuYW1lID0gXCJcIiArIHZhbHVlO1xuICAgICAgfVxuICAgICAgZGVzdGluYXRpb24ucHVzaChhcnJheUludGVyc3RpdGlhbCk7XG4gICAgICBhdHRyaWJ1dGVOYW1lID0gZXNjYXBlSlNPYmplY3RGb3JJbnN0cnVjdGlvblNjcmlwdHMoYXR0cmlidXRlTmFtZSk7XG4gICAgICBkZXN0aW5hdGlvbi5wdXNoKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgZGVzdGluYXRpb24ucHVzaChhcnJheUludGVyc3RpdGlhbCk7XG4gICAgICBhdHRyaWJ1dGVOYW1lID0gZXNjYXBlSlNPYmplY3RGb3JJbnN0cnVjdGlvblNjcmlwdHMobmFtZSk7XG4gICAgICBkZXN0aW5hdGlvbi5wdXNoKGF0dHJpYnV0ZU5hbWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVIb2lzdGFibGVTdGF0ZSgpIHtcbiAgICAgIHJldHVybiB7IHN0eWxlczogbmV3IFNldCgpLCBzdHlsZXNoZWV0czogbmV3IFNldCgpLCBzdXNwZW5zZXlJbWFnZXM6ICExIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByZWxvYWRCb290c3RyYXBTY3JpcHRPck1vZHVsZShcbiAgICAgIHJlc3VtYWJsZVN0YXRlLFxuICAgICAgcmVuZGVyU3RhdGUsXG4gICAgICBocmVmLFxuICAgICAgcHJvcHNcbiAgICApIHtcbiAgICAgIChyZXN1bWFibGVTdGF0ZS5zY3JpcHRSZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoaHJlZikgfHxcbiAgICAgICAgcmVzdW1hYmxlU3RhdGUubW9kdWxlU2NyaXB0UmVzb3VyY2VzLmhhc093blByb3BlcnR5KGhyZWYpKSAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICdJbnRlcm5hbCBSZWFjdCBFcnJvcjogUmVhY3QgZXhwZWN0ZWQgYm9vdHN0cmFwIHNjcmlwdCBvciBtb2R1bGUgd2l0aCBzcmMgXCIlc1wiIHRvIG5vdCBoYXZlIGJlZW4gcHJlbG9hZGVkIGFscmVhZHkuIHBsZWFzZSBmaWxlIGFuIGlzc3VlJyxcbiAgICAgICAgICBocmVmXG4gICAgICAgICk7XG4gICAgICByZXN1bWFibGVTdGF0ZS5zY3JpcHRSZXNvdXJjZXNbaHJlZl0gPSBFWElTVFM7XG4gICAgICByZXN1bWFibGVTdGF0ZS5tb2R1bGVTY3JpcHRSZXNvdXJjZXNbaHJlZl0gPSBFWElTVFM7XG4gICAgICByZXN1bWFibGVTdGF0ZSA9IFtdO1xuICAgICAgcHVzaExpbmtJbXBsKHJlc3VtYWJsZVN0YXRlLCBwcm9wcyk7XG4gICAgICByZW5kZXJTdGF0ZS5ib290c3RyYXBTY3JpcHRzLmFkZChyZXN1bWFibGVTdGF0ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkb3B0UHJlbG9hZENyZWRlbnRpYWxzKHRhcmdldCwgcHJlbG9hZFN0YXRlKSB7XG4gICAgICBudWxsID09IHRhcmdldC5jcm9zc09yaWdpbiAmJiAodGFyZ2V0LmNyb3NzT3JpZ2luID0gcHJlbG9hZFN0YXRlWzBdKTtcbiAgICAgIG51bGwgPT0gdGFyZ2V0LmludGVncml0eSAmJiAodGFyZ2V0LmludGVncml0eSA9IHByZWxvYWRTdGF0ZVsxXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFByZWxvYWRBc0hlYWRlcihocmVmLCBhcywgcGFyYW1zKSB7XG4gICAgICBocmVmID0gZXNjYXBlSHJlZkZvckxpbmtIZWFkZXJVUkxDb250ZXh0KGhyZWYpO1xuICAgICAgYXMgPSBlc2NhcGVTdHJpbmdGb3JMaW5rSGVhZGVyUXVvdGVkUGFyYW1WYWx1ZUNvbnRleHQoYXMsIFwiYXNcIik7XG4gICAgICBhcyA9IFwiPFwiICsgaHJlZiArICc+OyByZWw9cHJlbG9hZDsgYXM9XCInICsgYXMgKyAnXCInO1xuICAgICAgZm9yICh2YXIgcGFyYW1OYW1lIGluIHBhcmFtcylcbiAgICAgICAgaGFzT3duUHJvcGVydHkuY2FsbChwYXJhbXMsIHBhcmFtTmFtZSkgJiZcbiAgICAgICAgICAoKGhyZWYgPSBwYXJhbXNbcGFyYW1OYW1lXSksXG4gICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGhyZWYgJiZcbiAgICAgICAgICAgIChhcyArPVxuICAgICAgICAgICAgICBcIjsgXCIgK1xuICAgICAgICAgICAgICBwYXJhbU5hbWUudG9Mb3dlckNhc2UoKSArXG4gICAgICAgICAgICAgICc9XCInICtcbiAgICAgICAgICAgICAgZXNjYXBlU3RyaW5nRm9yTGlua0hlYWRlclF1b3RlZFBhcmFtVmFsdWVDb250ZXh0KFxuICAgICAgICAgICAgICAgIGhyZWYsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lXG4gICAgICAgICAgICAgICkgK1xuICAgICAgICAgICAgICAnXCInKSk7XG4gICAgICByZXR1cm4gYXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVzY2FwZUhyZWZGb3JMaW5rSGVhZGVyVVJMQ29udGV4dChocmVmSW5wdXQpIHtcbiAgICAgIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24oaHJlZklucHV0LCBcImhyZWZcIik7XG4gICAgICByZXR1cm4gKFwiXCIgKyBocmVmSW5wdXQpLnJlcGxhY2UoXG4gICAgICAgIHJlZ2V4Rm9ySHJlZkluTGlua0hlYWRlclVSTENvbnRleHQsXG4gICAgICAgIGVzY2FwZUhyZWZGb3JMaW5rSGVhZGVyVVJMQ29udGV4dFJlcGxhY2VyXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlc2NhcGVIcmVmRm9yTGlua0hlYWRlclVSTENvbnRleHRSZXBsYWNlcihtYXRjaCkge1xuICAgICAgc3dpdGNoIChtYXRjaCkge1xuICAgICAgICBjYXNlIFwiPFwiOlxuICAgICAgICAgIHJldHVybiBcIiUzQ1wiO1xuICAgICAgICBjYXNlIFwiPlwiOlxuICAgICAgICAgIHJldHVybiBcIiUzRVwiO1xuICAgICAgICBjYXNlIFwiXFxuXCI6XG4gICAgICAgICAgcmV0dXJuIFwiJTBBXCI7XG4gICAgICAgIGNhc2UgXCJcXHJcIjpcbiAgICAgICAgICByZXR1cm4gXCIlMERcIjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiZXNjYXBlTGlua0hyZWZGb3JIZWFkZXJDb250ZXh0UmVwbGFjZXIgZW5jb3VudGVyZWQgYSBtYXRjaCBpdCBkb2VzIG5vdCBrbm93IGhvdyB0byByZXBsYWNlLiB0aGlzIG1lYW5zIHRoZSBtYXRjaCByZWdleCBhbmQgdGhlIHJlcGxhY2VtZW50IGNoYXJhY3RlcnMgYXJlIG5vIGxvbmdlciBpbiBzeW5jLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0XCJcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBlc2NhcGVTdHJpbmdGb3JMaW5rSGVhZGVyUXVvdGVkUGFyYW1WYWx1ZUNvbnRleHQodmFsdWUsIG5hbWUpIHtcbiAgICAgIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSAmJlxuICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlRoZSBwcm92aWRlZCBgJXNgIG9wdGlvbiBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLiBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgdXNpbmcgaXQgaGVyZS5cIixcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIHR5cGVOYW1lKHZhbHVlKVxuICAgICAgICApLFxuICAgICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpKTtcbiAgICAgIHJldHVybiAoXCJcIiArIHZhbHVlKS5yZXBsYWNlKFxuICAgICAgICByZWdleEZvckxpbmtIZWFkZXJRdW90ZWRQYXJhbVZhbHVlQ29udGV4dCxcbiAgICAgICAgZXNjYXBlU3RyaW5nRm9yTGlua0hlYWRlclF1b3RlZFBhcmFtVmFsdWVDb250ZXh0UmVwbGFjZXJcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVzY2FwZVN0cmluZ0ZvckxpbmtIZWFkZXJRdW90ZWRQYXJhbVZhbHVlQ29udGV4dFJlcGxhY2VyKG1hdGNoKSB7XG4gICAgICBzd2l0Y2ggKG1hdGNoKSB7XG4gICAgICAgIGNhc2UgJ1wiJzpcbiAgICAgICAgICByZXR1cm4gXCIlMjJcIjtcbiAgICAgICAgY2FzZSBcIidcIjpcbiAgICAgICAgICByZXR1cm4gXCIlMjdcIjtcbiAgICAgICAgY2FzZSBcIjtcIjpcbiAgICAgICAgICByZXR1cm4gXCIlM0JcIjtcbiAgICAgICAgY2FzZSBcIixcIjpcbiAgICAgICAgICByZXR1cm4gXCIlMkNcIjtcbiAgICAgICAgY2FzZSBcIlxcblwiOlxuICAgICAgICAgIHJldHVybiBcIiUwQVwiO1xuICAgICAgICBjYXNlIFwiXFxyXCI6XG4gICAgICAgICAgcmV0dXJuIFwiJTBEXCI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcImVzY2FwZVN0cmluZ0ZvckxpbmtIZWFkZXJRdW90ZWRQYXJhbVZhbHVlQ29udGV4dFJlcGxhY2VyIGVuY291bnRlcmVkIGEgbWF0Y2ggaXQgZG9lcyBub3Qga25vdyBob3cgdG8gcmVwbGFjZS4gdGhpcyBtZWFucyB0aGUgbWF0Y2ggcmVnZXggYW5kIHRoZSByZXBsYWNlbWVudCBjaGFyYWN0ZXJzIGFyZSBubyBsb25nZXIgaW4gc3luYy4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdFwiXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaG9pc3RTdHlsZVF1ZXVlRGVwZW5kZW5jeShzdHlsZVF1ZXVlKSB7XG4gICAgICB0aGlzLnN0eWxlcy5hZGQoc3R5bGVRdWV1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhvaXN0U3R5bGVzaGVldERlcGVuZGVuY3koc3R5bGVzaGVldCkge1xuICAgICAgdGhpcy5zdHlsZXNoZWV0cy5hZGQoc3R5bGVzaGVldCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhvaXN0SG9pc3RhYmxlcyhwYXJlbnRTdGF0ZSwgY2hpbGRTdGF0ZSkge1xuICAgICAgY2hpbGRTdGF0ZS5zdHlsZXMuZm9yRWFjaChob2lzdFN0eWxlUXVldWVEZXBlbmRlbmN5LCBwYXJlbnRTdGF0ZSk7XG4gICAgICBjaGlsZFN0YXRlLnN0eWxlc2hlZXRzLmZvckVhY2goaG9pc3RTdHlsZXNoZWV0RGVwZW5kZW5jeSwgcGFyZW50U3RhdGUpO1xuICAgICAgY2hpbGRTdGF0ZS5zdXNwZW5zZXlJbWFnZXMgJiYgKHBhcmVudFN0YXRlLnN1c3BlbnNleUltYWdlcyA9ICEwKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlUmVuZGVyU3RhdGUocmVzdW1hYmxlU3RhdGUsIGdlbmVyYXRlU3RhdGljTWFya3VwKSB7XG4gICAgICB2YXIgaWRQcmVmaXggPSByZXN1bWFibGVTdGF0ZS5pZFByZWZpeCxcbiAgICAgICAgYm9vdHN0cmFwQ2h1bmtzID0gW10sXG4gICAgICAgIGJvb3RzdHJhcFNjcmlwdENvbnRlbnQgPSByZXN1bWFibGVTdGF0ZS5ib290c3RyYXBTY3JpcHRDb250ZW50LFxuICAgICAgICBib290c3RyYXBTY3JpcHRzID0gcmVzdW1hYmxlU3RhdGUuYm9vdHN0cmFwU2NyaXB0cyxcbiAgICAgICAgYm9vdHN0cmFwTW9kdWxlcyA9IHJlc3VtYWJsZVN0YXRlLmJvb3RzdHJhcE1vZHVsZXM7XG4gICAgICB2b2lkIDAgIT09IGJvb3RzdHJhcFNjcmlwdENvbnRlbnQgJiZcbiAgICAgICAgKGJvb3RzdHJhcENodW5rcy5wdXNoKFwiPHNjcmlwdFwiKSxcbiAgICAgICAgcHVzaENvbXBsZXRlZFNoZWxsSWRBdHRyaWJ1dGUoYm9vdHN0cmFwQ2h1bmtzLCByZXN1bWFibGVTdGF0ZSksXG4gICAgICAgIGJvb3RzdHJhcENodW5rcy5wdXNoKFxuICAgICAgICAgIGVuZE9mU3RhcnRUYWcsXG4gICAgICAgICAgZXNjYXBlRW50aXJlSW5saW5lU2NyaXB0Q29udGVudChib290c3RyYXBTY3JpcHRDb250ZW50KSxcbiAgICAgICAgICBlbmRJbmxpbmVTY3JpcHRcbiAgICAgICAgKSk7XG4gICAgICBpZFByZWZpeCA9IHtcbiAgICAgICAgcGxhY2Vob2xkZXJQcmVmaXg6IGlkUHJlZml4ICsgXCJQOlwiLFxuICAgICAgICBzZWdtZW50UHJlZml4OiBpZFByZWZpeCArIFwiUzpcIixcbiAgICAgICAgYm91bmRhcnlQcmVmaXg6IGlkUHJlZml4ICsgXCJCOlwiLFxuICAgICAgICBzdGFydElubGluZVNjcmlwdDogXCI8c2NyaXB0XCIsXG4gICAgICAgIHN0YXJ0SW5saW5lU3R5bGU6IFwiPHN0eWxlXCIsXG4gICAgICAgIHByZWFtYmxlOiB7IGh0bWxDaHVua3M6IG51bGwsIGhlYWRDaHVua3M6IG51bGwsIGJvZHlDaHVua3M6IG51bGwgfSxcbiAgICAgICAgZXh0ZXJuYWxSdW50aW1lU2NyaXB0OiBudWxsLFxuICAgICAgICBib290c3RyYXBDaHVua3M6IGJvb3RzdHJhcENodW5rcyxcbiAgICAgICAgaW1wb3J0TWFwQ2h1bmtzOiBbXSxcbiAgICAgICAgb25IZWFkZXJzOiB2b2lkIDAsXG4gICAgICAgIGhlYWRlcnM6IG51bGwsXG4gICAgICAgIHJlc2V0czoge1xuICAgICAgICAgIGZvbnQ6IHt9LFxuICAgICAgICAgIGRuczoge30sXG4gICAgICAgICAgY29ubmVjdDogeyBkZWZhdWx0OiB7fSwgYW5vbnltb3VzOiB7fSwgY3JlZGVudGlhbHM6IHt9IH0sXG4gICAgICAgICAgaW1hZ2U6IHt9LFxuICAgICAgICAgIHN0eWxlOiB7fVxuICAgICAgICB9LFxuICAgICAgICBjaGFyc2V0Q2h1bmtzOiBbXSxcbiAgICAgICAgdmlld3BvcnRDaHVua3M6IFtdLFxuICAgICAgICBob2lzdGFibGVDaHVua3M6IFtdLFxuICAgICAgICBwcmVjb25uZWN0czogbmV3IFNldCgpLFxuICAgICAgICBmb250UHJlbG9hZHM6IG5ldyBTZXQoKSxcbiAgICAgICAgaGlnaEltYWdlUHJlbG9hZHM6IG5ldyBTZXQoKSxcbiAgICAgICAgc3R5bGVzOiBuZXcgTWFwKCksXG4gICAgICAgIGJvb3RzdHJhcFNjcmlwdHM6IG5ldyBTZXQoKSxcbiAgICAgICAgc2NyaXB0czogbmV3IFNldCgpLFxuICAgICAgICBidWxrUHJlbG9hZHM6IG5ldyBTZXQoKSxcbiAgICAgICAgcHJlbG9hZHM6IHtcbiAgICAgICAgICBpbWFnZXM6IG5ldyBNYXAoKSxcbiAgICAgICAgICBzdHlsZXNoZWV0czogbmV3IE1hcCgpLFxuICAgICAgICAgIHNjcmlwdHM6IG5ldyBNYXAoKSxcbiAgICAgICAgICBtb2R1bGVTY3JpcHRzOiBuZXcgTWFwKClcbiAgICAgICAgfSxcbiAgICAgICAgbm9uY2U6IHsgc2NyaXB0OiB2b2lkIDAsIHN0eWxlOiB2b2lkIDAgfSxcbiAgICAgICAgaG9pc3RhYmxlU3RhdGU6IG51bGwsXG4gICAgICAgIHN0eWxlc1RvSG9pc3Q6ICExXG4gICAgICB9O1xuICAgICAgaWYgKHZvaWQgMCAhPT0gYm9vdHN0cmFwU2NyaXB0cylcbiAgICAgICAgZm9yIChcbiAgICAgICAgICBib290c3RyYXBTY3JpcHRDb250ZW50ID0gMDtcbiAgICAgICAgICBib290c3RyYXBTY3JpcHRDb250ZW50IDwgYm9vdHN0cmFwU2NyaXB0cy5sZW5ndGg7XG4gICAgICAgICAgYm9vdHN0cmFwU2NyaXB0Q29udGVudCsrXG4gICAgICAgICkge1xuICAgICAgICAgIHZhciBzY3JpcHRDb25maWcgPSBib290c3RyYXBTY3JpcHRzW2Jvb3RzdHJhcFNjcmlwdENvbnRlbnRdLFxuICAgICAgICAgICAgc3JjLFxuICAgICAgICAgICAgY3Jvc3NPcmlnaW4gPSB2b2lkIDAsXG4gICAgICAgICAgICBpbnRlZ3JpdHkgPSB2b2lkIDAsXG4gICAgICAgICAgICBwcm9wcyA9IHtcbiAgICAgICAgICAgICAgcmVsOiBcInByZWxvYWRcIixcbiAgICAgICAgICAgICAgYXM6IFwic2NyaXB0XCIsXG4gICAgICAgICAgICAgIGZldGNoUHJpb3JpdHk6IFwibG93XCIsXG4gICAgICAgICAgICAgIG5vbmNlOiB2b2lkIDBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHNjcmlwdENvbmZpZ1xuICAgICAgICAgICAgPyAocHJvcHMuaHJlZiA9IHNyYyA9IHNjcmlwdENvbmZpZylcbiAgICAgICAgICAgIDogKChwcm9wcy5ocmVmID0gc3JjID0gc2NyaXB0Q29uZmlnLnNyYyksXG4gICAgICAgICAgICAgIChwcm9wcy5pbnRlZ3JpdHkgPSBpbnRlZ3JpdHkgPVxuICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBzY3JpcHRDb25maWcuaW50ZWdyaXR5XG4gICAgICAgICAgICAgICAgICA/IHNjcmlwdENvbmZpZy5pbnRlZ3JpdHlcbiAgICAgICAgICAgICAgICAgIDogdm9pZCAwKSxcbiAgICAgICAgICAgICAgKHByb3BzLmNyb3NzT3JpZ2luID0gY3Jvc3NPcmlnaW4gPVxuICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBzY3JpcHRDb25maWcgfHxcbiAgICAgICAgICAgICAgICBudWxsID09IHNjcmlwdENvbmZpZy5jcm9zc09yaWdpblxuICAgICAgICAgICAgICAgICAgPyB2b2lkIDBcbiAgICAgICAgICAgICAgICAgIDogXCJ1c2UtY3JlZGVudGlhbHNcIiA9PT0gc2NyaXB0Q29uZmlnLmNyb3NzT3JpZ2luXG4gICAgICAgICAgICAgICAgICAgID8gXCJ1c2UtY3JlZGVudGlhbHNcIlxuICAgICAgICAgICAgICAgICAgICA6IFwiXCIpKTtcbiAgICAgICAgICBwcmVsb2FkQm9vdHN0cmFwU2NyaXB0T3JNb2R1bGUocmVzdW1hYmxlU3RhdGUsIGlkUHJlZml4LCBzcmMsIHByb3BzKTtcbiAgICAgICAgICBib290c3RyYXBDaHVua3MucHVzaChcbiAgICAgICAgICAgICc8c2NyaXB0IHNyYz1cIicsXG4gICAgICAgICAgICBlc2NhcGVUZXh0Rm9yQnJvd3NlcihzcmMpLFxuICAgICAgICAgICAgYXR0cmlidXRlRW5kXG4gICAgICAgICAgKTtcbiAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgaW50ZWdyaXR5ICYmXG4gICAgICAgICAgICBib290c3RyYXBDaHVua3MucHVzaChcbiAgICAgICAgICAgICAgJyBpbnRlZ3JpdHk9XCInLFxuICAgICAgICAgICAgICBlc2NhcGVUZXh0Rm9yQnJvd3NlcihpbnRlZ3JpdHkpLFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVFbmRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGNyb3NzT3JpZ2luICYmXG4gICAgICAgICAgICBib290c3RyYXBDaHVua3MucHVzaChcbiAgICAgICAgICAgICAgJyBjcm9zc29yaWdpbj1cIicsXG4gICAgICAgICAgICAgIGVzY2FwZVRleHRGb3JCcm93c2VyKGNyb3NzT3JpZ2luKSxcbiAgICAgICAgICAgICAgYXR0cmlidXRlRW5kXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHB1c2hDb21wbGV0ZWRTaGVsbElkQXR0cmlidXRlKGJvb3RzdHJhcENodW5rcywgcmVzdW1hYmxlU3RhdGUpO1xuICAgICAgICAgIGJvb3RzdHJhcENodW5rcy5wdXNoKCcgYXN5bmM9XCJcIj5cXHgzYy9zY3JpcHQ+Jyk7XG4gICAgICAgIH1cbiAgICAgIGlmICh2b2lkIDAgIT09IGJvb3RzdHJhcE1vZHVsZXMpXG4gICAgICAgIGZvciAoXG4gICAgICAgICAgYm9vdHN0cmFwU2NyaXB0cyA9IDA7XG4gICAgICAgICAgYm9vdHN0cmFwU2NyaXB0cyA8IGJvb3RzdHJhcE1vZHVsZXMubGVuZ3RoO1xuICAgICAgICAgIGJvb3RzdHJhcFNjcmlwdHMrK1xuICAgICAgICApXG4gICAgICAgICAgKGJvb3RzdHJhcFNjcmlwdENvbnRlbnQgPSBib290c3RyYXBNb2R1bGVzW2Jvb3RzdHJhcFNjcmlwdHNdKSxcbiAgICAgICAgICAgIChjcm9zc09yaWdpbiA9IHNyYyA9IHZvaWQgMCksXG4gICAgICAgICAgICAoaW50ZWdyaXR5ID0ge1xuICAgICAgICAgICAgICByZWw6IFwibW9kdWxlcHJlbG9hZFwiLFxuICAgICAgICAgICAgICBmZXRjaFByaW9yaXR5OiBcImxvd1wiLFxuICAgICAgICAgICAgICBub25jZTogdm9pZCAwXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBib290c3RyYXBTY3JpcHRDb250ZW50XG4gICAgICAgICAgICAgID8gKGludGVncml0eS5ocmVmID0gc2NyaXB0Q29uZmlnID0gYm9vdHN0cmFwU2NyaXB0Q29udGVudClcbiAgICAgICAgICAgICAgOiAoKGludGVncml0eS5ocmVmID0gc2NyaXB0Q29uZmlnID0gYm9vdHN0cmFwU2NyaXB0Q29udGVudC5zcmMpLFxuICAgICAgICAgICAgICAgIChpbnRlZ3JpdHkuaW50ZWdyaXR5ID0gY3Jvc3NPcmlnaW4gPVxuICAgICAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGJvb3RzdHJhcFNjcmlwdENvbnRlbnQuaW50ZWdyaXR5XG4gICAgICAgICAgICAgICAgICAgID8gYm9vdHN0cmFwU2NyaXB0Q29udGVudC5pbnRlZ3JpdHlcbiAgICAgICAgICAgICAgICAgICAgOiB2b2lkIDApLFxuICAgICAgICAgICAgICAgIChpbnRlZ3JpdHkuY3Jvc3NPcmlnaW4gPSBzcmMgPVxuICAgICAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGJvb3RzdHJhcFNjcmlwdENvbnRlbnQgfHxcbiAgICAgICAgICAgICAgICAgIG51bGwgPT0gYm9vdHN0cmFwU2NyaXB0Q29udGVudC5jcm9zc09yaWdpblxuICAgICAgICAgICAgICAgICAgICA/IHZvaWQgMFxuICAgICAgICAgICAgICAgICAgICA6IFwidXNlLWNyZWRlbnRpYWxzXCIgPT09IGJvb3RzdHJhcFNjcmlwdENvbnRlbnQuY3Jvc3NPcmlnaW5cbiAgICAgICAgICAgICAgICAgICAgICA/IFwidXNlLWNyZWRlbnRpYWxzXCJcbiAgICAgICAgICAgICAgICAgICAgICA6IFwiXCIpKSxcbiAgICAgICAgICAgIHByZWxvYWRCb290c3RyYXBTY3JpcHRPck1vZHVsZShcbiAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUsXG4gICAgICAgICAgICAgIGlkUHJlZml4LFxuICAgICAgICAgICAgICBzY3JpcHRDb25maWcsXG4gICAgICAgICAgICAgIGludGVncml0eVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGJvb3RzdHJhcENodW5rcy5wdXNoKFxuICAgICAgICAgICAgICAnPHNjcmlwdCB0eXBlPVwibW9kdWxlXCIgc3JjPVwiJyxcbiAgICAgICAgICAgICAgZXNjYXBlVGV4dEZvckJyb3dzZXIoc2NyaXB0Q29uZmlnKSxcbiAgICAgICAgICAgICAgYXR0cmlidXRlRW5kXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGNyb3NzT3JpZ2luICYmXG4gICAgICAgICAgICAgIGJvb3RzdHJhcENodW5rcy5wdXNoKFxuICAgICAgICAgICAgICAgICcgaW50ZWdyaXR5PVwiJyxcbiAgICAgICAgICAgICAgICBlc2NhcGVUZXh0Rm9yQnJvd3Nlcihjcm9zc09yaWdpbiksXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlRW5kXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2Ygc3JjICYmXG4gICAgICAgICAgICAgIGJvb3RzdHJhcENodW5rcy5wdXNoKFxuICAgICAgICAgICAgICAgICcgY3Jvc3NvcmlnaW49XCInLFxuICAgICAgICAgICAgICAgIGVzY2FwZVRleHRGb3JCcm93c2VyKHNyYyksXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlRW5kXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICBwdXNoQ29tcGxldGVkU2hlbGxJZEF0dHJpYnV0ZShib290c3RyYXBDaHVua3MsIHJlc3VtYWJsZVN0YXRlKSxcbiAgICAgICAgICAgIGJvb3RzdHJhcENodW5rcy5wdXNoKCcgYXN5bmM9XCJcIj5cXHgzYy9zY3JpcHQ+Jyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwbGFjZWhvbGRlclByZWZpeDogaWRQcmVmaXgucGxhY2Vob2xkZXJQcmVmaXgsXG4gICAgICAgIHNlZ21lbnRQcmVmaXg6IGlkUHJlZml4LnNlZ21lbnRQcmVmaXgsXG4gICAgICAgIGJvdW5kYXJ5UHJlZml4OiBpZFByZWZpeC5ib3VuZGFyeVByZWZpeCxcbiAgICAgICAgc3RhcnRJbmxpbmVTY3JpcHQ6IGlkUHJlZml4LnN0YXJ0SW5saW5lU2NyaXB0LFxuICAgICAgICBzdGFydElubGluZVN0eWxlOiBpZFByZWZpeC5zdGFydElubGluZVN0eWxlLFxuICAgICAgICBwcmVhbWJsZTogaWRQcmVmaXgucHJlYW1ibGUsXG4gICAgICAgIGV4dGVybmFsUnVudGltZVNjcmlwdDogaWRQcmVmaXguZXh0ZXJuYWxSdW50aW1lU2NyaXB0LFxuICAgICAgICBib290c3RyYXBDaHVua3M6IGlkUHJlZml4LmJvb3RzdHJhcENodW5rcyxcbiAgICAgICAgaW1wb3J0TWFwQ2h1bmtzOiBpZFByZWZpeC5pbXBvcnRNYXBDaHVua3MsXG4gICAgICAgIG9uSGVhZGVyczogaWRQcmVmaXgub25IZWFkZXJzLFxuICAgICAgICBoZWFkZXJzOiBpZFByZWZpeC5oZWFkZXJzLFxuICAgICAgICByZXNldHM6IGlkUHJlZml4LnJlc2V0cyxcbiAgICAgICAgY2hhcnNldENodW5rczogaWRQcmVmaXguY2hhcnNldENodW5rcyxcbiAgICAgICAgdmlld3BvcnRDaHVua3M6IGlkUHJlZml4LnZpZXdwb3J0Q2h1bmtzLFxuICAgICAgICBob2lzdGFibGVDaHVua3M6IGlkUHJlZml4LmhvaXN0YWJsZUNodW5rcyxcbiAgICAgICAgcHJlY29ubmVjdHM6IGlkUHJlZml4LnByZWNvbm5lY3RzLFxuICAgICAgICBmb250UHJlbG9hZHM6IGlkUHJlZml4LmZvbnRQcmVsb2FkcyxcbiAgICAgICAgaGlnaEltYWdlUHJlbG9hZHM6IGlkUHJlZml4LmhpZ2hJbWFnZVByZWxvYWRzLFxuICAgICAgICBzdHlsZXM6IGlkUHJlZml4LnN0eWxlcyxcbiAgICAgICAgYm9vdHN0cmFwU2NyaXB0czogaWRQcmVmaXguYm9vdHN0cmFwU2NyaXB0cyxcbiAgICAgICAgc2NyaXB0czogaWRQcmVmaXguc2NyaXB0cyxcbiAgICAgICAgYnVsa1ByZWxvYWRzOiBpZFByZWZpeC5idWxrUHJlbG9hZHMsXG4gICAgICAgIHByZWxvYWRzOiBpZFByZWZpeC5wcmVsb2FkcyxcbiAgICAgICAgbm9uY2U6IGlkUHJlZml4Lm5vbmNlLFxuICAgICAgICBzdHlsZXNUb0hvaXN0OiBpZFByZWZpeC5zdHlsZXNUb0hvaXN0LFxuICAgICAgICBnZW5lcmF0ZVN0YXRpY01hcmt1cDogZ2VuZXJhdGVTdGF0aWNNYXJrdXBcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hUZXh0SW5zdGFuY2UodGFyZ2V0LCB0ZXh0LCByZW5kZXJTdGF0ZSwgdGV4dEVtYmVkZGVkKSB7XG4gICAgICBpZiAocmVuZGVyU3RhdGUuZ2VuZXJhdGVTdGF0aWNNYXJrdXApXG4gICAgICAgIHJldHVybiB0YXJnZXQucHVzaChlc2NhcGVUZXh0Rm9yQnJvd3Nlcih0ZXh0KSksICExO1xuICAgICAgXCJcIiA9PT0gdGV4dFxuICAgICAgICA/ICh0YXJnZXQgPSB0ZXh0RW1iZWRkZWQpXG4gICAgICAgIDogKHRleHRFbWJlZGRlZCAmJiB0YXJnZXQucHVzaChcIlxceDNjIS0tIC0tXFx4M2VcIiksXG4gICAgICAgICAgdGFyZ2V0LnB1c2goZXNjYXBlVGV4dEZvckJyb3dzZXIodGV4dCkpLFxuICAgICAgICAgICh0YXJnZXQgPSAhMCkpO1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaFNlZ21lbnRGaW5hbGUoXG4gICAgICB0YXJnZXQsXG4gICAgICByZW5kZXJTdGF0ZSxcbiAgICAgIGxhc3RQdXNoZWRUZXh0LFxuICAgICAgdGV4dEVtYmVkZGVkXG4gICAgKSB7XG4gICAgICByZW5kZXJTdGF0ZS5nZW5lcmF0ZVN0YXRpY01hcmt1cCB8fFxuICAgICAgICAobGFzdFB1c2hlZFRleHQgJiYgdGV4dEVtYmVkZGVkICYmIHRhcmdldC5wdXNoKFwiXFx4M2MhLS0gLS1cXHgzZVwiKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB7XG4gICAgICBpZiAobnVsbCA9PSB0eXBlKSByZXR1cm4gbnVsbDtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlKVxuICAgICAgICByZXR1cm4gdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRVxuICAgICAgICAgID8gbnVsbFxuICAgICAgICAgIDogdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgdHlwZSkgcmV0dXJuIHR5cGU7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIkZyYWdtZW50XCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJQcm9maWxlclwiO1xuICAgICAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiU3RyaWN0TW9kZVwiO1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VMaXN0XCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfQUNUSVZJVFlfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJBY3Rpdml0eVwiO1xuICAgICAgfVxuICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiB0eXBlKVxuICAgICAgICBzd2l0Y2ggKFxuICAgICAgICAgIChcIm51bWJlclwiID09PSB0eXBlb2YgdHlwZS50YWcgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICB0eXBlLiQkdHlwZW9mKVxuICAgICAgICApIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIFwiUG9ydGFsXCI7XG4gICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIjtcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTlNVTUVSX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKHR5cGUuX2NvbnRleHQuZGlzcGxheU5hbWUgfHwgXCJDb250ZXh0XCIpICsgXCIuQ29uc3VtZXJcIjtcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICB2YXIgaW5uZXJUeXBlID0gdHlwZS5yZW5kZXI7XG4gICAgICAgICAgICB0eXBlID0gdHlwZS5kaXNwbGF5TmFtZTtcbiAgICAgICAgICAgIHR5cGUgfHxcbiAgICAgICAgICAgICAgKCh0eXBlID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8IFwiXCIpLFxuICAgICAgICAgICAgICAodHlwZSA9IFwiXCIgIT09IHR5cGUgPyBcIkZvcndhcmRSZWYoXCIgKyB0eXBlICsgXCIpXCIgOiBcIkZvcndhcmRSZWZcIikpO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAoaW5uZXJUeXBlID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsKSxcbiAgICAgICAgICAgICAgbnVsbCAhPT0gaW5uZXJUeXBlXG4gICAgICAgICAgICAgICAgPyBpbm5lclR5cGVcbiAgICAgICAgICAgICAgICA6IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8IFwiTWVtb1wiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgaW5uZXJUeXBlID0gdHlwZS5fcGF5bG9hZDtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLl9pbml0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKGlubmVyVHlwZSkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvcFRvTmVhcmVzdENvbW1vbkFuY2VzdG9yKHByZXYsIG5leHQpIHtcbiAgICAgIGlmIChwcmV2ICE9PSBuZXh0KSB7XG4gICAgICAgIHByZXYuY29udGV4dC5fY3VycmVudFZhbHVlMiA9IHByZXYucGFyZW50VmFsdWU7XG4gICAgICAgIHByZXYgPSBwcmV2LnBhcmVudDtcbiAgICAgICAgdmFyIHBhcmVudE5leHQgPSBuZXh0LnBhcmVudDtcbiAgICAgICAgaWYgKG51bGwgPT09IHByZXYpIHtcbiAgICAgICAgICBpZiAobnVsbCAhPT0gcGFyZW50TmV4dClcbiAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICBcIlRoZSBzdGFja3MgbXVzdCByZWFjaCB0aGUgcm9vdCBhdCB0aGUgc2FtZSB0aW1lLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChudWxsID09PSBwYXJlbnROZXh0KVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgIFwiVGhlIHN0YWNrcyBtdXN0IHJlYWNoIHRoZSByb290IGF0IHRoZSBzYW1lIHRpbWUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgcG9wVG9OZWFyZXN0Q29tbW9uQW5jZXN0b3IocHJldiwgcGFyZW50TmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dC5jb250ZXh0Ll9jdXJyZW50VmFsdWUyID0gbmV4dC52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcG9wQWxsUHJldmlvdXMocHJldikge1xuICAgICAgcHJldi5jb250ZXh0Ll9jdXJyZW50VmFsdWUyID0gcHJldi5wYXJlbnRWYWx1ZTtcbiAgICAgIHByZXYgPSBwcmV2LnBhcmVudDtcbiAgICAgIG51bGwgIT09IHByZXYgJiYgcG9wQWxsUHJldmlvdXMocHJldik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hBbGxOZXh0KG5leHQpIHtcbiAgICAgIHZhciBwYXJlbnROZXh0ID0gbmV4dC5wYXJlbnQ7XG4gICAgICBudWxsICE9PSBwYXJlbnROZXh0ICYmIHB1c2hBbGxOZXh0KHBhcmVudE5leHQpO1xuICAgICAgbmV4dC5jb250ZXh0Ll9jdXJyZW50VmFsdWUyID0gbmV4dC52YWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9wUHJldmlvdXNUb0NvbW1vbkxldmVsKHByZXYsIG5leHQpIHtcbiAgICAgIHByZXYuY29udGV4dC5fY3VycmVudFZhbHVlMiA9IHByZXYucGFyZW50VmFsdWU7XG4gICAgICBwcmV2ID0gcHJldi5wYXJlbnQ7XG4gICAgICBpZiAobnVsbCA9PT0gcHJldilcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJUaGUgZGVwdGggbXVzdCBlcXVhbCBhdCBsZWFzdCBhdCB6ZXJvIGJlZm9yZSByZWFjaGluZyB0aGUgcm9vdC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICApO1xuICAgICAgcHJldi5kZXB0aCA9PT0gbmV4dC5kZXB0aFxuICAgICAgICA/IHBvcFRvTmVhcmVzdENvbW1vbkFuY2VzdG9yKHByZXYsIG5leHQpXG4gICAgICAgIDogcG9wUHJldmlvdXNUb0NvbW1vbkxldmVsKHByZXYsIG5leHQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb3BOZXh0VG9Db21tb25MZXZlbChwcmV2LCBuZXh0KSB7XG4gICAgICB2YXIgcGFyZW50TmV4dCA9IG5leHQucGFyZW50O1xuICAgICAgaWYgKG51bGwgPT09IHBhcmVudE5leHQpXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiVGhlIGRlcHRoIG11c3QgZXF1YWwgYXQgbGVhc3QgYXQgemVybyBiZWZvcmUgcmVhY2hpbmcgdGhlIHJvb3QuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgKTtcbiAgICAgIHByZXYuZGVwdGggPT09IHBhcmVudE5leHQuZGVwdGhcbiAgICAgICAgPyBwb3BUb05lYXJlc3RDb21tb25BbmNlc3RvcihwcmV2LCBwYXJlbnROZXh0KVxuICAgICAgICA6IHBvcE5leHRUb0NvbW1vbkxldmVsKHByZXYsIHBhcmVudE5leHQpO1xuICAgICAgbmV4dC5jb250ZXh0Ll9jdXJyZW50VmFsdWUyID0gbmV4dC52YWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3dpdGNoQ29udGV4dChuZXdTbmFwc2hvdCkge1xuICAgICAgdmFyIHByZXYgPSBjdXJyZW50QWN0aXZlU25hcHNob3Q7XG4gICAgICBwcmV2ICE9PSBuZXdTbmFwc2hvdCAmJlxuICAgICAgICAobnVsbCA9PT0gcHJldlxuICAgICAgICAgID8gcHVzaEFsbE5leHQobmV3U25hcHNob3QpXG4gICAgICAgICAgOiBudWxsID09PSBuZXdTbmFwc2hvdFxuICAgICAgICAgICAgPyBwb3BBbGxQcmV2aW91cyhwcmV2KVxuICAgICAgICAgICAgOiBwcmV2LmRlcHRoID09PSBuZXdTbmFwc2hvdC5kZXB0aFxuICAgICAgICAgICAgICA/IHBvcFRvTmVhcmVzdENvbW1vbkFuY2VzdG9yKHByZXYsIG5ld1NuYXBzaG90KVxuICAgICAgICAgICAgICA6IHByZXYuZGVwdGggPiBuZXdTbmFwc2hvdC5kZXB0aFxuICAgICAgICAgICAgICAgID8gcG9wUHJldmlvdXNUb0NvbW1vbkxldmVsKHByZXYsIG5ld1NuYXBzaG90KVxuICAgICAgICAgICAgICAgIDogcG9wTmV4dFRvQ29tbW9uTGV2ZWwocHJldiwgbmV3U25hcHNob3QpLFxuICAgICAgICAoY3VycmVudEFjdGl2ZVNuYXBzaG90ID0gbmV3U25hcHNob3QpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrKSB7XG4gICAgICBpZiAobnVsbCAhPT0gY2FsbGJhY2sgJiYgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGtleSA9IFN0cmluZyhjYWxsYmFjayk7XG4gICAgICAgIGRpZFdhcm5PbkludmFsaWRDYWxsYmFjay5oYXMoa2V5KSB8fFxuICAgICAgICAgIChkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2suYWRkKGtleSksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiRXhwZWN0ZWQgdGhlIGxhc3Qgb3B0aW9uYWwgYGNhbGxiYWNrYCBhcmd1bWVudCB0byBiZSBhIGZ1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy5cIixcbiAgICAgICAgICAgIGNhbGxiYWNrXG4gICAgICAgICAgKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XG4gICAgICBwdWJsaWNJbnN0YW5jZSA9XG4gICAgICAgICgocHVibGljSW5zdGFuY2UgPSBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3RvcikgJiZcbiAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUocHVibGljSW5zdGFuY2UpKSB8fFxuICAgICAgICBcIlJlYWN0Q2xhc3NcIjtcbiAgICAgIHZhciB3YXJuaW5nS2V5ID0gcHVibGljSW5zdGFuY2UgKyBcIi5cIiArIGNhbGxlck5hbWU7XG4gICAgICBkaWRXYXJuQWJvdXROb29wVXBkYXRlRm9yQ29tcG9uZW50W3dhcm5pbmdLZXldIHx8XG4gICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiQ2FuIG9ubHkgdXBkYXRlIGEgbW91bnRpbmcgY29tcG9uZW50LiBUaGlzIHVzdWFsbHkgbWVhbnMgeW91IGNhbGxlZCAlcygpIG91dHNpZGUgY29tcG9uZW50V2lsbE1vdW50KCkgb24gdGhlIHNlcnZlci4gVGhpcyBpcyBhIG5vLW9wLlxcblxcblBsZWFzZSBjaGVjayB0aGUgY29kZSBmb3IgdGhlICVzIGNvbXBvbmVudC5cIixcbiAgICAgICAgICBjYWxsZXJOYW1lLFxuICAgICAgICAgIHB1YmxpY0luc3RhbmNlXG4gICAgICAgICksXG4gICAgICAgIChkaWRXYXJuQWJvdXROb29wVXBkYXRlRm9yQ29tcG9uZW50W3dhcm5pbmdLZXldID0gITApKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaFRyZWVDb250ZXh0KGJhc2VDb250ZXh0LCB0b3RhbENoaWxkcmVuLCBpbmRleCkge1xuICAgICAgdmFyIGJhc2VJZFdpdGhMZWFkaW5nQml0ID0gYmFzZUNvbnRleHQuaWQ7XG4gICAgICBiYXNlQ29udGV4dCA9IGJhc2VDb250ZXh0Lm92ZXJmbG93O1xuICAgICAgdmFyIGJhc2VMZW5ndGggPSAzMiAtIGNsejMyKGJhc2VJZFdpdGhMZWFkaW5nQml0KSAtIDE7XG4gICAgICBiYXNlSWRXaXRoTGVhZGluZ0JpdCAmPSB+KDEgPDwgYmFzZUxlbmd0aCk7XG4gICAgICBpbmRleCArPSAxO1xuICAgICAgdmFyIGxlbmd0aCA9IDMyIC0gY2x6MzIodG90YWxDaGlsZHJlbikgKyBiYXNlTGVuZ3RoO1xuICAgICAgaWYgKDMwIDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBudW1iZXJPZk92ZXJmbG93Qml0cyA9IGJhc2VMZW5ndGggLSAoYmFzZUxlbmd0aCAlIDUpO1xuICAgICAgICBsZW5ndGggPSAoXG4gICAgICAgICAgYmFzZUlkV2l0aExlYWRpbmdCaXQgJlxuICAgICAgICAgICgoMSA8PCBudW1iZXJPZk92ZXJmbG93Qml0cykgLSAxKVxuICAgICAgICApLnRvU3RyaW5nKDMyKTtcbiAgICAgICAgYmFzZUlkV2l0aExlYWRpbmdCaXQgPj49IG51bWJlck9mT3ZlcmZsb3dCaXRzO1xuICAgICAgICBiYXNlTGVuZ3RoIC09IG51bWJlck9mT3ZlcmZsb3dCaXRzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlkOlxuICAgICAgICAgICAgKDEgPDwgKDMyIC0gY2x6MzIodG90YWxDaGlsZHJlbikgKyBiYXNlTGVuZ3RoKSkgfFxuICAgICAgICAgICAgKGluZGV4IDw8IGJhc2VMZW5ndGgpIHxcbiAgICAgICAgICAgIGJhc2VJZFdpdGhMZWFkaW5nQml0LFxuICAgICAgICAgIG92ZXJmbG93OiBsZW5ndGggKyBiYXNlQ29udGV4dFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6ICgxIDw8IGxlbmd0aCkgfCAoaW5kZXggPDwgYmFzZUxlbmd0aCkgfCBiYXNlSWRXaXRoTGVhZGluZ0JpdCxcbiAgICAgICAgb3ZlcmZsb3c6IGJhc2VDb250ZXh0XG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbHozMkZhbGxiYWNrKHgpIHtcbiAgICAgIHggPj4+PSAwO1xuICAgICAgcmV0dXJuIDAgPT09IHggPyAzMiA6ICgzMSAtICgobG9nKHgpIC8gTE4yKSB8IDApKSB8IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vb3AoKSB7fVxuICAgIGZ1bmN0aW9uIHRyYWNrVXNlZFRoZW5hYmxlKHRoZW5hYmxlU3RhdGUsIHRoZW5hYmxlLCBpbmRleCkge1xuICAgICAgaW5kZXggPSB0aGVuYWJsZVN0YXRlW2luZGV4XTtcbiAgICAgIHZvaWQgMCA9PT0gaW5kZXhcbiAgICAgICAgPyB0aGVuYWJsZVN0YXRlLnB1c2godGhlbmFibGUpXG4gICAgICAgIDogaW5kZXggIT09IHRoZW5hYmxlICYmICh0aGVuYWJsZS50aGVuKG5vb3AsIG5vb3ApLCAodGhlbmFibGUgPSBpbmRleCkpO1xuICAgICAgc3dpdGNoICh0aGVuYWJsZS5zdGF0dXMpIHtcbiAgICAgICAgY2FzZSBcImZ1bGZpbGxlZFwiOlxuICAgICAgICAgIHJldHVybiB0aGVuYWJsZS52YWx1ZTtcbiAgICAgICAgY2FzZSBcInJlamVjdGVkXCI6XG4gICAgICAgICAgdGhyb3cgdGhlbmFibGUucmVhc29uO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiB0aGVuYWJsZS5zdGF0dXNcbiAgICAgICAgICAgID8gdGhlbmFibGUudGhlbihub29wLCBub29wKVxuICAgICAgICAgICAgOiAoKHRoZW5hYmxlU3RhdGUgPSB0aGVuYWJsZSksXG4gICAgICAgICAgICAgICh0aGVuYWJsZVN0YXRlLnN0YXR1cyA9IFwicGVuZGluZ1wiKSxcbiAgICAgICAgICAgICAgdGhlbmFibGVTdGF0ZS50aGVuKFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChmdWxmaWxsZWRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKFwicGVuZGluZ1wiID09PSB0aGVuYWJsZS5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZ1bGZpbGxlZFRoZW5hYmxlID0gdGhlbmFibGU7XG4gICAgICAgICAgICAgICAgICAgIGZ1bGZpbGxlZFRoZW5hYmxlLnN0YXR1cyA9IFwiZnVsZmlsbGVkXCI7XG4gICAgICAgICAgICAgICAgICAgIGZ1bGZpbGxlZFRoZW5hYmxlLnZhbHVlID0gZnVsZmlsbGVkVmFsdWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChcInBlbmRpbmdcIiA9PT0gdGhlbmFibGUuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWplY3RlZFRoZW5hYmxlID0gdGhlbmFibGU7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdGVkVGhlbmFibGUuc3RhdHVzID0gXCJyZWplY3RlZFwiO1xuICAgICAgICAgICAgICAgICAgICByZWplY3RlZFRoZW5hYmxlLnJlYXNvbiA9IGVycm9yO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgc3dpdGNoICh0aGVuYWJsZS5zdGF0dXMpIHtcbiAgICAgICAgICAgIGNhc2UgXCJmdWxmaWxsZWRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIHRoZW5hYmxlLnZhbHVlO1xuICAgICAgICAgICAgY2FzZSBcInJlamVjdGVkXCI6XG4gICAgICAgICAgICAgIHRocm93IHRoZW5hYmxlLnJlYXNvbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3VzcGVuZGVkVGhlbmFibGUgPSB0aGVuYWJsZTtcbiAgICAgICAgICB0aHJvdyBTdXNwZW5zZUV4Y2VwdGlvbjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0U3VzcGVuZGVkVGhlbmFibGUoKSB7XG4gICAgICBpZiAobnVsbCA9PT0gc3VzcGVuZGVkVGhlbmFibGUpXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiRXhwZWN0ZWQgYSBzdXNwZW5kZWQgdGhlbmFibGUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICk7XG4gICAgICB2YXIgdGhlbmFibGUgPSBzdXNwZW5kZWRUaGVuYWJsZTtcbiAgICAgIHN1c3BlbmRlZFRoZW5hYmxlID0gbnVsbDtcbiAgICAgIHJldHVybiB0aGVuYWJsZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXMoeCwgeSkge1xuICAgICAgcmV0dXJuICh4ID09PSB5ICYmICgwICE9PSB4IHx8IDEgLyB4ID09PSAxIC8geSkpIHx8ICh4ICE9PSB4ICYmIHkgIT09IHkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCkge1xuICAgICAgaWYgKG51bGwgPT09IGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudClcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJJbnZhbGlkIGhvb2sgY2FsbC4gSG9va3MgY2FuIG9ubHkgYmUgY2FsbGVkIGluc2lkZSBvZiB0aGUgYm9keSBvZiBhIGZ1bmN0aW9uIGNvbXBvbmVudC4gVGhpcyBjb3VsZCBoYXBwZW4gZm9yIG9uZSBvZiB0aGUgZm9sbG93aW5nIHJlYXNvbnM6XFxuMS4gWW91IG1pZ2h0IGhhdmUgbWlzbWF0Y2hpbmcgdmVyc2lvbnMgb2YgUmVhY3QgYW5kIHRoZSByZW5kZXJlciAoc3VjaCBhcyBSZWFjdCBET00pXFxuMi4gWW91IG1pZ2h0IGJlIGJyZWFraW5nIHRoZSBSdWxlcyBvZiBIb29rc1xcbjMuIFlvdSBtaWdodCBoYXZlIG1vcmUgdGhhbiBvbmUgY29weSBvZiBSZWFjdCBpbiB0aGUgc2FtZSBhcHBcXG5TZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9pbnZhbGlkLWhvb2stY2FsbCBmb3IgdGlwcyBhYm91dCBob3cgdG8gZGVidWcgYW5kIGZpeCB0aGlzIHByb2JsZW0uXCJcbiAgICAgICAgKTtcbiAgICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiRG8gbm90IGNhbGwgSG9va3MgaW5zaWRlIHVzZUVmZmVjdCguLi4pLCB1c2VNZW1vKC4uLiksIG9yIG90aGVyIGJ1aWx0LWluIEhvb2tzLiBZb3UgY2FuIG9ubHkgY2FsbCBIb29rcyBhdCB0aGUgdG9wIGxldmVsIG9mIHlvdXIgUmVhY3QgZnVuY3Rpb24uIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9ydWxlcy1vZi1ob29rc1wiXG4gICAgICAgICk7XG4gICAgICByZXR1cm4gY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVIb29rKCkge1xuICAgICAgaWYgKDAgPCBudW1iZXJPZlJlUmVuZGVycylcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJSZW5kZXJlZCBtb3JlIGhvb2tzIHRoYW4gZHVyaW5nIHRoZSBwcmV2aW91cyByZW5kZXJcIik7XG4gICAgICByZXR1cm4geyBtZW1vaXplZFN0YXRlOiBudWxsLCBxdWV1ZTogbnVsbCwgbmV4dDogbnVsbCB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKSB7XG4gICAgICBudWxsID09PSB3b3JrSW5Qcm9ncmVzc0hvb2tcbiAgICAgICAgPyBudWxsID09PSBmaXJzdFdvcmtJblByb2dyZXNzSG9va1xuICAgICAgICAgID8gKChpc1JlUmVuZGVyID0gITEpLFxuICAgICAgICAgICAgKGZpcnN0V29ya0luUHJvZ3Jlc3NIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rID0gY3JlYXRlSG9vaygpKSlcbiAgICAgICAgICA6ICgoaXNSZVJlbmRlciA9ICEwKSwgKHdvcmtJblByb2dyZXNzSG9vayA9IGZpcnN0V29ya0luUHJvZ3Jlc3NIb29rKSlcbiAgICAgICAgOiBudWxsID09PSB3b3JrSW5Qcm9ncmVzc0hvb2submV4dFxuICAgICAgICAgID8gKChpc1JlUmVuZGVyID0gITEpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vay5uZXh0ID0gY3JlYXRlSG9vaygpKSlcbiAgICAgICAgICA6ICgoaXNSZVJlbmRlciA9ICEwKSwgKHdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vay5uZXh0KSk7XG4gICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3NIb29rO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRUaGVuYWJsZVN0YXRlQWZ0ZXJTdXNwZW5kaW5nKCkge1xuICAgICAgdmFyIHN0YXRlID0gdGhlbmFibGVTdGF0ZTtcbiAgICAgIHRoZW5hYmxlU3RhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNldEhvb2tzU3RhdGUoKSB7XG4gICAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSAhMTtcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0tleVBhdGggPVxuICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdSZXF1ZXN0ID1cbiAgICAgICAgY3VycmVudGx5UmVuZGVyaW5nVGFzayA9XG4gICAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCA9XG4gICAgICAgICAgbnVsbDtcbiAgICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSAhMTtcbiAgICAgIGZpcnN0V29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcbiAgICAgIG51bWJlck9mUmVSZW5kZXJzID0gMDtcbiAgICAgIHdvcmtJblByb2dyZXNzSG9vayA9IHJlbmRlclBoYXNlVXBkYXRlcyA9IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlYWRDb250ZXh0KGNvbnRleHQpIHtcbiAgICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiQ29udGV4dCBjYW4gb25seSBiZSByZWFkIHdoaWxlIFJlYWN0IGlzIHJlbmRlcmluZy4gSW4gY2xhc3NlcywgeW91IGNhbiByZWFkIGl0IGluIHRoZSByZW5kZXIgbWV0aG9kIG9yIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4gSW4gZnVuY3Rpb24gY29tcG9uZW50cywgeW91IGNhbiByZWFkIGl0IGRpcmVjdGx5IGluIHRoZSBmdW5jdGlvbiBib2R5LCBidXQgbm90IGluc2lkZSBIb29rcyBsaWtlIHVzZVJlZHVjZXIoKSBvciB1c2VNZW1vKCkuXCJcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiBjb250ZXh0Ll9jdXJyZW50VmFsdWUyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBiYXNpY1N0YXRlUmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XG4gICAgICByZXR1cm4gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgYWN0aW9uID8gYWN0aW9uKHN0YXRlKSA6IGFjdGlvbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICByZWR1Y2VyICE9PSBiYXNpY1N0YXRlUmVkdWNlciAmJiAoY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVJlZHVjZXJcIik7XG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQgPSByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gICAgICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIGlmIChpc1JlUmVuZGVyKSB7XG4gICAgICAgIGluaXQgPSB3b3JrSW5Qcm9ncmVzc0hvb2sucXVldWU7XG4gICAgICAgIGluaXRpYWxBcmcgPSBpbml0LmRpc3BhdGNoO1xuICAgICAgICBpZiAobnVsbCAhPT0gcmVuZGVyUGhhc2VVcGRhdGVzKSB7XG4gICAgICAgICAgdmFyIGZpcnN0UmVuZGVyUGhhc2VVcGRhdGUgPSByZW5kZXJQaGFzZVVwZGF0ZXMuZ2V0KGluaXQpO1xuICAgICAgICAgIGlmICh2b2lkIDAgIT09IGZpcnN0UmVuZGVyUGhhc2VVcGRhdGUpIHtcbiAgICAgICAgICAgIHJlbmRlclBoYXNlVXBkYXRlcy5kZWxldGUoaW5pdCk7XG4gICAgICAgICAgICBpbml0ID0gd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHZhciBhY3Rpb24gPSBmaXJzdFJlbmRlclBoYXNlVXBkYXRlLmFjdGlvbjtcbiAgICAgICAgICAgICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gITA7XG4gICAgICAgICAgICAgIGluaXQgPSByZWR1Y2VyKGluaXQsIGFjdGlvbik7XG4gICAgICAgICAgICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9ICExO1xuICAgICAgICAgICAgICBmaXJzdFJlbmRlclBoYXNlVXBkYXRlID0gZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZS5uZXh0O1xuICAgICAgICAgICAgfSB3aGlsZSAobnVsbCAhPT0gZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZSk7XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZSA9IGluaXQ7XG4gICAgICAgICAgICByZXR1cm4gW2luaXQsIGluaXRpYWxBcmddO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3dvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlLCBpbml0aWFsQXJnXTtcbiAgICAgIH1cbiAgICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9ICEwO1xuICAgICAgcmVkdWNlciA9XG4gICAgICAgIHJlZHVjZXIgPT09IGJhc2ljU3RhdGVSZWR1Y2VyXG4gICAgICAgICAgPyBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbml0aWFsQXJnXG4gICAgICAgICAgICA/IGluaXRpYWxBcmcoKVxuICAgICAgICAgICAgOiBpbml0aWFsQXJnXG4gICAgICAgICAgOiB2b2lkIDAgIT09IGluaXRcbiAgICAgICAgICAgID8gaW5pdChpbml0aWFsQXJnKVxuICAgICAgICAgICAgOiBpbml0aWFsQXJnO1xuICAgICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gITE7XG4gICAgICB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZSA9IHJlZHVjZXI7XG4gICAgICByZWR1Y2VyID0gd29ya0luUHJvZ3Jlc3NIb29rLnF1ZXVlID0geyBsYXN0OiBudWxsLCBkaXNwYXRjaDogbnVsbCB9O1xuICAgICAgcmVkdWNlciA9IHJlZHVjZXIuZGlzcGF0Y2ggPSBkaXNwYXRjaEFjdGlvbi5iaW5kKFxuICAgICAgICBudWxsLFxuICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQsXG4gICAgICAgIHJlZHVjZXJcbiAgICAgICk7XG4gICAgICByZXR1cm4gW3dvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlLCByZWR1Y2VyXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXNlTWVtbyhuZXh0Q3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQgPSByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gICAgICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIGRlcHMgPSB2b2lkIDAgPT09IGRlcHMgPyBudWxsIDogZGVwcztcbiAgICAgIGlmIChudWxsICE9PSB3b3JrSW5Qcm9ncmVzc0hvb2spIHtcbiAgICAgICAgdmFyIHByZXZTdGF0ZSA9IHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlO1xuICAgICAgICBpZiAobnVsbCAhPT0gcHJldlN0YXRlICYmIG51bGwgIT09IGRlcHMpIHtcbiAgICAgICAgICBhOiB7XG4gICAgICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gcHJldlN0YXRlWzFdO1xuICAgICAgICAgICAgaWYgKG51bGwgPT09IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdClcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIiVzIHJlY2VpdmVkIGEgZmluYWwgYXJndW1lbnQgZHVyaW5nIHRoaXMgcmVuZGVyLCBidXQgbm90IGR1cmluZyB0aGUgcHJldmlvdXMgcmVuZGVyLiBFdmVuIHRob3VnaCB0aGUgZmluYWwgYXJndW1lbnQgaXMgb3B0aW9uYWwsIGl0cyB0eXBlIGNhbm5vdCBjaGFuZ2UgYmV0d2VlbiByZW5kZXJzLlwiLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2XG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICExKTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBkZXBzLmxlbmd0aCAhPT0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0Lmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIlRoZSBmaW5hbCBhcmd1bWVudCBwYXNzZWQgdG8gJXMgY2hhbmdlZCBzaXplIGJldHdlZW4gcmVuZGVycy4gVGhlIG9yZGVyIGFuZCBzaXplIG9mIHRoaXMgYXJyYXkgbXVzdCByZW1haW4gY29uc3RhbnQuXFxuXFxuUHJldmlvdXM6ICVzXFxuSW5jb21pbmc6ICVzXCIsXG4gICAgICAgICAgICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldixcbiAgICAgICAgICAgICAgICAgIFwiW1wiICsgZGVwcy5qb2luKFwiLCBcIikgKyBcIl1cIixcbiAgICAgICAgICAgICAgICAgIFwiW1wiICsgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LmpvaW4oXCIsIFwiKSArIFwiXVwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICAgICAgaSA8IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdC5sZW5ndGggJiYgaSA8IGRlcHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGkrK1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgaWYgKCFvYmplY3RJcyhkZXBzW2ldLCBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHRbaV0pKSB7XG4gICAgICAgICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAhMTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAhMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCkgcmV0dXJuIHByZXZTdGF0ZVswXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gITA7XG4gICAgICBuZXh0Q3JlYXRlID0gbmV4dENyZWF0ZSgpO1xuICAgICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gITE7XG4gICAgICB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZSA9IFtuZXh0Q3JlYXRlLCBkZXBzXTtcbiAgICAgIHJldHVybiBuZXh0Q3JlYXRlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkaXNwYXRjaEFjdGlvbihjb21wb25lbnRJZGVudGl0eSwgcXVldWUsIGFjdGlvbikge1xuICAgICAgaWYgKDI1IDw9IG51bWJlck9mUmVSZW5kZXJzKVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIlRvbyBtYW55IHJlLXJlbmRlcnMuIFJlYWN0IGxpbWl0cyB0aGUgbnVtYmVyIG9mIHJlbmRlcnMgdG8gcHJldmVudCBhbiBpbmZpbml0ZSBsb29wLlwiXG4gICAgICAgICk7XG4gICAgICBpZiAoY29tcG9uZW50SWRlbnRpdHkgPT09IGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudClcbiAgICAgICAgaWYgKFxuICAgICAgICAgICgoZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9ICEwKSxcbiAgICAgICAgICAoY29tcG9uZW50SWRlbnRpdHkgPSB7IGFjdGlvbjogYWN0aW9uLCBuZXh0OiBudWxsIH0pLFxuICAgICAgICAgIG51bGwgPT09IHJlbmRlclBoYXNlVXBkYXRlcyAmJiAocmVuZGVyUGhhc2VVcGRhdGVzID0gbmV3IE1hcCgpKSxcbiAgICAgICAgICAoYWN0aW9uID0gcmVuZGVyUGhhc2VVcGRhdGVzLmdldChxdWV1ZSkpLFxuICAgICAgICAgIHZvaWQgMCA9PT0gYWN0aW9uKVxuICAgICAgICApXG4gICAgICAgICAgcmVuZGVyUGhhc2VVcGRhdGVzLnNldChxdWV1ZSwgY29tcG9uZW50SWRlbnRpdHkpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBmb3IgKHF1ZXVlID0gYWN0aW9uOyBudWxsICE9PSBxdWV1ZS5uZXh0OyApIHF1ZXVlID0gcXVldWUubmV4dDtcbiAgICAgICAgICBxdWV1ZS5uZXh0ID0gY29tcG9uZW50SWRlbnRpdHk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdGhyb3dPblVzZUVmZmVjdEV2ZW50Q2FsbCgpIHtcbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICBcIkEgZnVuY3Rpb24gd3JhcHBlZCBpbiB1c2VFZmZlY3RFdmVudCBjYW4ndCBiZSBjYWxsZWQgZHVyaW5nIHJlbmRlcmluZy5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdW5zdXBwb3J0ZWRTdGFydFRyYW5zaXRpb24oKSB7XG4gICAgICB0aHJvdyBFcnJvcihcInN0YXJ0VHJhbnNpdGlvbiBjYW5ub3QgYmUgY2FsbGVkIGR1cmluZyBzZXJ2ZXIgcmVuZGVyaW5nLlwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdW5zdXBwb3J0ZWRTZXRPcHRpbWlzdGljU3RhdGUoKSB7XG4gICAgICB0aHJvdyBFcnJvcihcIkNhbm5vdCB1cGRhdGUgb3B0aW1pc3RpYyBzdGF0ZSB3aGlsZSByZW5kZXJpbmcuXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1c2VBY3Rpb25TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZSwgcGVybWFsaW5rKSB7XG4gICAgICByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gICAgICB2YXIgYWN0aW9uU3RhdGVIb29rSW5kZXggPSBhY3Rpb25TdGF0ZUNvdW50ZXIrKyxcbiAgICAgICAgcmVxdWVzdCA9IGN1cnJlbnRseVJlbmRlcmluZ1JlcXVlc3Q7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgYWN0aW9uLiQkRk9STV9BQ1RJT04pIHtcbiAgICAgICAgdmFyIG5leHRQb3N0YmFja1N0YXRlS2V5ID0gbnVsbCxcbiAgICAgICAgICBjb21wb25lbnRLZXlQYXRoID0gY3VycmVudGx5UmVuZGVyaW5nS2V5UGF0aDtcbiAgICAgICAgcmVxdWVzdCA9IHJlcXVlc3QuZm9ybVN0YXRlO1xuICAgICAgICB2YXIgaXNTaWduYXR1cmVFcXVhbCA9IGFjdGlvbi4kJElTX1NJR05BVFVSRV9FUVVBTDtcbiAgICAgICAgaWYgKG51bGwgIT09IHJlcXVlc3QgJiYgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaXNTaWduYXR1cmVFcXVhbCkge1xuICAgICAgICAgIHZhciBwb3N0YmFja0tleSA9IHJlcXVlc3RbMV07XG4gICAgICAgICAgaXNTaWduYXR1cmVFcXVhbC5jYWxsKGFjdGlvbiwgcmVxdWVzdFsyXSwgcmVxdWVzdFszXSkgJiZcbiAgICAgICAgICAgICgobmV4dFBvc3RiYWNrU3RhdGVLZXkgPVxuICAgICAgICAgICAgICB2b2lkIDAgIT09IHBlcm1hbGlua1xuICAgICAgICAgICAgICAgID8gXCJwXCIgKyBwZXJtYWxpbmtcbiAgICAgICAgICAgICAgICA6IFwia1wiICtcbiAgICAgICAgICAgICAgICAgIG11cm11cmhhc2gzXzMyX2djKFxuICAgICAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShbXG4gICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50S2V5UGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgIGFjdGlvblN0YXRlSG9va0luZGV4XG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgIHBvc3RiYWNrS2V5ID09PSBuZXh0UG9zdGJhY2tTdGF0ZUtleSAmJlxuICAgICAgICAgICAgICAoKGFjdGlvblN0YXRlTWF0Y2hpbmdJbmRleCA9IGFjdGlvblN0YXRlSG9va0luZGV4KSxcbiAgICAgICAgICAgICAgKGluaXRpYWxTdGF0ZSA9IHJlcXVlc3RbMF0pKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJvdW5kQWN0aW9uID0gYWN0aW9uLmJpbmQobnVsbCwgaW5pdGlhbFN0YXRlKTtcbiAgICAgICAgYWN0aW9uID0gZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgICAgICBib3VuZEFjdGlvbihwYXlsb2FkKTtcbiAgICAgICAgfTtcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgYm91bmRBY3Rpb24uJCRGT1JNX0FDVElPTiAmJlxuICAgICAgICAgIChhY3Rpb24uJCRGT1JNX0FDVElPTiA9IGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICAgICAgICAgIHByZWZpeCA9IGJvdW5kQWN0aW9uLiQkRk9STV9BQ1RJT04ocHJlZml4KTtcbiAgICAgICAgICAgIHZvaWQgMCAhPT0gcGVybWFsaW5rICYmXG4gICAgICAgICAgICAgIChjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHBlcm1hbGluaywgXCJ0YXJnZXRcIiksXG4gICAgICAgICAgICAgIChwZXJtYWxpbmsgKz0gXCJcIiksXG4gICAgICAgICAgICAgIChwcmVmaXguYWN0aW9uID0gcGVybWFsaW5rKSk7XG4gICAgICAgICAgICB2YXIgZm9ybURhdGEgPSBwcmVmaXguZGF0YTtcbiAgICAgICAgICAgIGZvcm1EYXRhICYmXG4gICAgICAgICAgICAgIChudWxsID09PSBuZXh0UG9zdGJhY2tTdGF0ZUtleSAmJlxuICAgICAgICAgICAgICAgIChuZXh0UG9zdGJhY2tTdGF0ZUtleSA9XG4gICAgICAgICAgICAgICAgICB2b2lkIDAgIT09IHBlcm1hbGlua1xuICAgICAgICAgICAgICAgICAgICA/IFwicFwiICsgcGVybWFsaW5rXG4gICAgICAgICAgICAgICAgICAgIDogXCJrXCIgK1xuICAgICAgICAgICAgICAgICAgICAgIG11cm11cmhhc2gzXzMyX2djKFxuICAgICAgICAgICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoW1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRLZXlQYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25TdGF0ZUhvb2tJbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChcIiRBQ1RJT05fS0VZXCIsIG5leHRQb3N0YmFja1N0YXRlS2V5KSk7XG4gICAgICAgICAgICByZXR1cm4gcHJlZml4O1xuICAgICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gW2luaXRpYWxTdGF0ZSwgYWN0aW9uLCAhMV07XG4gICAgICB9XG4gICAgICB2YXIgX2JvdW5kQWN0aW9uID0gYWN0aW9uLmJpbmQobnVsbCwgaW5pdGlhbFN0YXRlKTtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIGluaXRpYWxTdGF0ZSxcbiAgICAgICAgZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgICAgICBfYm91bmRBY3Rpb24ocGF5bG9hZCk7XG4gICAgICAgIH0sXG4gICAgICAgICExXG4gICAgICBdO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1bndyYXBUaGVuYWJsZSh0aGVuYWJsZSkge1xuICAgICAgdmFyIGluZGV4ID0gdGhlbmFibGVJbmRleENvdW50ZXI7XG4gICAgICB0aGVuYWJsZUluZGV4Q291bnRlciArPSAxO1xuICAgICAgbnVsbCA9PT0gdGhlbmFibGVTdGF0ZSAmJiAodGhlbmFibGVTdGF0ZSA9IFtdKTtcbiAgICAgIHJldHVybiB0cmFja1VzZWRUaGVuYWJsZSh0aGVuYWJsZVN0YXRlLCB0aGVuYWJsZSwgaW5kZXgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1bnN1cHBvcnRlZFJlZnJlc2goKSB7XG4gICAgICB0aHJvdyBFcnJvcihcIkNhY2hlIGNhbm5vdCBiZSByZWZyZXNoZWQgZHVyaW5nIHNlcnZlciByZW5kZXJpbmcuXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkaXNhYmxlZExvZygpIHt9XG4gICAgZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gICAgICBpZiAoMCA9PT0gZGlzYWJsZWREZXB0aCkge1xuICAgICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICAgIHByZXZJbmZvID0gY29uc29sZS5pbmZvO1xuICAgICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgICAgcHJldkdyb3VwID0gY29uc29sZS5ncm91cDtcbiAgICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDtcbiAgICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICAgIHdyaXRhYmxlOiAhMFxuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBkaXNhYmxlZERlcHRoKys7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAgICAgIGRpc2FibGVkRGVwdGgtLTtcbiAgICAgIGlmICgwID09PSBkaXNhYmxlZERlcHRoKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHsgY29uZmlndXJhYmxlOiAhMCwgZW51bWVyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2TG9nIH0pLFxuICAgICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZJbmZvIH0pLFxuICAgICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZXYXJuIH0pLFxuICAgICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2RXJyb3IgfSksXG4gICAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZHcm91cCB9KSxcbiAgICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkIH0pLFxuICAgICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2R3JvdXBFbmQgfSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAwID4gZGlzYWJsZWREZXB0aCAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZvcm1hdE93bmVyU3RhY2soZXJyb3IpIHtcbiAgICAgIHZhciBwcmV2UHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTtcbiAgICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdm9pZCAwO1xuICAgICAgZXJyb3IgPSBlcnJvci5zdGFjaztcbiAgICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldlByZXBhcmVTdGFja1RyYWNlO1xuICAgICAgZXJyb3Iuc3RhcnRzV2l0aChcIkVycm9yOiByZWFjdC1zdGFjay10b3AtZnJhbWVcXG5cIikgJiZcbiAgICAgICAgKGVycm9yID0gZXJyb3Iuc2xpY2UoMjkpKTtcbiAgICAgIHByZXZQcmVwYXJlU3RhY2tUcmFjZSA9IGVycm9yLmluZGV4T2YoXCJcXG5cIik7XG4gICAgICAtMSAhPT0gcHJldlByZXBhcmVTdGFja1RyYWNlICYmXG4gICAgICAgIChlcnJvciA9IGVycm9yLnNsaWNlKHByZXZQcmVwYXJlU3RhY2tUcmFjZSArIDEpKTtcbiAgICAgIHByZXZQcmVwYXJlU3RhY2tUcmFjZSA9IGVycm9yLmluZGV4T2YoXCJyZWFjdF9zdGFja19ib3R0b21fZnJhbWVcIik7XG4gICAgICAtMSAhPT0gcHJldlByZXBhcmVTdGFja1RyYWNlICYmXG4gICAgICAgIChwcmV2UHJlcGFyZVN0YWNrVHJhY2UgPSBlcnJvci5sYXN0SW5kZXhPZihcbiAgICAgICAgICBcIlxcblwiLFxuICAgICAgICAgIHByZXZQcmVwYXJlU3RhY2tUcmFjZVxuICAgICAgICApKTtcbiAgICAgIGlmICgtMSAhPT0gcHJldlByZXBhcmVTdGFja1RyYWNlKVxuICAgICAgICBlcnJvciA9IGVycm9yLnNsaWNlKDAsIHByZXZQcmVwYXJlU3RhY2tUcmFjZSk7XG4gICAgICBlbHNlIHJldHVybiBcIlwiO1xuICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSB7XG4gICAgICBpZiAodm9pZCAwID09PSBwcmVmaXgpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIHZhciBtYXRjaCA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgICAgcHJlZml4ID0gKG1hdGNoICYmIG1hdGNoWzFdKSB8fCBcIlwiO1xuICAgICAgICAgIHN1ZmZpeCA9XG4gICAgICAgICAgICAtMSA8IHguc3RhY2suaW5kZXhPZihcIlxcbiAgICBhdFwiKVxuICAgICAgICAgICAgICA/IFwiICg8YW5vbnltb3VzPilcIlxuICAgICAgICAgICAgICA6IC0xIDwgeC5zdGFjay5pbmRleE9mKFwiQFwiKVxuICAgICAgICAgICAgICAgID8gXCJAdW5rbm93bjowOjBcIlxuICAgICAgICAgICAgICAgIDogXCJcIjtcbiAgICAgICAgfVxuICAgICAgcmV0dXJuIFwiXFxuXCIgKyBwcmVmaXggKyBuYW1lICsgc3VmZml4O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgICAgIGlmICghZm4gfHwgcmVlbnRyeSkgcmV0dXJuIFwiXCI7XG4gICAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG4gICAgICBpZiAodm9pZCAwICE9PSBmcmFtZSkgcmV0dXJuIGZyYW1lO1xuICAgICAgcmVlbnRyeSA9ICEwO1xuICAgICAgZnJhbWUgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTtcbiAgICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdm9pZCAwO1xuICAgICAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlciA9IG51bGw7XG4gICAgICBwcmV2aW91c0Rpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IG51bGw7XG4gICAgICBkaXNhYmxlTG9ncygpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIFJ1bkluUm9vdEZyYW1lID0ge1xuICAgICAgICAgIERldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKGNvbnN0cnVjdCkge1xuICAgICAgICAgICAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgXCJwcm9wc1wiLCB7XG4gICAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIFJlZmxlY3QgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRyb2wgPSB4O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgRmFrZS5jYWxsKCk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoICh4JDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbCA9IHgkMDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGZuLmNhbGwoRmFrZS5wcm90b3R5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoICh4JDEpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2wgPSB4JDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIChGYWtlID0gZm4oKSkgJiZcbiAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIEZha2UuY2F0Y2ggJiZcbiAgICAgICAgICAgICAgICAgIEZha2UuY2F0Y2goZnVuY3Rpb24gKCkge30pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAgICAgICAgICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIFwic3RyaW5nXCIgPT09IHR5cGVvZiBzYW1wbGUuc3RhY2spXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtzYW1wbGUuc3RhY2ssIGNvbnRyb2wuc3RhY2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtudWxsLCBudWxsXTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdC5kaXNwbGF5TmFtZSA9XG4gICAgICAgICAgXCJEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3RcIjtcbiAgICAgICAgdmFyIG5hbWVQcm9wRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoXG4gICAgICAgICAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LFxuICAgICAgICAgIFwibmFtZVwiXG4gICAgICAgICk7XG4gICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvciAmJlxuICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvci5jb25maWd1cmFibGUgJiZcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICAgICAgICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QsXG4gICAgICAgICAgICBcIm5hbWVcIixcbiAgICAgICAgICAgIHsgdmFsdWU6IFwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290XCIgfVxuICAgICAgICAgICk7XG4gICAgICAgIHZhciBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPVxuICAgICAgICAgICAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290KCksXG4gICAgICAgICAgc2FtcGxlU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMF0sXG4gICAgICAgICAgY29udHJvbFN0YWNrID0gX1J1bkluUm9vdEZyYW1lJERldGVyWzFdO1xuICAgICAgICBpZiAoc2FtcGxlU3RhY2sgJiYgY29udHJvbFN0YWNrKSB7XG4gICAgICAgICAgdmFyIHNhbXBsZUxpbmVzID0gc2FtcGxlU3RhY2suc3BsaXQoXCJcXG5cIiksXG4gICAgICAgICAgICBjb250cm9sTGluZXMgPSBjb250cm9sU3RhY2suc3BsaXQoXCJcXG5cIik7XG4gICAgICAgICAgZm9yIChcbiAgICAgICAgICAgIF9SdW5JblJvb3RGcmFtZSREZXRlciA9IG5hbWVQcm9wRGVzY3JpcHRvciA9IDA7XG4gICAgICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IgPCBzYW1wbGVMaW5lcy5sZW5ndGggJiZcbiAgICAgICAgICAgICFzYW1wbGVMaW5lc1tuYW1lUHJvcERlc2NyaXB0b3JdLmluY2x1ZGVzKFxuICAgICAgICAgICAgICBcIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdFwiXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgKVxuICAgICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yKys7XG4gICAgICAgICAgZm9yIChcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIF9SdW5JblJvb3RGcmFtZSREZXRlciA8IGNvbnRyb2xMaW5lcy5sZW5ndGggJiZcbiAgICAgICAgICAgICFjb250cm9sTGluZXNbX1J1bkluUm9vdEZyYW1lJERldGVyXS5pbmNsdWRlcyhcbiAgICAgICAgICAgICAgXCJEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3RcIlxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgIClcbiAgICAgICAgICAgIF9SdW5JblJvb3RGcmFtZSREZXRlcisrO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvciA9PT0gc2FtcGxlTGluZXMubGVuZ3RoIHx8XG4gICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPT09IGNvbnRyb2xMaW5lcy5sZW5ndGhcbiAgICAgICAgICApXG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxLFxuICAgICAgICAgICAgICAgIF9SdW5JblJvb3RGcmFtZSREZXRlciA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAxIDw9IG5hbWVQcm9wRGVzY3JpcHRvciAmJlxuICAgICAgICAgICAgICAwIDw9IF9SdW5JblJvb3RGcmFtZSREZXRlciAmJlxuICAgICAgICAgICAgICBzYW1wbGVMaW5lc1tuYW1lUHJvcERlc2NyaXB0b3JdICE9PVxuICAgICAgICAgICAgICAgIGNvbnRyb2xMaW5lc1tfUnVuSW5Sb290RnJhbWUkRGV0ZXJdO1xuXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIF9SdW5JblJvb3RGcmFtZSREZXRlci0tO1xuICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICA7XG4gICAgICAgICAgICAxIDw9IG5hbWVQcm9wRGVzY3JpcHRvciAmJiAwIDw9IF9SdW5JblJvb3RGcmFtZSREZXRlcjtcbiAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvci0tLCBfUnVuSW5Sb290RnJhbWUkRGV0ZXItLVxuICAgICAgICAgIClcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgc2FtcGxlTGluZXNbbmFtZVByb3BEZXNjcmlwdG9yXSAhPT1cbiAgICAgICAgICAgICAgY29udHJvbExpbmVzW19SdW5JblJvb3RGcmFtZSREZXRlcl1cbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBpZiAoMSAhPT0gbmFtZVByb3BEZXNjcmlwdG9yIHx8IDEgIT09IF9SdW5JblJvb3RGcmFtZSREZXRlcikge1xuICAgICAgICAgICAgICAgIGRvXG4gICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIChuYW1lUHJvcERlc2NyaXB0b3ItLSxcbiAgICAgICAgICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyLS0sXG4gICAgICAgICAgICAgICAgICAgIDAgPiBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgfHxcbiAgICAgICAgICAgICAgICAgICAgICBzYW1wbGVMaW5lc1tuYW1lUHJvcERlc2NyaXB0b3JdICE9PVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbExpbmVzW19SdW5JblJvb3RGcmFtZSREZXRlcl0pXG4gICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9XG4gICAgICAgICAgICAgICAgICAgICAgXCJcXG5cIiArXG4gICAgICAgICAgICAgICAgICAgICAgc2FtcGxlTGluZXNbbmFtZVByb3BEZXNjcmlwdG9yXS5yZXBsYWNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgXCIgYXQgbmV3IFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCIgYXQgXCJcbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBmbi5kaXNwbGF5TmFtZSAmJlxuICAgICAgICAgICAgICAgICAgICAgIF9mcmFtZS5pbmNsdWRlcyhcIjxhbm9ueW1vdXM+XCIpICYmXG4gICAgICAgICAgICAgICAgICAgICAgKF9mcmFtZSA9IF9mcmFtZS5yZXBsYWNlKFwiPGFub255bW91cz5cIiwgZm4uZGlzcGxheU5hbWUpKTtcbiAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZm4gJiZcbiAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoMSA8PSBuYW1lUHJvcERlc2NyaXB0b3IgJiYgMCA8PSBfUnVuSW5Sb290RnJhbWUkRGV0ZXIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICAocmVlbnRyeSA9ICExKSxcbiAgICAgICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZpb3VzRGlzcGF0Y2hlciksXG4gICAgICAgICAgcmVlbmFibGVMb2dzKCksXG4gICAgICAgICAgKEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gZnJhbWUpO1xuICAgICAgfVxuICAgICAgc2FtcGxlTGluZXMgPSAoc2FtcGxlTGluZXMgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiBcIlwiKVxuICAgICAgICA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHNhbXBsZUxpbmVzKVxuICAgICAgICA6IFwiXCI7XG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBmbiAmJiBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc2FtcGxlTGluZXMpO1xuICAgICAgcmV0dXJuIHNhbXBsZUxpbmVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZUNvbXBvbmVudFN0YWNrQnlUeXBlKHR5cGUpIHtcbiAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgdHlwZSkgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHJldHVybiB0eXBlLnByb3RvdHlwZSAmJiB0eXBlLnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50XG4gICAgICAgICAgPyBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKHR5cGUsICEwKVxuICAgICAgICAgIDogZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCAhMSk7XG4gICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUgJiYgbnVsbCAhPT0gdHlwZSkge1xuICAgICAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLnJlbmRlciwgITEpO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZS50eXBlLCAhMSk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGUsXG4gICAgICAgICAgICAgIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgICAgbGF6eUNvbXBvbmVudCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB0eXBlID0gbGF6eUNvbXBvbmVudChwYXlsb2FkKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKFwiTGF6eVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZUNvbXBvbmVudFN0YWNrQnlUeXBlKHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgdHlwZS5uYW1lKSB7XG4gICAgICAgICAgYToge1xuICAgICAgICAgICAgcGF5bG9hZCA9IHR5cGUubmFtZTtcbiAgICAgICAgICAgIGxhenlDb21wb25lbnQgPSB0eXBlLmVudjtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLmRlYnVnTG9jYXRpb247XG4gICAgICAgICAgICBpZiAobnVsbCAhPSB0eXBlKSB7XG4gICAgICAgICAgICAgIHR5cGUgPSBmb3JtYXRPd25lclN0YWNrKHR5cGUpO1xuICAgICAgICAgICAgICB2YXIgaWR4ID0gdHlwZS5sYXN0SW5kZXhPZihcIlxcblwiKTtcbiAgICAgICAgICAgICAgdHlwZSA9IC0xID09PSBpZHggPyB0eXBlIDogdHlwZS5zbGljZShpZHggKyAxKTtcbiAgICAgICAgICAgICAgaWYgKC0xICE9PSB0eXBlLmluZGV4T2YocGF5bG9hZCkpIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkID0gXCJcXG5cIiArIHR5cGU7XG4gICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGF5bG9hZCA9IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKFxuICAgICAgICAgICAgICBwYXlsb2FkICsgKGxhenlDb21wb25lbnQgPyBcIiBbXCIgKyBsYXp5Q29tcG9uZW50ICsgXCJdXCIgOiBcIlwiKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoXCJTdXNwZW5zZUxpc3RcIik7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoXCJTdXNwZW5zZVwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0VsaWdpYmxlRm9yT3V0bGluaW5nKHJlcXVlc3QsIGJvdW5kYXJ5KSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICAoNTAwIDwgYm91bmRhcnkuYnl0ZVNpemUgfHwgITEpICYmIG51bGwgPT09IGJvdW5kYXJ5LmNvbnRlbnRQcmVhbWJsZVxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVmYXVsdEVycm9ySGFuZGxlcihlcnJvcikge1xuICAgICAgaWYgKFxuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgZXJyb3IgJiZcbiAgICAgICAgbnVsbCAhPT0gZXJyb3IgJiZcbiAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGVycm9yLmVudmlyb25tZW50TmFtZVxuICAgICAgKSB7XG4gICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSBlcnJvci5lbnZpcm9ubWVudE5hbWU7XG4gICAgICAgIGVycm9yID0gW2Vycm9yXS5zbGljZSgwKTtcbiAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGVycm9yWzBdXG4gICAgICAgICAgPyBlcnJvci5zcGxpY2UoXG4gICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgIDEsXG4gICAgICAgICAgICAgIFwiWyVzXSBcIiArIGVycm9yWzBdLFxuICAgICAgICAgICAgICBcIiBcIiArIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCArIFwiIFwiXG4gICAgICAgICAgICApXG4gICAgICAgICAgOiBlcnJvci5zcGxpY2UoMCwgMCwgXCJbJXNdXCIsIFwiIFwiICsgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ICsgXCIgXCIpO1xuICAgICAgICBlcnJvci51bnNoaWZ0KGNvbnNvbGUpO1xuICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSBiaW5kLmFwcGx5KGNvbnNvbGUuZXJyb3IsIGVycm9yKTtcbiAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0KCk7XG4gICAgICB9IGVsc2UgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVxdWVzdEluc3RhbmNlKFxuICAgICAgcmVzdW1hYmxlU3RhdGUsXG4gICAgICByZW5kZXJTdGF0ZSxcbiAgICAgIHJvb3RGb3JtYXRDb250ZXh0LFxuICAgICAgcHJvZ3Jlc3NpdmVDaHVua1NpemUsXG4gICAgICBvbkVycm9yLFxuICAgICAgb25BbGxSZWFkeSxcbiAgICAgIG9uU2hlbGxSZWFkeSxcbiAgICAgIG9uU2hlbGxFcnJvcixcbiAgICAgIG9uRmF0YWxFcnJvcixcbiAgICAgIG9uUG9zdHBvbmUsXG4gICAgICBmb3JtU3RhdGVcbiAgICApIHtcbiAgICAgIHZhciBhYm9ydFNldCA9IG5ldyBTZXQoKTtcbiAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBudWxsO1xuICAgICAgdGhpcy5mbHVzaFNjaGVkdWxlZCA9ICExO1xuICAgICAgdGhpcy5yZXN1bWFibGVTdGF0ZSA9IHJlc3VtYWJsZVN0YXRlO1xuICAgICAgdGhpcy5yZW5kZXJTdGF0ZSA9IHJlbmRlclN0YXRlO1xuICAgICAgdGhpcy5yb290Rm9ybWF0Q29udGV4dCA9IHJvb3RGb3JtYXRDb250ZXh0O1xuICAgICAgdGhpcy5wcm9ncmVzc2l2ZUNodW5rU2l6ZSA9XG4gICAgICAgIHZvaWQgMCA9PT0gcHJvZ3Jlc3NpdmVDaHVua1NpemUgPyAxMjgwMCA6IHByb2dyZXNzaXZlQ2h1bmtTaXplO1xuICAgICAgdGhpcy5zdGF0dXMgPSAxMDtcbiAgICAgIHRoaXMuZmF0YWxFcnJvciA9IG51bGw7XG4gICAgICB0aGlzLnBlbmRpbmdSb290VGFza3MgPSB0aGlzLmFsbFBlbmRpbmdUYXNrcyA9IHRoaXMubmV4dFNlZ21lbnRJZCA9IDA7XG4gICAgICB0aGlzLmNvbXBsZXRlZFByZWFtYmxlU2VnbWVudHMgPSB0aGlzLmNvbXBsZXRlZFJvb3RTZWdtZW50ID0gbnVsbDtcbiAgICAgIHRoaXMuYnl0ZVNpemUgPSAwO1xuICAgICAgdGhpcy5hYm9ydGFibGVUYXNrcyA9IGFib3J0U2V0O1xuICAgICAgdGhpcy5waW5nZWRUYXNrcyA9IFtdO1xuICAgICAgdGhpcy5jbGllbnRSZW5kZXJlZEJvdW5kYXJpZXMgPSBbXTtcbiAgICAgIHRoaXMuY29tcGxldGVkQm91bmRhcmllcyA9IFtdO1xuICAgICAgdGhpcy5wYXJ0aWFsQm91bmRhcmllcyA9IFtdO1xuICAgICAgdGhpcy50cmFja2VkUG9zdHBvbmVzID0gbnVsbDtcbiAgICAgIHRoaXMub25FcnJvciA9IHZvaWQgMCA9PT0gb25FcnJvciA/IGRlZmF1bHRFcnJvckhhbmRsZXIgOiBvbkVycm9yO1xuICAgICAgdGhpcy5vblBvc3Rwb25lID0gdm9pZCAwID09PSBvblBvc3Rwb25lID8gbm9vcCA6IG9uUG9zdHBvbmU7XG4gICAgICB0aGlzLm9uQWxsUmVhZHkgPSB2b2lkIDAgPT09IG9uQWxsUmVhZHkgPyBub29wIDogb25BbGxSZWFkeTtcbiAgICAgIHRoaXMub25TaGVsbFJlYWR5ID0gdm9pZCAwID09PSBvblNoZWxsUmVhZHkgPyBub29wIDogb25TaGVsbFJlYWR5O1xuICAgICAgdGhpcy5vblNoZWxsRXJyb3IgPSB2b2lkIDAgPT09IG9uU2hlbGxFcnJvciA/IG5vb3AgOiBvblNoZWxsRXJyb3I7XG4gICAgICB0aGlzLm9uRmF0YWxFcnJvciA9IHZvaWQgMCA9PT0gb25GYXRhbEVycm9yID8gbm9vcCA6IG9uRmF0YWxFcnJvcjtcbiAgICAgIHRoaXMuZm9ybVN0YXRlID0gdm9pZCAwID09PSBmb3JtU3RhdGUgPyBudWxsIDogZm9ybVN0YXRlO1xuICAgICAgdGhpcy5kaWRXYXJuRm9yS2V5ID0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlUmVxdWVzdChcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgcmVzdW1hYmxlU3RhdGUsXG4gICAgICByZW5kZXJTdGF0ZSxcbiAgICAgIHJvb3RGb3JtYXRDb250ZXh0LFxuICAgICAgcHJvZ3Jlc3NpdmVDaHVua1NpemUsXG4gICAgICBvbkVycm9yLFxuICAgICAgb25BbGxSZWFkeSxcbiAgICAgIG9uU2hlbGxSZWFkeSxcbiAgICAgIG9uU2hlbGxFcnJvcixcbiAgICAgIG9uRmF0YWxFcnJvcixcbiAgICAgIG9uUG9zdHBvbmUsXG4gICAgICBmb3JtU3RhdGVcbiAgICApIHtcbiAgICAgIHZhciBub3cgPSBnZXRDdXJyZW50VGltZSgpO1xuICAgICAgMWUzIDwgbm93IC0gbGFzdFJlc2V0VGltZSAmJlxuICAgICAgICAoKFJlYWN0U2hhcmVkSW50ZXJuYWxzLnJlY2VudGx5Q3JlYXRlZE93bmVyU3RhY2tzID0gMCksXG4gICAgICAgIChsYXN0UmVzZXRUaW1lID0gbm93KSk7XG4gICAgICByZXN1bWFibGVTdGF0ZSA9IG5ldyBSZXF1ZXN0SW5zdGFuY2UoXG4gICAgICAgIHJlc3VtYWJsZVN0YXRlLFxuICAgICAgICByZW5kZXJTdGF0ZSxcbiAgICAgICAgcm9vdEZvcm1hdENvbnRleHQsXG4gICAgICAgIHByb2dyZXNzaXZlQ2h1bmtTaXplLFxuICAgICAgICBvbkVycm9yLFxuICAgICAgICBvbkFsbFJlYWR5LFxuICAgICAgICBvblNoZWxsUmVhZHksXG4gICAgICAgIG9uU2hlbGxFcnJvcixcbiAgICAgICAgb25GYXRhbEVycm9yLFxuICAgICAgICBvblBvc3Rwb25lLFxuICAgICAgICBmb3JtU3RhdGVcbiAgICAgICk7XG4gICAgICByZW5kZXJTdGF0ZSA9IGNyZWF0ZVBlbmRpbmdTZWdtZW50KFxuICAgICAgICByZXN1bWFibGVTdGF0ZSxcbiAgICAgICAgMCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgcm9vdEZvcm1hdENvbnRleHQsXG4gICAgICAgICExLFxuICAgICAgICAhMVxuICAgICAgKTtcbiAgICAgIHJlbmRlclN0YXRlLnBhcmVudEZsdXNoZWQgPSAhMDtcbiAgICAgIGNoaWxkcmVuID0gY3JlYXRlUmVuZGVyVGFzayhcbiAgICAgICAgcmVzdW1hYmxlU3RhdGUsXG4gICAgICAgIG51bGwsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICAtMSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgcmVuZGVyU3RhdGUsXG4gICAgICAgIG51bGwsXG4gICAgICAgIG51bGwsXG4gICAgICAgIHJlc3VtYWJsZVN0YXRlLmFib3J0YWJsZVRhc2tzLFxuICAgICAgICBudWxsLFxuICAgICAgICByb290Rm9ybWF0Q29udGV4dCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgZW1wdHlUcmVlQ29udGV4dCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgZW1wdHlDb250ZXh0T2JqZWN0LFxuICAgICAgICBudWxsXG4gICAgICApO1xuICAgICAgcHVzaENvbXBvbmVudFN0YWNrKGNoaWxkcmVuKTtcbiAgICAgIHJlc3VtYWJsZVN0YXRlLnBpbmdlZFRhc2tzLnB1c2goY2hpbGRyZW4pO1xuICAgICAgcmV0dXJuIHJlc3VtYWJsZVN0YXRlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwaW5nVGFzayhyZXF1ZXN0LCB0YXNrKSB7XG4gICAgICByZXF1ZXN0LnBpbmdlZFRhc2tzLnB1c2godGFzayk7XG4gICAgICAxID09PSByZXF1ZXN0LnBpbmdlZFRhc2tzLmxlbmd0aCAmJlxuICAgICAgICAoKHJlcXVlc3QuZmx1c2hTY2hlZHVsZWQgPSBudWxsICE9PSByZXF1ZXN0LmRlc3RpbmF0aW9uKSxcbiAgICAgICAgcGVyZm9ybVdvcmsocmVxdWVzdCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5KFxuICAgICAgcmVxdWVzdCxcbiAgICAgIHJvdyxcbiAgICAgIGZhbGxiYWNrQWJvcnRhYmxlVGFza3MsXG4gICAgICBjb250ZW50UHJlYW1ibGUsXG4gICAgICBmYWxsYmFja1ByZWFtYmxlXG4gICAgKSB7XG4gICAgICBmYWxsYmFja0Fib3J0YWJsZVRhc2tzID0ge1xuICAgICAgICBzdGF0dXM6IFBFTkRJTkcsXG4gICAgICAgIHJvb3RTZWdtZW50SUQ6IC0xLFxuICAgICAgICBwYXJlbnRGbHVzaGVkOiAhMSxcbiAgICAgICAgcGVuZGluZ1Rhc2tzOiAwLFxuICAgICAgICByb3c6IHJvdyxcbiAgICAgICAgY29tcGxldGVkU2VnbWVudHM6IFtdLFxuICAgICAgICBieXRlU2l6ZTogMCxcbiAgICAgICAgZmFsbGJhY2tBYm9ydGFibGVUYXNrczogZmFsbGJhY2tBYm9ydGFibGVUYXNrcyxcbiAgICAgICAgZXJyb3JEaWdlc3Q6IG51bGwsXG4gICAgICAgIGNvbnRlbnRTdGF0ZTogY3JlYXRlSG9pc3RhYmxlU3RhdGUoKSxcbiAgICAgICAgZmFsbGJhY2tTdGF0ZTogY3JlYXRlSG9pc3RhYmxlU3RhdGUoKSxcbiAgICAgICAgY29udGVudFByZWFtYmxlOiBjb250ZW50UHJlYW1ibGUsXG4gICAgICAgIGZhbGxiYWNrUHJlYW1ibGU6IGZhbGxiYWNrUHJlYW1ibGUsXG4gICAgICAgIHRyYWNrZWRDb250ZW50S2V5UGF0aDogbnVsbCxcbiAgICAgICAgdHJhY2tlZEZhbGxiYWNrTm9kZTogbnVsbCxcbiAgICAgICAgZXJyb3JNZXNzYWdlOiBudWxsLFxuICAgICAgICBlcnJvclN0YWNrOiBudWxsLFxuICAgICAgICBlcnJvckNvbXBvbmVudFN0YWNrOiBudWxsXG4gICAgICB9O1xuICAgICAgbnVsbCAhPT0gcm93ICYmXG4gICAgICAgIChyb3cucGVuZGluZ1Rhc2tzKyssXG4gICAgICAgIChjb250ZW50UHJlYW1ibGUgPSByb3cuYm91bmRhcmllcyksXG4gICAgICAgIG51bGwgIT09IGNvbnRlbnRQcmVhbWJsZSAmJlxuICAgICAgICAgIChyZXF1ZXN0LmFsbFBlbmRpbmdUYXNrcysrLFxuICAgICAgICAgIGZhbGxiYWNrQWJvcnRhYmxlVGFza3MucGVuZGluZ1Rhc2tzKyssXG4gICAgICAgICAgY29udGVudFByZWFtYmxlLnB1c2goZmFsbGJhY2tBYm9ydGFibGVUYXNrcykpLFxuICAgICAgICAocmVxdWVzdCA9IHJvdy5pbmhlcml0ZWRIb2lzdGFibGVzKSxcbiAgICAgICAgbnVsbCAhPT0gcmVxdWVzdCAmJlxuICAgICAgICAgIGhvaXN0SG9pc3RhYmxlcyhmYWxsYmFja0Fib3J0YWJsZVRhc2tzLmNvbnRlbnRTdGF0ZSwgcmVxdWVzdCkpO1xuICAgICAgcmV0dXJuIGZhbGxiYWNrQWJvcnRhYmxlVGFza3M7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlbmRlclRhc2soXG4gICAgICByZXF1ZXN0LFxuICAgICAgdGhlbmFibGVTdGF0ZSxcbiAgICAgIG5vZGUsXG4gICAgICBjaGlsZEluZGV4LFxuICAgICAgYmxvY2tlZEJvdW5kYXJ5LFxuICAgICAgYmxvY2tlZFNlZ21lbnQsXG4gICAgICBibG9ja2VkUHJlYW1ibGUsXG4gICAgICBob2lzdGFibGVTdGF0ZSxcbiAgICAgIGFib3J0U2V0LFxuICAgICAga2V5UGF0aCxcbiAgICAgIGZvcm1hdENvbnRleHQsXG4gICAgICBjb250ZXh0LFxuICAgICAgdHJlZUNvbnRleHQsXG4gICAgICByb3csXG4gICAgICBjb21wb25lbnRTdGFjayxcbiAgICAgIGxlZ2FjeUNvbnRleHQsXG4gICAgICBkZWJ1Z1Rhc2tcbiAgICApIHtcbiAgICAgIHJlcXVlc3QuYWxsUGVuZGluZ1Rhc2tzKys7XG4gICAgICBudWxsID09PSBibG9ja2VkQm91bmRhcnlcbiAgICAgICAgPyByZXF1ZXN0LnBlbmRpbmdSb290VGFza3MrK1xuICAgICAgICA6IGJsb2NrZWRCb3VuZGFyeS5wZW5kaW5nVGFza3MrKztcbiAgICAgIG51bGwgIT09IHJvdyAmJiByb3cucGVuZGluZ1Rhc2tzKys7XG4gICAgICB2YXIgdGFzayA9IHtcbiAgICAgICAgcmVwbGF5OiBudWxsLFxuICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICBjaGlsZEluZGV4OiBjaGlsZEluZGV4LFxuICAgICAgICBwaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHBpbmdUYXNrKHJlcXVlc3QsIHRhc2spO1xuICAgICAgICB9LFxuICAgICAgICBibG9ja2VkQm91bmRhcnk6IGJsb2NrZWRCb3VuZGFyeSxcbiAgICAgICAgYmxvY2tlZFNlZ21lbnQ6IGJsb2NrZWRTZWdtZW50LFxuICAgICAgICBibG9ja2VkUHJlYW1ibGU6IGJsb2NrZWRQcmVhbWJsZSxcbiAgICAgICAgaG9pc3RhYmxlU3RhdGU6IGhvaXN0YWJsZVN0YXRlLFxuICAgICAgICBhYm9ydFNldDogYWJvcnRTZXQsXG4gICAgICAgIGtleVBhdGg6IGtleVBhdGgsXG4gICAgICAgIGZvcm1hdENvbnRleHQ6IGZvcm1hdENvbnRleHQsXG4gICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgIHRyZWVDb250ZXh0OiB0cmVlQ29udGV4dCxcbiAgICAgICAgcm93OiByb3csXG4gICAgICAgIGNvbXBvbmVudFN0YWNrOiBjb21wb25lbnRTdGFjayxcbiAgICAgICAgdGhlbmFibGVTdGF0ZTogdGhlbmFibGVTdGF0ZVxuICAgICAgfTtcbiAgICAgIHRhc2suZGVidWdUYXNrID0gZGVidWdUYXNrO1xuICAgICAgYWJvcnRTZXQuYWRkKHRhc2spO1xuICAgICAgcmV0dXJuIHRhc2s7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlcGxheVRhc2soXG4gICAgICByZXF1ZXN0LFxuICAgICAgdGhlbmFibGVTdGF0ZSxcbiAgICAgIHJlcGxheSxcbiAgICAgIG5vZGUsXG4gICAgICBjaGlsZEluZGV4LFxuICAgICAgYmxvY2tlZEJvdW5kYXJ5LFxuICAgICAgaG9pc3RhYmxlU3RhdGUsXG4gICAgICBhYm9ydFNldCxcbiAgICAgIGtleVBhdGgsXG4gICAgICBmb3JtYXRDb250ZXh0LFxuICAgICAgY29udGV4dCxcbiAgICAgIHRyZWVDb250ZXh0LFxuICAgICAgcm93LFxuICAgICAgY29tcG9uZW50U3RhY2ssXG4gICAgICBsZWdhY3lDb250ZXh0LFxuICAgICAgZGVidWdUYXNrXG4gICAgKSB7XG4gICAgICByZXF1ZXN0LmFsbFBlbmRpbmdUYXNrcysrO1xuICAgICAgbnVsbCA9PT0gYmxvY2tlZEJvdW5kYXJ5XG4gICAgICAgID8gcmVxdWVzdC5wZW5kaW5nUm9vdFRhc2tzKytcbiAgICAgICAgOiBibG9ja2VkQm91bmRhcnkucGVuZGluZ1Rhc2tzKys7XG4gICAgICBudWxsICE9PSByb3cgJiYgcm93LnBlbmRpbmdUYXNrcysrO1xuICAgICAgcmVwbGF5LnBlbmRpbmdUYXNrcysrO1xuICAgICAgdmFyIHRhc2sgPSB7XG4gICAgICAgIHJlcGxheTogcmVwbGF5LFxuICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICBjaGlsZEluZGV4OiBjaGlsZEluZGV4LFxuICAgICAgICBwaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHBpbmdUYXNrKHJlcXVlc3QsIHRhc2spO1xuICAgICAgICB9LFxuICAgICAgICBibG9ja2VkQm91bmRhcnk6IGJsb2NrZWRCb3VuZGFyeSxcbiAgICAgICAgYmxvY2tlZFNlZ21lbnQ6IG51bGwsXG4gICAgICAgIGJsb2NrZWRQcmVhbWJsZTogbnVsbCxcbiAgICAgICAgaG9pc3RhYmxlU3RhdGU6IGhvaXN0YWJsZVN0YXRlLFxuICAgICAgICBhYm9ydFNldDogYWJvcnRTZXQsXG4gICAgICAgIGtleVBhdGg6IGtleVBhdGgsXG4gICAgICAgIGZvcm1hdENvbnRleHQ6IGZvcm1hdENvbnRleHQsXG4gICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgIHRyZWVDb250ZXh0OiB0cmVlQ29udGV4dCxcbiAgICAgICAgcm93OiByb3csXG4gICAgICAgIGNvbXBvbmVudFN0YWNrOiBjb21wb25lbnRTdGFjayxcbiAgICAgICAgdGhlbmFibGVTdGF0ZTogdGhlbmFibGVTdGF0ZVxuICAgICAgfTtcbiAgICAgIHRhc2suZGVidWdUYXNrID0gZGVidWdUYXNrO1xuICAgICAgYWJvcnRTZXQuYWRkKHRhc2spO1xuICAgICAgcmV0dXJuIHRhc2s7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVBlbmRpbmdTZWdtZW50KFxuICAgICAgcmVxdWVzdCxcbiAgICAgIGluZGV4LFxuICAgICAgYm91bmRhcnksXG4gICAgICBwYXJlbnRGb3JtYXRDb250ZXh0LFxuICAgICAgbGFzdFB1c2hlZFRleHQsXG4gICAgICB0ZXh0RW1iZWRkZWRcbiAgICApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXR1czogUEVORElORyxcbiAgICAgICAgcGFyZW50Rmx1c2hlZDogITEsXG4gICAgICAgIGlkOiAtMSxcbiAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICBjaHVua3M6IFtdLFxuICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgIHByZWFtYmxlQ2hpbGRyZW46IFtdLFxuICAgICAgICBwYXJlbnRGb3JtYXRDb250ZXh0OiBwYXJlbnRGb3JtYXRDb250ZXh0LFxuICAgICAgICBib3VuZGFyeTogYm91bmRhcnksXG4gICAgICAgIGxhc3RQdXNoZWRUZXh0OiBsYXN0UHVzaGVkVGV4dCxcbiAgICAgICAgdGV4dEVtYmVkZGVkOiB0ZXh0RW1iZWRkZWRcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEN1cnJlbnRTdGFja0luREVWKCkge1xuICAgICAgaWYgKG51bGwgPT09IGN1cnJlbnRUYXNrSW5ERVYgfHwgbnVsbCA9PT0gY3VycmVudFRhc2tJbkRFVi5jb21wb25lbnRTdGFjaylcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB2YXIgY29tcG9uZW50U3RhY2sgPSBjdXJyZW50VGFza0luREVWLmNvbXBvbmVudFN0YWNrO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGluZm8gPSBcIlwiO1xuICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGNvbXBvbmVudFN0YWNrLnR5cGUpXG4gICAgICAgICAgaW5mbyArPSBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShjb21wb25lbnRTdGFjay50eXBlKTtcbiAgICAgICAgZWxzZSBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY29tcG9uZW50U3RhY2sudHlwZSkge1xuICAgICAgICAgIGlmICghY29tcG9uZW50U3RhY2sub3duZXIpIHtcbiAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX3RlbXBfY29uc3QgPSBpbmZvLFxuICAgICAgICAgICAgICBmbiA9IGNvbXBvbmVudFN0YWNrLnR5cGUsXG4gICAgICAgICAgICAgIG5hbWUgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiBcIlwiO1xuICAgICAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IG5hbWVcbiAgICAgICAgICAgICAgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKVxuICAgICAgICAgICAgICA6IFwiXCI7XG4gICAgICAgICAgICBpbmZvID0gSlNDb21waWxlcl90ZW1wX2NvbnN0ICsgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgY29tcG9uZW50U3RhY2sub3duZXIgfHxcbiAgICAgICAgICAgIChpbmZvICs9IGRlc2NyaWJlQ29tcG9uZW50U3RhY2tCeVR5cGUoY29tcG9uZW50U3RhY2sudHlwZSkpO1xuICAgICAgICBmb3IgKDsgY29tcG9uZW50U3RhY2s7IClcbiAgICAgICAgICAoSlNDb21waWxlcl90ZW1wX2NvbnN0ID0gbnVsbCksXG4gICAgICAgICAgICBudWxsICE9IGNvbXBvbmVudFN0YWNrLmRlYnVnU3RhY2tcbiAgICAgICAgICAgICAgPyAoSlNDb21waWxlcl90ZW1wX2NvbnN0ID0gZm9ybWF0T3duZXJTdGFjayhcbiAgICAgICAgICAgICAgICAgIGNvbXBvbmVudFN0YWNrLmRlYnVnU3RhY2tcbiAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgICA6ICgoSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gY29tcG9uZW50U3RhY2spLFxuICAgICAgICAgICAgICAgIG51bGwgIT0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LnN0YWNrICYmXG4gICAgICAgICAgICAgICAgICAoSlNDb21waWxlcl90ZW1wX2NvbnN0ID1cbiAgICAgICAgICAgICAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdC5zdGFja1xuICAgICAgICAgICAgICAgICAgICAgID8gKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdC5zdGFjayA9IGZvcm1hdE93bmVyU3RhY2soXG4gICAgICAgICAgICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdC5zdGFja1xuICAgICAgICAgICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgICAgICAgICA6IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdC5zdGFjaykpLFxuICAgICAgICAgICAgKGNvbXBvbmVudFN0YWNrID0gY29tcG9uZW50U3RhY2sub3duZXIpICYmXG4gICAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcF9jb25zdCAmJlxuICAgICAgICAgICAgICAoaW5mbyArPSBcIlxcblwiICsgSlNDb21waWxlcl90ZW1wX2NvbnN0KTtcbiAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMCA9IGluZm87XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMCA9XG4gICAgICAgICAgXCJcXG5FcnJvciBnZW5lcmF0aW5nIHN0YWNrOiBcIiArIHgubWVzc2FnZSArIFwiXFxuXCIgKyB4LnN0YWNrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaEhhbHRlZEF3YWl0T25Db21wb25lbnRTdGFjayh0YXNrLCBkZWJ1Z0luZm8pIHtcbiAgICAgIGlmIChudWxsICE9IGRlYnVnSW5mbylcbiAgICAgICAgZm9yICh2YXIgaSA9IGRlYnVnSW5mby5sZW5ndGggLSAxOyAwIDw9IGk7IGktLSkge1xuICAgICAgICAgIHZhciBpbmZvID0gZGVidWdJbmZvW2ldO1xuICAgICAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgaW5mby5uYW1lKSBicmVhaztcbiAgICAgICAgICBpZiAoXCJudW1iZXJcIiA9PT0gdHlwZW9mIGluZm8udGltZSkgYnJlYWs7XG4gICAgICAgICAgaWYgKG51bGwgIT0gaW5mby5hd2FpdGVkKSB7XG4gICAgICAgICAgICB2YXIgYmVzdFN0YWNrID0gbnVsbCA9PSBpbmZvLmRlYnVnU3RhY2sgPyBpbmZvLmF3YWl0ZWQgOiBpbmZvO1xuICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gYmVzdFN0YWNrLmRlYnVnU3RhY2spIHtcbiAgICAgICAgICAgICAgdGFzay5jb21wb25lbnRTdGFjayA9IHtcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IHRhc2suY29tcG9uZW50U3RhY2ssXG4gICAgICAgICAgICAgICAgdHlwZTogaW5mbyxcbiAgICAgICAgICAgICAgICBvd25lcjogYmVzdFN0YWNrLm93bmVyLFxuICAgICAgICAgICAgICAgIHN0YWNrOiBiZXN0U3RhY2suZGVidWdTdGFja1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB0YXNrLmRlYnVnVGFzayA9IGJlc3RTdGFjay5kZWJ1Z1Rhc2s7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoU2VydmVyQ29tcG9uZW50U3RhY2sodGFzaywgZGVidWdJbmZvKSB7XG4gICAgICBpZiAobnVsbCAhPSBkZWJ1Z0luZm8pXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVidWdJbmZvLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGNvbXBvbmVudEluZm8gPSBkZWJ1Z0luZm9baV07XG4gICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGNvbXBvbmVudEluZm8ubmFtZSAmJlxuICAgICAgICAgICAgdm9pZCAwICE9PSBjb21wb25lbnRJbmZvLmRlYnVnU3RhY2sgJiZcbiAgICAgICAgICAgICgodGFzay5jb21wb25lbnRTdGFjayA9IHtcbiAgICAgICAgICAgICAgcGFyZW50OiB0YXNrLmNvbXBvbmVudFN0YWNrLFxuICAgICAgICAgICAgICB0eXBlOiBjb21wb25lbnRJbmZvLFxuICAgICAgICAgICAgICBvd25lcjogY29tcG9uZW50SW5mby5vd25lcixcbiAgICAgICAgICAgICAgc3RhY2s6IGNvbXBvbmVudEluZm8uZGVidWdTdGFja1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAodGFzay5kZWJ1Z1Rhc2sgPSBjb21wb25lbnRJbmZvLmRlYnVnVGFzaykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hDb21wb25lbnRTdGFjayh0YXNrKSB7XG4gICAgICB2YXIgbm9kZSA9IHRhc2subm9kZTtcbiAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2Ygbm9kZSAmJiBudWxsICE9PSBub2RlKVxuICAgICAgICBzd2l0Y2ggKG5vZGUuJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICAgIHZhciB0eXBlID0gbm9kZS50eXBlLFxuICAgICAgICAgICAgICBvd25lciA9IG5vZGUuX293bmVyLFxuICAgICAgICAgICAgICBzdGFjayA9IG5vZGUuX2RlYnVnU3RhY2s7XG4gICAgICAgICAgICBwdXNoU2VydmVyQ29tcG9uZW50U3RhY2sodGFzaywgbm9kZS5fZGVidWdJbmZvKTtcbiAgICAgICAgICAgIHRhc2suZGVidWdUYXNrID0gbm9kZS5fZGVidWdUYXNrO1xuICAgICAgICAgICAgdGFzay5jb21wb25lbnRTdGFjayA9IHtcbiAgICAgICAgICAgICAgcGFyZW50OiB0YXNrLmNvbXBvbmVudFN0YWNrLFxuICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICBvd25lcjogb3duZXIsXG4gICAgICAgICAgICAgIHN0YWNrOiBzdGFja1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgcHVzaFNlcnZlckNvbXBvbmVudFN0YWNrKHRhc2ssIG5vZGUuX2RlYnVnSW5mbyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2Ygbm9kZS50aGVuICYmXG4gICAgICAgICAgICAgIHB1c2hTZXJ2ZXJDb21wb25lbnRTdGFjayh0YXNrLCBub2RlLl9kZWJ1Z0luZm8pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcGxhY2VTdXNwZW5zZUNvbXBvbmVudFN0YWNrV2l0aFN1c3BlbnNlRmFsbGJhY2tTdGFjayhcbiAgICAgIGNvbXBvbmVudFN0YWNrXG4gICAgKSB7XG4gICAgICByZXR1cm4gbnVsbCA9PT0gY29tcG9uZW50U3RhY2tcbiAgICAgICAgPyBudWxsXG4gICAgICAgIDoge1xuICAgICAgICAgICAgcGFyZW50OiBjb21wb25lbnRTdGFjay5wYXJlbnQsXG4gICAgICAgICAgICB0eXBlOiBcIlN1c3BlbnNlIEZhbGxiYWNrXCIsXG4gICAgICAgICAgICBvd25lcjogY29tcG9uZW50U3RhY2sub3duZXIsXG4gICAgICAgICAgICBzdGFjazogY29tcG9uZW50U3RhY2suc3RhY2tcbiAgICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRUaHJvd25JbmZvKG5vZGUkanNjb21wJDApIHtcbiAgICAgIHZhciBlcnJvckluZm8gPSB7fTtcbiAgICAgIG5vZGUkanNjb21wJDAgJiZcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVycm9ySW5mbywgXCJjb21wb25lbnRTdGFja1wiLCB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHZhciBpbmZvID0gXCJcIixcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZSRqc2NvbXAkMDtcbiAgICAgICAgICAgICAgZG9cbiAgICAgICAgICAgICAgICAoaW5mbyArPSBkZXNjcmliZUNvbXBvbmVudFN0YWNrQnlUeXBlKG5vZGUudHlwZSkpLFxuICAgICAgICAgICAgICAgICAgKG5vZGUgPSBub2RlLnBhcmVudCk7XG4gICAgICAgICAgICAgIHdoaWxlIChub2RlKTtcbiAgICAgICAgICAgICAgdmFyIHN0YWNrID0gaW5mbztcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgc3RhY2sgPSBcIlxcbkVycm9yIGdlbmVyYXRpbmcgc3RhY2s6IFwiICsgeC5tZXNzYWdlICsgXCJcXG5cIiArIHguc3RhY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyb3JJbmZvLCBcImNvbXBvbmVudFN0YWNrXCIsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IHN0YWNrXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBzdGFjaztcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgcmV0dXJuIGVycm9ySW5mbztcbiAgICB9XG4gICAgZnVuY3Rpb24gZW5jb2RlRXJyb3JGb3JCb3VuZGFyeShcbiAgICAgIGJvdW5kYXJ5LFxuICAgICAgZGlnZXN0LFxuICAgICAgZXJyb3IsXG4gICAgICB0aHJvd25JbmZvLFxuICAgICAgd2FzQWJvcnRlZFxuICAgICkge1xuICAgICAgYm91bmRhcnkuZXJyb3JEaWdlc3QgPSBkaWdlc3Q7XG4gICAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yXG4gICAgICAgID8gKChkaWdlc3QgPSBTdHJpbmcoZXJyb3IubWVzc2FnZSkpLCAoZXJyb3IgPSBTdHJpbmcoZXJyb3Iuc3RhY2spKSlcbiAgICAgICAgOiAoKGRpZ2VzdCA9XG4gICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgZXJyb3IgJiYgbnVsbCAhPT0gZXJyb3JcbiAgICAgICAgICAgICAgPyBkZXNjcmliZU9iamVjdEZvckVycm9yTWVzc2FnZShlcnJvcilcbiAgICAgICAgICAgICAgOiBTdHJpbmcoZXJyb3IpKSxcbiAgICAgICAgICAoZXJyb3IgPSBudWxsKSk7XG4gICAgICB3YXNBYm9ydGVkID0gd2FzQWJvcnRlZFxuICAgICAgICA/IFwiU3dpdGNoZWQgdG8gY2xpZW50IHJlbmRlcmluZyBiZWNhdXNlIHRoZSBzZXJ2ZXIgcmVuZGVyaW5nIGFib3J0ZWQgZHVlIHRvOlxcblxcblwiXG4gICAgICAgIDogXCJTd2l0Y2hlZCB0byBjbGllbnQgcmVuZGVyaW5nIGJlY2F1c2UgdGhlIHNlcnZlciByZW5kZXJpbmcgZXJyb3JlZDpcXG5cXG5cIjtcbiAgICAgIGJvdW5kYXJ5LmVycm9yTWVzc2FnZSA9IHdhc0Fib3J0ZWQgKyBkaWdlc3Q7XG4gICAgICBib3VuZGFyeS5lcnJvclN0YWNrID0gbnVsbCAhPT0gZXJyb3IgPyB3YXNBYm9ydGVkICsgZXJyb3IgOiBudWxsO1xuICAgICAgYm91bmRhcnkuZXJyb3JDb21wb25lbnRTdGFjayA9IHRocm93bkluZm8uY29tcG9uZW50U3RhY2s7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxvZ1JlY292ZXJhYmxlRXJyb3IocmVxdWVzdCwgZXJyb3IsIGVycm9ySW5mbywgZGVidWdUYXNrKSB7XG4gICAgICByZXF1ZXN0ID0gcmVxdWVzdC5vbkVycm9yO1xuICAgICAgZXJyb3IgPSBkZWJ1Z1Rhc2tcbiAgICAgICAgPyBkZWJ1Z1Rhc2sucnVuKHJlcXVlc3QuYmluZChudWxsLCBlcnJvciwgZXJyb3JJbmZvKSlcbiAgICAgICAgOiByZXF1ZXN0KGVycm9yLCBlcnJvckluZm8pO1xuICAgICAgaWYgKG51bGwgIT0gZXJyb3IgJiYgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIGVycm9yKVxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICdvbkVycm9yIHJldHVybmVkIHNvbWV0aGluZyB3aXRoIGEgdHlwZSBvdGhlciB0aGFuIFwic3RyaW5nXCIuIG9uRXJyb3Igc2hvdWxkIHJldHVybiBhIHN0cmluZyBhbmQgbWF5IHJldHVybiBudWxsIG9yIHVuZGVmaW5lZCBidXQgbXVzdCBub3QgcmV0dXJuIGFueXRoaW5nIGVsc2UuIEl0IHJlY2VpdmVkIHNvbWV0aGluZyBvZiB0eXBlIFwiJXNcIiBpbnN0ZWFkJyxcbiAgICAgICAgICB0eXBlb2YgZXJyb3JcbiAgICAgICAgKTtcbiAgICAgIGVsc2UgcmV0dXJuIGVycm9yO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmYXRhbEVycm9yKHJlcXVlc3QsIGVycm9yLCBlcnJvckluZm8sIGRlYnVnVGFzaykge1xuICAgICAgZXJyb3JJbmZvID0gcmVxdWVzdC5vblNoZWxsRXJyb3I7XG4gICAgICB2YXIgb25GYXRhbEVycm9yID0gcmVxdWVzdC5vbkZhdGFsRXJyb3I7XG4gICAgICBkZWJ1Z1Rhc2tcbiAgICAgICAgPyAoZGVidWdUYXNrLnJ1bihlcnJvckluZm8uYmluZChudWxsLCBlcnJvcikpLFxuICAgICAgICAgIGRlYnVnVGFzay5ydW4ob25GYXRhbEVycm9yLmJpbmQobnVsbCwgZXJyb3IpKSlcbiAgICAgICAgOiAoZXJyb3JJbmZvKGVycm9yKSwgb25GYXRhbEVycm9yKGVycm9yKSk7XG4gICAgICBudWxsICE9PSByZXF1ZXN0LmRlc3RpbmF0aW9uXG4gICAgICAgID8gKChyZXF1ZXN0LnN0YXR1cyA9IENMT1NFRCksIHJlcXVlc3QuZGVzdGluYXRpb24uZGVzdHJveShlcnJvcikpXG4gICAgICAgIDogKChyZXF1ZXN0LnN0YXR1cyA9IDEzKSwgKHJlcXVlc3QuZmF0YWxFcnJvciA9IGVycm9yKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmlzaFN1c3BlbnNlTGlzdFJvdyhyZXF1ZXN0LCByb3cpIHtcbiAgICAgIHVuYmxvY2tTdXNwZW5zZUxpc3RSb3cocmVxdWVzdCwgcm93Lm5leHQsIHJvdy5ob2lzdGFibGVzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdW5ibG9ja1N1c3BlbnNlTGlzdFJvdyhcbiAgICAgIHJlcXVlc3QsXG4gICAgICB1bmJsb2NrZWRSb3csXG4gICAgICBpbmhlcml0ZWRIb2lzdGFibGVzXG4gICAgKSB7XG4gICAgICBmb3IgKDsgbnVsbCAhPT0gdW5ibG9ja2VkUm93OyApIHtcbiAgICAgICAgbnVsbCAhPT0gaW5oZXJpdGVkSG9pc3RhYmxlcyAmJlxuICAgICAgICAgIChob2lzdEhvaXN0YWJsZXModW5ibG9ja2VkUm93LmhvaXN0YWJsZXMsIGluaGVyaXRlZEhvaXN0YWJsZXMpLFxuICAgICAgICAgICh1bmJsb2NrZWRSb3cuaW5oZXJpdGVkSG9pc3RhYmxlcyA9IGluaGVyaXRlZEhvaXN0YWJsZXMpKTtcbiAgICAgICAgdmFyIHVuYmxvY2tlZEJvdW5kYXJpZXMgPSB1bmJsb2NrZWRSb3cuYm91bmRhcmllcztcbiAgICAgICAgaWYgKG51bGwgIT09IHVuYmxvY2tlZEJvdW5kYXJpZXMpIHtcbiAgICAgICAgICB1bmJsb2NrZWRSb3cuYm91bmRhcmllcyA9IG51bGw7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1bmJsb2NrZWRCb3VuZGFyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdW5ibG9ja2VkQm91bmRhcnkgPSB1bmJsb2NrZWRCb3VuZGFyaWVzW2ldO1xuICAgICAgICAgICAgbnVsbCAhPT0gaW5oZXJpdGVkSG9pc3RhYmxlcyAmJlxuICAgICAgICAgICAgICBob2lzdEhvaXN0YWJsZXMoXG4gICAgICAgICAgICAgICAgdW5ibG9ja2VkQm91bmRhcnkuY29udGVudFN0YXRlLFxuICAgICAgICAgICAgICAgIGluaGVyaXRlZEhvaXN0YWJsZXNcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGZpbmlzaGVkVGFzayhyZXF1ZXN0LCB1bmJsb2NrZWRCb3VuZGFyeSwgbnVsbCwgbnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHVuYmxvY2tlZFJvdy5wZW5kaW5nVGFza3MtLTtcbiAgICAgICAgaWYgKDAgPCB1bmJsb2NrZWRSb3cucGVuZGluZ1Rhc2tzKSBicmVhaztcbiAgICAgICAgaW5oZXJpdGVkSG9pc3RhYmxlcyA9IHVuYmxvY2tlZFJvdy5ob2lzdGFibGVzO1xuICAgICAgICB1bmJsb2NrZWRSb3cgPSB1bmJsb2NrZWRSb3cubmV4dDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdHJ5VG9SZXNvbHZlVG9nZXRoZXJSb3cocmVxdWVzdCwgdG9nZXRoZXJSb3cpIHtcbiAgICAgIHZhciBib3VuZGFyaWVzID0gdG9nZXRoZXJSb3cuYm91bmRhcmllcztcbiAgICAgIGlmIChcbiAgICAgICAgbnVsbCAhPT0gYm91bmRhcmllcyAmJlxuICAgICAgICB0b2dldGhlclJvdy5wZW5kaW5nVGFza3MgPT09IGJvdW5kYXJpZXMubGVuZ3RoXG4gICAgICApIHtcbiAgICAgICAgZm9yIChcbiAgICAgICAgICB2YXIgYWxsQ29tcGxldGVBbmRJbmxpbmFibGUgPSAhMCwgaSA9IDA7XG4gICAgICAgICAgaSA8IGJvdW5kYXJpZXMubGVuZ3RoO1xuICAgICAgICAgIGkrK1xuICAgICAgICApIHtcbiAgICAgICAgICB2YXIgcm93Qm91bmRhcnkgPSBib3VuZGFyaWVzW2ldO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIDEgIT09IHJvd0JvdW5kYXJ5LnBlbmRpbmdUYXNrcyB8fFxuICAgICAgICAgICAgcm93Qm91bmRhcnkucGFyZW50Rmx1c2hlZCB8fFxuICAgICAgICAgICAgaXNFbGlnaWJsZUZvck91dGxpbmluZyhyZXF1ZXN0LCByb3dCb3VuZGFyeSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGFsbENvbXBsZXRlQW5kSW5saW5hYmxlID0gITE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYWxsQ29tcGxldGVBbmRJbmxpbmFibGUgJiZcbiAgICAgICAgICB1bmJsb2NrU3VzcGVuc2VMaXN0Um93KHJlcXVlc3QsIHRvZ2V0aGVyUm93LCB0b2dldGhlclJvdy5ob2lzdGFibGVzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlU3VzcGVuc2VMaXN0Um93KHByZXZpb3VzUm93KSB7XG4gICAgICB2YXIgbmV3Um93ID0ge1xuICAgICAgICBwZW5kaW5nVGFza3M6IDEsXG4gICAgICAgIGJvdW5kYXJpZXM6IG51bGwsXG4gICAgICAgIGhvaXN0YWJsZXM6IGNyZWF0ZUhvaXN0YWJsZVN0YXRlKCksXG4gICAgICAgIGluaGVyaXRlZEhvaXN0YWJsZXM6IG51bGwsXG4gICAgICAgIHRvZ2V0aGVyOiAhMSxcbiAgICAgICAgbmV4dDogbnVsbFxuICAgICAgfTtcbiAgICAgIG51bGwgIT09IHByZXZpb3VzUm93ICYmXG4gICAgICAgIDAgPCBwcmV2aW91c1Jvdy5wZW5kaW5nVGFza3MgJiZcbiAgICAgICAgKG5ld1Jvdy5wZW5kaW5nVGFza3MrKyxcbiAgICAgICAgKG5ld1Jvdy5ib3VuZGFyaWVzID0gW10pLFxuICAgICAgICAocHJldmlvdXNSb3cubmV4dCA9IG5ld1JvdykpO1xuICAgICAgcmV0dXJuIG5ld1JvdztcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVuZGVyU3VzcGVuc2VMaXN0Um93cyhyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCByb3dzLCByZXZlYWxPcmRlcikge1xuICAgICAgdmFyIHByZXZLZXlQYXRoID0gdGFzay5rZXlQYXRoLFxuICAgICAgICBwcmV2VHJlZUNvbnRleHQgPSB0YXNrLnRyZWVDb250ZXh0LFxuICAgICAgICBwcmV2Um93ID0gdGFzay5yb3csXG4gICAgICAgIHByZXZpb3VzQ29tcG9uZW50U3RhY2sgPSB0YXNrLmNvbXBvbmVudFN0YWNrO1xuICAgICAgdmFyIHByZXZpb3VzRGVidWdUYXNrID0gdGFzay5kZWJ1Z1Rhc2s7XG4gICAgICBwdXNoU2VydmVyQ29tcG9uZW50U3RhY2sodGFzaywgdGFzay5ub2RlLnByb3BzLmNoaWxkcmVuLl9kZWJ1Z0luZm8pO1xuICAgICAgdGFzay5rZXlQYXRoID0ga2V5UGF0aDtcbiAgICAgIGtleVBhdGggPSByb3dzLmxlbmd0aDtcbiAgICAgIHZhciBwcmV2aW91c1N1c3BlbnNlTGlzdFJvdyA9IG51bGw7XG4gICAgICBpZiAobnVsbCAhPT0gdGFzay5yZXBsYXkpIHtcbiAgICAgICAgdmFyIHJlc3VtZVNsb3RzID0gdGFzay5yZXBsYXkuc2xvdHM7XG4gICAgICAgIGlmIChudWxsICE9PSByZXN1bWVTbG90cyAmJiBcIm9iamVjdFwiID09PSB0eXBlb2YgcmVzdW1lU2xvdHMpXG4gICAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBrZXlQYXRoOyBuKyspIHtcbiAgICAgICAgICAgIHZhciBpID1cbiAgICAgICAgICAgICAgICBcImJhY2t3YXJkc1wiICE9PSByZXZlYWxPcmRlciAmJlxuICAgICAgICAgICAgICAgIFwidW5zdGFibGVfbGVnYWN5LWJhY2t3YXJkc1wiICE9PSByZXZlYWxPcmRlclxuICAgICAgICAgICAgICAgICAgPyBuXG4gICAgICAgICAgICAgICAgICA6IGtleVBhdGggLSAxIC0gbixcbiAgICAgICAgICAgICAgbm9kZSA9IHJvd3NbaV07XG4gICAgICAgICAgICB0YXNrLnJvdyA9IHByZXZpb3VzU3VzcGVuc2VMaXN0Um93ID0gY3JlYXRlU3VzcGVuc2VMaXN0Um93KFxuICAgICAgICAgICAgICBwcmV2aW91c1N1c3BlbnNlTGlzdFJvd1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRhc2sudHJlZUNvbnRleHQgPSBwdXNoVHJlZUNvbnRleHQocHJldlRyZWVDb250ZXh0LCBrZXlQYXRoLCBpKTtcbiAgICAgICAgICAgIHZhciByZXN1bWVTZWdtZW50SUQgPSByZXN1bWVTbG90c1tpXTtcbiAgICAgICAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiByZXN1bWVTZWdtZW50SURcbiAgICAgICAgICAgICAgPyAocmVzdW1lTm9kZShyZXF1ZXN0LCB0YXNrLCByZXN1bWVTZWdtZW50SUQsIG5vZGUsIGkpLFxuICAgICAgICAgICAgICAgIGRlbGV0ZSByZXN1bWVTbG90c1tpXSlcbiAgICAgICAgICAgICAgOiByZW5kZXJOb2RlKHJlcXVlc3QsIHRhc2ssIG5vZGUsIGkpO1xuICAgICAgICAgICAgMCA9PT0gLS1wcmV2aW91c1N1c3BlbnNlTGlzdFJvdy5wZW5kaW5nVGFza3MgJiZcbiAgICAgICAgICAgICAgZmluaXNoU3VzcGVuc2VMaXN0Um93KHJlcXVlc3QsIHByZXZpb3VzU3VzcGVuc2VMaXN0Um93KTtcbiAgICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBmb3IgKHJlc3VtZVNsb3RzID0gMDsgcmVzdW1lU2xvdHMgPCBrZXlQYXRoOyByZXN1bWVTbG90cysrKVxuICAgICAgICAgICAgKG4gPVxuICAgICAgICAgICAgICBcImJhY2t3YXJkc1wiICE9PSByZXZlYWxPcmRlciAmJlxuICAgICAgICAgICAgICBcInVuc3RhYmxlX2xlZ2FjeS1iYWNrd2FyZHNcIiAhPT0gcmV2ZWFsT3JkZXJcbiAgICAgICAgICAgICAgICA/IHJlc3VtZVNsb3RzXG4gICAgICAgICAgICAgICAgOiBrZXlQYXRoIC0gMSAtIHJlc3VtZVNsb3RzKSxcbiAgICAgICAgICAgICAgKGkgPSByb3dzW25dKSxcbiAgICAgICAgICAgICAgd2FybkZvck1pc3NpbmdLZXkocmVxdWVzdCwgdGFzaywgaSksXG4gICAgICAgICAgICAgICh0YXNrLnJvdyA9IHByZXZpb3VzU3VzcGVuc2VMaXN0Um93ID1cbiAgICAgICAgICAgICAgICBjcmVhdGVTdXNwZW5zZUxpc3RSb3cocHJldmlvdXNTdXNwZW5zZUxpc3RSb3cpKSxcbiAgICAgICAgICAgICAgKHRhc2sudHJlZUNvbnRleHQgPSBwdXNoVHJlZUNvbnRleHQocHJldlRyZWVDb250ZXh0LCBrZXlQYXRoLCBuKSksXG4gICAgICAgICAgICAgIHJlbmRlck5vZGUocmVxdWVzdCwgdGFzaywgaSwgbiksXG4gICAgICAgICAgICAgIDAgPT09IC0tcHJldmlvdXNTdXNwZW5zZUxpc3RSb3cucGVuZGluZ1Rhc2tzICYmXG4gICAgICAgICAgICAgICAgZmluaXNoU3VzcGVuc2VMaXN0Um93KHJlcXVlc3QsIHByZXZpb3VzU3VzcGVuc2VMaXN0Um93KTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIFwiYmFja3dhcmRzXCIgIT09IHJldmVhbE9yZGVyICYmXG4gICAgICAgIFwidW5zdGFibGVfbGVnYWN5LWJhY2t3YXJkc1wiICE9PSByZXZlYWxPcmRlclxuICAgICAgKVxuICAgICAgICBmb3IgKHJldmVhbE9yZGVyID0gMDsgcmV2ZWFsT3JkZXIgPCBrZXlQYXRoOyByZXZlYWxPcmRlcisrKVxuICAgICAgICAgIChyZXN1bWVTbG90cyA9IHJvd3NbcmV2ZWFsT3JkZXJdKSxcbiAgICAgICAgICAgIHdhcm5Gb3JNaXNzaW5nS2V5KHJlcXVlc3QsIHRhc2ssIHJlc3VtZVNsb3RzKSxcbiAgICAgICAgICAgICh0YXNrLnJvdyA9IHByZXZpb3VzU3VzcGVuc2VMaXN0Um93ID1cbiAgICAgICAgICAgICAgY3JlYXRlU3VzcGVuc2VMaXN0Um93KHByZXZpb3VzU3VzcGVuc2VMaXN0Um93KSksXG4gICAgICAgICAgICAodGFzay50cmVlQ29udGV4dCA9IHB1c2hUcmVlQ29udGV4dChcbiAgICAgICAgICAgICAgcHJldlRyZWVDb250ZXh0LFxuICAgICAgICAgICAgICBrZXlQYXRoLFxuICAgICAgICAgICAgICByZXZlYWxPcmRlclxuICAgICAgICAgICAgKSksXG4gICAgICAgICAgICByZW5kZXJOb2RlKHJlcXVlc3QsIHRhc2ssIHJlc3VtZVNsb3RzLCByZXZlYWxPcmRlciksXG4gICAgICAgICAgICAwID09PSAtLXByZXZpb3VzU3VzcGVuc2VMaXN0Um93LnBlbmRpbmdUYXNrcyAmJlxuICAgICAgICAgICAgICBmaW5pc2hTdXNwZW5zZUxpc3RSb3cocmVxdWVzdCwgcHJldmlvdXNTdXNwZW5zZUxpc3RSb3cpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHJldmVhbE9yZGVyID0gdGFzay5ibG9ja2VkU2VnbWVudDtcbiAgICAgICAgcmVzdW1lU2xvdHMgPSByZXZlYWxPcmRlci5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgIG4gPSByZXZlYWxPcmRlci5jaHVua3MubGVuZ3RoO1xuICAgICAgICBmb3IgKGkgPSBrZXlQYXRoIC0gMTsgMCA8PSBpOyBpLS0pIHtcbiAgICAgICAgICBub2RlID0gcm93c1tpXTtcbiAgICAgICAgICB0YXNrLnJvdyA9IHByZXZpb3VzU3VzcGVuc2VMaXN0Um93ID0gY3JlYXRlU3VzcGVuc2VMaXN0Um93KFxuICAgICAgICAgICAgcHJldmlvdXNTdXNwZW5zZUxpc3RSb3dcbiAgICAgICAgICApO1xuICAgICAgICAgIHRhc2sudHJlZUNvbnRleHQgPSBwdXNoVHJlZUNvbnRleHQocHJldlRyZWVDb250ZXh0LCBrZXlQYXRoLCBpKTtcbiAgICAgICAgICByZXN1bWVTZWdtZW50SUQgPSBjcmVhdGVQZW5kaW5nU2VnbWVudChcbiAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICBuLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHRhc2suZm9ybWF0Q29udGV4dCxcbiAgICAgICAgICAgIDAgPT09IGkgPyByZXZlYWxPcmRlci5sYXN0UHVzaGVkVGV4dCA6ICEwLFxuICAgICAgICAgICAgITBcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldmVhbE9yZGVyLmNoaWxkcmVuLnNwbGljZShyZXN1bWVTbG90cywgMCwgcmVzdW1lU2VnbWVudElEKTtcbiAgICAgICAgICB0YXNrLmJsb2NrZWRTZWdtZW50ID0gcmVzdW1lU2VnbWVudElEO1xuICAgICAgICAgIHdhcm5Gb3JNaXNzaW5nS2V5KHJlcXVlc3QsIHRhc2ssIG5vZGUpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZW5kZXJOb2RlKHJlcXVlc3QsIHRhc2ssIG5vZGUsIGkpLFxuICAgICAgICAgICAgICBwdXNoU2VnbWVudEZpbmFsZShcbiAgICAgICAgICAgICAgICByZXN1bWVTZWdtZW50SUQuY2h1bmtzLFxuICAgICAgICAgICAgICAgIHJlcXVlc3QucmVuZGVyU3RhdGUsXG4gICAgICAgICAgICAgICAgcmVzdW1lU2VnbWVudElELmxhc3RQdXNoZWRUZXh0LFxuICAgICAgICAgICAgICAgIHJlc3VtZVNlZ21lbnRJRC50ZXh0RW1iZWRkZWRcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgKHJlc3VtZVNlZ21lbnRJRC5zdGF0dXMgPSBDT01QTEVURUQpLFxuICAgICAgICAgICAgICAwID09PSAtLXByZXZpb3VzU3VzcGVuc2VMaXN0Um93LnBlbmRpbmdUYXNrcyAmJlxuICAgICAgICAgICAgICAgIGZpbmlzaFN1c3BlbnNlTGlzdFJvdyhyZXF1ZXN0LCBwcmV2aW91c1N1c3BlbnNlTGlzdFJvdyk7XG4gICAgICAgICAgfSBjYXRjaCAodGhyb3duVmFsdWUpIHtcbiAgICAgICAgICAgIHRocm93IChcbiAgICAgICAgICAgICAgKChyZXN1bWVTZWdtZW50SUQuc3RhdHVzID1cbiAgICAgICAgICAgICAgICAxMiA9PT0gcmVxdWVzdC5zdGF0dXMgPyBBQk9SVEVEIDogRVJST1JFRCksXG4gICAgICAgICAgICAgIHRocm93blZhbHVlKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGFzay5ibG9ja2VkU2VnbWVudCA9IHJldmVhbE9yZGVyO1xuICAgICAgICByZXZlYWxPcmRlci5sYXN0UHVzaGVkVGV4dCA9ICExO1xuICAgICAgfVxuICAgICAgbnVsbCAhPT0gcHJldlJvdyAmJlxuICAgICAgICBudWxsICE9PSBwcmV2aW91c1N1c3BlbnNlTGlzdFJvdyAmJlxuICAgICAgICAwIDwgcHJldmlvdXNTdXNwZW5zZUxpc3RSb3cucGVuZGluZ1Rhc2tzICYmXG4gICAgICAgIChwcmV2Um93LnBlbmRpbmdUYXNrcysrLCAocHJldmlvdXNTdXNwZW5zZUxpc3RSb3cubmV4dCA9IHByZXZSb3cpKTtcbiAgICAgIHRhc2sudHJlZUNvbnRleHQgPSBwcmV2VHJlZUNvbnRleHQ7XG4gICAgICB0YXNrLnJvdyA9IHByZXZSb3c7XG4gICAgICB0YXNrLmtleVBhdGggPSBwcmV2S2V5UGF0aDtcbiAgICAgIHRhc2suY29tcG9uZW50U3RhY2sgPSBwcmV2aW91c0NvbXBvbmVudFN0YWNrO1xuICAgICAgdGFzay5kZWJ1Z1Rhc2sgPSBwcmV2aW91c0RlYnVnVGFzaztcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVuZGVyV2l0aEhvb2tzKFxuICAgICAgcmVxdWVzdCxcbiAgICAgIHRhc2ssXG4gICAgICBrZXlQYXRoLFxuICAgICAgQ29tcG9uZW50LFxuICAgICAgcHJvcHMsXG4gICAgICBzZWNvbmRBcmdcbiAgICApIHtcbiAgICAgIHZhciBwcmV2VGhlbmFibGVTdGF0ZSA9IHRhc2sudGhlbmFibGVTdGF0ZTtcbiAgICAgIHRhc2sudGhlbmFibGVTdGF0ZSA9IG51bGw7XG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQgPSB7fTtcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ1Rhc2sgPSB0YXNrO1xuICAgICAgY3VycmVudGx5UmVuZGVyaW5nUmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdLZXlQYXRoID0ga2V5UGF0aDtcbiAgICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9ICExO1xuICAgICAgYWN0aW9uU3RhdGVDb3VudGVyID0gbG9jYWxJZENvdW50ZXIgPSAwO1xuICAgICAgYWN0aW9uU3RhdGVNYXRjaGluZ0luZGV4ID0gLTE7XG4gICAgICB0aGVuYWJsZUluZGV4Q291bnRlciA9IDA7XG4gICAgICB0aGVuYWJsZVN0YXRlID0gcHJldlRoZW5hYmxlU3RhdGU7XG4gICAgICBmb3IgKFxuICAgICAgICByZXF1ZXN0ID0gY2FsbENvbXBvbmVudEluREVWKENvbXBvbmVudCwgcHJvcHMsIHNlY29uZEFyZyk7XG4gICAgICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGU7XG5cbiAgICAgIClcbiAgICAgICAgKGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSAhMSksXG4gICAgICAgICAgKGFjdGlvblN0YXRlQ291bnRlciA9IGxvY2FsSWRDb3VudGVyID0gMCksXG4gICAgICAgICAgKGFjdGlvblN0YXRlTWF0Y2hpbmdJbmRleCA9IC0xKSxcbiAgICAgICAgICAodGhlbmFibGVJbmRleENvdW50ZXIgPSAwKSxcbiAgICAgICAgICAobnVtYmVyT2ZSZVJlbmRlcnMgKz0gMSksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzSG9vayA9IG51bGwpLFxuICAgICAgICAgIChyZXF1ZXN0ID0gQ29tcG9uZW50KHByb3BzLCBzZWNvbmRBcmcpKTtcbiAgICAgIHJlc2V0SG9va3NTdGF0ZSgpO1xuICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmlzaEZ1bmN0aW9uQ29tcG9uZW50KFxuICAgICAgcmVxdWVzdCxcbiAgICAgIHRhc2ssXG4gICAgICBrZXlQYXRoLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBoYXNJZCxcbiAgICAgIGFjdGlvblN0YXRlQ291bnQsXG4gICAgICBhY3Rpb25TdGF0ZU1hdGNoaW5nSW5kZXhcbiAgICApIHtcbiAgICAgIHZhciBkaWRFbWl0QWN0aW9uU3RhdGVNYXJrZXJzID0gITE7XG4gICAgICBpZiAoMCAhPT0gYWN0aW9uU3RhdGVDb3VudCAmJiBudWxsICE9PSByZXF1ZXN0LmZvcm1TdGF0ZSkge1xuICAgICAgICB2YXIgc2VnbWVudCA9IHRhc2suYmxvY2tlZFNlZ21lbnQ7XG4gICAgICAgIGlmIChudWxsICE9PSBzZWdtZW50KSB7XG4gICAgICAgICAgZGlkRW1pdEFjdGlvblN0YXRlTWFya2VycyA9ICEwO1xuICAgICAgICAgIHNlZ21lbnQgPSBzZWdtZW50LmNodW5rcztcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFjdGlvblN0YXRlQ291bnQ7IGkrKylcbiAgICAgICAgICAgIGkgPT09IGFjdGlvblN0YXRlTWF0Y2hpbmdJbmRleFxuICAgICAgICAgICAgICA/IHNlZ21lbnQucHVzaChcIlxceDNjIS0tRiEtLVxceDNlXCIpXG4gICAgICAgICAgICAgIDogc2VnbWVudC5wdXNoKFwiXFx4M2MhLS1GLS1cXHgzZVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYWN0aW9uU3RhdGVDb3VudCA9IHRhc2sua2V5UGF0aDtcbiAgICAgIHRhc2sua2V5UGF0aCA9IGtleVBhdGg7XG4gICAgICBoYXNJZFxuICAgICAgICA/ICgoa2V5UGF0aCA9IHRhc2sudHJlZUNvbnRleHQpLFxuICAgICAgICAgICh0YXNrLnRyZWVDb250ZXh0ID0gcHVzaFRyZWVDb250ZXh0KGtleVBhdGgsIDEsIDApKSxcbiAgICAgICAgICByZW5kZXJOb2RlKHJlcXVlc3QsIHRhc2ssIGNoaWxkcmVuLCAtMSksXG4gICAgICAgICAgKHRhc2sudHJlZUNvbnRleHQgPSBrZXlQYXRoKSlcbiAgICAgICAgOiBkaWRFbWl0QWN0aW9uU3RhdGVNYXJrZXJzXG4gICAgICAgICAgPyByZW5kZXJOb2RlKHJlcXVlc3QsIHRhc2ssIGNoaWxkcmVuLCAtMSlcbiAgICAgICAgICA6IHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBjaGlsZHJlbiwgLTEpO1xuICAgICAgdGFzay5rZXlQYXRoID0gYWN0aW9uU3RhdGVDb3VudDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVuZGVyRWxlbWVudChyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCB0eXBlLCBwcm9wcywgcmVmKSB7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgaWYgKHR5cGUucHJvdG90eXBlICYmIHR5cGUucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpIHtcbiAgICAgICAgICB2YXIgbmV3UHJvcHMgPSBwcm9wcztcbiAgICAgICAgICBpZiAoXCJyZWZcIiBpbiBwcm9wcykge1xuICAgICAgICAgICAgbmV3UHJvcHMgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIHByb3BOYW1lIGluIHByb3BzKVxuICAgICAgICAgICAgICBcInJlZlwiICE9PSBwcm9wTmFtZSAmJiAobmV3UHJvcHNbcHJvcE5hbWVdID0gcHJvcHNbcHJvcE5hbWVdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuICAgICAgICAgIGlmIChkZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgICAgIG5ld1Byb3BzID09PSBwcm9wcyAmJiAobmV3UHJvcHMgPSBhc3NpZ24oe30sIG5ld1Byb3BzLCBwcm9wcykpO1xuICAgICAgICAgICAgZm9yICh2YXIgX3Byb3BOYW1lIGluIGRlZmF1bHRQcm9wcylcbiAgICAgICAgICAgICAgdm9pZCAwID09PSBuZXdQcm9wc1tfcHJvcE5hbWVdICYmXG4gICAgICAgICAgICAgICAgKG5ld1Byb3BzW19wcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbX3Byb3BOYW1lXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByZXNvbHZlZFByb3BzID0gbmV3UHJvcHM7XG4gICAgICAgICAgdmFyIGNvbnRleHQgPSBlbXB0eUNvbnRleHRPYmplY3QsXG4gICAgICAgICAgICBjb250ZXh0VHlwZSA9IHR5cGUuY29udGV4dFR5cGU7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgXCJjb250ZXh0VHlwZVwiIGluIHR5cGUgJiZcbiAgICAgICAgICAgIG51bGwgIT09IGNvbnRleHRUeXBlICYmXG4gICAgICAgICAgICAodm9pZCAwID09PSBjb250ZXh0VHlwZSB8fFxuICAgICAgICAgICAgICBjb250ZXh0VHlwZS4kJHR5cGVvZiAhPT0gUkVBQ1RfQ09OVEVYVF9UWVBFKSAmJlxuICAgICAgICAgICAgIWRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZS5oYXModHlwZSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZS5hZGQodHlwZSk7XG4gICAgICAgICAgICB2YXIgYWRkZW5kdW0gPVxuICAgICAgICAgICAgICB2b2lkIDAgPT09IGNvbnRleHRUeXBlXG4gICAgICAgICAgICAgICAgPyBcIiBIb3dldmVyLCBpdCBpcyBzZXQgdG8gdW5kZWZpbmVkLiBUaGlzIGNhbiBiZSBjYXVzZWQgYnkgYSB0eXBvIG9yIGJ5IG1peGluZyB1cCBuYW1lZCBhbmQgZGVmYXVsdCBpbXBvcnRzLiBUaGlzIGNhbiBhbHNvIGhhcHBlbiBkdWUgdG8gYSBjaXJjdWxhciBkZXBlbmRlbmN5LCBzbyB0cnkgbW92aW5nIHRoZSBjcmVhdGVDb250ZXh0KCkgY2FsbCB0byBhIHNlcGFyYXRlIGZpbGUuXCJcbiAgICAgICAgICAgICAgICA6IFwib2JqZWN0XCIgIT09IHR5cGVvZiBjb250ZXh0VHlwZVxuICAgICAgICAgICAgICAgICAgPyBcIiBIb3dldmVyLCBpdCBpcyBzZXQgdG8gYSBcIiArIHR5cGVvZiBjb250ZXh0VHlwZSArIFwiLlwiXG4gICAgICAgICAgICAgICAgICA6IGNvbnRleHRUeXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05TVU1FUl9UWVBFXG4gICAgICAgICAgICAgICAgICAgID8gXCIgRGlkIHlvdSBhY2NpZGVudGFsbHkgcGFzcyB0aGUgQ29udGV4dC5Db25zdW1lciBpbnN0ZWFkP1wiXG4gICAgICAgICAgICAgICAgICAgIDogXCIgSG93ZXZlciwgaXQgaXMgc2V0IHRvIGFuIG9iamVjdCB3aXRoIGtleXMge1wiICtcbiAgICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhjb250ZXh0VHlwZSkuam9pbihcIiwgXCIpICtcbiAgICAgICAgICAgICAgICAgICAgICBcIn0uXCI7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIiVzIGRlZmluZXMgYW4gaW52YWxpZCBjb250ZXh0VHlwZS4gY29udGV4dFR5cGUgc2hvdWxkIHBvaW50IHRvIHRoZSBDb250ZXh0IG9iamVjdCByZXR1cm5lZCBieSBSZWFjdC5jcmVhdGVDb250ZXh0KCkuJXNcIixcbiAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHx8IFwiQ29tcG9uZW50XCIsXG4gICAgICAgICAgICAgIGFkZGVuZHVtXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgY29udGV4dFR5cGUgJiZcbiAgICAgICAgICAgIG51bGwgIT09IGNvbnRleHRUeXBlICYmXG4gICAgICAgICAgICAoY29udGV4dCA9IGNvbnRleHRUeXBlLl9jdXJyZW50VmFsdWUyKTtcbiAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgdHlwZShyZXNvbHZlZFByb3BzLCBjb250ZXh0KTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyAmJlxuICAgICAgICAgICAgKG51bGwgPT09IGluc3RhbmNlLnN0YXRlIHx8IHZvaWQgMCA9PT0gaW5zdGFuY2Uuc3RhdGUpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB8fCBcIkNvbXBvbmVudFwiO1xuICAgICAgICAgICAgZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlLmhhcyhjb21wb25lbnROYW1lKSB8fFxuICAgICAgICAgICAgICAoZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlLmFkZChjb21wb25lbnROYW1lKSxcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcImAlc2AgdXNlcyBgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzYCBidXQgaXRzIGluaXRpYWwgc3RhdGUgaXMgJXMuIFRoaXMgaXMgbm90IHJlY29tbWVuZGVkLiBJbnN0ZWFkLCBkZWZpbmUgdGhlIGluaXRpYWwgc3RhdGUgYnkgYXNzaWduaW5nIGFuIG9iamVjdCB0byBgdGhpcy5zdGF0ZWAgaW4gdGhlIGNvbnN0cnVjdG9yIG9mIGAlc2AuIFRoaXMgZW5zdXJlcyB0aGF0IGBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNgIGFyZ3VtZW50cyBoYXZlIGEgY29uc2lzdGVudCBzaGFwZS5cIixcbiAgICAgICAgICAgICAgICBjb21wb25lbnROYW1lLFxuICAgICAgICAgICAgICAgIG51bGwgPT09IGluc3RhbmNlLnN0YXRlID8gXCJudWxsXCIgOiBcInVuZGVmaW5lZFwiLFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIHx8XG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdmFyIGZvdW5kV2lsbE1vdW50TmFtZSA9IG51bGwsXG4gICAgICAgICAgICAgIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgPSBudWxsLFxuICAgICAgICAgICAgICBmb3VuZFdpbGxVcGRhdGVOYW1lID0gbnVsbDtcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCAmJlxuICAgICAgICAgICAgITAgIT09IGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudC5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nXG4gICAgICAgICAgICAgID8gKGZvdW5kV2lsbE1vdW50TmFtZSA9IFwiY29tcG9uZW50V2lsbE1vdW50XCIpXG4gICAgICAgICAgICAgIDogXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCAmJlxuICAgICAgICAgICAgICAgIChmb3VuZFdpbGxNb3VudE5hbWUgPSBcIlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnRcIik7XG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzICYmXG4gICAgICAgICAgICAhMCAhPT1cbiAgICAgICAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcy5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nXG4gICAgICAgICAgICAgID8gKGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgPSBcImNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNcIilcbiAgICAgICAgICAgICAgOiBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgICAgICAgICAgICB0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgJiZcbiAgICAgICAgICAgICAgICAoZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSA9XG4gICAgICAgICAgICAgICAgICBcIlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzXCIpO1xuICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZSAmJlxuICAgICAgICAgICAgITAgIT09IGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ1xuICAgICAgICAgICAgICA/IChmb3VuZFdpbGxVcGRhdGVOYW1lID0gXCJjb21wb25lbnRXaWxsVXBkYXRlXCIpXG4gICAgICAgICAgICAgIDogXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgJiZcbiAgICAgICAgICAgICAgICAoZm91bmRXaWxsVXBkYXRlTmFtZSA9IFwiVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGVcIik7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIG51bGwgIT09IGZvdW5kV2lsbE1vdW50TmFtZSB8fFxuICAgICAgICAgICAgICBudWxsICE9PSBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lIHx8XG4gICAgICAgICAgICAgIG51bGwgIT09IGZvdW5kV2lsbFVwZGF0ZU5hbWVcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICB2YXIgX2NvbXBvbmVudE5hbWUgPVxuICAgICAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHx8IFwiQ29tcG9uZW50XCIsXG4gICAgICAgICAgICAgICAgbmV3QXBpTmFtZSA9XG4gICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc1xuICAgICAgICAgICAgICAgICAgICA/IFwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKClcIlxuICAgICAgICAgICAgICAgICAgICA6IFwiZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKVwiO1xuICAgICAgICAgICAgICBkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlLmhhcyhfY29tcG9uZW50TmFtZSkgfHxcbiAgICAgICAgICAgICAgICAoZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZS5hZGQoXG4gICAgICAgICAgICAgICAgICBfY29tcG9uZW50TmFtZVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiVW5zYWZlIGxlZ2FjeSBsaWZlY3ljbGVzIHdpbGwgbm90IGJlIGNhbGxlZCBmb3IgY29tcG9uZW50cyB1c2luZyBuZXcgY29tcG9uZW50IEFQSXMuXFxuXFxuJXMgdXNlcyAlcyBidXQgYWxzbyBjb250YWlucyB0aGUgZm9sbG93aW5nIGxlZ2FjeSBsaWZlY3ljbGVzOiVzJXMlc1xcblxcblRoZSBhYm92ZSBsaWZlY3ljbGVzIHNob3VsZCBiZSByZW1vdmVkLiBMZWFybiBtb3JlIGFib3V0IHRoaXMgd2FybmluZyBoZXJlOlxcbmh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzXCIsXG4gICAgICAgICAgICAgICAgICBfY29tcG9uZW50TmFtZSxcbiAgICAgICAgICAgICAgICAgIG5ld0FwaU5hbWUsXG4gICAgICAgICAgICAgICAgICBudWxsICE9PSBmb3VuZFdpbGxNb3VudE5hbWVcbiAgICAgICAgICAgICAgICAgICAgPyBcIlxcbiAgXCIgKyBmb3VuZFdpbGxNb3VudE5hbWVcbiAgICAgICAgICAgICAgICAgICAgOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZVxuICAgICAgICAgICAgICAgICAgICA/IFwiXFxuICBcIiArIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWVcbiAgICAgICAgICAgICAgICAgICAgOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gZm91bmRXaWxsVXBkYXRlTmFtZVxuICAgICAgICAgICAgICAgICAgICA/IFwiXFxuICBcIiArIGZvdW5kV2lsbFVwZGF0ZU5hbWVcbiAgICAgICAgICAgICAgICAgICAgOiBcIlwiXG4gICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHx8IFwiQ29tcG9uZW50XCI7XG4gICAgICAgICAgaW5zdGFuY2UucmVuZGVyIHx8XG4gICAgICAgICAgICAodHlwZS5wcm90b3R5cGUgJiYgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZS5wcm90b3R5cGUucmVuZGVyXG4gICAgICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiTm8gYHJlbmRlcmAgbWV0aG9kIGZvdW5kIG9uIHRoZSAlcyBpbnN0YW5jZTogZGlkIHlvdSBhY2NpZGVudGFsbHkgcmV0dXJuIGFuIG9iamVjdCBmcm9tIHRoZSBjb25zdHJ1Y3Rvcj9cIixcbiAgICAgICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIDogY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiTm8gYHJlbmRlcmAgbWV0aG9kIGZvdW5kIG9uIHRoZSAlcyBpbnN0YW5jZTogeW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBkZWZpbmUgYHJlbmRlcmAuXCIsXG4gICAgICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgIWluc3RhbmNlLmdldEluaXRpYWxTdGF0ZSB8fFxuICAgICAgICAgICAgaW5zdGFuY2UuZ2V0SW5pdGlhbFN0YXRlLmlzUmVhY3RDbGFzc0FwcHJvdmVkIHx8XG4gICAgICAgICAgICBpbnN0YW5jZS5zdGF0ZSB8fFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJnZXRJbml0aWFsU3RhdGUgd2FzIGRlZmluZWQgb24gJXMsIGEgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcy4gVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiBEaWQgeW91IG1lYW4gdG8gZGVmaW5lIGEgc3RhdGUgcHJvcGVydHkgaW5zdGVhZD9cIixcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBpbnN0YW5jZS5nZXREZWZhdWx0UHJvcHMgJiZcbiAgICAgICAgICAgICFpbnN0YW5jZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiZ2V0RGVmYXVsdFByb3BzIHdhcyBkZWZpbmVkIG9uICVzLCBhIHBsYWluIEphdmFTY3JpcHQgY2xhc3MuIFRoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IHRvIGRlZmluZSBkZWZhdWx0UHJvcHMgaW5zdGVhZC5cIixcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBpbnN0YW5jZS5jb250ZXh0VHlwZSAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJjb250ZXh0VHlwZSB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IHRvIGRlZmluZSBjb250ZXh0VHlwZSBpbnN0ZWFkLlwiLFxuICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHR5cGUuY2hpbGRDb250ZXh0VHlwZXMgJiZcbiAgICAgICAgICAgICFkaWRXYXJuQWJvdXRDaGlsZENvbnRleHRUeXBlcy5oYXModHlwZSkgJiZcbiAgICAgICAgICAgIChkaWRXYXJuQWJvdXRDaGlsZENvbnRleHRUeXBlcy5hZGQodHlwZSksXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIiVzIHVzZXMgdGhlIGxlZ2FjeSBjaGlsZENvbnRleHRUeXBlcyBBUEkgd2hpY2ggd2FzIHJlbW92ZWQgaW4gUmVhY3QgMTkuIFVzZSBSZWFjdC5jcmVhdGVDb250ZXh0KCkgaW5zdGVhZC4gKGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvbGVnYWN5LWNvbnRleHQpXCIsXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICkpO1xuICAgICAgICAgIHR5cGUuY29udGV4dFR5cGVzICYmXG4gICAgICAgICAgICAhZGlkV2FybkFib3V0Q29udGV4dFR5cGVzJDEuaGFzKHR5cGUpICYmXG4gICAgICAgICAgICAoZGlkV2FybkFib3V0Q29udGV4dFR5cGVzJDEuYWRkKHR5cGUpLFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCIlcyB1c2VzIHRoZSBsZWdhY3kgY29udGV4dFR5cGVzIEFQSSB3aGljaCB3YXMgcmVtb3ZlZCBpbiBSZWFjdCAxOS4gVXNlIFJlYWN0LmNyZWF0ZUNvbnRleHQoKSB3aXRoIHN0YXRpYyBjb250ZXh0VHlwZSBpbnN0ZWFkLiAoaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9sZWdhY3ktY29udGV4dClcIixcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgKSk7XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50U2hvdWxkVXBkYXRlICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIiVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgY29tcG9uZW50U2hvdWxkVXBkYXRlKCkuIERpZCB5b3UgbWVhbiBzaG91bGRDb21wb25lbnRVcGRhdGUoKT8gVGhlIG5hbWUgaXMgcGhyYXNlZCBhcyBhIHF1ZXN0aW9uIGJlY2F1c2UgdGhlIGZ1bmN0aW9uIGlzIGV4cGVjdGVkIHRvIHJldHVybiBhIHZhbHVlLlwiLFxuICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHR5cGUucHJvdG90eXBlICYmXG4gICAgICAgICAgICB0eXBlLnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCAmJlxuICAgICAgICAgICAgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZSAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCIlcyBoYXMgYSBtZXRob2QgY2FsbGVkIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpLiBzaG91bGRDb21wb25lbnRVcGRhdGUgc2hvdWxkIG5vdCBiZSB1c2VkIHdoZW4gZXh0ZW5kaW5nIFJlYWN0LlB1cmVDb21wb25lbnQuIFBsZWFzZSBleHRlbmQgUmVhY3QuQ29tcG9uZW50IGlmIHNob3VsZENvbXBvbmVudFVwZGF0ZSBpcyB1c2VkLlwiLFxuICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgXCJBIHB1cmUgY29tcG9uZW50XCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVW5tb3VudCAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCIlcyBoYXMgYSBtZXRob2QgY2FsbGVkIGNvbXBvbmVudERpZFVubW91bnQoKS4gQnV0IHRoZXJlIGlzIG5vIHN1Y2ggbGlmZWN5Y2xlIG1ldGhvZC4gRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxVbm1vdW50KCk/XCIsXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkUmVjZWl2ZVByb3BzICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIiVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgY29tcG9uZW50RGlkUmVjZWl2ZVByb3BzKCkuIEJ1dCB0aGVyZSBpcyBubyBzdWNoIGxpZmVjeWNsZSBtZXRob2QuIElmIHlvdSBtZWFudCB0byB1cGRhdGUgdGhlIHN0YXRlIGluIHJlc3BvbnNlIHRvIGNoYW5naW5nIHByb3BzLCB1c2UgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpLiBJZiB5b3UgbWVhbnQgdG8gZmV0Y2ggZGF0YSBvciBydW4gc2lkZS1lZmZlY3RzIG9yIG11dGF0aW9ucyBhZnRlciBSZWFjdCBoYXMgdXBkYXRlZCB0aGUgVUksIHVzZSBjb21wb25lbnREaWRVcGRhdGUoKS5cIixcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIiVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcygpLiBEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpP1wiLFxuICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIiVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMoKS4gRGlkIHlvdSBtZWFuIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/XCIsXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgdmFyIGhhc011dGF0ZWRQcm9wcyA9IGluc3RhbmNlLnByb3BzICE9PSByZXNvbHZlZFByb3BzO1xuICAgICAgICAgIHZvaWQgMCAhPT0gaW5zdGFuY2UucHJvcHMgJiZcbiAgICAgICAgICAgIGhhc011dGF0ZWRQcm9wcyAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJXaGVuIGNhbGxpbmcgc3VwZXIoKSBpbiBgJXNgLCBtYWtlIHN1cmUgdG8gcGFzcyB1cCB0aGUgc2FtZSBwcm9wcyB0aGF0IHlvdXIgY29tcG9uZW50J3MgY29uc3RydWN0b3Igd2FzIHBhc3NlZC5cIixcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBpbnN0YW5jZS5kZWZhdWx0UHJvcHMgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiU2V0dGluZyBkZWZhdWx0UHJvcHMgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMgaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSBpZ25vcmVkLiBJbnN0ZWFkLCBkZWZpbmUgZGVmYXVsdFByb3BzIGFzIGEgc3RhdGljIHByb3BlcnR5IG9uICVzLlwiLFxuICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlIHx8XG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgfHxcbiAgICAgICAgICAgIGRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZS5oYXModHlwZSkgfHxcbiAgICAgICAgICAgIChkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUuYWRkKHR5cGUpLFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCIlczogZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSBzaG91bGQgYmUgdXNlZCB3aXRoIGNvbXBvbmVudERpZFVwZGF0ZSgpLiBUaGlzIGNvbXBvbmVudCBkZWZpbmVzIGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCkgb25seS5cIixcbiAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpXG4gICAgICAgICAgICApKTtcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiJXM6IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcygpIGlzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgbWV0aG9kIGFuZCB3aWxsIGJlIGlnbm9yZWQuIEluc3RlYWQsIGRlY2xhcmUgaXQgYXMgYSBzdGF0aWMgbWV0aG9kLlwiLFxuICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCIlczogZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKCkgaXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBtZXRob2QgYW5kIHdpbGwgYmUgaWdub3JlZC4gSW5zdGVhZCwgZGVjbGFyZSBpdCBhcyBhIHN0YXRpYyBtZXRob2QuXCIsXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCIlczogZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSBpcyBkZWZpbmVkIGFzIGEgc3RhdGljIG1ldGhvZCBhbmQgd2lsbCBiZSBpZ25vcmVkLiBJbnN0ZWFkLCBkZWNsYXJlIGl0IGFzIGFuIGluc3RhbmNlIG1ldGhvZC5cIixcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB2YXIgc3RhdGUgPSBpbnN0YW5jZS5zdGF0ZTtcbiAgICAgICAgICBzdGF0ZSAmJlxuICAgICAgICAgICAgKFwib2JqZWN0XCIgIT09IHR5cGVvZiBzdGF0ZSB8fCBpc0FycmF5SW1wbChzdGF0ZSkpICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiJXMuc3RhdGU6IG11c3QgYmUgc2V0IHRvIGFuIG9iamVjdCBvciBudWxsXCIsIG5hbWUpO1xuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLmdldENoaWxkQ29udGV4dCAmJlxuICAgICAgICAgICAgXCJvYmplY3RcIiAhPT0gdHlwZW9mIHR5cGUuY2hpbGRDb250ZXh0VHlwZXMgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiJXMuZ2V0Q2hpbGRDb250ZXh0KCk6IGNoaWxkQ29udGV4dFR5cGVzIG11c3QgYmUgZGVmaW5lZCBpbiBvcmRlciB0byB1c2UgZ2V0Q2hpbGRDb250ZXh0KCkuXCIsXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgdmFyIGluaXRpYWxTdGF0ZSA9IHZvaWQgMCAhPT0gaW5zdGFuY2Uuc3RhdGUgPyBpbnN0YW5jZS5zdGF0ZSA6IG51bGw7XG4gICAgICAgICAgaW5zdGFuY2UudXBkYXRlciA9IGNsYXNzQ29tcG9uZW50VXBkYXRlcjtcbiAgICAgICAgICBpbnN0YW5jZS5wcm9wcyA9IHJlc29sdmVkUHJvcHM7XG4gICAgICAgICAgaW5zdGFuY2Uuc3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gICAgICAgICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSB7IHF1ZXVlOiBbXSwgcmVwbGFjZTogITEgfTtcbiAgICAgICAgICBpbnN0YW5jZS5fcmVhY3RJbnRlcm5hbHMgPSBpbnRlcm5hbEluc3RhbmNlO1xuICAgICAgICAgIHZhciBjb250ZXh0VHlwZSRqc2NvbXAkMCA9IHR5cGUuY29udGV4dFR5cGU7XG4gICAgICAgICAgaW5zdGFuY2UuY29udGV4dCA9XG4gICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgY29udGV4dFR5cGUkanNjb21wJDAgJiZcbiAgICAgICAgICAgIG51bGwgIT09IGNvbnRleHRUeXBlJGpzY29tcCQwXG4gICAgICAgICAgICAgID8gY29udGV4dFR5cGUkanNjb21wJDAuX2N1cnJlbnRWYWx1ZTJcbiAgICAgICAgICAgICAgOiBlbXB0eUNvbnRleHRPYmplY3Q7XG4gICAgICAgICAgaWYgKGluc3RhbmNlLnN0YXRlID09PSByZXNvbHZlZFByb3BzKSB7XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50TmFtZSRqc2NvbXAkMCA9XG4gICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB8fCBcIkNvbXBvbmVudFwiO1xuICAgICAgICAgICAgZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGUuaGFzKFxuICAgICAgICAgICAgICBjb21wb25lbnROYW1lJGpzY29tcCQwXG4gICAgICAgICAgICApIHx8XG4gICAgICAgICAgICAgIChkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZS5hZGQoXG4gICAgICAgICAgICAgICAgY29tcG9uZW50TmFtZSRqc2NvbXAkMFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiJXM6IEl0IGlzIG5vdCByZWNvbW1lbmRlZCB0byBhc3NpZ24gcHJvcHMgZGlyZWN0bHkgdG8gc3RhdGUgYmVjYXVzZSB1cGRhdGVzIHRvIHByb3BzIHdvbid0IGJlIHJlZmxlY3RlZCBpbiBzdGF0ZS4gSW4gbW9zdCBjYXNlcywgaXQgaXMgYmV0dGVyIHRvIHVzZSBwcm9wcyBkaXJlY3RseS5cIixcbiAgICAgICAgICAgICAgICBjb21wb25lbnROYW1lJGpzY29tcCQwXG4gICAgICAgICAgICAgICkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID0gdHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM7XG4gICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcykge1xuICAgICAgICAgICAgdmFyIHBhcnRpYWxTdGF0ZSA9IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhcbiAgICAgICAgICAgICAgcmVzb2x2ZWRQcm9wcyxcbiAgICAgICAgICAgICAgaW5pdGlhbFN0YXRlXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKHZvaWQgMCA9PT0gcGFydGlhbFN0YXRlKSB7XG4gICAgICAgICAgICAgIHZhciBjb21wb25lbnROYW1lJGpzY29tcCQxID1cbiAgICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgXCJDb21wb25lbnRcIjtcbiAgICAgICAgICAgICAgZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlLmhhcyhjb21wb25lbnROYW1lJGpzY29tcCQxKSB8fFxuICAgICAgICAgICAgICAgIChkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGUuYWRkKGNvbXBvbmVudE5hbWUkanNjb21wJDEpLFxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIiVzLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcygpOiBBIHZhbGlkIHN0YXRlIG9iamVjdCAob3IgbnVsbCkgbXVzdCBiZSByZXR1cm5lZC4gWW91IGhhdmUgcmV0dXJuZWQgdW5kZWZpbmVkLlwiLFxuICAgICAgICAgICAgICAgICAgY29tcG9uZW50TmFtZSRqc2NvbXAkMVxuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9XG4gICAgICAgICAgICAgIG51bGwgPT09IHBhcnRpYWxTdGF0ZSB8fCB2b2lkIDAgPT09IHBhcnRpYWxTdGF0ZVxuICAgICAgICAgICAgICAgID8gaW5pdGlhbFN0YXRlXG4gICAgICAgICAgICAgICAgOiBhc3NpZ24oe30sIGluaXRpYWxTdGF0ZSwgcGFydGlhbFN0YXRlKTtcbiAgICAgICAgICAgIGluc3RhbmNlLnN0YXRlID0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiB0eXBlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyAmJlxuICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgJiZcbiAgICAgICAgICAgIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50IHx8XG4gICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudClcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciBvbGRTdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xuICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCkge1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgITAgIT09IGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudC5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHZhciBjb21wb25lbnROYW1lJGpzY29tcCQyID1cbiAgICAgICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB8fCBcIlVua25vd25cIjtcbiAgICAgICAgICAgICAgICBkaWRXYXJuQWJvdXREZXByZWNhdGVkV2lsbE1vdW50W2NvbXBvbmVudE5hbWUkanNjb21wJDJdIHx8XG4gICAgICAgICAgICAgICAgICAoY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICAgICBcImNvbXBvbmVudFdpbGxNb3VudCBoYXMgYmVlbiByZW5hbWVkLCBhbmQgaXMgbm90IHJlY29tbWVuZGVkIGZvciB1c2UuIFNlZSBodHRwczovL3JlYWN0LmRldi9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4qIE1vdmUgY29kZSBmcm9tIGNvbXBvbmVudFdpbGxNb3VudCB0byBjb21wb25lbnREaWRNb3VudCAocHJlZmVycmVkIGluIG1vc3QgY2FzZXMpIG9yIHRoZSBjb25zdHJ1Y3Rvci5cXG5cXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXNcIixcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50TmFtZSRqc2NvbXAkMlxuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgIChkaWRXYXJuQWJvdXREZXByZWNhdGVkV2lsbE1vdW50W2NvbXBvbmVudE5hbWUkanNjb21wJDJdID1cbiAgICAgICAgICAgICAgICAgICAgITApKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgJiZcbiAgICAgICAgICAgICAgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgICAgICAgICAgb2xkU3RhdGUgIT09IGluc3RhbmNlLnN0YXRlICYmXG4gICAgICAgICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiJXMuY29tcG9uZW50V2lsbE1vdW50KCk6IEFzc2lnbmluZyBkaXJlY3RseSB0byB0aGlzLnN0YXRlIGlzIGRlcHJlY2F0ZWQgKGV4Y2VwdCBpbnNpZGUgYSBjb21wb25lbnQncyBjb25zdHJ1Y3RvcikuIFVzZSBzZXRTdGF0ZSBpbnN0ZWFkLlwiLFxuICAgICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB8fCBcIkNvbXBvbmVudFwiXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIGNsYXNzQ29tcG9uZW50VXBkYXRlci5lbnF1ZXVlUmVwbGFjZVN0YXRlKFxuICAgICAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgICAgIGluc3RhbmNlLnN0YXRlLFxuICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIG51bGwgIT09IGludGVybmFsSW5zdGFuY2UucXVldWUgJiZcbiAgICAgICAgICAgICAgMCA8IGludGVybmFsSW5zdGFuY2UucXVldWUubGVuZ3RoXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgdmFyIG9sZFF1ZXVlID0gaW50ZXJuYWxJbnN0YW5jZS5xdWV1ZSxcbiAgICAgICAgICAgICAgICBvbGRSZXBsYWNlID0gaW50ZXJuYWxJbnN0YW5jZS5yZXBsYWNlO1xuICAgICAgICAgICAgICBpbnRlcm5hbEluc3RhbmNlLnF1ZXVlID0gbnVsbDtcbiAgICAgICAgICAgICAgaW50ZXJuYWxJbnN0YW5jZS5yZXBsYWNlID0gITE7XG4gICAgICAgICAgICAgIGlmIChvbGRSZXBsYWNlICYmIDEgPT09IG9sZFF1ZXVlLmxlbmd0aClcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5zdGF0ZSA9IG9sZFF1ZXVlWzBdO1xuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgICAgdmFyIG5leHRTdGF0ZSA9IG9sZFJlcGxhY2UgPyBvbGRRdWV1ZVswXSA6IGluc3RhbmNlLnN0YXRlLFxuICAgICAgICAgICAgICAgICAgICBkb250TXV0YXRlID0gITAsXG4gICAgICAgICAgICAgICAgICAgIGkgPSBvbGRSZXBsYWNlID8gMSA6IDA7XG4gICAgICAgICAgICAgICAgICBpIDwgb2xkUXVldWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgaSsrXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcGFydGlhbCA9IG9sZFF1ZXVlW2ldLFxuICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsU3RhdGUkanNjb21wJDAgPVxuICAgICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHBhcnRpYWxcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcGFydGlhbC5jYWxsKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRTdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlZFByb3BzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZvaWQgMFxuICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHBhcnRpYWw7XG4gICAgICAgICAgICAgICAgICBudWxsICE9IHBhcnRpYWxTdGF0ZSRqc2NvbXAkMCAmJlxuICAgICAgICAgICAgICAgICAgICAoZG9udE11dGF0ZVxuICAgICAgICAgICAgICAgICAgICAgID8gKChkb250TXV0YXRlID0gITEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgKG5leHRTdGF0ZSA9IGFzc2lnbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRTdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbFN0YXRlJGpzY29tcCQwXG4gICAgICAgICAgICAgICAgICAgICAgICApKSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGFzc2lnbihuZXh0U3RhdGUsIHBhcnRpYWxTdGF0ZSRqc2NvbXAkMCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5zdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGludGVybmFsSW5zdGFuY2UucXVldWUgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbmV4dENoaWxkcmVuID0gY2FsbFJlbmRlckluREVWKGluc3RhbmNlKTtcbiAgICAgICAgICBpZiAoMTIgPT09IHJlcXVlc3Quc3RhdHVzKSB0aHJvdyBudWxsO1xuICAgICAgICAgIGluc3RhbmNlLnByb3BzICE9PSByZXNvbHZlZFByb3BzICYmXG4gICAgICAgICAgICAoZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcyB8fFxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiSXQgbG9va3MgbGlrZSAlcyBpcyByZWFzc2lnbmluZyBpdHMgb3duIGB0aGlzLnByb3BzYCB3aGlsZSByZW5kZXJpbmcuIFRoaXMgaXMgbm90IHN1cHBvcnRlZCBhbmQgY2FuIGxlYWQgdG8gY29uZnVzaW5nIGJ1Z3MuXCIsXG4gICAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHx8IFwiYSBjb21wb25lbnRcIlxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgKGRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMgPSAhMCkpO1xuICAgICAgICAgIHZhciBwcmV2S2V5UGF0aCA9IHRhc2sua2V5UGF0aDtcbiAgICAgICAgICB0YXNrLmtleVBhdGggPSBrZXlQYXRoO1xuICAgICAgICAgIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBuZXh0Q2hpbGRyZW4sIC0xKTtcbiAgICAgICAgICB0YXNrLmtleVBhdGggPSBwcmV2S2V5UGF0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodHlwZS5wcm90b3R5cGUgJiYgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZS5wcm90b3R5cGUucmVuZGVyKSB7XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50TmFtZSRqc2NvbXAkMyA9XG4gICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB8fCBcIlVua25vd25cIjtcbiAgICAgICAgICAgIGRpZFdhcm5BYm91dEJhZENsYXNzW2NvbXBvbmVudE5hbWUkanNjb21wJDNdIHx8XG4gICAgICAgICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiVGhlIDwlcyAvPiBjb21wb25lbnQgYXBwZWFycyB0byBoYXZlIGEgcmVuZGVyIG1ldGhvZCwgYnV0IGRvZXNuJ3QgZXh0ZW5kIFJlYWN0LkNvbXBvbmVudC4gVGhpcyBpcyBsaWtlbHkgdG8gY2F1c2UgZXJyb3JzLiBDaGFuZ2UgJXMgdG8gZXh0ZW5kIFJlYWN0LkNvbXBvbmVudCBpbnN0ZWFkLlwiLFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudE5hbWUkanNjb21wJDMsXG4gICAgICAgICAgICAgICAgY29tcG9uZW50TmFtZSRqc2NvbXAkM1xuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAoZGlkV2FybkFib3V0QmFkQ2xhc3NbY29tcG9uZW50TmFtZSRqc2NvbXAkM10gPSAhMCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdmFsdWUgPSByZW5kZXJXaXRoSG9va3MoXG4gICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgdGFzayxcbiAgICAgICAgICAgIGtleVBhdGgsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICB2b2lkIDBcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmICgxMiA9PT0gcmVxdWVzdC5zdGF0dXMpIHRocm93IG51bGw7XG4gICAgICAgICAgdmFyIGhhc0lkID0gMCAhPT0gbG9jYWxJZENvdW50ZXIsXG4gICAgICAgICAgICBhY3Rpb25TdGF0ZUNvdW50ID0gYWN0aW9uU3RhdGVDb3VudGVyLFxuICAgICAgICAgICAgYWN0aW9uU3RhdGVNYXRjaGluZ0luZGV4JGpzY29tcCQwID0gYWN0aW9uU3RhdGVNYXRjaGluZ0luZGV4O1xuICAgICAgICAgIGlmICh0eXBlLmNvbnRleHRUeXBlcykge1xuICAgICAgICAgICAgdmFyIF9jb21wb25lbnROYW1lJGpzY29tcCQwID1cbiAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHx8IFwiVW5rbm93blwiO1xuICAgICAgICAgICAgZGlkV2FybkFib3V0Q29udGV4dFR5cGVzW19jb21wb25lbnROYW1lJGpzY29tcCQwXSB8fFxuICAgICAgICAgICAgICAoKGRpZFdhcm5BYm91dENvbnRleHRUeXBlc1tfY29tcG9uZW50TmFtZSRqc2NvbXAkMF0gPSAhMCksXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCIlcyB1c2VzIHRoZSBsZWdhY3kgY29udGV4dFR5cGVzIEFQSSB3aGljaCB3YXMgcmVtb3ZlZCBpbiBSZWFjdCAxOS4gVXNlIFJlYWN0LmNyZWF0ZUNvbnRleHQoKSB3aXRoIFJlYWN0LnVzZUNvbnRleHQoKSBpbnN0ZWFkLiAoaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9sZWdhY3ktY29udGV4dClcIixcbiAgICAgICAgICAgICAgICBfY29tcG9uZW50TmFtZSRqc2NvbXAkMFxuICAgICAgICAgICAgICApKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdHlwZSAmJlxuICAgICAgICAgICAgdHlwZS5jaGlsZENvbnRleHRUeXBlcyAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJjaGlsZENvbnRleHRUeXBlcyBjYW5ub3QgYmUgZGVmaW5lZCBvbiBhIGZ1bmN0aW9uIGNvbXBvbmVudC5cXG4gICVzLmNoaWxkQ29udGV4dFR5cGVzID0gLi4uXCIsXG4gICAgICAgICAgICAgIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IFwiQ29tcG9uZW50XCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKSB7XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50TmFtZSRqc2NvbXAkNCA9XG4gICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB8fCBcIlVua25vd25cIjtcbiAgICAgICAgICAgIGRpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25Db21wb25lbnRbXG4gICAgICAgICAgICAgIGNvbXBvbmVudE5hbWUkanNjb21wJDRcbiAgICAgICAgICAgIF0gfHxcbiAgICAgICAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCIlczogRnVuY3Rpb24gY29tcG9uZW50cyBkbyBub3Qgc3VwcG9ydCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuXCIsXG4gICAgICAgICAgICAgICAgY29tcG9uZW50TmFtZSRqc2NvbXAkNFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAoZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbkNvbXBvbmVudFtcbiAgICAgICAgICAgICAgICBjb21wb25lbnROYW1lJGpzY29tcCQ0XG4gICAgICAgICAgICAgIF0gPSAhMCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZS5jb250ZXh0VHlwZSAmJlxuICAgICAgICAgICAgbnVsbCAhPT0gdHlwZS5jb250ZXh0VHlwZVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdmFyIF9jb21wb25lbnROYW1lMiA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB8fCBcIlVua25vd25cIjtcbiAgICAgICAgICAgIGRpZFdhcm5BYm91dENvbnRleHRUeXBlT25GdW5jdGlvbkNvbXBvbmVudFtfY29tcG9uZW50TmFtZTJdIHx8XG4gICAgICAgICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiJXM6IEZ1bmN0aW9uIGNvbXBvbmVudHMgZG8gbm90IHN1cHBvcnQgY29udGV4dFR5cGUuXCIsXG4gICAgICAgICAgICAgICAgX2NvbXBvbmVudE5hbWUyXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIChkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnRbX2NvbXBvbmVudE5hbWUyXSA9XG4gICAgICAgICAgICAgICAgITApKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmluaXNoRnVuY3Rpb25Db21wb25lbnQoXG4gICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgdGFzayxcbiAgICAgICAgICAgIGtleVBhdGgsXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGhhc0lkLFxuICAgICAgICAgICAgYWN0aW9uU3RhdGVDb3VudCxcbiAgICAgICAgICAgIGFjdGlvblN0YXRlTWF0Y2hpbmdJbmRleCRqc2NvbXAkMFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIGVsc2UgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlKSB7XG4gICAgICAgIHZhciBzZWdtZW50ID0gdGFzay5ibG9ja2VkU2VnbWVudDtcbiAgICAgICAgaWYgKG51bGwgPT09IHNlZ21lbnQpIHtcbiAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgICAgICAgIHByZXZDb250ZXh0ID0gdGFzay5mb3JtYXRDb250ZXh0LFxuICAgICAgICAgICAgcHJldktleVBhdGgkanNjb21wJDAgPSB0YXNrLmtleVBhdGg7XG4gICAgICAgICAgdGFzay5mb3JtYXRDb250ZXh0ID0gZ2V0Q2hpbGRGb3JtYXRDb250ZXh0KHByZXZDb250ZXh0LCB0eXBlLCBwcm9wcyk7XG4gICAgICAgICAgdGFzay5rZXlQYXRoID0ga2V5UGF0aDtcbiAgICAgICAgICByZW5kZXJOb2RlKHJlcXVlc3QsIHRhc2ssIGNoaWxkcmVuLCAtMSk7XG4gICAgICAgICAgdGFzay5mb3JtYXRDb250ZXh0ID0gcHJldkNvbnRleHQ7XG4gICAgICAgICAgdGFzay5rZXlQYXRoID0gcHJldktleVBhdGgkanNjb21wJDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF9jaGlsZHJlbiA9IHB1c2hTdGFydEluc3RhbmNlKFxuICAgICAgICAgICAgc2VnbWVudC5jaHVua3MsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICByZXF1ZXN0LnJlc3VtYWJsZVN0YXRlLFxuICAgICAgICAgICAgcmVxdWVzdC5yZW5kZXJTdGF0ZSxcbiAgICAgICAgICAgIHRhc2suYmxvY2tlZFByZWFtYmxlLFxuICAgICAgICAgICAgdGFzay5ob2lzdGFibGVTdGF0ZSxcbiAgICAgICAgICAgIHRhc2suZm9ybWF0Q29udGV4dCxcbiAgICAgICAgICAgIHNlZ21lbnQubGFzdFB1c2hlZFRleHRcbiAgICAgICAgICApO1xuICAgICAgICAgIHNlZ21lbnQubGFzdFB1c2hlZFRleHQgPSAhMTtcbiAgICAgICAgICB2YXIgX3ByZXZDb250ZXh0MiA9IHRhc2suZm9ybWF0Q29udGV4dCxcbiAgICAgICAgICAgIF9wcmV2S2V5UGF0aDMgPSB0YXNrLmtleVBhdGg7XG4gICAgICAgICAgdGFzay5rZXlQYXRoID0ga2V5UGF0aDtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAodGFzay5mb3JtYXRDb250ZXh0ID0gZ2V0Q2hpbGRGb3JtYXRDb250ZXh0KFxuICAgICAgICAgICAgICBfcHJldkNvbnRleHQyLFxuICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICBwcm9wc1xuICAgICAgICAgICAgKSkuaW5zZXJ0aW9uTW9kZSA9PT0gSFRNTF9IRUFEX01PREVcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciBwcmVhbWJsZVNlZ21lbnQgPSBjcmVhdGVQZW5kaW5nU2VnbWVudChcbiAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgdGFzay5mb3JtYXRDb250ZXh0LFxuICAgICAgICAgICAgICAhMSxcbiAgICAgICAgICAgICAgITFcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBzZWdtZW50LnByZWFtYmxlQ2hpbGRyZW4ucHVzaChwcmVhbWJsZVNlZ21lbnQpO1xuICAgICAgICAgICAgdGFzay5ibG9ja2VkU2VnbWVudCA9IHByZWFtYmxlU2VnbWVudDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIChwcmVhbWJsZVNlZ21lbnQuc3RhdHVzID0gNiksXG4gICAgICAgICAgICAgICAgcmVuZGVyTm9kZShyZXF1ZXN0LCB0YXNrLCBfY2hpbGRyZW4sIC0xKSxcbiAgICAgICAgICAgICAgICBwdXNoU2VnbWVudEZpbmFsZShcbiAgICAgICAgICAgICAgICAgIHByZWFtYmxlU2VnbWVudC5jaHVua3MsXG4gICAgICAgICAgICAgICAgICByZXF1ZXN0LnJlbmRlclN0YXRlLFxuICAgICAgICAgICAgICAgICAgcHJlYW1ibGVTZWdtZW50Lmxhc3RQdXNoZWRUZXh0LFxuICAgICAgICAgICAgICAgICAgcHJlYW1ibGVTZWdtZW50LnRleHRFbWJlZGRlZFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgKHByZWFtYmxlU2VnbWVudC5zdGF0dXMgPSBDT01QTEVURUQpO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgdGFzay5ibG9ja2VkU2VnbWVudCA9IHNlZ21lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHJlbmRlck5vZGUocmVxdWVzdCwgdGFzaywgX2NoaWxkcmVuLCAtMSk7XG4gICAgICAgICAgdGFzay5mb3JtYXRDb250ZXh0ID0gX3ByZXZDb250ZXh0MjtcbiAgICAgICAgICB0YXNrLmtleVBhdGggPSBfcHJldktleVBhdGgzO1xuICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBzZWdtZW50LmNodW5rcyxcbiAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUgPSByZXF1ZXN0LnJlc3VtYWJsZVN0YXRlO1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJ0aXRsZVwiOlxuICAgICAgICAgICAgICBjYXNlIFwic3R5bGVcIjpcbiAgICAgICAgICAgICAgY2FzZSBcInNjcmlwdFwiOlxuICAgICAgICAgICAgICBjYXNlIFwiYXJlYVwiOlxuICAgICAgICAgICAgICBjYXNlIFwiYmFzZVwiOlxuICAgICAgICAgICAgICBjYXNlIFwiYnJcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImNvbFwiOlxuICAgICAgICAgICAgICBjYXNlIFwiZW1iZWRcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImhyXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJpbWdcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImlucHV0XCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJrZXlnZW5cIjpcbiAgICAgICAgICAgICAgY2FzZSBcImxpbmtcIjpcbiAgICAgICAgICAgICAgY2FzZSBcIm1ldGFcIjpcbiAgICAgICAgICAgICAgY2FzZSBcInBhcmFtXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJzb3VyY2VcIjpcbiAgICAgICAgICAgICAgY2FzZSBcInRyYWNrXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJ3YnJcIjpcbiAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICBjYXNlIFwiYm9keVwiOlxuICAgICAgICAgICAgICAgIGlmIChfcHJldkNvbnRleHQyLmluc2VydGlvbk1vZGUgPD0gSFRNTF9IVE1MX01PREUpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLmhhc0JvZHkgPSAhMDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwiaHRtbFwiOlxuICAgICAgICAgICAgICAgIGlmIChfcHJldkNvbnRleHQyLmluc2VydGlvbk1vZGUgPT09IFJPT1RfSFRNTF9NT0RFKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZS5oYXNIdG1sID0gITA7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcImhlYWRcIjpcbiAgICAgICAgICAgICAgICBpZiAoX3ByZXZDb250ZXh0Mi5pbnNlcnRpb25Nb2RlIDw9IEhUTUxfSFRNTF9NT0RFKSBicmVhayBhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFyZ2V0LnB1c2goZW5kQ2h1bmtGb3JUYWcodHlwZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWdtZW50Lmxhc3RQdXNoZWRUZXh0ID0gITE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgICAgICAgdmFyIHByZXZLZXlQYXRoJGpzY29tcCQxID0gdGFzay5rZXlQYXRoO1xuICAgICAgICAgICAgdGFzay5rZXlQYXRoID0ga2V5UGF0aDtcbiAgICAgICAgICAgIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBwcm9wcy5jaGlsZHJlbiwgLTEpO1xuICAgICAgICAgICAgdGFzay5rZXlQYXRoID0gcHJldktleVBhdGgkanNjb21wJDE7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgY2FzZSBSRUFDVF9BQ1RJVklUWV9UWVBFOlxuICAgICAgICAgICAgdmFyIHNlZ21lbnQkanNjb21wJDAgPSB0YXNrLmJsb2NrZWRTZWdtZW50O1xuICAgICAgICAgICAgaWYgKG51bGwgPT09IHNlZ21lbnQkanNjb21wJDApIHtcbiAgICAgICAgICAgICAgaWYgKFwiaGlkZGVuXCIgIT09IHByb3BzLm1vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJldktleVBhdGgkanNjb21wJDIgPSB0YXNrLmtleVBhdGg7XG4gICAgICAgICAgICAgICAgdGFzay5rZXlQYXRoID0ga2V5UGF0aDtcbiAgICAgICAgICAgICAgICByZW5kZXJOb2RlKHJlcXVlc3QsIHRhc2ssIHByb3BzLmNoaWxkcmVuLCAtMSk7XG4gICAgICAgICAgICAgICAgdGFzay5rZXlQYXRoID0gcHJldktleVBhdGgkanNjb21wJDI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXCJoaWRkZW5cIiAhPT0gcHJvcHMubW9kZSkge1xuICAgICAgICAgICAgICByZXF1ZXN0LnJlbmRlclN0YXRlLmdlbmVyYXRlU3RhdGljTWFya3VwIHx8XG4gICAgICAgICAgICAgICAgc2VnbWVudCRqc2NvbXAkMC5jaHVua3MucHVzaChcIlxceDNjIS0tJi0tXFx4M2VcIik7XG4gICAgICAgICAgICAgIHNlZ21lbnQkanNjb21wJDAubGFzdFB1c2hlZFRleHQgPSAhMTtcbiAgICAgICAgICAgICAgdmFyIF9wcmV2S2V5UGF0aDQgPSB0YXNrLmtleVBhdGg7XG4gICAgICAgICAgICAgIHRhc2sua2V5UGF0aCA9IGtleVBhdGg7XG4gICAgICAgICAgICAgIHJlbmRlck5vZGUocmVxdWVzdCwgdGFzaywgcHJvcHMuY2hpbGRyZW4sIC0xKTtcbiAgICAgICAgICAgICAgdGFzay5rZXlQYXRoID0gX3ByZXZLZXlQYXRoNDtcbiAgICAgICAgICAgICAgcmVxdWVzdC5yZW5kZXJTdGF0ZS5nZW5lcmF0ZVN0YXRpY01hcmt1cCB8fFxuICAgICAgICAgICAgICAgIHNlZ21lbnQkanNjb21wJDAuY2h1bmtzLnB1c2goXCJcXHgzYyEtLS8mLS1cXHgzZVwiKTtcbiAgICAgICAgICAgICAgc2VnbWVudCRqc2NvbXAkMC5sYXN0UHVzaGVkVGV4dCA9ICExO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICAgICAgYToge1xuICAgICAgICAgICAgICB2YXIgY2hpbGRyZW4kanNjb21wJDAgPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgICAgICAgICAgICByZXZlYWxPcmRlciA9IHByb3BzLnJldmVhbE9yZGVyO1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgXCJmb3J3YXJkc1wiID09PSByZXZlYWxPcmRlciB8fFxuICAgICAgICAgICAgICAgIFwiYmFja3dhcmRzXCIgPT09IHJldmVhbE9yZGVyIHx8XG4gICAgICAgICAgICAgICAgXCJ1bnN0YWJsZV9sZWdhY3ktYmFja3dhcmRzXCIgPT09IHJldmVhbE9yZGVyXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGlmIChpc0FycmF5SW1wbChjaGlsZHJlbiRqc2NvbXAkMCkpIHtcbiAgICAgICAgICAgICAgICAgIHJlbmRlclN1c3BlbnNlTGlzdFJvd3MoXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgIHRhc2ssXG4gICAgICAgICAgICAgICAgICAgIGtleVBhdGgsXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuJGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICByZXZlYWxPcmRlclxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihjaGlsZHJlbiRqc2NvbXAkMCk7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgICAgICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChjaGlsZHJlbiRqc2NvbXAkMCk7XG4gICAgICAgICAgICAgICAgICBpZiAoaXRlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVJdGVyYWJsZShcbiAgICAgICAgICAgICAgICAgICAgICB0YXNrLFxuICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuJGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICAgIC0xLFxuICAgICAgICAgICAgICAgICAgICAgIGl0ZXJhdG9yLFxuICAgICAgICAgICAgICAgICAgICAgIGl0ZXJhdG9yRm5cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc3RlcC5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHJvd3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICBkbyByb3dzLnB1c2goc3RlcC52YWx1ZSksIChzdGVwID0gaXRlcmF0b3IubmV4dCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIXN0ZXAuZG9uZSk7XG4gICAgICAgICAgICAgICAgICAgICAgcmVuZGVyU3VzcGVuc2VMaXN0Um93cyhcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrLFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5UGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuJGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV2ZWFsT3JkZXJcbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChcInRvZ2V0aGVyXCIgPT09IHJldmVhbE9yZGVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9wcmV2S2V5UGF0aDIgPSB0YXNrLmtleVBhdGgsXG4gICAgICAgICAgICAgICAgICBwcmV2Um93ID0gdGFzay5yb3csXG4gICAgICAgICAgICAgICAgICBuZXdSb3cgPSAodGFzay5yb3cgPSBjcmVhdGVTdXNwZW5zZUxpc3RSb3cobnVsbCkpO1xuICAgICAgICAgICAgICAgIG5ld1Jvdy5ib3VuZGFyaWVzID0gW107XG4gICAgICAgICAgICAgICAgbmV3Um93LnRvZ2V0aGVyID0gITA7XG4gICAgICAgICAgICAgICAgdGFzay5rZXlQYXRoID0ga2V5UGF0aDtcbiAgICAgICAgICAgICAgICByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgY2hpbGRyZW4kanNjb21wJDAsIC0xKTtcbiAgICAgICAgICAgICAgICAwID09PSAtLW5ld1Jvdy5wZW5kaW5nVGFza3MgJiZcbiAgICAgICAgICAgICAgICAgIGZpbmlzaFN1c3BlbnNlTGlzdFJvdyhyZXF1ZXN0LCBuZXdSb3cpO1xuICAgICAgICAgICAgICAgIHRhc2sua2V5UGF0aCA9IF9wcmV2S2V5UGF0aDI7XG4gICAgICAgICAgICAgICAgdGFzay5yb3cgPSBwcmV2Um93O1xuICAgICAgICAgICAgICAgIG51bGwgIT09IHByZXZSb3cgJiZcbiAgICAgICAgICAgICAgICAgIDAgPCBuZXdSb3cucGVuZGluZ1Rhc2tzICYmXG4gICAgICAgICAgICAgICAgICAocHJldlJvdy5wZW5kaW5nVGFza3MrKywgKG5ld1Jvdy5uZXh0ID0gcHJldlJvdykpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBwcmV2S2V5UGF0aCRqc2NvbXAkMyA9IHRhc2sua2V5UGF0aDtcbiAgICAgICAgICAgICAgICB0YXNrLmtleVBhdGggPSBrZXlQYXRoO1xuICAgICAgICAgICAgICAgIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBjaGlsZHJlbiRqc2NvbXAkMCwgLTEpO1xuICAgICAgICAgICAgICAgIHRhc2sua2V5UGF0aCA9IHByZXZLZXlQYXRoJGpzY29tcCQzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgY2FzZSBSRUFDVF9WSUVXX1RSQU5TSVRJT05fVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NDT1BFX1RZUEU6XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgXCJSZWFjdERPTVNlcnZlciBkb2VzIG5vdCB5ZXQgc3VwcG9ydCBzY29wZSBjb21wb25lbnRzLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICAgIGE6IGlmIChudWxsICE9PSB0YXNrLnJlcGxheSkge1xuICAgICAgICAgICAgICB2YXIgX3ByZXZLZXlQYXRoID0gdGFzay5rZXlQYXRoLFxuICAgICAgICAgICAgICAgIF9wcmV2Q29udGV4dCA9IHRhc2suZm9ybWF0Q29udGV4dCxcbiAgICAgICAgICAgICAgICBfcHJldlJvdyA9IHRhc2sucm93O1xuICAgICAgICAgICAgICB0YXNrLmtleVBhdGggPSBrZXlQYXRoO1xuICAgICAgICAgICAgICB0YXNrLmZvcm1hdENvbnRleHQgPSBnZXRTdXNwZW5zZUNvbnRlbnRGb3JtYXRDb250ZXh0KFxuICAgICAgICAgICAgICAgIHJlcXVlc3QucmVzdW1hYmxlU3RhdGUsXG4gICAgICAgICAgICAgICAgX3ByZXZDb250ZXh0XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHRhc2sucm93ID0gbnVsbDtcbiAgICAgICAgICAgICAgdmFyIF9jb250ZW50ID0gcHJvcHMuY2hpbGRyZW47XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyTm9kZShyZXF1ZXN0LCB0YXNrLCBfY29udGVudCwgLTEpO1xuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICh0YXNrLmtleVBhdGggPSBfcHJldktleVBhdGgpLFxuICAgICAgICAgICAgICAgICAgKHRhc2suZm9ybWF0Q29udGV4dCA9IF9wcmV2Q29udGV4dCksXG4gICAgICAgICAgICAgICAgICAodGFzay5yb3cgPSBfcHJldlJvdyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBwcmV2S2V5UGF0aCRqc2NvbXAkNCA9IHRhc2sua2V5UGF0aCxcbiAgICAgICAgICAgICAgICBwcmV2Q29udGV4dCRqc2NvbXAkMCA9IHRhc2suZm9ybWF0Q29udGV4dCxcbiAgICAgICAgICAgICAgICBwcmV2Um93JGpzY29tcCQwID0gdGFzay5yb3csXG4gICAgICAgICAgICAgICAgcGFyZW50Qm91bmRhcnkgPSB0YXNrLmJsb2NrZWRCb3VuZGFyeSxcbiAgICAgICAgICAgICAgICBwYXJlbnRQcmVhbWJsZSA9IHRhc2suYmxvY2tlZFByZWFtYmxlLFxuICAgICAgICAgICAgICAgIHBhcmVudEhvaXN0YWJsZVN0YXRlID0gdGFzay5ob2lzdGFibGVTdGF0ZSxcbiAgICAgICAgICAgICAgICBwYXJlbnRTZWdtZW50ID0gdGFzay5ibG9ja2VkU2VnbWVudCxcbiAgICAgICAgICAgICAgICBmYWxsYmFjayA9IHByb3BzLmZhbGxiYWNrLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgICAgICAgICAgICBmYWxsYmFja0Fib3J0U2V0ID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgICB2YXIgbmV3Qm91bmRhcnkgPSBjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5KFxuICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgdGFzay5yb3csXG4gICAgICAgICAgICAgICAgZmFsbGJhY2tBYm9ydFNldCxcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgbnVsbCAhPT0gcmVxdWVzdC50cmFja2VkUG9zdHBvbmVzICYmXG4gICAgICAgICAgICAgICAgKG5ld0JvdW5kYXJ5LnRyYWNrZWRDb250ZW50S2V5UGF0aCA9IGtleVBhdGgpO1xuICAgICAgICAgICAgICB2YXIgYm91bmRhcnlTZWdtZW50ID0gY3JlYXRlUGVuZGluZ1NlZ21lbnQoXG4gICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICBwYXJlbnRTZWdtZW50LmNodW5rcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgbmV3Qm91bmRhcnksXG4gICAgICAgICAgICAgICAgdGFzay5mb3JtYXRDb250ZXh0LFxuICAgICAgICAgICAgICAgICExLFxuICAgICAgICAgICAgICAgICExXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHBhcmVudFNlZ21lbnQuY2hpbGRyZW4ucHVzaChib3VuZGFyeVNlZ21lbnQpO1xuICAgICAgICAgICAgICBwYXJlbnRTZWdtZW50Lmxhc3RQdXNoZWRUZXh0ID0gITE7XG4gICAgICAgICAgICAgIHZhciBjb250ZW50Um9vdFNlZ21lbnQgPSBjcmVhdGVQZW5kaW5nU2VnbWVudChcbiAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICB0YXNrLmZvcm1hdENvbnRleHQsXG4gICAgICAgICAgICAgICAgITEsXG4gICAgICAgICAgICAgICAgITFcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgY29udGVudFJvb3RTZWdtZW50LnBhcmVudEZsdXNoZWQgPSAhMDtcbiAgICAgICAgICAgICAgaWYgKG51bGwgIT09IHJlcXVlc3QudHJhY2tlZFBvc3Rwb25lcykge1xuICAgICAgICAgICAgICAgIHZhciBzdXNwZW5zZUNvbXBvbmVudFN0YWNrID0gdGFzay5jb21wb25lbnRTdGFjayxcbiAgICAgICAgICAgICAgICAgIGZhbGxiYWNrS2V5UGF0aCA9IFtcbiAgICAgICAgICAgICAgICAgICAga2V5UGF0aFswXSxcbiAgICAgICAgICAgICAgICAgICAgXCJTdXNwZW5zZSBGYWxsYmFja1wiLFxuICAgICAgICAgICAgICAgICAgICBrZXlQYXRoWzJdXG4gICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgZmFsbGJhY2tSZXBsYXlOb2RlID0gW1xuICAgICAgICAgICAgICAgICAgICBmYWxsYmFja0tleVBhdGhbMV0sXG4gICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrS2V5UGF0aFsyXSxcbiAgICAgICAgICAgICAgICAgICAgW10sXG4gICAgICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgcmVxdWVzdC50cmFja2VkUG9zdHBvbmVzLndvcmtpbmdNYXAuc2V0KFxuICAgICAgICAgICAgICAgICAgZmFsbGJhY2tLZXlQYXRoLFxuICAgICAgICAgICAgICAgICAgZmFsbGJhY2tSZXBsYXlOb2RlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBuZXdCb3VuZGFyeS50cmFja2VkRmFsbGJhY2tOb2RlID0gZmFsbGJhY2tSZXBsYXlOb2RlO1xuICAgICAgICAgICAgICAgIHRhc2suYmxvY2tlZFNlZ21lbnQgPSBib3VuZGFyeVNlZ21lbnQ7XG4gICAgICAgICAgICAgICAgdGFzay5ibG9ja2VkUHJlYW1ibGUgPSBuZXdCb3VuZGFyeS5mYWxsYmFja1ByZWFtYmxlO1xuICAgICAgICAgICAgICAgIHRhc2sua2V5UGF0aCA9IGZhbGxiYWNrS2V5UGF0aDtcbiAgICAgICAgICAgICAgICB0YXNrLmZvcm1hdENvbnRleHQgPSBnZXRTdXNwZW5zZUZhbGxiYWNrRm9ybWF0Q29udGV4dChcbiAgICAgICAgICAgICAgICAgIHJlcXVlc3QucmVzdW1hYmxlU3RhdGUsXG4gICAgICAgICAgICAgICAgICBwcmV2Q29udGV4dCRqc2NvbXAkMFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdGFzay5jb21wb25lbnRTdGFjayA9XG4gICAgICAgICAgICAgICAgICByZXBsYWNlU3VzcGVuc2VDb21wb25lbnRTdGFja1dpdGhTdXNwZW5zZUZhbGxiYWNrU3RhY2soXG4gICAgICAgICAgICAgICAgICAgIHN1c3BlbnNlQ29tcG9uZW50U3RhY2tcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYm91bmRhcnlTZWdtZW50LnN0YXR1cyA9IDY7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHJlbmRlck5vZGUocmVxdWVzdCwgdGFzaywgZmFsbGJhY2ssIC0xKSxcbiAgICAgICAgICAgICAgICAgICAgcHVzaFNlZ21lbnRGaW5hbGUoXG4gICAgICAgICAgICAgICAgICAgICAgYm91bmRhcnlTZWdtZW50LmNodW5rcyxcbiAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LnJlbmRlclN0YXRlLFxuICAgICAgICAgICAgICAgICAgICAgIGJvdW5kYXJ5U2VnbWVudC5sYXN0UHVzaGVkVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICBib3VuZGFyeVNlZ21lbnQudGV4dEVtYmVkZGVkXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIChib3VuZGFyeVNlZ21lbnQuc3RhdHVzID0gQ09NUExFVEVEKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoICh0aHJvd25WYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgKFxuICAgICAgICAgICAgICAgICAgICAoKGJvdW5kYXJ5U2VnbWVudC5zdGF0dXMgPVxuICAgICAgICAgICAgICAgICAgICAgIDEyID09PSByZXF1ZXN0LnN0YXR1cyA/IEFCT1JURUQgOiBFUlJPUkVEKSxcbiAgICAgICAgICAgICAgICAgICAgdGhyb3duVmFsdWUpXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAodGFzay5ibG9ja2VkU2VnbWVudCA9IHBhcmVudFNlZ21lbnQpLFxuICAgICAgICAgICAgICAgICAgICAodGFzay5ibG9ja2VkUHJlYW1ibGUgPSBwYXJlbnRQcmVhbWJsZSksXG4gICAgICAgICAgICAgICAgICAgICh0YXNrLmtleVBhdGggPSBwcmV2S2V5UGF0aCRqc2NvbXAkNCksXG4gICAgICAgICAgICAgICAgICAgICh0YXNrLmZvcm1hdENvbnRleHQgPSBwcmV2Q29udGV4dCRqc2NvbXAkMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBzdXNwZW5kZWRQcmltYXJ5VGFzayA9IGNyZWF0ZVJlbmRlclRhc2soXG4gICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAtMSxcbiAgICAgICAgICAgICAgICAgIG5ld0JvdW5kYXJ5LFxuICAgICAgICAgICAgICAgICAgY29udGVudFJvb3RTZWdtZW50LFxuICAgICAgICAgICAgICAgICAgbmV3Qm91bmRhcnkuY29udGVudFByZWFtYmxlLFxuICAgICAgICAgICAgICAgICAgbmV3Qm91bmRhcnkuY29udGVudFN0YXRlLFxuICAgICAgICAgICAgICAgICAgdGFzay5hYm9ydFNldCxcbiAgICAgICAgICAgICAgICAgIGtleVBhdGgsXG4gICAgICAgICAgICAgICAgICBnZXRTdXNwZW5zZUNvbnRlbnRGb3JtYXRDb250ZXh0KFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LnJlc3VtYWJsZVN0YXRlLFxuICAgICAgICAgICAgICAgICAgICB0YXNrLmZvcm1hdENvbnRleHRcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICB0YXNrLmNvbnRleHQsXG4gICAgICAgICAgICAgICAgICB0YXNrLnRyZWVDb250ZXh0LFxuICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgIHN1c3BlbnNlQ29tcG9uZW50U3RhY2ssXG4gICAgICAgICAgICAgICAgICBlbXB0eUNvbnRleHRPYmplY3QsXG4gICAgICAgICAgICAgICAgICB0YXNrLmRlYnVnVGFza1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcHVzaENvbXBvbmVudFN0YWNrKHN1c3BlbmRlZFByaW1hcnlUYXNrKTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnBpbmdlZFRhc2tzLnB1c2goc3VzcGVuZGVkUHJpbWFyeVRhc2spO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhc2suYmxvY2tlZEJvdW5kYXJ5ID0gbmV3Qm91bmRhcnk7XG4gICAgICAgICAgICAgICAgdGFzay5ibG9ja2VkUHJlYW1ibGUgPSBuZXdCb3VuZGFyeS5jb250ZW50UHJlYW1ibGU7XG4gICAgICAgICAgICAgICAgdGFzay5ob2lzdGFibGVTdGF0ZSA9IG5ld0JvdW5kYXJ5LmNvbnRlbnRTdGF0ZTtcbiAgICAgICAgICAgICAgICB0YXNrLmJsb2NrZWRTZWdtZW50ID0gY29udGVudFJvb3RTZWdtZW50O1xuICAgICAgICAgICAgICAgIHRhc2sua2V5UGF0aCA9IGtleVBhdGg7XG4gICAgICAgICAgICAgICAgdGFzay5mb3JtYXRDb250ZXh0ID0gZ2V0U3VzcGVuc2VDb250ZW50Rm9ybWF0Q29udGV4dChcbiAgICAgICAgICAgICAgICAgIHJlcXVlc3QucmVzdW1hYmxlU3RhdGUsXG4gICAgICAgICAgICAgICAgICBwcmV2Q29udGV4dCRqc2NvbXAkMFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdGFzay5yb3cgPSBudWxsO1xuICAgICAgICAgICAgICAgIGNvbnRlbnRSb290U2VnbWVudC5zdGF0dXMgPSA2O1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIChyZW5kZXJOb2RlKHJlcXVlc3QsIHRhc2ssIGNvbnRlbnQsIC0xKSxcbiAgICAgICAgICAgICAgICAgICAgcHVzaFNlZ21lbnRGaW5hbGUoXG4gICAgICAgICAgICAgICAgICAgICAgY29udGVudFJvb3RTZWdtZW50LmNodW5rcyxcbiAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LnJlbmRlclN0YXRlLFxuICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRSb290U2VnbWVudC5sYXN0UHVzaGVkVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICBjb250ZW50Um9vdFNlZ21lbnQudGV4dEVtYmVkZGVkXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIChjb250ZW50Um9vdFNlZ21lbnQuc3RhdHVzID0gQ09NUExFVEVEKSxcbiAgICAgICAgICAgICAgICAgICAgcXVldWVDb21wbGV0ZWRTZWdtZW50KG5ld0JvdW5kYXJ5LCBjb250ZW50Um9vdFNlZ21lbnQpLFxuICAgICAgICAgICAgICAgICAgICAwID09PSBuZXdCb3VuZGFyeS5wZW5kaW5nVGFza3MgJiZcbiAgICAgICAgICAgICAgICAgICAgICBuZXdCb3VuZGFyeS5zdGF0dXMgPT09IFBFTkRJTkcpXG4gICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICgobmV3Qm91bmRhcnkuc3RhdHVzID0gQ09NUExFVEVEKSxcbiAgICAgICAgICAgICAgICAgICAgICAhaXNFbGlnaWJsZUZvck91dGxpbmluZyhyZXF1ZXN0LCBuZXdCb3VuZGFyeSkpXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgIG51bGwgIT09IHByZXZSb3ckanNjb21wJDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIDAgPT09IC0tcHJldlJvdyRqc2NvbXAkMC5wZW5kaW5nVGFza3MgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaFN1c3BlbnNlTGlzdFJvdyhyZXF1ZXN0LCBwcmV2Um93JGpzY29tcCQwKTtcbiAgICAgICAgICAgICAgICAgICAgICAwID09PSByZXF1ZXN0LnBlbmRpbmdSb290VGFza3MgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2suYmxvY2tlZFByZWFtYmxlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVwYXJlUHJlYW1ibGUocmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgIG51bGwgIT09IHByZXZSb3ckanNjb21wJDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICBwcmV2Um93JGpzY29tcCQwLnRvZ2V0aGVyICYmXG4gICAgICAgICAgICAgICAgICAgICAgdHJ5VG9SZXNvbHZlVG9nZXRoZXJSb3cocmVxdWVzdCwgcHJldlJvdyRqc2NvbXAkMCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAodGhyb3duVmFsdWUkMikge1xuICAgICAgICAgICAgICAgICAgbmV3Qm91bmRhcnkuc3RhdHVzID0gQ0xJRU5UX1JFTkRFUkVEO1xuICAgICAgICAgICAgICAgICAgaWYgKDEyID09PSByZXF1ZXN0LnN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50Um9vdFNlZ21lbnQuc3RhdHVzID0gQUJPUlRFRDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gcmVxdWVzdC5mYXRhbEVycm9yO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgIChjb250ZW50Um9vdFNlZ21lbnQuc3RhdHVzID0gRVJST1JFRCksXG4gICAgICAgICAgICAgICAgICAgICAgKGVycm9yID0gdGhyb3duVmFsdWUkMik7XG4gICAgICAgICAgICAgICAgICB2YXIgdGhyb3duSW5mbyA9IGdldFRocm93bkluZm8odGFzay5jb21wb25lbnRTdGFjayk7XG4gICAgICAgICAgICAgICAgICB2YXIgZXJyb3JEaWdlc3QgPSBsb2dSZWNvdmVyYWJsZUVycm9yKFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgdGhyb3duSW5mbyxcbiAgICAgICAgICAgICAgICAgICAgdGFzay5kZWJ1Z1Rhc2tcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBlbmNvZGVFcnJvckZvckJvdW5kYXJ5KFxuICAgICAgICAgICAgICAgICAgICBuZXdCb3VuZGFyeSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JEaWdlc3QsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgICAgICB0aHJvd25JbmZvLFxuICAgICAgICAgICAgICAgICAgICAhMVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIHVudHJhY2tCb3VuZGFyeShyZXF1ZXN0LCBuZXdCb3VuZGFyeSk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICh0YXNrLmJsb2NrZWRCb3VuZGFyeSA9IHBhcmVudEJvdW5kYXJ5KSxcbiAgICAgICAgICAgICAgICAgICAgKHRhc2suYmxvY2tlZFByZWFtYmxlID0gcGFyZW50UHJlYW1ibGUpLFxuICAgICAgICAgICAgICAgICAgICAodGFzay5ob2lzdGFibGVTdGF0ZSA9IHBhcmVudEhvaXN0YWJsZVN0YXRlKSxcbiAgICAgICAgICAgICAgICAgICAgKHRhc2suYmxvY2tlZFNlZ21lbnQgPSBwYXJlbnRTZWdtZW50KSxcbiAgICAgICAgICAgICAgICAgICAgKHRhc2sua2V5UGF0aCA9IHByZXZLZXlQYXRoJGpzY29tcCQ0KSxcbiAgICAgICAgICAgICAgICAgICAgKHRhc2suZm9ybWF0Q29udGV4dCA9IHByZXZDb250ZXh0JGpzY29tcCQwKSxcbiAgICAgICAgICAgICAgICAgICAgKHRhc2sucm93ID0gcHJldlJvdyRqc2NvbXAkMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBzdXNwZW5kZWRGYWxsYmFja1Rhc2sgPSBjcmVhdGVSZW5kZXJUYXNrKFxuICAgICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICBmYWxsYmFjayxcbiAgICAgICAgICAgICAgICAgIC0xLFxuICAgICAgICAgICAgICAgICAgcGFyZW50Qm91bmRhcnksXG4gICAgICAgICAgICAgICAgICBib3VuZGFyeVNlZ21lbnQsXG4gICAgICAgICAgICAgICAgICBuZXdCb3VuZGFyeS5mYWxsYmFja1ByZWFtYmxlLFxuICAgICAgICAgICAgICAgICAgbmV3Qm91bmRhcnkuZmFsbGJhY2tTdGF0ZSxcbiAgICAgICAgICAgICAgICAgIGZhbGxiYWNrQWJvcnRTZXQsXG4gICAgICAgICAgICAgICAgICBba2V5UGF0aFswXSwgXCJTdXNwZW5zZSBGYWxsYmFja1wiLCBrZXlQYXRoWzJdXSxcbiAgICAgICAgICAgICAgICAgIGdldFN1c3BlbnNlRmFsbGJhY2tGb3JtYXRDb250ZXh0KFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LnJlc3VtYWJsZVN0YXRlLFxuICAgICAgICAgICAgICAgICAgICB0YXNrLmZvcm1hdENvbnRleHRcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICB0YXNrLmNvbnRleHQsXG4gICAgICAgICAgICAgICAgICB0YXNrLnRyZWVDb250ZXh0LFxuICAgICAgICAgICAgICAgICAgdGFzay5yb3csXG4gICAgICAgICAgICAgICAgICByZXBsYWNlU3VzcGVuc2VDb21wb25lbnRTdGFja1dpdGhTdXNwZW5zZUZhbGxiYWNrU3RhY2soXG4gICAgICAgICAgICAgICAgICAgIHRhc2suY29tcG9uZW50U3RhY2tcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICBlbXB0eUNvbnRleHRPYmplY3QsXG4gICAgICAgICAgICAgICAgICB0YXNrLmRlYnVnVGFza1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcHVzaENvbXBvbmVudFN0YWNrKHN1c3BlbmRlZEZhbGxiYWNrVGFzayk7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5waW5nZWRUYXNrcy5wdXNoKHN1c3BlbmRlZEZhbGxiYWNrVGFzayk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUgJiYgbnVsbCAhPT0gdHlwZSlcbiAgICAgICAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgICAgaWYgKFwicmVmXCIgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcHNXaXRob3V0UmVmID0ge307XG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHByb3BzKVxuICAgICAgICAgICAgICAgICAgXCJyZWZcIiAhPT0ga2V5ICYmIChwcm9wc1dpdGhvdXRSZWZba2V5XSA9IHByb3BzW2tleV0pO1xuICAgICAgICAgICAgICB9IGVsc2UgcHJvcHNXaXRob3V0UmVmID0gcHJvcHM7XG4gICAgICAgICAgICAgIHZhciBjaGlsZHJlbiRqc2NvbXAkMSA9IHJlbmRlcldpdGhIb29rcyhcbiAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgIHRhc2ssXG4gICAgICAgICAgICAgICAga2V5UGF0aCxcbiAgICAgICAgICAgICAgICB0eXBlLnJlbmRlcixcbiAgICAgICAgICAgICAgICBwcm9wc1dpdGhvdXRSZWYsXG4gICAgICAgICAgICAgICAgcmVmXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGZpbmlzaEZ1bmN0aW9uQ29tcG9uZW50KFxuICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgdGFzayxcbiAgICAgICAgICAgICAgICBrZXlQYXRoLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuJGpzY29tcCQxLFxuICAgICAgICAgICAgICAgIDAgIT09IGxvY2FsSWRDb3VudGVyLFxuICAgICAgICAgICAgICAgIGFjdGlvblN0YXRlQ291bnRlcixcbiAgICAgICAgICAgICAgICBhY3Rpb25TdGF0ZU1hdGNoaW5nSW5kZXhcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICAgIHJlbmRlckVsZW1lbnQocmVxdWVzdCwgdGFzaywga2V5UGF0aCwgdHlwZS50eXBlLCBwcm9wcywgcmVmKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICAgIHZhciB2YWx1ZSRqc2NvbXAkMCA9IHByb3BzLnZhbHVlLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuJGpzY29tcCQyID0gcHJvcHMuY2hpbGRyZW47XG4gICAgICAgICAgICAgIHZhciBwcmV2U25hcHNob3QgPSB0YXNrLmNvbnRleHQ7XG4gICAgICAgICAgICAgIHZhciBwcmV2S2V5UGF0aCRqc2NvbXAkNSA9IHRhc2sua2V5UGF0aDtcbiAgICAgICAgICAgICAgdmFyIHByZXZWYWx1ZSA9IHR5cGUuX2N1cnJlbnRWYWx1ZTI7XG4gICAgICAgICAgICAgIHR5cGUuX2N1cnJlbnRWYWx1ZTIgPSB2YWx1ZSRqc2NvbXAkMDtcbiAgICAgICAgICAgICAgdm9pZCAwICE9PSB0eXBlLl9jdXJyZW50UmVuZGVyZXIyICYmXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gdHlwZS5fY3VycmVudFJlbmRlcmVyMiAmJlxuICAgICAgICAgICAgICAgIHR5cGUuX2N1cnJlbnRSZW5kZXJlcjIgIT09IHJlbmRlcmVyU2lnaWwgJiZcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJEZXRlY3RlZCBtdWx0aXBsZSByZW5kZXJlcnMgY29uY3VycmVudGx5IHJlbmRlcmluZyB0aGUgc2FtZSBjb250ZXh0IHByb3ZpZGVyLiBUaGlzIGlzIGN1cnJlbnRseSB1bnN1cHBvcnRlZC5cIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHR5cGUuX2N1cnJlbnRSZW5kZXJlcjIgPSByZW5kZXJlclNpZ2lsO1xuICAgICAgICAgICAgICB2YXIgcHJldk5vZGUgPSBjdXJyZW50QWN0aXZlU25hcHNob3QsXG4gICAgICAgICAgICAgICAgbmV3Tm9kZSA9IHtcbiAgICAgICAgICAgICAgICAgIHBhcmVudDogcHJldk5vZGUsXG4gICAgICAgICAgICAgICAgICBkZXB0aDogbnVsbCA9PT0gcHJldk5vZGUgPyAwIDogcHJldk5vZGUuZGVwdGggKyAxLFxuICAgICAgICAgICAgICAgICAgY29udGV4dDogdHlwZSxcbiAgICAgICAgICAgICAgICAgIHBhcmVudFZhbHVlOiBwcmV2VmFsdWUsXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUkanNjb21wJDBcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBjdXJyZW50QWN0aXZlU25hcHNob3QgPSBuZXdOb2RlO1xuICAgICAgICAgICAgICB0YXNrLmNvbnRleHQgPSBuZXdOb2RlO1xuICAgICAgICAgICAgICB0YXNrLmtleVBhdGggPSBrZXlQYXRoO1xuICAgICAgICAgICAgICByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgY2hpbGRyZW4kanNjb21wJDIsIC0xKTtcbiAgICAgICAgICAgICAgdmFyIHByZXZTbmFwc2hvdCRqc2NvbXAkMCA9IGN1cnJlbnRBY3RpdmVTbmFwc2hvdDtcbiAgICAgICAgICAgICAgaWYgKG51bGwgPT09IHByZXZTbmFwc2hvdCRqc2NvbXAkMClcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiVHJpZWQgdG8gcG9wIGEgQ29udGV4dCBhdCB0aGUgcm9vdCBvZiB0aGUgYXBwLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcHJldlNuYXBzaG90JGpzY29tcCQwLmNvbnRleHQgIT09IHR5cGUgJiZcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJUaGUgcGFyZW50IGNvbnRleHQgaXMgbm90IHRoZSBleHBlY3RlZCBjb250ZXh0LiBUaGlzIGlzIHByb2JhYmx5IGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcHJldlNuYXBzaG90JGpzY29tcCQwLmNvbnRleHQuX2N1cnJlbnRWYWx1ZTIgPVxuICAgICAgICAgICAgICAgIHByZXZTbmFwc2hvdCRqc2NvbXAkMC5wYXJlbnRWYWx1ZTtcbiAgICAgICAgICAgICAgdm9pZCAwICE9PSB0eXBlLl9jdXJyZW50UmVuZGVyZXIyICYmXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gdHlwZS5fY3VycmVudFJlbmRlcmVyMiAmJlxuICAgICAgICAgICAgICAgIHR5cGUuX2N1cnJlbnRSZW5kZXJlcjIgIT09IHJlbmRlcmVyU2lnaWwgJiZcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJEZXRlY3RlZCBtdWx0aXBsZSByZW5kZXJlcnMgY29uY3VycmVudGx5IHJlbmRlcmluZyB0aGUgc2FtZSBjb250ZXh0IHByb3ZpZGVyLiBUaGlzIGlzIGN1cnJlbnRseSB1bnN1cHBvcnRlZC5cIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHR5cGUuX2N1cnJlbnRSZW5kZXJlcjIgPSByZW5kZXJlclNpZ2lsO1xuICAgICAgICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwID0gKGN1cnJlbnRBY3RpdmVTbmFwc2hvdCA9XG4gICAgICAgICAgICAgICAgcHJldlNuYXBzaG90JGpzY29tcCQwLnBhcmVudCk7XG4gICAgICAgICAgICAgIHRhc2suY29udGV4dCA9IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMDtcbiAgICAgICAgICAgICAgdGFzay5rZXlQYXRoID0gcHJldktleVBhdGgkanNjb21wJDU7XG4gICAgICAgICAgICAgIHByZXZTbmFwc2hvdCAhPT0gdGFzay5jb250ZXh0ICYmXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiUG9wcGluZyB0aGUgY29udGV4dCBwcm92aWRlciBkaWQgbm90IHJldHVybiBiYWNrIHRvIHRoZSBvcmlnaW5hbCBzbmFwc2hvdC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OU1VNRVJfVFlQRTpcbiAgICAgICAgICAgICAgdmFyIGNvbnRleHQkanNjb21wJDAgPSB0eXBlLl9jb250ZXh0LFxuICAgICAgICAgICAgICAgIHJlbmRlciA9IHByb3BzLmNoaWxkcmVuO1xuICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiByZW5kZXIgJiZcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJBIGNvbnRleHQgY29uc3VtZXIgd2FzIHJlbmRlcmVkIHdpdGggbXVsdGlwbGUgY2hpbGRyZW4sIG9yIGEgY2hpbGQgdGhhdCBpc24ndCBhIGZ1bmN0aW9uLiBBIGNvbnRleHQgY29uc3VtZXIgZXhwZWN0cyBhIHNpbmdsZSBjaGlsZCB0aGF0IGlzIGEgZnVuY3Rpb24uIElmIHlvdSBkaWQgcGFzcyBhIGZ1bmN0aW9uLCBtYWtlIHN1cmUgdGhlcmUgaXMgbm8gdHJhaWxpbmcgb3IgbGVhZGluZyB3aGl0ZXNwYWNlIGFyb3VuZCBpdC5cIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHZhciBuZXdDaGlsZHJlbiA9IHJlbmRlcihjb250ZXh0JGpzY29tcCQwLl9jdXJyZW50VmFsdWUyKSxcbiAgICAgICAgICAgICAgICBwcmV2S2V5UGF0aCRqc2NvbXAkNiA9IHRhc2sua2V5UGF0aDtcbiAgICAgICAgICAgICAgdGFzay5rZXlQYXRoID0ga2V5UGF0aDtcbiAgICAgICAgICAgICAgcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIG5ld0NoaWxkcmVuLCAtMSk7XG4gICAgICAgICAgICAgIHRhc2sua2V5UGF0aCA9IHByZXZLZXlQYXRoJGpzY29tcCQ2O1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgICAgdmFyIENvbXBvbmVudCA9IGNhbGxMYXp5SW5pdEluREVWKHR5cGUpO1xuICAgICAgICAgICAgICBpZiAoMTIgPT09IHJlcXVlc3Quc3RhdHVzKSB0aHJvdyBudWxsO1xuICAgICAgICAgICAgICByZW5kZXJFbGVtZW50KHJlcXVlc3QsIHRhc2ssIGtleVBhdGgsIENvbXBvbmVudCwgcHJvcHMsIHJlZik7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIHZhciBpbmZvID0gXCJcIjtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHZvaWQgMCA9PT0gdHlwZSB8fFxuICAgICAgICAgIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSAmJlxuICAgICAgICAgICAgbnVsbCAhPT0gdHlwZSAmJlxuICAgICAgICAgICAgMCA9PT0gT2JqZWN0LmtleXModHlwZSkubGVuZ3RoKVxuICAgICAgICApXG4gICAgICAgICAgaW5mbyArPVxuICAgICAgICAgICAgXCIgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIkVsZW1lbnQgdHlwZSBpcyBpbnZhbGlkOiBleHBlY3RlZCBhIHN0cmluZyAoZm9yIGJ1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgY29tcG9uZW50cykgYnV0IGdvdDogXCIgK1xuICAgICAgICAgICAgKChudWxsID09IHR5cGUgPyB0eXBlIDogdHlwZW9mIHR5cGUpICsgXCIuXCIgKyBpbmZvKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZXN1bWVOb2RlKHJlcXVlc3QsIHRhc2ssIHNlZ21lbnRJZCwgbm9kZSwgY2hpbGRJbmRleCkge1xuICAgICAgdmFyIHByZXZSZXBsYXkgPSB0YXNrLnJlcGxheSxcbiAgICAgICAgYmxvY2tlZEJvdW5kYXJ5ID0gdGFzay5ibG9ja2VkQm91bmRhcnksXG4gICAgICAgIHJlc3VtZWRTZWdtZW50ID0gY3JlYXRlUGVuZGluZ1NlZ21lbnQoXG4gICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAwLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgdGFzay5mb3JtYXRDb250ZXh0LFxuICAgICAgICAgICExLFxuICAgICAgICAgICExXG4gICAgICAgICk7XG4gICAgICByZXN1bWVkU2VnbWVudC5pZCA9IHNlZ21lbnRJZDtcbiAgICAgIHJlc3VtZWRTZWdtZW50LnBhcmVudEZsdXNoZWQgPSAhMDtcbiAgICAgIHRyeSB7XG4gICAgICAgICh0YXNrLnJlcGxheSA9IG51bGwpLFxuICAgICAgICAgICh0YXNrLmJsb2NrZWRTZWdtZW50ID0gcmVzdW1lZFNlZ21lbnQpLFxuICAgICAgICAgIHJlbmRlck5vZGUocmVxdWVzdCwgdGFzaywgbm9kZSwgY2hpbGRJbmRleCksXG4gICAgICAgICAgKHJlc3VtZWRTZWdtZW50LnN0YXR1cyA9IENPTVBMRVRFRCksXG4gICAgICAgICAgbnVsbCA9PT0gYmxvY2tlZEJvdW5kYXJ5XG4gICAgICAgICAgICA/IChyZXF1ZXN0LmNvbXBsZXRlZFJvb3RTZWdtZW50ID0gcmVzdW1lZFNlZ21lbnQpXG4gICAgICAgICAgICA6IChxdWV1ZUNvbXBsZXRlZFNlZ21lbnQoYmxvY2tlZEJvdW5kYXJ5LCByZXN1bWVkU2VnbWVudCksXG4gICAgICAgICAgICAgIGJsb2NrZWRCb3VuZGFyeS5wYXJlbnRGbHVzaGVkICYmXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5wYXJ0aWFsQm91bmRhcmllcy5wdXNoKGJsb2NrZWRCb3VuZGFyeSkpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgKHRhc2sucmVwbGF5ID0gcHJldlJlcGxheSksICh0YXNrLmJsb2NrZWRTZWdtZW50ID0gbnVsbCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcGxheUVsZW1lbnQoXG4gICAgICByZXF1ZXN0LFxuICAgICAgdGFzayxcbiAgICAgIGtleVBhdGgsXG4gICAgICBuYW1lLFxuICAgICAga2V5T3JJbmRleCxcbiAgICAgIGNoaWxkSW5kZXgsXG4gICAgICB0eXBlLFxuICAgICAgcHJvcHMsXG4gICAgICByZWYsXG4gICAgICByZXBsYXlcbiAgICApIHtcbiAgICAgIGNoaWxkSW5kZXggPSByZXBsYXkubm9kZXM7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkSW5kZXgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSBjaGlsZEluZGV4W2ldO1xuICAgICAgICBpZiAoa2V5T3JJbmRleCA9PT0gbm9kZVsxXSkge1xuICAgICAgICAgIGlmICg0ID09PSBub2RlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKG51bGwgIT09IG5hbWUgJiYgbmFtZSAhPT0gbm9kZVswXSlcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJFeHBlY3RlZCB0aGUgcmVzdW1lIHRvIHJlbmRlciA8XCIgK1xuICAgICAgICAgICAgICAgICAgbm9kZVswXSArXG4gICAgICAgICAgICAgICAgICBcIj4gaW4gdGhpcyBzbG90IGJ1dCBpbnN0ZWFkIGl0IHJlbmRlcmVkIDxcIiArXG4gICAgICAgICAgICAgICAgICBuYW1lICtcbiAgICAgICAgICAgICAgICAgIFwiPi4gVGhlIHRyZWUgZG9lc24ndCBtYXRjaCBzbyBSZWFjdCB3aWxsIGZhbGxiYWNrIHRvIGNsaWVudCByZW5kZXJpbmcuXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHZhciBjaGlsZE5vZGVzID0gbm9kZVsyXTtcbiAgICAgICAgICAgIG5hbWUgPSBub2RlWzNdO1xuICAgICAgICAgICAga2V5T3JJbmRleCA9IHRhc2subm9kZTtcbiAgICAgICAgICAgIHRhc2sucmVwbGF5ID0geyBub2RlczogY2hpbGROb2Rlcywgc2xvdHM6IG5hbWUsIHBlbmRpbmdUYXNrczogMSB9O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmVuZGVyRWxlbWVudChyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCB0eXBlLCBwcm9wcywgcmVmKTtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIDEgPT09IHRhc2sucmVwbGF5LnBlbmRpbmdUYXNrcyAmJlxuICAgICAgICAgICAgICAgIDAgPCB0YXNrLnJlcGxheS5ub2Rlcy5sZW5ndGhcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJDb3VsZG4ndCBmaW5kIGFsbCByZXN1bWFibGUgc2xvdHMgYnkga2V5L2luZGV4IGR1cmluZyByZXBsYXlpbmcuIFRoZSB0cmVlIGRvZXNuJ3QgbWF0Y2ggc28gUmVhY3Qgd2lsbCBmYWxsYmFjayB0byBjbGllbnQgcmVuZGVyaW5nLlwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgdGFzay5yZXBsYXkucGVuZGluZ1Rhc2tzLS07XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgeCAmJlxuICAgICAgICAgICAgICAgIG51bGwgIT09IHggJiZcbiAgICAgICAgICAgICAgICAoeCA9PT0gU3VzcGVuc2VFeGNlcHRpb24gfHwgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgeC50aGVuKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgdGhyb3cgKFxuICAgICAgICAgICAgICAgICAgKHRhc2subm9kZSA9PT0ga2V5T3JJbmRleFxuICAgICAgICAgICAgICAgICAgICA/ICh0YXNrLnJlcGxheSA9IHJlcGxheSlcbiAgICAgICAgICAgICAgICAgICAgOiBjaGlsZEluZGV4LnNwbGljZShpLCAxKSxcbiAgICAgICAgICAgICAgICAgIHgpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgdGFzay5yZXBsYXkucGVuZGluZ1Rhc2tzLS07XG4gICAgICAgICAgICAgIHR5cGUgPSBnZXRUaHJvd25JbmZvKHRhc2suY29tcG9uZW50U3RhY2spO1xuICAgICAgICAgICAgICBwcm9wcyA9IHJlcXVlc3Q7XG4gICAgICAgICAgICAgIHJlcXVlc3QgPSB0YXNrLmJsb2NrZWRCb3VuZGFyeTtcbiAgICAgICAgICAgICAga2V5UGF0aCA9IHg7XG4gICAgICAgICAgICAgIHJlZiA9IG5hbWU7XG4gICAgICAgICAgICAgIG5hbWUgPSBsb2dSZWNvdmVyYWJsZUVycm9yKHByb3BzLCBrZXlQYXRoLCB0eXBlLCB0YXNrLmRlYnVnVGFzayk7XG4gICAgICAgICAgICAgIGFib3J0UmVtYWluaW5nUmVwbGF5Tm9kZXMoXG4gICAgICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICBjaGlsZE5vZGVzLFxuICAgICAgICAgICAgICAgIHJlZixcbiAgICAgICAgICAgICAgICBrZXlQYXRoLFxuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICAhMVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFzay5yZXBsYXkgPSByZXBsYXk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlICE9PSBSRUFDVF9TVVNQRU5TRV9UWVBFKVxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIkV4cGVjdGVkIHRoZSByZXN1bWUgdG8gcmVuZGVyIDxTdXNwZW5zZT4gaW4gdGhpcyBzbG90IGJ1dCBpbnN0ZWFkIGl0IHJlbmRlcmVkIDxcIiArXG4gICAgICAgICAgICAgICAgICAoZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHx8IFwiVW5rbm93blwiKSArXG4gICAgICAgICAgICAgICAgICBcIj4uIFRoZSB0cmVlIGRvZXNuJ3QgbWF0Y2ggc28gUmVhY3Qgd2lsbCBmYWxsYmFjayB0byBjbGllbnQgcmVuZGVyaW5nLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBhOiB7XG4gICAgICAgICAgICAgIHJlcGxheSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgbmFtZSA9IG5vZGVbNV07XG4gICAgICAgICAgICAgIHR5cGUgPSBub2RlWzJdO1xuICAgICAgICAgICAgICByZWYgPSBub2RlWzNdO1xuICAgICAgICAgICAgICBrZXlPckluZGV4ID0gbnVsbCA9PT0gbm9kZVs0XSA/IFtdIDogbm9kZVs0XVsyXTtcbiAgICAgICAgICAgICAgbm9kZSA9IG51bGwgPT09IG5vZGVbNF0gPyBudWxsIDogbm9kZVs0XVszXTtcbiAgICAgICAgICAgICAgdmFyIHByZXZLZXlQYXRoID0gdGFzay5rZXlQYXRoLFxuICAgICAgICAgICAgICAgIHByZXZDb250ZXh0ID0gdGFzay5mb3JtYXRDb250ZXh0LFxuICAgICAgICAgICAgICAgIHByZXZSb3cgPSB0YXNrLnJvdyxcbiAgICAgICAgICAgICAgICBwcmV2aW91c1JlcGxheVNldCA9IHRhc2sucmVwbGF5LFxuICAgICAgICAgICAgICAgIHBhcmVudEJvdW5kYXJ5ID0gdGFzay5ibG9ja2VkQm91bmRhcnksXG4gICAgICAgICAgICAgICAgcGFyZW50SG9pc3RhYmxlU3RhdGUgPSB0YXNrLmhvaXN0YWJsZVN0YXRlLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgICAgICAgICAgICBmYWxsYmFjayA9IHByb3BzLmZhbGxiYWNrLFxuICAgICAgICAgICAgICAgIGZhbGxiYWNrQWJvcnRTZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICAgIHByb3BzID0gY3JlYXRlU3VzcGVuc2VCb3VuZGFyeShcbiAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgIHRhc2sucm93LFxuICAgICAgICAgICAgICAgIGZhbGxiYWNrQWJvcnRTZXQsXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHByb3BzLnBhcmVudEZsdXNoZWQgPSAhMDtcbiAgICAgICAgICAgICAgcHJvcHMucm9vdFNlZ21lbnRJRCA9IG5hbWU7XG4gICAgICAgICAgICAgIHRhc2suYmxvY2tlZEJvdW5kYXJ5ID0gcHJvcHM7XG4gICAgICAgICAgICAgIHRhc2suaG9pc3RhYmxlU3RhdGUgPSBwcm9wcy5jb250ZW50U3RhdGU7XG4gICAgICAgICAgICAgIHRhc2sua2V5UGF0aCA9IGtleVBhdGg7XG4gICAgICAgICAgICAgIHRhc2suZm9ybWF0Q29udGV4dCA9IGdldFN1c3BlbnNlQ29udGVudEZvcm1hdENvbnRleHQoXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5yZXN1bWFibGVTdGF0ZSxcbiAgICAgICAgICAgICAgICBwcmV2Q29udGV4dFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB0YXNrLnJvdyA9IG51bGw7XG4gICAgICAgICAgICAgIHRhc2sucmVwbGF5ID0geyBub2RlczogdHlwZSwgc2xvdHM6IHJlZiwgcGVuZGluZ1Rhc2tzOiAxIH07XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyTm9kZShyZXF1ZXN0LCB0YXNrLCBjb250ZW50LCAtMSk7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgMSA9PT0gdGFzay5yZXBsYXkucGVuZGluZ1Rhc2tzICYmXG4gICAgICAgICAgICAgICAgICAwIDwgdGFzay5yZXBsYXkubm9kZXMubGVuZ3RoXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiQ291bGRuJ3QgZmluZCBhbGwgcmVzdW1hYmxlIHNsb3RzIGJ5IGtleS9pbmRleCBkdXJpbmcgcmVwbGF5aW5nLiBUaGUgdHJlZSBkb2Vzbid0IG1hdGNoIHNvIFJlYWN0IHdpbGwgZmFsbGJhY2sgdG8gY2xpZW50IHJlbmRlcmluZy5cIlxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB0YXNrLnJlcGxheS5wZW5kaW5nVGFza3MtLTtcbiAgICAgICAgICAgICAgICBpZiAoMCA9PT0gcHJvcHMucGVuZGluZ1Rhc2tzICYmIHByb3BzLnN0YXR1cyA9PT0gUEVORElORykge1xuICAgICAgICAgICAgICAgICAgcHJvcHMuc3RhdHVzID0gQ09NUExFVEVEO1xuICAgICAgICAgICAgICAgICAgcmVxdWVzdC5jb21wbGV0ZWRCb3VuZGFyaWVzLnB1c2gocHJvcHMpO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgKHByb3BzLnN0YXR1cyA9IENMSUVOVF9SRU5ERVJFRCksXG4gICAgICAgICAgICAgICAgICAoY2hpbGROb2RlcyA9IGdldFRocm93bkluZm8odGFzay5jb21wb25lbnRTdGFjaykpLFxuICAgICAgICAgICAgICAgICAgKHJlcGxheSA9IGxvZ1JlY292ZXJhYmxlRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGVzLFxuICAgICAgICAgICAgICAgICAgICB0YXNrLmRlYnVnVGFza1xuICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgICBlbmNvZGVFcnJvckZvckJvdW5kYXJ5KHByb3BzLCByZXBsYXksIGVycm9yLCBjaGlsZE5vZGVzLCAhMSksXG4gICAgICAgICAgICAgICAgICB0YXNrLnJlcGxheS5wZW5kaW5nVGFza3MtLSxcbiAgICAgICAgICAgICAgICAgIHJlcXVlc3QuY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzLnB1c2gocHJvcHMpO1xuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICh0YXNrLmJsb2NrZWRCb3VuZGFyeSA9IHBhcmVudEJvdW5kYXJ5KSxcbiAgICAgICAgICAgICAgICAgICh0YXNrLmhvaXN0YWJsZVN0YXRlID0gcGFyZW50SG9pc3RhYmxlU3RhdGUpLFxuICAgICAgICAgICAgICAgICAgKHRhc2sucmVwbGF5ID0gcHJldmlvdXNSZXBsYXlTZXQpLFxuICAgICAgICAgICAgICAgICAgKHRhc2sua2V5UGF0aCA9IHByZXZLZXlQYXRoKSxcbiAgICAgICAgICAgICAgICAgICh0YXNrLmZvcm1hdENvbnRleHQgPSBwcmV2Q29udGV4dCksXG4gICAgICAgICAgICAgICAgICAodGFzay5yb3cgPSBwcmV2Um93KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwcm9wcyA9IGNyZWF0ZVJlcGxheVRhc2soXG4gICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIHsgbm9kZXM6IGtleU9ySW5kZXgsIHNsb3RzOiBub2RlLCBwZW5kaW5nVGFza3M6IDAgfSxcbiAgICAgICAgICAgICAgICBmYWxsYmFjayxcbiAgICAgICAgICAgICAgICAtMSxcbiAgICAgICAgICAgICAgICBwYXJlbnRCb3VuZGFyeSxcbiAgICAgICAgICAgICAgICBwcm9wcy5mYWxsYmFja1N0YXRlLFxuICAgICAgICAgICAgICAgIGZhbGxiYWNrQWJvcnRTZXQsXG4gICAgICAgICAgICAgICAgW2tleVBhdGhbMF0sIFwiU3VzcGVuc2UgRmFsbGJhY2tcIiwga2V5UGF0aFsyXV0sXG4gICAgICAgICAgICAgICAgZ2V0U3VzcGVuc2VGYWxsYmFja0Zvcm1hdENvbnRleHQoXG4gICAgICAgICAgICAgICAgICByZXF1ZXN0LnJlc3VtYWJsZVN0YXRlLFxuICAgICAgICAgICAgICAgICAgdGFzay5mb3JtYXRDb250ZXh0XG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICB0YXNrLmNvbnRleHQsXG4gICAgICAgICAgICAgICAgdGFzay50cmVlQ29udGV4dCxcbiAgICAgICAgICAgICAgICB0YXNrLnJvdyxcbiAgICAgICAgICAgICAgICByZXBsYWNlU3VzcGVuc2VDb21wb25lbnRTdGFja1dpdGhTdXNwZW5zZUZhbGxiYWNrU3RhY2soXG4gICAgICAgICAgICAgICAgICB0YXNrLmNvbXBvbmVudFN0YWNrXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBlbXB0eUNvbnRleHRPYmplY3QsXG4gICAgICAgICAgICAgICAgdGFzay5kZWJ1Z1Rhc2tcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcHVzaENvbXBvbmVudFN0YWNrKHByb3BzKTtcbiAgICAgICAgICAgICAgcmVxdWVzdC5waW5nZWRUYXNrcy5wdXNoKHByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY2hpbGRJbmRleC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVJdGVyYWJsZShcbiAgICAgIHRhc2ssXG4gICAgICBpdGVyYWJsZSxcbiAgICAgIGNoaWxkSW5kZXgsXG4gICAgICBpdGVyYXRvcixcbiAgICAgIGl0ZXJhdG9yRm5cbiAgICApIHtcbiAgICAgIGlmIChpdGVyYXRvciA9PT0gaXRlcmFibGUpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIC0xICE9PSBjaGlsZEluZGV4IHx8XG4gICAgICAgICAgbnVsbCA9PT0gdGFzay5jb21wb25lbnRTdGFjayB8fFxuICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHRhc2suY29tcG9uZW50U3RhY2sudHlwZSB8fFxuICAgICAgICAgIFwiW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl1cIiAhPT1cbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0YXNrLmNvbXBvbmVudFN0YWNrLnR5cGUpIHx8XG4gICAgICAgICAgXCJbb2JqZWN0IEdlbmVyYXRvcl1cIiAhPT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGl0ZXJhdG9yKVxuICAgICAgICApXG4gICAgICAgICAgZGlkV2FybkFib3V0R2VuZXJhdG9ycyB8fFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJVc2luZyBJdGVyYXRvcnMgYXMgY2hpbGRyZW4gaXMgdW5zdXBwb3J0ZWQgYW5kIHdpbGwgbGlrZWx5IHlpZWxkIHVuZXhwZWN0ZWQgcmVzdWx0cyBiZWNhdXNlIGVudW1lcmF0aW5nIGEgZ2VuZXJhdG9yIG11dGF0ZXMgaXQuIFlvdSBtYXkgY29udmVydCBpdCB0byBhbiBhcnJheSB3aXRoIGBBcnJheS5mcm9tKClgIG9yIHRoZSBgWy4uLnNwcmVhZF1gIG9wZXJhdG9yIGJlZm9yZSByZW5kZXJpbmcuIFlvdSBjYW4gYWxzbyB1c2UgYW4gSXRlcmFibGUgdGhhdCBjYW4gaXRlcmF0ZSBtdWx0aXBsZSB0aW1lcyBvdmVyIHRoZSBzYW1lIGl0ZW1zLlwiXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgKGRpZFdhcm5BYm91dEdlbmVyYXRvcnMgPSAhMCk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgaXRlcmFibGUuZW50cmllcyAhPT0gaXRlcmF0b3JGbiB8fFxuICAgICAgICAgIGRpZFdhcm5BYm91dE1hcHMgfHxcbiAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiVXNpbmcgTWFwcyBhcyBjaGlsZHJlbiBpcyBub3Qgc3VwcG9ydGVkLiBVc2UgYW4gYXJyYXkgb2Yga2V5ZWQgUmVhY3RFbGVtZW50cyBpbnN0ZWFkLlwiXG4gICAgICAgICAgKSxcbiAgICAgICAgICAoZGlkV2FybkFib3V0TWFwcyA9ICEwKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBub2RlLCBjaGlsZEluZGV4KSB7XG4gICAgICBudWxsICE9PSB0YXNrLnJlcGxheSAmJiBcIm51bWJlclwiID09PSB0eXBlb2YgdGFzay5yZXBsYXkuc2xvdHNcbiAgICAgICAgPyByZXN1bWVOb2RlKHJlcXVlc3QsIHRhc2ssIHRhc2sucmVwbGF5LnNsb3RzLCBub2RlLCBjaGlsZEluZGV4KVxuICAgICAgICA6ICgodGFzay5ub2RlID0gbm9kZSksXG4gICAgICAgICAgKHRhc2suY2hpbGRJbmRleCA9IGNoaWxkSW5kZXgpLFxuICAgICAgICAgIChub2RlID0gdGFzay5jb21wb25lbnRTdGFjayksXG4gICAgICAgICAgKGNoaWxkSW5kZXggPSB0YXNrLmRlYnVnVGFzayksXG4gICAgICAgICAgcHVzaENvbXBvbmVudFN0YWNrKHRhc2spLFxuICAgICAgICAgIHJldHJ5Tm9kZShyZXF1ZXN0LCB0YXNrKSxcbiAgICAgICAgICAodGFzay5jb21wb25lbnRTdGFjayA9IG5vZGUpLFxuICAgICAgICAgICh0YXNrLmRlYnVnVGFzayA9IGNoaWxkSW5kZXgpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmV0cnlOb2RlKHJlcXVlc3QsIHRhc2spIHtcbiAgICAgIHZhciBub2RlID0gdGFzay5ub2RlLFxuICAgICAgICBjaGlsZEluZGV4ID0gdGFzay5jaGlsZEluZGV4O1xuICAgICAgaWYgKG51bGwgIT09IG5vZGUpIHtcbiAgICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBub2RlKSB7XG4gICAgICAgICAgc3dpdGNoIChub2RlLiQkdHlwZW9mKSB7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICAgICAgdmFyIHR5cGUgPSBub2RlLnR5cGUsXG4gICAgICAgICAgICAgICAga2V5ID0gbm9kZS5rZXk7XG4gICAgICAgICAgICAgIG5vZGUgPSBub2RlLnByb3BzO1xuICAgICAgICAgICAgICB2YXIgcmVmUHJvcCA9IG5vZGUucmVmO1xuICAgICAgICAgICAgICByZWZQcm9wID0gdm9pZCAwICE9PSByZWZQcm9wID8gcmVmUHJvcCA6IG51bGw7XG4gICAgICAgICAgICAgIHZhciBkZWJ1Z1Rhc2sgPSB0YXNrLmRlYnVnVGFzayxcbiAgICAgICAgICAgICAgICBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgICAgICAgICBrZXkgPSBudWxsID09IGtleSA/ICgtMSA9PT0gY2hpbGRJbmRleCA/IDAgOiBjaGlsZEluZGV4KSA6IGtleTtcbiAgICAgICAgICAgICAgdmFyIGtleVBhdGggPSBbdGFzay5rZXlQYXRoLCBuYW1lLCBrZXldO1xuICAgICAgICAgICAgICBudWxsICE9PSB0YXNrLnJlcGxheVxuICAgICAgICAgICAgICAgID8gZGVidWdUYXNrXG4gICAgICAgICAgICAgICAgICA/IGRlYnVnVGFzay5ydW4oXG4gICAgICAgICAgICAgICAgICAgICAgcmVwbGF5RWxlbWVudC5iaW5kKFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrLFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5UGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZEluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZQcm9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFzay5yZXBsYXlcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIDogcmVwbGF5RWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICAgIHRhc2ssXG4gICAgICAgICAgICAgICAgICAgICAga2V5UGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICBjaGlsZEluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICByZWZQcm9wLFxuICAgICAgICAgICAgICAgICAgICAgIHRhc2sucmVwbGF5XG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICA6IGRlYnVnVGFza1xuICAgICAgICAgICAgICAgICAgPyBkZWJ1Z1Rhc2sucnVuKFxuICAgICAgICAgICAgICAgICAgICAgIHJlbmRlckVsZW1lbnQuYmluZChcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFzayxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleVBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZlByb3BcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIDogcmVuZGVyRWxlbWVudChyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCB0eXBlLCBub2RlLCByZWZQcm9wKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJQb3J0YWxzIGFyZSBub3QgY3VycmVudGx5IHN1cHBvcnRlZCBieSB0aGUgc2VydmVyIHJlbmRlcmVyLiBSZW5kZXIgdGhlbSBjb25kaXRpb25hbGx5IHNvIHRoYXQgdGhleSBvbmx5IGFwcGVhciBvbiB0aGUgY2xpZW50IHJlbmRlci5cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAgIHR5cGUgPSBjYWxsTGF6eUluaXRJbkRFVihub2RlKTtcbiAgICAgICAgICAgICAgaWYgKDEyID09PSByZXF1ZXN0LnN0YXR1cykgdGhyb3cgbnVsbDtcbiAgICAgICAgICAgICAgcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIHR5cGUsIGNoaWxkSW5kZXgpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0FycmF5SW1wbChub2RlKSkge1xuICAgICAgICAgICAgcmVuZGVyQ2hpbGRyZW5BcnJheShyZXF1ZXN0LCB0YXNrLCBub2RlLCBjaGlsZEluZGV4KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKChrZXkgPSBnZXRJdGVyYXRvckZuKG5vZGUpKSlcbiAgICAgICAgICAgIGlmICgodHlwZSA9IGtleS5jYWxsKG5vZGUpKSkge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUl0ZXJhYmxlKHRhc2ssIG5vZGUsIGNoaWxkSW5kZXgsIHR5cGUsIGtleSk7XG4gICAgICAgICAgICAgIG5vZGUgPSB0eXBlLm5leHQoKTtcbiAgICAgICAgICAgICAgaWYgKCFub2RlLmRvbmUpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBbXTtcbiAgICAgICAgICAgICAgICBkbyBrZXkucHVzaChub2RlLnZhbHVlKSwgKG5vZGUgPSB0eXBlLm5leHQoKSk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCFub2RlLmRvbmUpO1xuICAgICAgICAgICAgICAgIHJlbmRlckNoaWxkcmVuQXJyYXkocmVxdWVzdCwgdGFzaywga2V5LCBjaGlsZEluZGV4KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG5vZGUudGhlbilcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICh0YXNrLnRoZW5hYmxlU3RhdGUgPSBudWxsKSxcbiAgICAgICAgICAgICAgcmVuZGVyTm9kZURlc3RydWN0aXZlKFxuICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgdGFzayxcbiAgICAgICAgICAgICAgICB1bndyYXBUaGVuYWJsZShub2RlKSxcbiAgICAgICAgICAgICAgICBjaGlsZEluZGV4XG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKG5vZGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSlcbiAgICAgICAgICAgIHJldHVybiByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUoXG4gICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgIHRhc2ssXG4gICAgICAgICAgICAgIG5vZGUuX2N1cnJlbnRWYWx1ZTIsXG4gICAgICAgICAgICAgIGNoaWxkSW5kZXhcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgcmVxdWVzdCA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChub2RlKTtcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiBcIiArXG4gICAgICAgICAgICAgIChcIltvYmplY3QgT2JqZWN0XVwiID09PSByZXF1ZXN0XG4gICAgICAgICAgICAgICAgPyBcIm9iamVjdCB3aXRoIGtleXMge1wiICsgT2JqZWN0LmtleXMobm9kZSkuam9pbihcIiwgXCIpICsgXCJ9XCJcbiAgICAgICAgICAgICAgICA6IHJlcXVlc3QpICtcbiAgICAgICAgICAgICAgXCIpLiBJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5IGluc3RlYWQuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBub2RlXG4gICAgICAgICAgPyAoKHRhc2sgPSB0YXNrLmJsb2NrZWRTZWdtZW50KSxcbiAgICAgICAgICAgIG51bGwgIT09IHRhc2sgJiZcbiAgICAgICAgICAgICAgKHRhc2subGFzdFB1c2hlZFRleHQgPSBwdXNoVGV4dEluc3RhbmNlKFxuICAgICAgICAgICAgICAgIHRhc2suY2h1bmtzLFxuICAgICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5yZW5kZXJTdGF0ZSxcbiAgICAgICAgICAgICAgICB0YXNrLmxhc3RQdXNoZWRUZXh0XG4gICAgICAgICAgICAgICkpKVxuICAgICAgICAgIDogXCJudW1iZXJcIiA9PT0gdHlwZW9mIG5vZGUgfHwgXCJiaWdpbnRcIiA9PT0gdHlwZW9mIG5vZGVcbiAgICAgICAgICAgID8gKCh0YXNrID0gdGFzay5ibG9ja2VkU2VnbWVudCksXG4gICAgICAgICAgICAgIG51bGwgIT09IHRhc2sgJiZcbiAgICAgICAgICAgICAgICAodGFzay5sYXN0UHVzaGVkVGV4dCA9IHB1c2hUZXh0SW5zdGFuY2UoXG4gICAgICAgICAgICAgICAgICB0YXNrLmNodW5rcyxcbiAgICAgICAgICAgICAgICAgIFwiXCIgKyBub2RlLFxuICAgICAgICAgICAgICAgICAgcmVxdWVzdC5yZW5kZXJTdGF0ZSxcbiAgICAgICAgICAgICAgICAgIHRhc2subGFzdFB1c2hlZFRleHRcbiAgICAgICAgICAgICAgICApKSlcbiAgICAgICAgICAgIDogKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG5vZGUgJiZcbiAgICAgICAgICAgICAgICAoKHJlcXVlc3QgPSBub2RlLmRpc3BsYXlOYW1lIHx8IG5vZGUubmFtZSB8fCBcIkNvbXBvbmVudFwiKSxcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJGdW5jdGlvbnMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkLiBUaGlzIG1heSBoYXBwZW4gaWYgeW91IHJldHVybiAlcyBpbnN0ZWFkIG9mIDwlcyAvPiBmcm9tIHJlbmRlci4gT3IgbWF5YmUgeW91IG1lYW50IHRvIGNhbGwgdGhpcyBmdW5jdGlvbiByYXRoZXIgdGhhbiByZXR1cm4gaXQuXCIsXG4gICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgcmVxdWVzdFxuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICBcInN5bWJvbFwiID09PSB0eXBlb2Ygbm9kZSAmJlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIlN5bWJvbHMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkLlxcbiAgJXNcIixcbiAgICAgICAgICAgICAgICAgIFN0cmluZyhub2RlKVxuICAgICAgICAgICAgICAgICkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB3YXJuRm9yTWlzc2luZ0tleShyZXF1ZXN0LCB0YXNrLCBjaGlsZCkge1xuICAgICAgaWYgKFxuICAgICAgICBudWxsICE9PSBjaGlsZCAmJlxuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgY2hpbGQgJiZcbiAgICAgICAgKGNoaWxkLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUgfHxcbiAgICAgICAgICBjaGlsZC4kJHR5cGVvZiA9PT0gUkVBQ1RfUE9SVEFMX1RZUEUpICYmXG4gICAgICAgIGNoaWxkLl9zdG9yZSAmJlxuICAgICAgICAoKCFjaGlsZC5fc3RvcmUudmFsaWRhdGVkICYmIG51bGwgPT0gY2hpbGQua2V5KSB8fFxuICAgICAgICAgIDIgPT09IGNoaWxkLl9zdG9yZS52YWxpZGF0ZWQpXG4gICAgICApIHtcbiAgICAgICAgaWYgKFwib2JqZWN0XCIgIT09IHR5cGVvZiBjaGlsZC5fc3RvcmUpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIlJlYWN0IENvbXBvbmVudCBpbiB3YXJuRm9yTWlzc2luZ0tleSBzaG91bGQgaGF2ZSBhIF9zdG9yZS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICk7XG4gICAgICAgIGNoaWxkLl9zdG9yZS52YWxpZGF0ZWQgPSAxO1xuICAgICAgICB2YXIgZGlkV2FybkZvcktleSA9IHJlcXVlc3QuZGlkV2FybkZvcktleTtcbiAgICAgICAgbnVsbCA9PSBkaWRXYXJuRm9yS2V5ICYmXG4gICAgICAgICAgKGRpZFdhcm5Gb3JLZXkgPSByZXF1ZXN0LmRpZFdhcm5Gb3JLZXkgPSBuZXcgV2Vha1NldCgpKTtcbiAgICAgICAgcmVxdWVzdCA9IHRhc2suY29tcG9uZW50U3RhY2s7XG4gICAgICAgIGlmIChudWxsICE9PSByZXF1ZXN0ICYmICFkaWRXYXJuRm9yS2V5LmhhcyhyZXF1ZXN0KSkge1xuICAgICAgICAgIGRpZFdhcm5Gb3JLZXkuYWRkKHJlcXVlc3QpO1xuICAgICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGNoaWxkLnR5cGUpO1xuICAgICAgICAgIGRpZFdhcm5Gb3JLZXkgPSBjaGlsZC5fb3duZXI7XG4gICAgICAgICAgdmFyIHBhcmVudE93bmVyID0gcmVxdWVzdC5vd25lcjtcbiAgICAgICAgICByZXF1ZXN0ID0gXCJcIjtcbiAgICAgICAgICBpZiAocGFyZW50T3duZXIgJiYgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIHBhcmVudE93bmVyLnR5cGUpIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHBhcmVudE93bmVyLnR5cGUpO1xuICAgICAgICAgICAgbmFtZSAmJlxuICAgICAgICAgICAgICAocmVxdWVzdCA9IFwiXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYFwiICsgbmFtZSArIFwiYC5cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlcXVlc3QgfHxcbiAgICAgICAgICAgIChjb21wb25lbnROYW1lICYmXG4gICAgICAgICAgICAgIChyZXF1ZXN0ID1cbiAgICAgICAgICAgICAgICBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICtcbiAgICAgICAgICAgICAgICBjb21wb25lbnROYW1lICtcbiAgICAgICAgICAgICAgICBcIj4uXCIpKTtcbiAgICAgICAgICBjb21wb25lbnROYW1lID0gXCJcIjtcbiAgICAgICAgICBudWxsICE9IGRpZFdhcm5Gb3JLZXkgJiZcbiAgICAgICAgICAgIHBhcmVudE93bmVyICE9PSBkaWRXYXJuRm9yS2V5ICYmXG4gICAgICAgICAgICAoKHBhcmVudE93bmVyID0gbnVsbCksXG4gICAgICAgICAgICBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgZGlkV2FybkZvcktleS50eXBlXG4gICAgICAgICAgICAgID8gKHBhcmVudE93bmVyID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGRpZFdhcm5Gb3JLZXkudHlwZSkpXG4gICAgICAgICAgICAgIDogXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGRpZFdhcm5Gb3JLZXkubmFtZSAmJlxuICAgICAgICAgICAgICAgIChwYXJlbnRPd25lciA9IGRpZFdhcm5Gb3JLZXkubmFtZSksXG4gICAgICAgICAgICBwYXJlbnRPd25lciAmJlxuICAgICAgICAgICAgICAoY29tcG9uZW50TmFtZSA9XG4gICAgICAgICAgICAgICAgXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBwYXJlbnRPd25lciArIFwiLlwiKSk7XG4gICAgICAgICAgZGlkV2FybkZvcktleSA9IHRhc2suY29tcG9uZW50U3RhY2s7XG4gICAgICAgICAgdGFzay5jb21wb25lbnRTdGFjayA9IHtcbiAgICAgICAgICAgIHBhcmVudDogdGFzay5jb21wb25lbnRTdGFjayxcbiAgICAgICAgICAgIHR5cGU6IGNoaWxkLnR5cGUsXG4gICAgICAgICAgICBvd25lcjogY2hpbGQuX293bmVyLFxuICAgICAgICAgICAgc3RhY2s6IGNoaWxkLl9kZWJ1Z1N0YWNrXG4gICAgICAgICAgfTtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgJ0VhY2ggY2hpbGQgaW4gYSBsaXN0IHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4lcyVzIFNlZSBodHRwczovL3JlYWN0LmRldi9saW5rL3dhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLFxuICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICAgICAgICApO1xuICAgICAgICAgIHRhc2suY29tcG9uZW50U3RhY2sgPSBkaWRXYXJuRm9yS2V5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbmRlckNoaWxkcmVuQXJyYXkocmVxdWVzdCwgdGFzaywgY2hpbGRyZW4sIGNoaWxkSW5kZXgpIHtcbiAgICAgIHZhciBwcmV2S2V5UGF0aCA9IHRhc2sua2V5UGF0aCxcbiAgICAgICAgcHJldmlvdXNDb21wb25lbnRTdGFjayA9IHRhc2suY29tcG9uZW50U3RhY2s7XG4gICAgICB2YXIgcHJldmlvdXNEZWJ1Z1Rhc2sgPSB0YXNrLmRlYnVnVGFzaztcbiAgICAgIHB1c2hTZXJ2ZXJDb21wb25lbnRTdGFjayh0YXNrLCB0YXNrLm5vZGUuX2RlYnVnSW5mbyk7XG4gICAgICBpZiAoXG4gICAgICAgIC0xICE9PSBjaGlsZEluZGV4ICYmXG4gICAgICAgICgodGFzay5rZXlQYXRoID0gW3Rhc2sua2V5UGF0aCwgXCJGcmFnbWVudFwiLCBjaGlsZEluZGV4XSksXG4gICAgICAgIG51bGwgIT09IHRhc2sucmVwbGF5KVxuICAgICAgKSB7XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgdmFyIHJlcGxheSA9IHRhc2sucmVwbGF5LCByZXBsYXlOb2RlcyA9IHJlcGxheS5ub2RlcywgaiA9IDA7XG4gICAgICAgICAgaiA8IHJlcGxheU5vZGVzLmxlbmd0aDtcbiAgICAgICAgICBqKytcbiAgICAgICAgKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSByZXBsYXlOb2Rlc1tqXTtcbiAgICAgICAgICBpZiAobm9kZVsxXSA9PT0gY2hpbGRJbmRleCkge1xuICAgICAgICAgICAgY2hpbGRJbmRleCA9IG5vZGVbMl07XG4gICAgICAgICAgICBub2RlID0gbm9kZVszXTtcbiAgICAgICAgICAgIHRhc2sucmVwbGF5ID0geyBub2RlczogY2hpbGRJbmRleCwgc2xvdHM6IG5vZGUsIHBlbmRpbmdUYXNrczogMSB9O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmVuZGVyQ2hpbGRyZW5BcnJheShyZXF1ZXN0LCB0YXNrLCBjaGlsZHJlbiwgLTEpO1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgMSA9PT0gdGFzay5yZXBsYXkucGVuZGluZ1Rhc2tzICYmXG4gICAgICAgICAgICAgICAgMCA8IHRhc2sucmVwbGF5Lm5vZGVzLmxlbmd0aFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIkNvdWxkbid0IGZpbmQgYWxsIHJlc3VtYWJsZSBzbG90cyBieSBrZXkvaW5kZXggZHVyaW5nIHJlcGxheWluZy4gVGhlIHRyZWUgZG9lc24ndCBtYXRjaCBzbyBSZWFjdCB3aWxsIGZhbGxiYWNrIHRvIGNsaWVudCByZW5kZXJpbmcuXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB0YXNrLnJlcGxheS5wZW5kaW5nVGFza3MtLTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiB4ICYmXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0geCAmJlxuICAgICAgICAgICAgICAgICh4ID09PSBTdXNwZW5zZUV4Y2VwdGlvbiB8fCBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB4LnRoZW4pXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICB0aHJvdyB4O1xuICAgICAgICAgICAgICB0YXNrLnJlcGxheS5wZW5kaW5nVGFza3MtLTtcbiAgICAgICAgICAgICAgdmFyIHRocm93bkluZm8gPSBnZXRUaHJvd25JbmZvKHRhc2suY29tcG9uZW50U3RhY2spO1xuICAgICAgICAgICAgICBjaGlsZHJlbiA9IHRhc2suYmxvY2tlZEJvdW5kYXJ5O1xuICAgICAgICAgICAgICB2YXIgZXJyb3IgPSB4LFxuICAgICAgICAgICAgICAgIHJlc3VtZVNsb3RzID0gbm9kZTtcbiAgICAgICAgICAgICAgbm9kZSA9IGxvZ1JlY292ZXJhYmxlRXJyb3IoXG4gICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICB0aHJvd25JbmZvLFxuICAgICAgICAgICAgICAgIHRhc2suZGVidWdUYXNrXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGFib3J0UmVtYWluaW5nUmVwbGF5Tm9kZXMoXG4gICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgICAgICAgICBjaGlsZEluZGV4LFxuICAgICAgICAgICAgICAgIHJlc3VtZVNsb3RzLFxuICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgICAgdGhyb3duSW5mbyxcbiAgICAgICAgICAgICAgICAhMVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFzay5yZXBsYXkgPSByZXBsYXk7XG4gICAgICAgICAgICByZXBsYXlOb2Rlcy5zcGxpY2UoaiwgMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGFzay5rZXlQYXRoID0gcHJldktleVBhdGg7XG4gICAgICAgIHRhc2suY29tcG9uZW50U3RhY2sgPSBwcmV2aW91c0NvbXBvbmVudFN0YWNrO1xuICAgICAgICB0YXNrLmRlYnVnVGFzayA9IHByZXZpb3VzRGVidWdUYXNrO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXBsYXkgPSB0YXNrLnRyZWVDb250ZXh0O1xuICAgICAgcmVwbGF5Tm9kZXMgPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgICBpZiAoXG4gICAgICAgIG51bGwgIT09IHRhc2sucmVwbGF5ICYmXG4gICAgICAgICgoaiA9IHRhc2sucmVwbGF5LnNsb3RzKSwgbnVsbCAhPT0gaiAmJiBcIm9iamVjdFwiID09PSB0eXBlb2YgailcbiAgICAgICkge1xuICAgICAgICBmb3IgKGNoaWxkSW5kZXggPSAwOyBjaGlsZEluZGV4IDwgcmVwbGF5Tm9kZXM7IGNoaWxkSW5kZXgrKylcbiAgICAgICAgICAobm9kZSA9IGNoaWxkcmVuW2NoaWxkSW5kZXhdKSxcbiAgICAgICAgICAgICh0YXNrLnRyZWVDb250ZXh0ID0gcHVzaFRyZWVDb250ZXh0KFxuICAgICAgICAgICAgICByZXBsYXksXG4gICAgICAgICAgICAgIHJlcGxheU5vZGVzLFxuICAgICAgICAgICAgICBjaGlsZEluZGV4XG4gICAgICAgICAgICApKSxcbiAgICAgICAgICAgIChlcnJvciA9IGpbY2hpbGRJbmRleF0pLFxuICAgICAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIGVycm9yXG4gICAgICAgICAgICAgID8gKHJlc3VtZU5vZGUocmVxdWVzdCwgdGFzaywgZXJyb3IsIG5vZGUsIGNoaWxkSW5kZXgpLFxuICAgICAgICAgICAgICAgIGRlbGV0ZSBqW2NoaWxkSW5kZXhdKVxuICAgICAgICAgICAgICA6IHJlbmRlck5vZGUocmVxdWVzdCwgdGFzaywgbm9kZSwgY2hpbGRJbmRleCk7XG4gICAgICAgIHRhc2sudHJlZUNvbnRleHQgPSByZXBsYXk7XG4gICAgICAgIHRhc2sua2V5UGF0aCA9IHByZXZLZXlQYXRoO1xuICAgICAgICB0YXNrLmNvbXBvbmVudFN0YWNrID0gcHJldmlvdXNDb21wb25lbnRTdGFjaztcbiAgICAgICAgdGFzay5kZWJ1Z1Rhc2sgPSBwcmV2aW91c0RlYnVnVGFzaztcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZm9yIChqID0gMDsgaiA8IHJlcGxheU5vZGVzOyBqKyspXG4gICAgICAgIChjaGlsZEluZGV4ID0gY2hpbGRyZW5bal0pLFxuICAgICAgICAgIHdhcm5Gb3JNaXNzaW5nS2V5KHJlcXVlc3QsIHRhc2ssIGNoaWxkSW5kZXgpLFxuICAgICAgICAgICh0YXNrLnRyZWVDb250ZXh0ID0gcHVzaFRyZWVDb250ZXh0KHJlcGxheSwgcmVwbGF5Tm9kZXMsIGopKSxcbiAgICAgICAgICByZW5kZXJOb2RlKHJlcXVlc3QsIHRhc2ssIGNoaWxkSW5kZXgsIGopO1xuICAgICAgdGFzay50cmVlQ29udGV4dCA9IHJlcGxheTtcbiAgICAgIHRhc2sua2V5UGF0aCA9IHByZXZLZXlQYXRoO1xuICAgICAgdGFzay5jb21wb25lbnRTdGFjayA9IHByZXZpb3VzQ29tcG9uZW50U3RhY2s7XG4gICAgICB0YXNrLmRlYnVnVGFzayA9IHByZXZpb3VzRGVidWdUYXNrO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFja1Bvc3Rwb25lZEJvdW5kYXJ5KHJlcXVlc3QsIHRyYWNrZWRQb3N0cG9uZXMsIGJvdW5kYXJ5KSB7XG4gICAgICBib3VuZGFyeS5zdGF0dXMgPSBQT1NUUE9ORUQ7XG4gICAgICBib3VuZGFyeS5yb290U2VnbWVudElEID0gcmVxdWVzdC5uZXh0U2VnbWVudElkKys7XG4gICAgICByZXF1ZXN0ID0gYm91bmRhcnkudHJhY2tlZENvbnRlbnRLZXlQYXRoO1xuICAgICAgaWYgKG51bGwgPT09IHJlcXVlc3QpXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiSXQgc2hvdWxkIG5vdCBiZSBwb3NzaWJsZSB0byBwb3N0cG9uZSBhdCB0aGUgcm9vdC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICApO1xuICAgICAgdmFyIGZhbGxiYWNrUmVwbGF5Tm9kZSA9IGJvdW5kYXJ5LnRyYWNrZWRGYWxsYmFja05vZGUsXG4gICAgICAgIGNoaWxkcmVuID0gW10sXG4gICAgICAgIGJvdW5kYXJ5Tm9kZSA9IHRyYWNrZWRQb3N0cG9uZXMud29ya2luZ01hcC5nZXQocmVxdWVzdCk7XG4gICAgICBpZiAodm9pZCAwID09PSBib3VuZGFyeU5vZGUpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgKGJvdW5kYXJ5ID0gW1xuICAgICAgICAgICAgcmVxdWVzdFsxXSxcbiAgICAgICAgICAgIHJlcXVlc3RbMl0sXG4gICAgICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBmYWxsYmFja1JlcGxheU5vZGUsXG4gICAgICAgICAgICBib3VuZGFyeS5yb290U2VnbWVudElEXG4gICAgICAgICAgXSksXG4gICAgICAgICAgdHJhY2tlZFBvc3Rwb25lcy53b3JraW5nTWFwLnNldChyZXF1ZXN0LCBib3VuZGFyeSksXG4gICAgICAgICAgYWRkVG9SZXBsYXlQYXJlbnQoYm91bmRhcnksIHJlcXVlc3RbMF0sIHRyYWNrZWRQb3N0cG9uZXMpLFxuICAgICAgICAgIGJvdW5kYXJ5XG4gICAgICAgICk7XG4gICAgICBib3VuZGFyeU5vZGVbNF0gPSBmYWxsYmFja1JlcGxheU5vZGU7XG4gICAgICBib3VuZGFyeU5vZGVbNV0gPSBib3VuZGFyeS5yb290U2VnbWVudElEO1xuICAgICAgcmV0dXJuIGJvdW5kYXJ5Tm9kZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdHJhY2tQb3N0cG9uZShyZXF1ZXN0LCB0cmFja2VkUG9zdHBvbmVzLCB0YXNrLCBzZWdtZW50KSB7XG4gICAgICBzZWdtZW50LnN0YXR1cyA9IFBPU1RQT05FRDtcbiAgICAgIHZhciBrZXlQYXRoID0gdGFzay5rZXlQYXRoLFxuICAgICAgICBib3VuZGFyeSA9IHRhc2suYmxvY2tlZEJvdW5kYXJ5O1xuICAgICAgaWYgKG51bGwgPT09IGJvdW5kYXJ5KVxuICAgICAgICAoc2VnbWVudC5pZCA9IHJlcXVlc3QubmV4dFNlZ21lbnRJZCsrKSxcbiAgICAgICAgICAodHJhY2tlZFBvc3Rwb25lcy5yb290U2xvdHMgPSBzZWdtZW50LmlkKSxcbiAgICAgICAgICBudWxsICE9PSByZXF1ZXN0LmNvbXBsZXRlZFJvb3RTZWdtZW50ICYmXG4gICAgICAgICAgICAocmVxdWVzdC5jb21wbGV0ZWRSb290U2VnbWVudC5zdGF0dXMgPSBQT1NUUE9ORUQpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChudWxsICE9PSBib3VuZGFyeSAmJiBib3VuZGFyeS5zdGF0dXMgPT09IFBFTkRJTkcpIHtcbiAgICAgICAgICB2YXIgYm91bmRhcnlOb2RlID0gdHJhY2tQb3N0cG9uZWRCb3VuZGFyeShcbiAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICB0cmFja2VkUG9zdHBvbmVzLFxuICAgICAgICAgICAgYm91bmRhcnlcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGJvdW5kYXJ5LnRyYWNrZWRDb250ZW50S2V5UGF0aCA9PT0ga2V5UGF0aCAmJlxuICAgICAgICAgICAgLTEgPT09IHRhc2suY2hpbGRJbmRleFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgLTEgPT09IHNlZ21lbnQuaWQgJiZcbiAgICAgICAgICAgICAgKHNlZ21lbnQuaWQgPSBzZWdtZW50LnBhcmVudEZsdXNoZWRcbiAgICAgICAgICAgICAgICA/IGJvdW5kYXJ5LnJvb3RTZWdtZW50SURcbiAgICAgICAgICAgICAgICA6IHJlcXVlc3QubmV4dFNlZ21lbnRJZCsrKTtcbiAgICAgICAgICAgIGJvdW5kYXJ5Tm9kZVszXSA9IHNlZ21lbnQuaWQ7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC0xID09PSBzZWdtZW50LmlkICYmXG4gICAgICAgICAgKHNlZ21lbnQuaWQgPVxuICAgICAgICAgICAgc2VnbWVudC5wYXJlbnRGbHVzaGVkICYmIG51bGwgIT09IGJvdW5kYXJ5XG4gICAgICAgICAgICAgID8gYm91bmRhcnkucm9vdFNlZ21lbnRJRFxuICAgICAgICAgICAgICA6IHJlcXVlc3QubmV4dFNlZ21lbnRJZCsrKTtcbiAgICAgICAgaWYgKC0xID09PSB0YXNrLmNoaWxkSW5kZXgpXG4gICAgICAgICAgbnVsbCA9PT0ga2V5UGF0aFxuICAgICAgICAgICAgPyAodHJhY2tlZFBvc3Rwb25lcy5yb290U2xvdHMgPSBzZWdtZW50LmlkKVxuICAgICAgICAgICAgOiAoKHRhc2sgPSB0cmFja2VkUG9zdHBvbmVzLndvcmtpbmdNYXAuZ2V0KGtleVBhdGgpKSxcbiAgICAgICAgICAgICAgdm9pZCAwID09PSB0YXNrXG4gICAgICAgICAgICAgICAgPyAoKHRhc2sgPSBba2V5UGF0aFsxXSwga2V5UGF0aFsyXSwgW10sIHNlZ21lbnQuaWRdKSxcbiAgICAgICAgICAgICAgICAgIGFkZFRvUmVwbGF5UGFyZW50KHRhc2ssIGtleVBhdGhbMF0sIHRyYWNrZWRQb3N0cG9uZXMpKVxuICAgICAgICAgICAgICAgIDogKHRhc2tbM10gPSBzZWdtZW50LmlkKSk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmIChudWxsID09PSBrZXlQYXRoKVxuICAgICAgICAgICAgaWYgKCgocmVxdWVzdCA9IHRyYWNrZWRQb3N0cG9uZXMucm9vdFNsb3RzKSwgbnVsbCA9PT0gcmVxdWVzdCkpXG4gICAgICAgICAgICAgIHJlcXVlc3QgPSB0cmFja2VkUG9zdHBvbmVzLnJvb3RTbG90cyA9IHt9O1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChcIm51bWJlclwiID09PSB0eXBlb2YgcmVxdWVzdClcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiSXQgc2hvdWxkIG5vdCBiZSBwb3NzaWJsZSB0byBwb3N0cG9uZSBib3RoIGF0IHRoZSByb290IG9mIGFuIGVsZW1lbnQgYXMgd2VsbCBhcyBhIHNsb3QgYmVsb3cuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAgICAgKChib3VuZGFyeSA9IHRyYWNrZWRQb3N0cG9uZXMud29ya2luZ01hcCksXG4gICAgICAgICAgICAoYm91bmRhcnlOb2RlID0gYm91bmRhcnkuZ2V0KGtleVBhdGgpKSxcbiAgICAgICAgICAgIHZvaWQgMCA9PT0gYm91bmRhcnlOb2RlKVxuICAgICAgICAgIClcbiAgICAgICAgICAgIChyZXF1ZXN0ID0ge30pLFxuICAgICAgICAgICAgICAoYm91bmRhcnlOb2RlID0gW2tleVBhdGhbMV0sIGtleVBhdGhbMl0sIFtdLCByZXF1ZXN0XSksXG4gICAgICAgICAgICAgIGJvdW5kYXJ5LnNldChrZXlQYXRoLCBib3VuZGFyeU5vZGUpLFxuICAgICAgICAgICAgICBhZGRUb1JlcGxheVBhcmVudChib3VuZGFyeU5vZGUsIGtleVBhdGhbMF0sIHRyYWNrZWRQb3N0cG9uZXMpO1xuICAgICAgICAgIGVsc2UgaWYgKCgocmVxdWVzdCA9IGJvdW5kYXJ5Tm9kZVszXSksIG51bGwgPT09IHJlcXVlc3QpKVxuICAgICAgICAgICAgcmVxdWVzdCA9IGJvdW5kYXJ5Tm9kZVszXSA9IHt9O1xuICAgICAgICAgIGVsc2UgaWYgKFwibnVtYmVyXCIgPT09IHR5cGVvZiByZXF1ZXN0KVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgIFwiSXQgc2hvdWxkIG5vdCBiZSBwb3NzaWJsZSB0byBwb3N0cG9uZSBib3RoIGF0IHRoZSByb290IG9mIGFuIGVsZW1lbnQgYXMgd2VsbCBhcyBhIHNsb3QgYmVsb3cuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgcmVxdWVzdFt0YXNrLmNoaWxkSW5kZXhdID0gc2VnbWVudC5pZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB1bnRyYWNrQm91bmRhcnkocmVxdWVzdCwgYm91bmRhcnkpIHtcbiAgICAgIHJlcXVlc3QgPSByZXF1ZXN0LnRyYWNrZWRQb3N0cG9uZXM7XG4gICAgICBudWxsICE9PSByZXF1ZXN0ICYmXG4gICAgICAgICgoYm91bmRhcnkgPSBib3VuZGFyeS50cmFja2VkQ29udGVudEtleVBhdGgpLFxuICAgICAgICBudWxsICE9PSBib3VuZGFyeSAmJlxuICAgICAgICAgICgoYm91bmRhcnkgPSByZXF1ZXN0LndvcmtpbmdNYXAuZ2V0KGJvdW5kYXJ5KSksXG4gICAgICAgICAgdm9pZCAwICE9PSBib3VuZGFyeSAmJlxuICAgICAgICAgICAgKChib3VuZGFyeS5sZW5ndGggPSA0KSwgKGJvdW5kYXJ5WzJdID0gW10pLCAoYm91bmRhcnlbM10gPSBudWxsKSkpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3Bhd25OZXdTdXNwZW5kZWRSZXBsYXlUYXNrKHJlcXVlc3QsIHRhc2ssIHRoZW5hYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybiBjcmVhdGVSZXBsYXlUYXNrKFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICB0aGVuYWJsZVN0YXRlLFxuICAgICAgICB0YXNrLnJlcGxheSxcbiAgICAgICAgdGFzay5ub2RlLFxuICAgICAgICB0YXNrLmNoaWxkSW5kZXgsXG4gICAgICAgIHRhc2suYmxvY2tlZEJvdW5kYXJ5LFxuICAgICAgICB0YXNrLmhvaXN0YWJsZVN0YXRlLFxuICAgICAgICB0YXNrLmFib3J0U2V0LFxuICAgICAgICB0YXNrLmtleVBhdGgsXG4gICAgICAgIHRhc2suZm9ybWF0Q29udGV4dCxcbiAgICAgICAgdGFzay5jb250ZXh0LFxuICAgICAgICB0YXNrLnRyZWVDb250ZXh0LFxuICAgICAgICB0YXNrLnJvdyxcbiAgICAgICAgdGFzay5jb21wb25lbnRTdGFjayxcbiAgICAgICAgZW1wdHlDb250ZXh0T2JqZWN0LFxuICAgICAgICB0YXNrLmRlYnVnVGFza1xuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3Bhd25OZXdTdXNwZW5kZWRSZW5kZXJUYXNrKHJlcXVlc3QsIHRhc2ssIHRoZW5hYmxlU3RhdGUpIHtcbiAgICAgIHZhciBzZWdtZW50ID0gdGFzay5ibG9ja2VkU2VnbWVudCxcbiAgICAgICAgbmV3U2VnbWVudCA9IGNyZWF0ZVBlbmRpbmdTZWdtZW50KFxuICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgc2VnbWVudC5jaHVua3MubGVuZ3RoLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgdGFzay5mb3JtYXRDb250ZXh0LFxuICAgICAgICAgIHNlZ21lbnQubGFzdFB1c2hlZFRleHQsXG4gICAgICAgICAgITBcbiAgICAgICAgKTtcbiAgICAgIHNlZ21lbnQuY2hpbGRyZW4ucHVzaChuZXdTZWdtZW50KTtcbiAgICAgIHNlZ21lbnQubGFzdFB1c2hlZFRleHQgPSAhMTtcbiAgICAgIHJldHVybiBjcmVhdGVSZW5kZXJUYXNrKFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICB0aGVuYWJsZVN0YXRlLFxuICAgICAgICB0YXNrLm5vZGUsXG4gICAgICAgIHRhc2suY2hpbGRJbmRleCxcbiAgICAgICAgdGFzay5ibG9ja2VkQm91bmRhcnksXG4gICAgICAgIG5ld1NlZ21lbnQsXG4gICAgICAgIHRhc2suYmxvY2tlZFByZWFtYmxlLFxuICAgICAgICB0YXNrLmhvaXN0YWJsZVN0YXRlLFxuICAgICAgICB0YXNrLmFib3J0U2V0LFxuICAgICAgICB0YXNrLmtleVBhdGgsXG4gICAgICAgIHRhc2suZm9ybWF0Q29udGV4dCxcbiAgICAgICAgdGFzay5jb250ZXh0LFxuICAgICAgICB0YXNrLnRyZWVDb250ZXh0LFxuICAgICAgICB0YXNrLnJvdyxcbiAgICAgICAgdGFzay5jb21wb25lbnRTdGFjayxcbiAgICAgICAgZW1wdHlDb250ZXh0T2JqZWN0LFxuICAgICAgICB0YXNrLmRlYnVnVGFza1xuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVuZGVyTm9kZShyZXF1ZXN0LCB0YXNrLCBub2RlLCBjaGlsZEluZGV4KSB7XG4gICAgICB2YXIgcHJldmlvdXNGb3JtYXRDb250ZXh0ID0gdGFzay5mb3JtYXRDb250ZXh0LFxuICAgICAgICBwcmV2aW91c0NvbnRleHQgPSB0YXNrLmNvbnRleHQsXG4gICAgICAgIHByZXZpb3VzS2V5UGF0aCA9IHRhc2sua2V5UGF0aCxcbiAgICAgICAgcHJldmlvdXNUcmVlQ29udGV4dCA9IHRhc2sudHJlZUNvbnRleHQsXG4gICAgICAgIHByZXZpb3VzQ29tcG9uZW50U3RhY2sgPSB0YXNrLmNvbXBvbmVudFN0YWNrLFxuICAgICAgICBwcmV2aW91c0RlYnVnVGFzayA9IHRhc2suZGVidWdUYXNrLFxuICAgICAgICBzZWdtZW50ID0gdGFzay5ibG9ja2VkU2VnbWVudDtcbiAgICAgIGlmIChudWxsID09PSBzZWdtZW50KSB7XG4gICAgICAgIHNlZ21lbnQgPSB0YXNrLnJlcGxheTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIG5vZGUsIGNoaWxkSW5kZXgpO1xuICAgICAgICB9IGNhdGNoICh0aHJvd25WYWx1ZSkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIChyZXNldEhvb2tzU3RhdGUoKSxcbiAgICAgICAgICAgIChub2RlID1cbiAgICAgICAgICAgICAgdGhyb3duVmFsdWUgPT09IFN1c3BlbnNlRXhjZXB0aW9uXG4gICAgICAgICAgICAgICAgPyBnZXRTdXNwZW5kZWRUaGVuYWJsZSgpXG4gICAgICAgICAgICAgICAgOiB0aHJvd25WYWx1ZSksXG4gICAgICAgICAgICAxMiAhPT0gcmVxdWVzdC5zdGF0dXMgJiYgXCJvYmplY3RcIiA9PT0gdHlwZW9mIG5vZGUgJiYgbnVsbCAhPT0gbm9kZSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBub2RlLnRoZW4pIHtcbiAgICAgICAgICAgICAgY2hpbGRJbmRleCA9XG4gICAgICAgICAgICAgICAgdGhyb3duVmFsdWUgPT09IFN1c3BlbnNlRXhjZXB0aW9uXG4gICAgICAgICAgICAgICAgICA/IGdldFRoZW5hYmxlU3RhdGVBZnRlclN1c3BlbmRpbmcoKVxuICAgICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgICByZXF1ZXN0ID0gc3Bhd25OZXdTdXNwZW5kZWRSZXBsYXlUYXNrKFxuICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgdGFzayxcbiAgICAgICAgICAgICAgICBjaGlsZEluZGV4XG4gICAgICAgICAgICAgICkucGluZztcbiAgICAgICAgICAgICAgbm9kZS50aGVuKHJlcXVlc3QsIHJlcXVlc3QpO1xuICAgICAgICAgICAgICB0YXNrLmZvcm1hdENvbnRleHQgPSBwcmV2aW91c0Zvcm1hdENvbnRleHQ7XG4gICAgICAgICAgICAgIHRhc2suY29udGV4dCA9IHByZXZpb3VzQ29udGV4dDtcbiAgICAgICAgICAgICAgdGFzay5rZXlQYXRoID0gcHJldmlvdXNLZXlQYXRoO1xuICAgICAgICAgICAgICB0YXNrLnRyZWVDb250ZXh0ID0gcHJldmlvdXNUcmVlQ29udGV4dDtcbiAgICAgICAgICAgICAgdGFzay5jb21wb25lbnRTdGFjayA9IHByZXZpb3VzQ29tcG9uZW50U3RhY2s7XG4gICAgICAgICAgICAgIHRhc2sucmVwbGF5ID0gc2VnbWVudDtcbiAgICAgICAgICAgICAgdGFzay5kZWJ1Z1Rhc2sgPSBwcmV2aW91c0RlYnVnVGFzaztcbiAgICAgICAgICAgICAgc3dpdGNoQ29udGV4dChwcmV2aW91c0NvbnRleHQpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoXCJNYXhpbXVtIGNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiID09PSBub2RlLm1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgbm9kZSA9XG4gICAgICAgICAgICAgICAgdGhyb3duVmFsdWUgPT09IFN1c3BlbnNlRXhjZXB0aW9uXG4gICAgICAgICAgICAgICAgICA/IGdldFRoZW5hYmxlU3RhdGVBZnRlclN1c3BlbmRpbmcoKVxuICAgICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgICBub2RlID0gc3Bhd25OZXdTdXNwZW5kZWRSZXBsYXlUYXNrKHJlcXVlc3QsIHRhc2ssIG5vZGUpO1xuICAgICAgICAgICAgICByZXF1ZXN0LnBpbmdlZFRhc2tzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgIHRhc2suZm9ybWF0Q29udGV4dCA9IHByZXZpb3VzRm9ybWF0Q29udGV4dDtcbiAgICAgICAgICAgICAgdGFzay5jb250ZXh0ID0gcHJldmlvdXNDb250ZXh0O1xuICAgICAgICAgICAgICB0YXNrLmtleVBhdGggPSBwcmV2aW91c0tleVBhdGg7XG4gICAgICAgICAgICAgIHRhc2sudHJlZUNvbnRleHQgPSBwcmV2aW91c1RyZWVDb250ZXh0O1xuICAgICAgICAgICAgICB0YXNrLmNvbXBvbmVudFN0YWNrID0gcHJldmlvdXNDb21wb25lbnRTdGFjaztcbiAgICAgICAgICAgICAgdGFzay5yZXBsYXkgPSBzZWdtZW50O1xuICAgICAgICAgICAgICB0YXNrLmRlYnVnVGFzayA9IHByZXZpb3VzRGVidWdUYXNrO1xuICAgICAgICAgICAgICBzd2l0Y2hDb250ZXh0KHByZXZpb3VzQ29udGV4dCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjaGlsZHJlbkxlbmd0aCA9IHNlZ21lbnQuY2hpbGRyZW4ubGVuZ3RoLFxuICAgICAgICAgIGNodW5rTGVuZ3RoID0gc2VnbWVudC5jaHVua3MubGVuZ3RoO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgbm9kZSwgY2hpbGRJbmRleCk7XG4gICAgICAgIH0gY2F0Y2ggKHRocm93blZhbHVlJDMpIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAocmVzZXRIb29rc1N0YXRlKCksXG4gICAgICAgICAgICAoc2VnbWVudC5jaGlsZHJlbi5sZW5ndGggPSBjaGlsZHJlbkxlbmd0aCksXG4gICAgICAgICAgICAoc2VnbWVudC5jaHVua3MubGVuZ3RoID0gY2h1bmtMZW5ndGgpLFxuICAgICAgICAgICAgKG5vZGUgPVxuICAgICAgICAgICAgICB0aHJvd25WYWx1ZSQzID09PSBTdXNwZW5zZUV4Y2VwdGlvblxuICAgICAgICAgICAgICAgID8gZ2V0U3VzcGVuZGVkVGhlbmFibGUoKVxuICAgICAgICAgICAgICAgIDogdGhyb3duVmFsdWUkMyksXG4gICAgICAgICAgICAxMiAhPT0gcmVxdWVzdC5zdGF0dXMgJiYgXCJvYmplY3RcIiA9PT0gdHlwZW9mIG5vZGUgJiYgbnVsbCAhPT0gbm9kZSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBub2RlLnRoZW4pIHtcbiAgICAgICAgICAgICAgc2VnbWVudCA9IG5vZGU7XG4gICAgICAgICAgICAgIG5vZGUgPVxuICAgICAgICAgICAgICAgIHRocm93blZhbHVlJDMgPT09IFN1c3BlbnNlRXhjZXB0aW9uXG4gICAgICAgICAgICAgICAgICA/IGdldFRoZW5hYmxlU3RhdGVBZnRlclN1c3BlbmRpbmcoKVxuICAgICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgICByZXF1ZXN0ID0gc3Bhd25OZXdTdXNwZW5kZWRSZW5kZXJUYXNrKHJlcXVlc3QsIHRhc2ssIG5vZGUpLnBpbmc7XG4gICAgICAgICAgICAgIHNlZ21lbnQudGhlbihyZXF1ZXN0LCByZXF1ZXN0KTtcbiAgICAgICAgICAgICAgdGFzay5mb3JtYXRDb250ZXh0ID0gcHJldmlvdXNGb3JtYXRDb250ZXh0O1xuICAgICAgICAgICAgICB0YXNrLmNvbnRleHQgPSBwcmV2aW91c0NvbnRleHQ7XG4gICAgICAgICAgICAgIHRhc2sua2V5UGF0aCA9IHByZXZpb3VzS2V5UGF0aDtcbiAgICAgICAgICAgICAgdGFzay50cmVlQ29udGV4dCA9IHByZXZpb3VzVHJlZUNvbnRleHQ7XG4gICAgICAgICAgICAgIHRhc2suY29tcG9uZW50U3RhY2sgPSBwcmV2aW91c0NvbXBvbmVudFN0YWNrO1xuICAgICAgICAgICAgICB0YXNrLmRlYnVnVGFzayA9IHByZXZpb3VzRGVidWdUYXNrO1xuICAgICAgICAgICAgICBzd2l0Y2hDb250ZXh0KHByZXZpb3VzQ29udGV4dCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChcIk1heGltdW0gY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIgPT09IG5vZGUubWVzc2FnZSkge1xuICAgICAgICAgICAgICBzZWdtZW50ID1cbiAgICAgICAgICAgICAgICB0aHJvd25WYWx1ZSQzID09PSBTdXNwZW5zZUV4Y2VwdGlvblxuICAgICAgICAgICAgICAgICAgPyBnZXRUaGVuYWJsZVN0YXRlQWZ0ZXJTdXNwZW5kaW5nKClcbiAgICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgICAgc2VnbWVudCA9IHNwYXduTmV3U3VzcGVuZGVkUmVuZGVyVGFzayhyZXF1ZXN0LCB0YXNrLCBzZWdtZW50KTtcbiAgICAgICAgICAgICAgcmVxdWVzdC5waW5nZWRUYXNrcy5wdXNoKHNlZ21lbnQpO1xuICAgICAgICAgICAgICB0YXNrLmZvcm1hdENvbnRleHQgPSBwcmV2aW91c0Zvcm1hdENvbnRleHQ7XG4gICAgICAgICAgICAgIHRhc2suY29udGV4dCA9IHByZXZpb3VzQ29udGV4dDtcbiAgICAgICAgICAgICAgdGFzay5rZXlQYXRoID0gcHJldmlvdXNLZXlQYXRoO1xuICAgICAgICAgICAgICB0YXNrLnRyZWVDb250ZXh0ID0gcHJldmlvdXNUcmVlQ29udGV4dDtcbiAgICAgICAgICAgICAgdGFzay5jb21wb25lbnRTdGFjayA9IHByZXZpb3VzQ29tcG9uZW50U3RhY2s7XG4gICAgICAgICAgICAgIHRhc2suZGVidWdUYXNrID0gcHJldmlvdXNEZWJ1Z1Rhc2s7XG4gICAgICAgICAgICAgIHN3aXRjaENvbnRleHQocHJldmlvdXNDb250ZXh0KTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGFzay5mb3JtYXRDb250ZXh0ID0gcHJldmlvdXNGb3JtYXRDb250ZXh0O1xuICAgICAgdGFzay5jb250ZXh0ID0gcHJldmlvdXNDb250ZXh0O1xuICAgICAgdGFzay5rZXlQYXRoID0gcHJldmlvdXNLZXlQYXRoO1xuICAgICAgdGFzay50cmVlQ29udGV4dCA9IHByZXZpb3VzVHJlZUNvbnRleHQ7XG4gICAgICBzd2l0Y2hDb250ZXh0KHByZXZpb3VzQ29udGV4dCk7XG4gICAgICB0aHJvdyBub2RlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhYm9ydFRhc2tTb2Z0KHRhc2spIHtcbiAgICAgIHZhciBib3VuZGFyeSA9IHRhc2suYmxvY2tlZEJvdW5kYXJ5LFxuICAgICAgICBzZWdtZW50ID0gdGFzay5ibG9ja2VkU2VnbWVudDtcbiAgICAgIG51bGwgIT09IHNlZ21lbnQgJiZcbiAgICAgICAgKChzZWdtZW50LnN0YXR1cyA9IEFCT1JURUQpLFxuICAgICAgICBmaW5pc2hlZFRhc2sodGhpcywgYm91bmRhcnksIHRhc2sucm93LCBzZWdtZW50KSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFib3J0UmVtYWluaW5nUmVwbGF5Tm9kZXMoXG4gICAgICByZXF1ZXN0JGpzY29tcCQwLFxuICAgICAgYm91bmRhcnksXG4gICAgICBub2RlcyxcbiAgICAgIHNsb3RzLFxuICAgICAgZXJyb3IkanNjb21wJDAsXG4gICAgICBlcnJvckRpZ2VzdCRqc2NvbXAkMCxcbiAgICAgIGVycm9ySW5mbyRqc2NvbXAkMCxcbiAgICAgIGFib3J0ZWRcbiAgICApIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgaWYgKDQgPT09IG5vZGUubGVuZ3RoKVxuICAgICAgICAgIGFib3J0UmVtYWluaW5nUmVwbGF5Tm9kZXMoXG4gICAgICAgICAgICByZXF1ZXN0JGpzY29tcCQwLFxuICAgICAgICAgICAgYm91bmRhcnksXG4gICAgICAgICAgICBub2RlWzJdLFxuICAgICAgICAgICAgbm9kZVszXSxcbiAgICAgICAgICAgIGVycm9yJGpzY29tcCQwLFxuICAgICAgICAgICAgZXJyb3JEaWdlc3QkanNjb21wJDAsXG4gICAgICAgICAgICBlcnJvckluZm8kanNjb21wJDAsXG4gICAgICAgICAgICBhYm9ydGVkXG4gICAgICAgICAgKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIHJlcXVlc3QgPSByZXF1ZXN0JGpzY29tcCQwO1xuICAgICAgICAgIG5vZGUgPSBub2RlWzVdO1xuICAgICAgICAgIHZhciBlcnJvciA9IGVycm9yJGpzY29tcCQwLFxuICAgICAgICAgICAgZXJyb3JEaWdlc3QgPSBlcnJvckRpZ2VzdCRqc2NvbXAkMCxcbiAgICAgICAgICAgIGVycm9ySW5mbyA9IGVycm9ySW5mbyRqc2NvbXAkMCxcbiAgICAgICAgICAgIHdhc0Fib3J0ZWQgPSBhYm9ydGVkLFxuICAgICAgICAgICAgcmVzdW1lZEJvdW5kYXJ5ID0gY3JlYXRlU3VzcGVuc2VCb3VuZGFyeShcbiAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgbmV3IFNldCgpLFxuICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHJlc3VtZWRCb3VuZGFyeS5wYXJlbnRGbHVzaGVkID0gITA7XG4gICAgICAgICAgcmVzdW1lZEJvdW5kYXJ5LnJvb3RTZWdtZW50SUQgPSBub2RlO1xuICAgICAgICAgIHJlc3VtZWRCb3VuZGFyeS5zdGF0dXMgPSBDTElFTlRfUkVOREVSRUQ7XG4gICAgICAgICAgZW5jb2RlRXJyb3JGb3JCb3VuZGFyeShcbiAgICAgICAgICAgIHJlc3VtZWRCb3VuZGFyeSxcbiAgICAgICAgICAgIGVycm9yRGlnZXN0LFxuICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICBlcnJvckluZm8sXG4gICAgICAgICAgICB3YXNBYm9ydGVkXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXN1bWVkQm91bmRhcnkucGFyZW50Rmx1c2hlZCAmJlxuICAgICAgICAgICAgcmVxdWVzdC5jbGllbnRSZW5kZXJlZEJvdW5kYXJpZXMucHVzaChyZXN1bWVkQm91bmRhcnkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBub2Rlcy5sZW5ndGggPSAwO1xuICAgICAgaWYgKG51bGwgIT09IHNsb3RzKSB7XG4gICAgICAgIGlmIChudWxsID09PSBib3VuZGFyeSlcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiV2Ugc2hvdWxkIG5vdCBoYXZlIGFueSByZXN1bWFibGUgbm9kZXMgaW4gdGhlIHNoZWxsLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgYm91bmRhcnkuc3RhdHVzICE9PSBDTElFTlRfUkVOREVSRUQgJiZcbiAgICAgICAgICAoKGJvdW5kYXJ5LnN0YXR1cyA9IENMSUVOVF9SRU5ERVJFRCksXG4gICAgICAgICAgZW5jb2RlRXJyb3JGb3JCb3VuZGFyeShcbiAgICAgICAgICAgIGJvdW5kYXJ5LFxuICAgICAgICAgICAgZXJyb3JEaWdlc3QkanNjb21wJDAsXG4gICAgICAgICAgICBlcnJvciRqc2NvbXAkMCxcbiAgICAgICAgICAgIGVycm9ySW5mbyRqc2NvbXAkMCxcbiAgICAgICAgICAgIGFib3J0ZWRcbiAgICAgICAgICApLFxuICAgICAgICAgIGJvdW5kYXJ5LnBhcmVudEZsdXNoZWQgJiZcbiAgICAgICAgICAgIHJlcXVlc3QkanNjb21wJDAuY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzLnB1c2goYm91bmRhcnkpKTtcbiAgICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBzbG90cylcbiAgICAgICAgICBmb3IgKHZhciBpbmRleCBpbiBzbG90cykgZGVsZXRlIHNsb3RzW2luZGV4XTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYWJvcnRUYXNrKHRhc2ssIHJlcXVlc3QsIGVycm9yKSB7XG4gICAgICB2YXIgYm91bmRhcnkgPSB0YXNrLmJsb2NrZWRCb3VuZGFyeSxcbiAgICAgICAgc2VnbWVudCA9IHRhc2suYmxvY2tlZFNlZ21lbnQ7XG4gICAgICBpZiAobnVsbCAhPT0gc2VnbWVudCkge1xuICAgICAgICBpZiAoNiA9PT0gc2VnbWVudC5zdGF0dXMpIHJldHVybjtcbiAgICAgICAgc2VnbWVudC5zdGF0dXMgPSBBQk9SVEVEO1xuICAgICAgfVxuICAgICAgdmFyIGVycm9ySW5mbyA9IGdldFRocm93bkluZm8odGFzay5jb21wb25lbnRTdGFjayksXG4gICAgICAgIG5vZGUgPSB0YXNrLm5vZGU7XG4gICAgICBudWxsICE9PSBub2RlICYmXG4gICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBub2RlICYmXG4gICAgICAgIHB1c2hIYWx0ZWRBd2FpdE9uQ29tcG9uZW50U3RhY2sodGFzaywgbm9kZS5fZGVidWdJbmZvKTtcbiAgICAgIGlmIChudWxsID09PSBib3VuZGFyeSkge1xuICAgICAgICBpZiAoMTMgIT09IHJlcXVlc3Quc3RhdHVzICYmIHJlcXVlc3Quc3RhdHVzICE9PSBDTE9TRUQpIHtcbiAgICAgICAgICBib3VuZGFyeSA9IHRhc2sucmVwbGF5O1xuICAgICAgICAgIGlmIChudWxsID09PSBib3VuZGFyeSkge1xuICAgICAgICAgICAgbnVsbCAhPT0gcmVxdWVzdC50cmFja2VkUG9zdHBvbmVzICYmIG51bGwgIT09IHNlZ21lbnRcbiAgICAgICAgICAgICAgPyAoKGJvdW5kYXJ5ID0gcmVxdWVzdC50cmFja2VkUG9zdHBvbmVzKSxcbiAgICAgICAgICAgICAgICBsb2dSZWNvdmVyYWJsZUVycm9yKHJlcXVlc3QsIGVycm9yLCBlcnJvckluZm8sIHRhc2suZGVidWdUYXNrKSxcbiAgICAgICAgICAgICAgICB0cmFja1Bvc3Rwb25lKHJlcXVlc3QsIGJvdW5kYXJ5LCB0YXNrLCBzZWdtZW50KSxcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFRhc2socmVxdWVzdCwgbnVsbCwgdGFzay5yb3csIHNlZ21lbnQpKVxuICAgICAgICAgICAgICA6IChsb2dSZWNvdmVyYWJsZUVycm9yKHJlcXVlc3QsIGVycm9yLCBlcnJvckluZm8sIHRhc2suZGVidWdUYXNrKSxcbiAgICAgICAgICAgICAgICBmYXRhbEVycm9yKHJlcXVlc3QsIGVycm9yLCBlcnJvckluZm8sIHRhc2suZGVidWdUYXNrKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGJvdW5kYXJ5LnBlbmRpbmdUYXNrcy0tO1xuICAgICAgICAgIDAgPT09IGJvdW5kYXJ5LnBlbmRpbmdUYXNrcyAmJlxuICAgICAgICAgICAgMCA8IGJvdW5kYXJ5Lm5vZGVzLmxlbmd0aCAmJlxuICAgICAgICAgICAgKChzZWdtZW50ID0gbG9nUmVjb3ZlcmFibGVFcnJvcihyZXF1ZXN0LCBlcnJvciwgZXJyb3JJbmZvLCBudWxsKSksXG4gICAgICAgICAgICBhYm9ydFJlbWFpbmluZ1JlcGxheU5vZGVzKFxuICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICBib3VuZGFyeS5ub2RlcyxcbiAgICAgICAgICAgICAgYm91bmRhcnkuc2xvdHMsXG4gICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICBzZWdtZW50LFxuICAgICAgICAgICAgICBlcnJvckluZm8sXG4gICAgICAgICAgICAgICEwXG4gICAgICAgICAgICApKTtcbiAgICAgICAgICByZXF1ZXN0LnBlbmRpbmdSb290VGFza3MtLTtcbiAgICAgICAgICAwID09PSByZXF1ZXN0LnBlbmRpbmdSb290VGFza3MgJiYgY29tcGxldGVTaGVsbChyZXF1ZXN0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZSA9IHJlcXVlc3QudHJhY2tlZFBvc3Rwb25lcztcbiAgICAgICAgaWYgKGJvdW5kYXJ5LnN0YXR1cyAhPT0gQ0xJRU5UX1JFTkRFUkVEKSB7XG4gICAgICAgICAgaWYgKG51bGwgIT09IG5vZGUgJiYgbnVsbCAhPT0gc2VnbWVudClcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIGxvZ1JlY292ZXJhYmxlRXJyb3IocmVxdWVzdCwgZXJyb3IsIGVycm9ySW5mbywgdGFzay5kZWJ1Z1Rhc2spLFxuICAgICAgICAgICAgICB0cmFja1Bvc3Rwb25lKHJlcXVlc3QsIG5vZGUsIHRhc2ssIHNlZ21lbnQpLFxuICAgICAgICAgICAgICBib3VuZGFyeS5mYWxsYmFja0Fib3J0YWJsZVRhc2tzLmZvckVhY2goZnVuY3Rpb24gKGZhbGxiYWNrVGFzaykge1xuICAgICAgICAgICAgICAgIHJldHVybiBhYm9ydFRhc2soZmFsbGJhY2tUYXNrLCByZXF1ZXN0LCBlcnJvcik7XG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICBib3VuZGFyeS5mYWxsYmFja0Fib3J0YWJsZVRhc2tzLmNsZWFyKCksXG4gICAgICAgICAgICAgIGZpbmlzaGVkVGFzayhyZXF1ZXN0LCBib3VuZGFyeSwgdGFzay5yb3csIHNlZ21lbnQpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGJvdW5kYXJ5LnN0YXR1cyA9IENMSUVOVF9SRU5ERVJFRDtcbiAgICAgICAgICBzZWdtZW50ID0gbG9nUmVjb3ZlcmFibGVFcnJvcihcbiAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgIGVycm9ySW5mbyxcbiAgICAgICAgICAgIHRhc2suZGVidWdUYXNrXG4gICAgICAgICAgKTtcbiAgICAgICAgICBib3VuZGFyeS5zdGF0dXMgPSBDTElFTlRfUkVOREVSRUQ7XG4gICAgICAgICAgZW5jb2RlRXJyb3JGb3JCb3VuZGFyeShib3VuZGFyeSwgc2VnbWVudCwgZXJyb3IsIGVycm9ySW5mbywgITApO1xuICAgICAgICAgIHVudHJhY2tCb3VuZGFyeShyZXF1ZXN0LCBib3VuZGFyeSk7XG4gICAgICAgICAgYm91bmRhcnkucGFyZW50Rmx1c2hlZCAmJlxuICAgICAgICAgICAgcmVxdWVzdC5jbGllbnRSZW5kZXJlZEJvdW5kYXJpZXMucHVzaChib3VuZGFyeSk7XG4gICAgICAgIH1cbiAgICAgICAgYm91bmRhcnkucGVuZGluZ1Rhc2tzLS07XG4gICAgICAgIGVycm9ySW5mbyA9IGJvdW5kYXJ5LnJvdztcbiAgICAgICAgbnVsbCAhPT0gZXJyb3JJbmZvICYmXG4gICAgICAgICAgMCA9PT0gLS1lcnJvckluZm8ucGVuZGluZ1Rhc2tzICYmXG4gICAgICAgICAgZmluaXNoU3VzcGVuc2VMaXN0Um93KHJlcXVlc3QsIGVycm9ySW5mbyk7XG4gICAgICAgIGJvdW5kYXJ5LmZhbGxiYWNrQWJvcnRhYmxlVGFza3MuZm9yRWFjaChmdW5jdGlvbiAoZmFsbGJhY2tUYXNrKSB7XG4gICAgICAgICAgcmV0dXJuIGFib3J0VGFzayhmYWxsYmFja1Rhc2ssIHJlcXVlc3QsIGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJvdW5kYXJ5LmZhbGxiYWNrQWJvcnRhYmxlVGFza3MuY2xlYXIoKTtcbiAgICAgIH1cbiAgICAgIHRhc2sgPSB0YXNrLnJvdztcbiAgICAgIG51bGwgIT09IHRhc2sgJiZcbiAgICAgICAgMCA9PT0gLS10YXNrLnBlbmRpbmdUYXNrcyAmJlxuICAgICAgICBmaW5pc2hTdXNwZW5zZUxpc3RSb3cocmVxdWVzdCwgdGFzayk7XG4gICAgICByZXF1ZXN0LmFsbFBlbmRpbmdUYXNrcy0tO1xuICAgICAgMCA9PT0gcmVxdWVzdC5hbGxQZW5kaW5nVGFza3MgJiYgY29tcGxldGVBbGwocmVxdWVzdCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNhZmVseUVtaXRFYXJseVByZWxvYWRzKHJlcXVlc3QsIHNoZWxsQ29tcGxldGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciByZW5kZXJTdGF0ZSA9IHJlcXVlc3QucmVuZGVyU3RhdGUsXG4gICAgICAgICAgb25IZWFkZXJzID0gcmVuZGVyU3RhdGUub25IZWFkZXJzO1xuICAgICAgICBpZiAob25IZWFkZXJzKSB7XG4gICAgICAgICAgdmFyIGhlYWRlcnMgPSByZW5kZXJTdGF0ZS5oZWFkZXJzO1xuICAgICAgICAgIGlmIChoZWFkZXJzKSB7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZS5oZWFkZXJzID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBsaW5rSGVhZGVyID0gaGVhZGVycy5wcmVjb25uZWN0cztcbiAgICAgICAgICAgIGhlYWRlcnMuZm9udFByZWxvYWRzICYmXG4gICAgICAgICAgICAgIChsaW5rSGVhZGVyICYmIChsaW5rSGVhZGVyICs9IFwiLCBcIiksXG4gICAgICAgICAgICAgIChsaW5rSGVhZGVyICs9IGhlYWRlcnMuZm9udFByZWxvYWRzKSk7XG4gICAgICAgICAgICBoZWFkZXJzLmhpZ2hJbWFnZVByZWxvYWRzICYmXG4gICAgICAgICAgICAgIChsaW5rSGVhZGVyICYmIChsaW5rSGVhZGVyICs9IFwiLCBcIiksXG4gICAgICAgICAgICAgIChsaW5rSGVhZGVyICs9IGhlYWRlcnMuaGlnaEltYWdlUHJlbG9hZHMpKTtcbiAgICAgICAgICAgIGlmICghc2hlbGxDb21wbGV0ZSkge1xuICAgICAgICAgICAgICB2YXIgcXVldWVJdGVyID0gcmVuZGVyU3RhdGUuc3R5bGVzLnZhbHVlcygpLFxuICAgICAgICAgICAgICAgIHF1ZXVlU3RlcCA9IHF1ZXVlSXRlci5uZXh0KCk7XG4gICAgICAgICAgICAgIGI6IGZvciAoXG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIDAgPCBoZWFkZXJzLnJlbWFpbmluZ0NhcGFjaXR5ICYmICFxdWV1ZVN0ZXAuZG9uZTtcbiAgICAgICAgICAgICAgICBxdWV1ZVN0ZXAgPSBxdWV1ZUl0ZXIubmV4dCgpXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgICAgdmFyIHNoZWV0SXRlciA9IHF1ZXVlU3RlcC52YWx1ZS5zaGVldHMudmFsdWVzKCksXG4gICAgICAgICAgICAgICAgICAgIHNoZWV0U3RlcCA9IHNoZWV0SXRlci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAwIDwgaGVhZGVycy5yZW1haW5pbmdDYXBhY2l0eSAmJiAhc2hlZXRTdGVwLmRvbmU7XG4gICAgICAgICAgICAgICAgICBzaGVldFN0ZXAgPSBzaGVldEl0ZXIubmV4dCgpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgc2hlZXQgPSBzaGVldFN0ZXAudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHByb3BzID0gc2hlZXQucHJvcHMsXG4gICAgICAgICAgICAgICAgICAgIGtleSA9IHByb3BzLmhyZWYsXG4gICAgICAgICAgICAgICAgICAgIHByb3BzJGpzY29tcCQwID0gc2hlZXQucHJvcHM7XG4gICAgICAgICAgICAgICAgICB2YXIgaGVhZGVyID0gZ2V0UHJlbG9hZEFzSGVhZGVyKFxuICAgICAgICAgICAgICAgICAgICBwcm9wcyRqc2NvbXAkMC5ocmVmLFxuICAgICAgICAgICAgICAgICAgICBcInN0eWxlXCIsXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICBjcm9zc09yaWdpbjogcHJvcHMkanNjb21wJDAuY3Jvc3NPcmlnaW4sXG4gICAgICAgICAgICAgICAgICAgICAgaW50ZWdyaXR5OiBwcm9wcyRqc2NvbXAkMC5pbnRlZ3JpdHksXG4gICAgICAgICAgICAgICAgICAgICAgbm9uY2U6IHByb3BzJGpzY29tcCQwLm5vbmNlLFxuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHByb3BzJGpzY29tcCQwLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgZmV0Y2hQcmlvcml0eTogcHJvcHMkanNjb21wJDAuZmV0Y2hQcmlvcml0eSxcbiAgICAgICAgICAgICAgICAgICAgICByZWZlcnJlclBvbGljeTogcHJvcHMkanNjb21wJDAucmVmZXJyZXJQb2xpY3ksXG4gICAgICAgICAgICAgICAgICAgICAgbWVkaWE6IHByb3BzJGpzY29tcCQwLm1lZGlhXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBpZiAoMCA8PSAoaGVhZGVycy5yZW1haW5pbmdDYXBhY2l0eSAtPSBoZWFkZXIubGVuZ3RoICsgMikpXG4gICAgICAgICAgICAgICAgICAgIChyZW5kZXJTdGF0ZS5yZXNldHMuc3R5bGVba2V5XSA9IFBSRUxPQURfTk9fQ1JFRFMpLFxuICAgICAgICAgICAgICAgICAgICAgIGxpbmtIZWFkZXIgJiYgKGxpbmtIZWFkZXIgKz0gXCIsIFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAobGlua0hlYWRlciArPSBoZWFkZXIpLFxuICAgICAgICAgICAgICAgICAgICAgIChyZW5kZXJTdGF0ZS5yZXNldHMuc3R5bGVba2V5XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgcHJvcHMuY3Jvc3NPcmlnaW4gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBwcm9wcy5pbnRlZ3JpdHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPyBbcHJvcHMuY3Jvc3NPcmlnaW4sIHByb3BzLmludGVncml0eV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgOiBQUkVMT0FEX05PX0NSRURTKTtcbiAgICAgICAgICAgICAgICAgIGVsc2UgYnJlYWsgYjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaW5rSGVhZGVyID8gb25IZWFkZXJzKHsgTGluazogbGlua0hlYWRlciB9KSA6IG9uSGVhZGVycyh7fSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dSZWNvdmVyYWJsZUVycm9yKHJlcXVlc3QsIGVycm9yLCB7fSwgbnVsbCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXBsZXRlU2hlbGwocmVxdWVzdCkge1xuICAgICAgbnVsbCA9PT0gcmVxdWVzdC50cmFja2VkUG9zdHBvbmVzICYmIHNhZmVseUVtaXRFYXJseVByZWxvYWRzKHJlcXVlc3QsICEwKTtcbiAgICAgIG51bGwgPT09IHJlcXVlc3QudHJhY2tlZFBvc3Rwb25lcyAmJiBwcmVwYXJlUHJlYW1ibGUocmVxdWVzdCk7XG4gICAgICByZXF1ZXN0Lm9uU2hlbGxFcnJvciA9IG5vb3A7XG4gICAgICByZXF1ZXN0ID0gcmVxdWVzdC5vblNoZWxsUmVhZHk7XG4gICAgICByZXF1ZXN0KCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXBsZXRlQWxsKHJlcXVlc3QpIHtcbiAgICAgIHNhZmVseUVtaXRFYXJseVByZWxvYWRzKFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICBudWxsID09PSByZXF1ZXN0LnRyYWNrZWRQb3N0cG9uZXNcbiAgICAgICAgICA/ICEwXG4gICAgICAgICAgOiBudWxsID09PSByZXF1ZXN0LmNvbXBsZXRlZFJvb3RTZWdtZW50IHx8XG4gICAgICAgICAgICAgIHJlcXVlc3QuY29tcGxldGVkUm9vdFNlZ21lbnQuc3RhdHVzICE9PSBQT1NUUE9ORURcbiAgICAgICk7XG4gICAgICBwcmVwYXJlUHJlYW1ibGUocmVxdWVzdCk7XG4gICAgICByZXF1ZXN0ID0gcmVxdWVzdC5vbkFsbFJlYWR5O1xuICAgICAgcmVxdWVzdCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBxdWV1ZUNvbXBsZXRlZFNlZ21lbnQoYm91bmRhcnksIHNlZ21lbnQpIHtcbiAgICAgIGlmIChcbiAgICAgICAgMCA9PT0gc2VnbWVudC5jaHVua3MubGVuZ3RoICYmXG4gICAgICAgIDEgPT09IHNlZ21lbnQuY2hpbGRyZW4ubGVuZ3RoICYmXG4gICAgICAgIG51bGwgPT09IHNlZ21lbnQuY2hpbGRyZW5bMF0uYm91bmRhcnkgJiZcbiAgICAgICAgLTEgPT09IHNlZ21lbnQuY2hpbGRyZW5bMF0uaWRcbiAgICAgICkge1xuICAgICAgICB2YXIgY2hpbGRTZWdtZW50ID0gc2VnbWVudC5jaGlsZHJlblswXTtcbiAgICAgICAgY2hpbGRTZWdtZW50LmlkID0gc2VnbWVudC5pZDtcbiAgICAgICAgY2hpbGRTZWdtZW50LnBhcmVudEZsdXNoZWQgPSAhMDtcbiAgICAgICAgKGNoaWxkU2VnbWVudC5zdGF0dXMgIT09IENPTVBMRVRFRCAmJlxuICAgICAgICAgIGNoaWxkU2VnbWVudC5zdGF0dXMgIT09IEFCT1JURUQgJiZcbiAgICAgICAgICBjaGlsZFNlZ21lbnQuc3RhdHVzICE9PSBFUlJPUkVEKSB8fFxuICAgICAgICAgIHF1ZXVlQ29tcGxldGVkU2VnbWVudChib3VuZGFyeSwgY2hpbGRTZWdtZW50KTtcbiAgICAgIH0gZWxzZSBib3VuZGFyeS5jb21wbGV0ZWRTZWdtZW50cy5wdXNoKHNlZ21lbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5pc2hlZFRhc2socmVxdWVzdCwgYm91bmRhcnksIHJvdywgc2VnbWVudCkge1xuICAgICAgbnVsbCAhPT0gcm93ICYmXG4gICAgICAgICgwID09PSAtLXJvdy5wZW5kaW5nVGFza3NcbiAgICAgICAgICA/IGZpbmlzaFN1c3BlbnNlTGlzdFJvdyhyZXF1ZXN0LCByb3cpXG4gICAgICAgICAgOiByb3cudG9nZXRoZXIgJiYgdHJ5VG9SZXNvbHZlVG9nZXRoZXJSb3cocmVxdWVzdCwgcm93KSk7XG4gICAgICByZXF1ZXN0LmFsbFBlbmRpbmdUYXNrcy0tO1xuICAgICAgaWYgKG51bGwgPT09IGJvdW5kYXJ5KSB7XG4gICAgICAgIGlmIChudWxsICE9PSBzZWdtZW50ICYmIHNlZ21lbnQucGFyZW50Rmx1c2hlZCkge1xuICAgICAgICAgIGlmIChudWxsICE9PSByZXF1ZXN0LmNvbXBsZXRlZFJvb3RTZWdtZW50KVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgIFwiVGhlcmUgY2FuIG9ubHkgYmUgb25lIHJvb3Qgc2VnbWVudC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICByZXF1ZXN0LmNvbXBsZXRlZFJvb3RTZWdtZW50ID0gc2VnbWVudDtcbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0LnBlbmRpbmdSb290VGFza3MtLTtcbiAgICAgICAgMCA9PT0gcmVxdWVzdC5wZW5kaW5nUm9vdFRhc2tzICYmIGNvbXBsZXRlU2hlbGwocmVxdWVzdCk7XG4gICAgICB9IGVsc2UgaWYgKChib3VuZGFyeS5wZW5kaW5nVGFza3MtLSwgYm91bmRhcnkuc3RhdHVzICE9PSBDTElFTlRfUkVOREVSRUQpKVxuICAgICAgICBpZiAoMCA9PT0gYm91bmRhcnkucGVuZGluZ1Rhc2tzKVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIChib3VuZGFyeS5zdGF0dXMgPT09IFBFTkRJTkcgJiYgKGJvdW5kYXJ5LnN0YXR1cyA9IENPTVBMRVRFRCksXG4gICAgICAgICAgICBudWxsICE9PSBzZWdtZW50ICYmXG4gICAgICAgICAgICAgIHNlZ21lbnQucGFyZW50Rmx1c2hlZCAmJlxuICAgICAgICAgICAgICAoc2VnbWVudC5zdGF0dXMgPT09IENPTVBMRVRFRCB8fCBzZWdtZW50LnN0YXR1cyA9PT0gQUJPUlRFRCkgJiZcbiAgICAgICAgICAgICAgcXVldWVDb21wbGV0ZWRTZWdtZW50KGJvdW5kYXJ5LCBzZWdtZW50KSxcbiAgICAgICAgICAgIGJvdW5kYXJ5LnBhcmVudEZsdXNoZWQgJiZcbiAgICAgICAgICAgICAgcmVxdWVzdC5jb21wbGV0ZWRCb3VuZGFyaWVzLnB1c2goYm91bmRhcnkpLFxuICAgICAgICAgICAgYm91bmRhcnkuc3RhdHVzID09PSBDT01QTEVURUQpXG4gICAgICAgICAgKVxuICAgICAgICAgICAgKHJvdyA9IGJvdW5kYXJ5LnJvdyksXG4gICAgICAgICAgICAgIG51bGwgIT09IHJvdyAmJlxuICAgICAgICAgICAgICAgIGhvaXN0SG9pc3RhYmxlcyhyb3cuaG9pc3RhYmxlcywgYm91bmRhcnkuY29udGVudFN0YXRlKSxcbiAgICAgICAgICAgICAgaXNFbGlnaWJsZUZvck91dGxpbmluZyhyZXF1ZXN0LCBib3VuZGFyeSkgfHxcbiAgICAgICAgICAgICAgICAoYm91bmRhcnkuZmFsbGJhY2tBYm9ydGFibGVUYXNrcy5mb3JFYWNoKFxuICAgICAgICAgICAgICAgICAgYWJvcnRUYXNrU29mdCxcbiAgICAgICAgICAgICAgICAgIHJlcXVlc3RcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGJvdW5kYXJ5LmZhbGxiYWNrQWJvcnRhYmxlVGFza3MuY2xlYXIoKSxcbiAgICAgICAgICAgICAgICBudWxsICE9PSByb3cgJiZcbiAgICAgICAgICAgICAgICAgIDAgPT09IC0tcm93LnBlbmRpbmdUYXNrcyAmJlxuICAgICAgICAgICAgICAgICAgZmluaXNoU3VzcGVuc2VMaXN0Um93KHJlcXVlc3QsIHJvdykpLFxuICAgICAgICAgICAgICAwID09PSByZXF1ZXN0LnBlbmRpbmdSb290VGFza3MgJiZcbiAgICAgICAgICAgICAgICBudWxsID09PSByZXF1ZXN0LnRyYWNrZWRQb3N0cG9uZXMgJiZcbiAgICAgICAgICAgICAgICBudWxsICE9PSBib3VuZGFyeS5jb250ZW50UHJlYW1ibGUgJiZcbiAgICAgICAgICAgICAgICBwcmVwYXJlUHJlYW1ibGUocmVxdWVzdCk7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIGJvdW5kYXJ5LnN0YXR1cyA9PT0gUE9TVFBPTkVEICYmXG4gICAgICAgICAgICAgICgoYm91bmRhcnkgPSBib3VuZGFyeS5yb3cpLCBudWxsICE9PSBib3VuZGFyeSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBpZiAobnVsbCAhPT0gcmVxdWVzdC50cmFja2VkUG9zdHBvbmVzKSB7XG4gICAgICAgICAgICAgICAgcm93ID0gcmVxdWVzdC50cmFja2VkUG9zdHBvbmVzO1xuICAgICAgICAgICAgICAgIHZhciBwb3N0cG9uZWRSb3cgPSBib3VuZGFyeS5uZXh0O1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgIG51bGwgIT09IHBvc3Rwb25lZFJvdyAmJlxuICAgICAgICAgICAgICAgICAgKChzZWdtZW50ID0gcG9zdHBvbmVkUm93LmJvdW5kYXJpZXMpLCBudWxsICE9PSBzZWdtZW50KVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgICAgIHBvc3Rwb25lZFJvdy5ib3VuZGFyaWVzID0gbnVsbCwgcG9zdHBvbmVkUm93ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgcG9zdHBvbmVkUm93IDwgc2VnbWVudC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHBvc3Rwb25lZFJvdysrXG4gICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvc3Rwb25lZEJvdW5kYXJ5ID0gc2VnbWVudFtwb3N0cG9uZWRSb3ddO1xuICAgICAgICAgICAgICAgICAgICB0cmFja1Bvc3Rwb25lZEJvdW5kYXJ5KHJlcXVlc3QsIHJvdywgcG9zdHBvbmVkQm91bmRhcnkpO1xuICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFRhc2socmVxdWVzdCwgcG9zdHBvbmVkQm91bmRhcnksIG51bGwsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIDAgPT09IC0tYm91bmRhcnkucGVuZGluZ1Rhc2tzICYmXG4gICAgICAgICAgICAgICAgZmluaXNoU3VzcGVuc2VMaXN0Um93KHJlcXVlc3QsIGJvdW5kYXJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBudWxsID09PSBzZWdtZW50IHx8XG4gICAgICAgICAgICAhc2VnbWVudC5wYXJlbnRGbHVzaGVkIHx8XG4gICAgICAgICAgICAoc2VnbWVudC5zdGF0dXMgIT09IENPTVBMRVRFRCAmJiBzZWdtZW50LnN0YXR1cyAhPT0gQUJPUlRFRCkgfHxcbiAgICAgICAgICAgIChxdWV1ZUNvbXBsZXRlZFNlZ21lbnQoYm91bmRhcnksIHNlZ21lbnQpLFxuICAgICAgICAgICAgMSA9PT0gYm91bmRhcnkuY29tcGxldGVkU2VnbWVudHMubGVuZ3RoICYmXG4gICAgICAgICAgICAgIGJvdW5kYXJ5LnBhcmVudEZsdXNoZWQgJiZcbiAgICAgICAgICAgICAgcmVxdWVzdC5wYXJ0aWFsQm91bmRhcmllcy5wdXNoKGJvdW5kYXJ5KSksXG4gICAgICAgICAgICAoYm91bmRhcnkgPSBib3VuZGFyeS5yb3cpLFxuICAgICAgICAgICAgbnVsbCAhPT0gYm91bmRhcnkgJiZcbiAgICAgICAgICAgICAgYm91bmRhcnkudG9nZXRoZXIgJiZcbiAgICAgICAgICAgICAgdHJ5VG9SZXNvbHZlVG9nZXRoZXJSb3cocmVxdWVzdCwgYm91bmRhcnkpO1xuICAgICAgMCA9PT0gcmVxdWVzdC5hbGxQZW5kaW5nVGFza3MgJiYgY29tcGxldGVBbGwocmVxdWVzdCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBlcmZvcm1Xb3JrKHJlcXVlc3QkanNjb21wJDIpIHtcbiAgICAgIGlmIChcbiAgICAgICAgcmVxdWVzdCRqc2NvbXAkMi5zdGF0dXMgIT09IENMT1NFRCAmJlxuICAgICAgICAxMyAhPT0gcmVxdWVzdCRqc2NvbXAkMi5zdGF0dXNcbiAgICAgICkge1xuICAgICAgICB2YXIgcHJldkNvbnRleHQgPSBjdXJyZW50QWN0aXZlU25hcHNob3QsXG4gICAgICAgICAgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSG9va3NEaXNwYXRjaGVyO1xuICAgICAgICB2YXIgcHJldkFzeW5jRGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkE7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkEgPSBEZWZhdWx0QXN5bmNEaXNwYXRjaGVyO1xuICAgICAgICB2YXIgcHJldlJlcXVlc3QgPSBjdXJyZW50UmVxdWVzdDtcbiAgICAgICAgY3VycmVudFJlcXVlc3QgPSByZXF1ZXN0JGpzY29tcCQyO1xuICAgICAgICB2YXIgcHJldkdldEN1cnJlbnRTdGFja0ltcGwgPSBSZWFjdFNoYXJlZEludGVybmFscy5nZXRDdXJyZW50U3RhY2s7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjayA9IGdldEN1cnJlbnRTdGFja0luREVWO1xuICAgICAgICB2YXIgcHJldlJlc3VtYWJsZVN0YXRlID0gY3VycmVudFJlc3VtYWJsZVN0YXRlO1xuICAgICAgICBjdXJyZW50UmVzdW1hYmxlU3RhdGUgPSByZXF1ZXN0JGpzY29tcCQyLnJlc3VtYWJsZVN0YXRlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBwaW5nZWRUYXNrcyA9IHJlcXVlc3QkanNjb21wJDIucGluZ2VkVGFza3MsXG4gICAgICAgICAgICBpO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBwaW5nZWRUYXNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHJlcXVlc3QgPSByZXF1ZXN0JGpzY29tcCQyLFxuICAgICAgICAgICAgICB0YXNrID0gcGluZ2VkVGFza3NbaV0sXG4gICAgICAgICAgICAgIHNlZ21lbnQgPSB0YXNrLmJsb2NrZWRTZWdtZW50O1xuICAgICAgICAgICAgaWYgKG51bGwgPT09IHNlZ21lbnQpIHtcbiAgICAgICAgICAgICAgdmFyIHByZXZUYXNrSW5ERVYgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgcmVxdWVzdCRqc2NvbXAkMCA9IHJlcXVlc3Q7XG4gICAgICAgICAgICAgIHJlcXVlc3QgPSB0YXNrO1xuICAgICAgICAgICAgICBpZiAoMCAhPT0gcmVxdWVzdC5yZXBsYXkucGVuZGluZ1Rhc2tzKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoQ29udGV4dChyZXF1ZXN0LmNvbnRleHQpO1xuICAgICAgICAgICAgICAgIHByZXZUYXNrSW5ERVYgPSBjdXJyZW50VGFza0luREVWO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRUYXNrSW5ERVYgPSByZXF1ZXN0O1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgcmVxdWVzdC5yZXBsYXkuc2xvdHNcbiAgICAgICAgICAgICAgICAgICAgPyByZXN1bWVOb2RlKFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LnJlcGxheS5zbG90cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3Qubm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QuY2hpbGRJbmRleFxuICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgOiByZXRyeU5vZGUocmVxdWVzdCRqc2NvbXAkMCwgcmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIDEgPT09IHJlcXVlc3QucmVwbGF5LnBlbmRpbmdUYXNrcyAmJlxuICAgICAgICAgICAgICAgICAgICAwIDwgcmVxdWVzdC5yZXBsYXkubm9kZXMubGVuZ3RoXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgIFwiQ291bGRuJ3QgZmluZCBhbGwgcmVzdW1hYmxlIHNsb3RzIGJ5IGtleS9pbmRleCBkdXJpbmcgcmVwbGF5aW5nLiBUaGUgdHJlZSBkb2Vzbid0IG1hdGNoIHNvIFJlYWN0IHdpbGwgZmFsbGJhY2sgdG8gY2xpZW50IHJlbmRlcmluZy5cIlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgcmVxdWVzdC5yZXBsYXkucGVuZGluZ1Rhc2tzLS07XG4gICAgICAgICAgICAgICAgICByZXF1ZXN0LmFib3J0U2V0LmRlbGV0ZShyZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkVGFzayhcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5ibG9ja2VkQm91bmRhcnksXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3Qucm93LFxuICAgICAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHRocm93blZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICByZXNldEhvb2tzU3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgIHZhciB4ID1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3duVmFsdWUgPT09IFN1c3BlbnNlRXhjZXB0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgPyBnZXRTdXNwZW5kZWRUaGVuYWJsZSgpXG4gICAgICAgICAgICAgICAgICAgICAgOiB0aHJvd25WYWx1ZTtcbiAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHggJiZcbiAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0geCAmJlxuICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB4LnRoZW5cbiAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGluZyA9IHJlcXVlc3QucGluZztcbiAgICAgICAgICAgICAgICAgICAgeC50aGVuKHBpbmcsIHBpbmcpO1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LnRoZW5hYmxlU3RhdGUgPVxuICAgICAgICAgICAgICAgICAgICAgIHRocm93blZhbHVlID09PSBTdXNwZW5zZUV4Y2VwdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgPyBnZXRUaGVuYWJsZVN0YXRlQWZ0ZXJTdXNwZW5kaW5nKClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QucmVwbGF5LnBlbmRpbmdUYXNrcy0tO1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmFib3J0U2V0LmRlbGV0ZShyZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9ySW5mbyA9IGdldFRocm93bkluZm8ocmVxdWVzdC5jb21wb25lbnRTdGFjayksXG4gICAgICAgICAgICAgICAgICAgICAgZXJyb3JEaWdlc3QgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCRqc2NvbXAkMSA9IHJlcXVlc3QkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgICAgYm91bmRhcnkgPSByZXF1ZXN0LmJsb2NrZWRCb3VuZGFyeSxcbiAgICAgICAgICAgICAgICAgICAgICBlcnJvciRqc2NvbXAkMCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAxMiA9PT0gcmVxdWVzdCRqc2NvbXAkMC5zdGF0dXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPyByZXF1ZXN0JGpzY29tcCQwLmZhdGFsRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgOiB4LFxuICAgICAgICAgICAgICAgICAgICAgIGVycm9ySW5mbyRqc2NvbXAkMCA9IGVycm9ySW5mbyxcbiAgICAgICAgICAgICAgICAgICAgICByZXBsYXlOb2RlcyA9IHJlcXVlc3QucmVwbGF5Lm5vZGVzLFxuICAgICAgICAgICAgICAgICAgICAgIHJlc3VtZVNsb3RzID0gcmVxdWVzdC5yZXBsYXkuc2xvdHM7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yRGlnZXN0ID0gbG9nUmVjb3ZlcmFibGVFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0JGpzY29tcCQxLFxuICAgICAgICAgICAgICAgICAgICAgIGVycm9yJGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICAgIGVycm9ySW5mbyRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmRlYnVnVGFza1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBhYm9ydFJlbWFpbmluZ1JlcGxheU5vZGVzKFxuICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QkanNjb21wJDEsXG4gICAgICAgICAgICAgICAgICAgICAgYm91bmRhcnksXG4gICAgICAgICAgICAgICAgICAgICAgcmVwbGF5Tm9kZXMsXG4gICAgICAgICAgICAgICAgICAgICAgcmVzdW1lU2xvdHMsXG4gICAgICAgICAgICAgICAgICAgICAgZXJyb3IkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgICAgZXJyb3JEaWdlc3QsXG4gICAgICAgICAgICAgICAgICAgICAgZXJyb3JJbmZvJGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICAgICExXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QkanNjb21wJDAucGVuZGluZ1Jvb3RUYXNrcy0tO1xuICAgICAgICAgICAgICAgICAgICAwID09PSByZXF1ZXN0JGpzY29tcCQwLnBlbmRpbmdSb290VGFza3MgJiZcbiAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZVNoZWxsKHJlcXVlc3QkanNjb21wJDApO1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0JGpzY29tcCQwLmFsbFBlbmRpbmdUYXNrcy0tO1xuICAgICAgICAgICAgICAgICAgICAwID09PSByZXF1ZXN0JGpzY29tcCQwLmFsbFBlbmRpbmdUYXNrcyAmJlxuICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlQWxsKHJlcXVlc3QkanNjb21wJDApO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50VGFza0luREVWID0gcHJldlRhc2tJbkRFVjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICgocmVxdWVzdCRqc2NvbXAkMCA9IHByZXZUYXNrSW5ERVYgPSB2b2lkIDApLFxuICAgICAgICAgICAgICAoZXJyb3JEaWdlc3QgPSB0YXNrKSxcbiAgICAgICAgICAgICAgKHJlcXVlc3QkanNjb21wJDEgPSBzZWdtZW50KSxcbiAgICAgICAgICAgICAgcmVxdWVzdCRqc2NvbXAkMS5zdGF0dXMgPT09IFBFTkRJTkcpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgcmVxdWVzdCRqc2NvbXAkMS5zdGF0dXMgPSA2O1xuICAgICAgICAgICAgICBzd2l0Y2hDb250ZXh0KGVycm9yRGlnZXN0LmNvbnRleHQpO1xuICAgICAgICAgICAgICByZXF1ZXN0JGpzY29tcCQwID0gY3VycmVudFRhc2tJbkRFVjtcbiAgICAgICAgICAgICAgY3VycmVudFRhc2tJbkRFViA9IGVycm9yRGlnZXN0O1xuICAgICAgICAgICAgICB2YXIgY2hpbGRyZW5MZW5ndGggPSByZXF1ZXN0JGpzY29tcCQxLmNoaWxkcmVuLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBjaHVua0xlbmd0aCA9IHJlcXVlc3QkanNjb21wJDEuY2h1bmtzLmxlbmd0aDtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXRyeU5vZGUocmVxdWVzdCwgZXJyb3JEaWdlc3QpLFxuICAgICAgICAgICAgICAgICAgcHVzaFNlZ21lbnRGaW5hbGUoXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QkanNjb21wJDEuY2h1bmtzLFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LnJlbmRlclN0YXRlLFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0JGpzY29tcCQxLmxhc3RQdXNoZWRUZXh0LFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0JGpzY29tcCQxLnRleHRFbWJlZGRlZFxuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgIGVycm9yRGlnZXN0LmFib3J0U2V0LmRlbGV0ZShlcnJvckRpZ2VzdCksXG4gICAgICAgICAgICAgICAgICAocmVxdWVzdCRqc2NvbXAkMS5zdGF0dXMgPSBDT01QTEVURUQpLFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRUYXNrKFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICBlcnJvckRpZ2VzdC5ibG9ja2VkQm91bmRhcnksXG4gICAgICAgICAgICAgICAgICAgIGVycm9yRGlnZXN0LnJvdyxcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCRqc2NvbXAkMVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAodGhyb3duVmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXNldEhvb2tzU3RhdGUoKTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0JGpzY29tcCQxLmNoaWxkcmVuLmxlbmd0aCA9IGNoaWxkcmVuTGVuZ3RoO1xuICAgICAgICAgICAgICAgIHJlcXVlc3QkanNjb21wJDEuY2h1bmtzLmxlbmd0aCA9IGNodW5rTGVuZ3RoO1xuICAgICAgICAgICAgICAgIHZhciB4JGpzY29tcCQwID1cbiAgICAgICAgICAgICAgICAgIHRocm93blZhbHVlID09PSBTdXNwZW5zZUV4Y2VwdGlvblxuICAgICAgICAgICAgICAgICAgICA/IGdldFN1c3BlbmRlZFRoZW5hYmxlKClcbiAgICAgICAgICAgICAgICAgICAgOiAxMiA9PT0gcmVxdWVzdC5zdGF0dXNcbiAgICAgICAgICAgICAgICAgICAgICA/IHJlcXVlc3QuZmF0YWxFcnJvclxuICAgICAgICAgICAgICAgICAgICAgIDogdGhyb3duVmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgMTIgPT09IHJlcXVlc3Quc3RhdHVzICYmXG4gICAgICAgICAgICAgICAgICBudWxsICE9PSByZXF1ZXN0LnRyYWNrZWRQb3N0cG9uZXNcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIHZhciB0cmFja2VkUG9zdHBvbmVzID0gcmVxdWVzdC50cmFja2VkUG9zdHBvbmVzLFxuICAgICAgICAgICAgICAgICAgICB0aHJvd25JbmZvID0gZ2V0VGhyb3duSW5mbyhlcnJvckRpZ2VzdC5jb21wb25lbnRTdGFjayk7XG4gICAgICAgICAgICAgICAgICBlcnJvckRpZ2VzdC5hYm9ydFNldC5kZWxldGUoZXJyb3JEaWdlc3QpO1xuICAgICAgICAgICAgICAgICAgbG9nUmVjb3ZlcmFibGVFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgeCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgdGhyb3duSW5mbyxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JEaWdlc3QuZGVidWdUYXNrXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgdHJhY2tQb3N0cG9uZShcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgdHJhY2tlZFBvc3Rwb25lcyxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JEaWdlc3QsXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QkanNjb21wJDFcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFRhc2soXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yRGlnZXN0LmJsb2NrZWRCb3VuZGFyeSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JEaWdlc3Qucm93LFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0JGpzY29tcCQxXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgeCRqc2NvbXAkMCAmJlxuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0geCRqc2NvbXAkMCAmJlxuICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgeCRqc2NvbXAkMC50aGVuXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICByZXF1ZXN0JGpzY29tcCQxLnN0YXR1cyA9IFBFTkRJTkc7XG4gICAgICAgICAgICAgICAgICBlcnJvckRpZ2VzdC50aGVuYWJsZVN0YXRlID1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3duVmFsdWUgPT09IFN1c3BlbnNlRXhjZXB0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgPyBnZXRUaGVuYWJsZVN0YXRlQWZ0ZXJTdXNwZW5kaW5nKClcbiAgICAgICAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICAgICAgICB2YXIgcGluZyRqc2NvbXAkMCA9IGVycm9yRGlnZXN0LnBpbmc7XG4gICAgICAgICAgICAgICAgICB4JGpzY29tcCQwLnRoZW4ocGluZyRqc2NvbXAkMCwgcGluZyRqc2NvbXAkMCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHZhciBlcnJvckluZm8kanNjb21wJDEgPSBnZXRUaHJvd25JbmZvKFxuICAgICAgICAgICAgICAgICAgICBlcnJvckRpZ2VzdC5jb21wb25lbnRTdGFja1xuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGVycm9yRGlnZXN0LmFib3J0U2V0LmRlbGV0ZShlcnJvckRpZ2VzdCk7XG4gICAgICAgICAgICAgICAgICByZXF1ZXN0JGpzY29tcCQxLnN0YXR1cyA9IEVSUk9SRUQ7XG4gICAgICAgICAgICAgICAgICB2YXIgYm91bmRhcnkkanNjb21wJDAgPSBlcnJvckRpZ2VzdC5ibG9ja2VkQm91bmRhcnksXG4gICAgICAgICAgICAgICAgICAgIHJvdyA9IGVycm9yRGlnZXN0LnJvdyxcbiAgICAgICAgICAgICAgICAgICAgZGVidWdUYXNrID0gZXJyb3JEaWdlc3QuZGVidWdUYXNrO1xuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gcm93ICYmXG4gICAgICAgICAgICAgICAgICAgIDAgPT09IC0tcm93LnBlbmRpbmdUYXNrcyAmJlxuICAgICAgICAgICAgICAgICAgICBmaW5pc2hTdXNwZW5zZUxpc3RSb3cocmVxdWVzdCwgcm93KTtcbiAgICAgICAgICAgICAgICAgIHJlcXVlc3QuYWxsUGVuZGluZ1Rhc2tzLS07XG4gICAgICAgICAgICAgICAgICBwcmV2VGFza0luREVWID0gbG9nUmVjb3ZlcmFibGVFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgeCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JJbmZvJGpzY29tcCQxLFxuICAgICAgICAgICAgICAgICAgICBkZWJ1Z1Rhc2tcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBpZiAobnVsbCA9PT0gYm91bmRhcnkkanNjb21wJDApXG4gICAgICAgICAgICAgICAgICAgIGZhdGFsRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgICB4JGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICAgIGVycm9ySW5mbyRqc2NvbXAkMSxcbiAgICAgICAgICAgICAgICAgICAgICBkZWJ1Z1Rhc2tcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgICAgICAoYm91bmRhcnkkanNjb21wJDAucGVuZGluZ1Rhc2tzLS0sXG4gICAgICAgICAgICAgICAgICAgIGJvdW5kYXJ5JGpzY29tcCQwLnN0YXR1cyAhPT0gQ0xJRU5UX1JFTkRFUkVEKVxuICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGJvdW5kYXJ5JGpzY29tcCQwLnN0YXR1cyA9IENMSUVOVF9SRU5ERVJFRDtcbiAgICAgICAgICAgICAgICAgICAgZW5jb2RlRXJyb3JGb3JCb3VuZGFyeShcbiAgICAgICAgICAgICAgICAgICAgICBib3VuZGFyeSRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgICBwcmV2VGFza0luREVWLFxuICAgICAgICAgICAgICAgICAgICAgIHgkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgICAgZXJyb3JJbmZvJGpzY29tcCQxLFxuICAgICAgICAgICAgICAgICAgICAgICExXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIHVudHJhY2tCb3VuZGFyeShyZXF1ZXN0LCBib3VuZGFyeSRqc2NvbXAkMCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBib3VuZGFyeVJvdyA9IGJvdW5kYXJ5JGpzY29tcCQwLnJvdztcbiAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gYm91bmRhcnlSb3cgJiZcbiAgICAgICAgICAgICAgICAgICAgICAwID09PSAtLWJvdW5kYXJ5Um93LnBlbmRpbmdUYXNrcyAmJlxuICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaFN1c3BlbnNlTGlzdFJvdyhyZXF1ZXN0LCBib3VuZGFyeVJvdyk7XG4gICAgICAgICAgICAgICAgICAgIGJvdW5kYXJ5JGpzY29tcCQwLnBhcmVudEZsdXNoZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmNsaWVudFJlbmRlcmVkQm91bmRhcmllcy5wdXNoKGJvdW5kYXJ5JGpzY29tcCQwKTtcbiAgICAgICAgICAgICAgICAgICAgMCA9PT0gcmVxdWVzdC5wZW5kaW5nUm9vdFRhc2tzICYmXG4gICAgICAgICAgICAgICAgICAgICAgbnVsbCA9PT0gcmVxdWVzdC50cmFja2VkUG9zdHBvbmVzICYmXG4gICAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gYm91bmRhcnkkanNjb21wJDAuY29udGVudFByZWFtYmxlICYmXG4gICAgICAgICAgICAgICAgICAgICAgcHJlcGFyZVByZWFtYmxlKHJlcXVlc3QpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgMCA9PT0gcmVxdWVzdC5hbGxQZW5kaW5nVGFza3MgJiYgY29tcGxldGVBbGwocmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRUYXNrSW5ERVYgPSByZXF1ZXN0JGpzY29tcCQwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHBpbmdlZFRhc2tzLnNwbGljZSgwLCBpKTtcbiAgICAgICAgICBudWxsICE9PSByZXF1ZXN0JGpzY29tcCQyLmRlc3RpbmF0aW9uICYmXG4gICAgICAgICAgICBmbHVzaENvbXBsZXRlZFF1ZXVlcyhcbiAgICAgICAgICAgICAgcmVxdWVzdCRqc2NvbXAkMixcbiAgICAgICAgICAgICAgcmVxdWVzdCRqc2NvbXAkMi5kZXN0aW5hdGlvblxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAocGluZ2VkVGFza3MgPSB7fSksXG4gICAgICAgICAgICBsb2dSZWNvdmVyYWJsZUVycm9yKHJlcXVlc3QkanNjb21wJDIsIGVycm9yLCBwaW5nZWRUYXNrcywgbnVsbCksXG4gICAgICAgICAgICBmYXRhbEVycm9yKHJlcXVlc3QkanNjb21wJDIsIGVycm9yLCBwaW5nZWRUYXNrcywgbnVsbCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgKGN1cnJlbnRSZXN1bWFibGVTdGF0ZSA9IHByZXZSZXN1bWFibGVTdGF0ZSksXG4gICAgICAgICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyKSxcbiAgICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5BID0gcHJldkFzeW5jRGlzcGF0Y2hlciksXG4gICAgICAgICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuZ2V0Q3VycmVudFN0YWNrID0gcHJldkdldEN1cnJlbnRTdGFja0ltcGwpLFxuICAgICAgICAgICAgcHJldkRpc3BhdGNoZXIgPT09IEhvb2tzRGlzcGF0Y2hlciAmJiBzd2l0Y2hDb250ZXh0KHByZXZDb250ZXh0KSxcbiAgICAgICAgICAgIChjdXJyZW50UmVxdWVzdCA9IHByZXZSZXF1ZXN0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwcmVwYXJlUHJlYW1ibGVGcm9tU3VidHJlZShcbiAgICAgIHJlcXVlc3QsXG4gICAgICBzZWdtZW50LFxuICAgICAgY29sbGVjdGVkUHJlYW1ibGVTZWdtZW50c1xuICAgICkge1xuICAgICAgc2VnbWVudC5wcmVhbWJsZUNoaWxkcmVuLmxlbmd0aCAmJlxuICAgICAgICBjb2xsZWN0ZWRQcmVhbWJsZVNlZ21lbnRzLnB1c2goc2VnbWVudC5wcmVhbWJsZUNoaWxkcmVuKTtcbiAgICAgIGZvciAodmFyIHBlbmRpbmdQcmVhbWJsZXMgPSAhMSwgaSA9IDA7IGkgPCBzZWdtZW50LmNoaWxkcmVuLmxlbmd0aDsgaSsrKVxuICAgICAgICBwZW5kaW5nUHJlYW1ibGVzID1cbiAgICAgICAgICBwcmVwYXJlUHJlYW1ibGVGcm9tU2VnbWVudChcbiAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICBzZWdtZW50LmNoaWxkcmVuW2ldLFxuICAgICAgICAgICAgY29sbGVjdGVkUHJlYW1ibGVTZWdtZW50c1xuICAgICAgICAgICkgfHwgcGVuZGluZ1ByZWFtYmxlcztcbiAgICAgIHJldHVybiBwZW5kaW5nUHJlYW1ibGVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcmVwYXJlUHJlYW1ibGVGcm9tU2VnbWVudChcbiAgICAgIHJlcXVlc3QsXG4gICAgICBzZWdtZW50LFxuICAgICAgY29sbGVjdGVkUHJlYW1ibGVTZWdtZW50c1xuICAgICkge1xuICAgICAgdmFyIGJvdW5kYXJ5ID0gc2VnbWVudC5ib3VuZGFyeTtcbiAgICAgIGlmIChudWxsID09PSBib3VuZGFyeSlcbiAgICAgICAgcmV0dXJuIHByZXBhcmVQcmVhbWJsZUZyb21TdWJ0cmVlKFxuICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgc2VnbWVudCxcbiAgICAgICAgICBjb2xsZWN0ZWRQcmVhbWJsZVNlZ21lbnRzXG4gICAgICAgICk7XG4gICAgICB2YXIgcHJlYW1ibGUgPSBib3VuZGFyeS5jb250ZW50UHJlYW1ibGUsXG4gICAgICAgIGZhbGxiYWNrUHJlYW1ibGUgPSBib3VuZGFyeS5mYWxsYmFja1ByZWFtYmxlO1xuICAgICAgaWYgKG51bGwgPT09IHByZWFtYmxlIHx8IG51bGwgPT09IGZhbGxiYWNrUHJlYW1ibGUpIHJldHVybiAhMTtcbiAgICAgIHN3aXRjaCAoYm91bmRhcnkuc3RhdHVzKSB7XG4gICAgICAgIGNhc2UgQ09NUExFVEVEOlxuICAgICAgICAgIGhvaXN0UHJlYW1ibGVTdGF0ZShyZXF1ZXN0LnJlbmRlclN0YXRlLCBwcmVhbWJsZSk7XG4gICAgICAgICAgcmVxdWVzdC5ieXRlU2l6ZSArPSBib3VuZGFyeS5ieXRlU2l6ZTtcbiAgICAgICAgICBzZWdtZW50ID0gYm91bmRhcnkuY29tcGxldGVkU2VnbWVudHNbMF07XG4gICAgICAgICAgaWYgKCFzZWdtZW50KVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgIFwiQSBwcmV2aW91c2x5IHVudmlzaXRlZCBib3VuZGFyeSBtdXN0IGhhdmUgZXhhY3RseSBvbmUgcm9vdCBzZWdtZW50LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiBwcmVwYXJlUHJlYW1ibGVGcm9tU3VidHJlZShcbiAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICBzZWdtZW50LFxuICAgICAgICAgICAgY29sbGVjdGVkUHJlYW1ibGVTZWdtZW50c1xuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgUE9TVFBPTkVEOlxuICAgICAgICAgIGlmIChudWxsICE9PSByZXF1ZXN0LnRyYWNrZWRQb3N0cG9uZXMpIHJldHVybiAhMDtcbiAgICAgICAgY2FzZSBDTElFTlRfUkVOREVSRUQ6XG4gICAgICAgICAgaWYgKHNlZ21lbnQuc3RhdHVzID09PSBDT01QTEVURUQpXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICBob2lzdFByZWFtYmxlU3RhdGUocmVxdWVzdC5yZW5kZXJTdGF0ZSwgZmFsbGJhY2tQcmVhbWJsZSksXG4gICAgICAgICAgICAgIHByZXBhcmVQcmVhbWJsZUZyb21TdWJ0cmVlKFxuICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgc2VnbWVudCxcbiAgICAgICAgICAgICAgICBjb2xsZWN0ZWRQcmVhbWJsZVNlZ21lbnRzXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwcmVwYXJlUHJlYW1ibGUocmVxdWVzdCkge1xuICAgICAgaWYgKFxuICAgICAgICByZXF1ZXN0LmNvbXBsZXRlZFJvb3RTZWdtZW50ICYmXG4gICAgICAgIG51bGwgPT09IHJlcXVlc3QuY29tcGxldGVkUHJlYW1ibGVTZWdtZW50c1xuICAgICAgKSB7XG4gICAgICAgIHZhciBjb2xsZWN0ZWRQcmVhbWJsZVNlZ21lbnRzID0gW10sXG4gICAgICAgICAgb3JpZ2luYWxSZXF1ZXN0Qnl0ZVNpemUgPSByZXF1ZXN0LmJ5dGVTaXplLFxuICAgICAgICAgIGhhc1BlbmRpbmdQcmVhbWJsZXMgPSBwcmVwYXJlUHJlYW1ibGVGcm9tU2VnbWVudChcbiAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICByZXF1ZXN0LmNvbXBsZXRlZFJvb3RTZWdtZW50LFxuICAgICAgICAgICAgY29sbGVjdGVkUHJlYW1ibGVTZWdtZW50c1xuICAgICAgICAgICksXG4gICAgICAgICAgcHJlYW1ibGUgPSByZXF1ZXN0LnJlbmRlclN0YXRlLnByZWFtYmxlO1xuICAgICAgICAhMSA9PT0gaGFzUGVuZGluZ1ByZWFtYmxlcyB8fFxuICAgICAgICAocHJlYW1ibGUuaGVhZENodW5rcyAmJiBwcmVhbWJsZS5ib2R5Q2h1bmtzKVxuICAgICAgICAgID8gKHJlcXVlc3QuY29tcGxldGVkUHJlYW1ibGVTZWdtZW50cyA9IGNvbGxlY3RlZFByZWFtYmxlU2VnbWVudHMpXG4gICAgICAgICAgOiAocmVxdWVzdC5ieXRlU2l6ZSA9IG9yaWdpbmFsUmVxdWVzdEJ5dGVTaXplKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZmx1c2hTdWJ0cmVlKHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBzZWdtZW50LCBob2lzdGFibGVTdGF0ZSkge1xuICAgICAgc2VnbWVudC5wYXJlbnRGbHVzaGVkID0gITA7XG4gICAgICBzd2l0Y2ggKHNlZ21lbnQuc3RhdHVzKSB7XG4gICAgICAgIGNhc2UgUEVORElORzpcbiAgICAgICAgICBzZWdtZW50LmlkID0gcmVxdWVzdC5uZXh0U2VnbWVudElkKys7XG4gICAgICAgIGNhc2UgUE9TVFBPTkVEOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoaG9pc3RhYmxlU3RhdGUgPSBzZWdtZW50LmlkKSxcbiAgICAgICAgICAgIChzZWdtZW50Lmxhc3RQdXNoZWRUZXh0ID0gITEpLFxuICAgICAgICAgICAgKHNlZ21lbnQudGV4dEVtYmVkZGVkID0gITEpLFxuICAgICAgICAgICAgKHJlcXVlc3QgPSByZXF1ZXN0LnJlbmRlclN0YXRlKSxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2gocGxhY2Vob2xkZXIxKSxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2gocmVxdWVzdC5wbGFjZWhvbGRlclByZWZpeCksXG4gICAgICAgICAgICAocmVxdWVzdCA9IGhvaXN0YWJsZVN0YXRlLnRvU3RyaW5nKDE2KSksXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKHJlcXVlc3QpLFxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChwbGFjZWhvbGRlcjIpXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBDT01QTEVURUQ6XG4gICAgICAgICAgc2VnbWVudC5zdGF0dXMgPSBGTFVTSEVEO1xuICAgICAgICAgIHZhciByID0gITAsXG4gICAgICAgICAgICBjaHVua3MgPSBzZWdtZW50LmNodW5rcyxcbiAgICAgICAgICAgIGNodW5rSWR4ID0gMDtcbiAgICAgICAgICBzZWdtZW50ID0gc2VnbWVudC5jaGlsZHJlbjtcbiAgICAgICAgICBmb3IgKHZhciBjaGlsZElkeCA9IDA7IGNoaWxkSWR4IDwgc2VnbWVudC5sZW5ndGg7IGNoaWxkSWR4KyspIHtcbiAgICAgICAgICAgIGZvciAociA9IHNlZ21lbnRbY2hpbGRJZHhdOyBjaHVua0lkeCA8IHIuaW5kZXg7IGNodW5rSWR4KyspXG4gICAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2goY2h1bmtzW2NodW5rSWR4XSk7XG4gICAgICAgICAgICByID0gZmx1c2hTZWdtZW50KHJlcXVlc3QsIGRlc3RpbmF0aW9uLCByLCBob2lzdGFibGVTdGF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoOyBjaHVua0lkeCA8IGNodW5rcy5sZW5ndGggLSAxOyBjaHVua0lkeCsrKVxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChjaHVua3NbY2h1bmtJZHhdKTtcbiAgICAgICAgICBjaHVua0lkeCA8IGNodW5rcy5sZW5ndGggJiYgKHIgPSBkZXN0aW5hdGlvbi5wdXNoKGNodW5rc1tjaHVua0lkeF0pKTtcbiAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgY2FzZSBBQk9SVEVEOlxuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiQWJvcnRlZCwgZXJyb3JlZCBvciBhbHJlYWR5IGZsdXNoZWQgYm91bmRhcmllcyBzaG91bGQgbm90IGJlIGZsdXNoZWQgYWdhaW4uIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBmbHVzaFNlZ21lbnQocmVxdWVzdCwgZGVzdGluYXRpb24sIHNlZ21lbnQsIGhvaXN0YWJsZVN0YXRlKSB7XG4gICAgICB2YXIgYm91bmRhcnkgPSBzZWdtZW50LmJvdW5kYXJ5O1xuICAgICAgaWYgKG51bGwgPT09IGJvdW5kYXJ5KVxuICAgICAgICByZXR1cm4gZmx1c2hTdWJ0cmVlKHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBzZWdtZW50LCBob2lzdGFibGVTdGF0ZSk7XG4gICAgICBib3VuZGFyeS5wYXJlbnRGbHVzaGVkID0gITA7XG4gICAgICBpZiAoYm91bmRhcnkuc3RhdHVzID09PSBDTElFTlRfUkVOREVSRUQpIHtcbiAgICAgICAgdmFyIHJvdyA9IGJvdW5kYXJ5LnJvdztcbiAgICAgICAgbnVsbCAhPT0gcm93ICYmXG4gICAgICAgICAgMCA9PT0gLS1yb3cucGVuZGluZ1Rhc2tzICYmXG4gICAgICAgICAgZmluaXNoU3VzcGVuc2VMaXN0Um93KHJlcXVlc3QsIHJvdyk7XG4gICAgICAgIGlmICghcmVxdWVzdC5yZW5kZXJTdGF0ZS5nZW5lcmF0ZVN0YXRpY01hcmt1cCkge1xuICAgICAgICAgIHZhciBlcnJvckRpZ2VzdCA9IGJvdW5kYXJ5LmVycm9yRGlnZXN0LFxuICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gYm91bmRhcnkuZXJyb3JNZXNzYWdlO1xuICAgICAgICAgIHJvdyA9IGJvdW5kYXJ5LmVycm9yU3RhY2s7XG4gICAgICAgICAgYm91bmRhcnkgPSBib3VuZGFyeS5lcnJvckNvbXBvbmVudFN0YWNrO1xuICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2goc3RhcnRDbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnkpO1xuICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2goY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxKTtcbiAgICAgICAgICBlcnJvckRpZ2VzdCAmJlxuICAgICAgICAgICAgKGRlc3RpbmF0aW9uLnB1c2goY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxQSksXG4gICAgICAgICAgICAoZXJyb3JEaWdlc3QgPSBlc2NhcGVUZXh0Rm9yQnJvd3NlcihlcnJvckRpZ2VzdCkpLFxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChlcnJvckRpZ2VzdCksXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKFxuICAgICAgICAgICAgICBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvckF0dHJJbnRlcnN0aXRpYWxcbiAgICAgICAgICAgICkpO1xuICAgICAgICAgIGVycm9yTWVzc2FnZSAmJlxuICAgICAgICAgICAgKGRlc3RpbmF0aW9uLnB1c2goY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxQiksXG4gICAgICAgICAgICAoZXJyb3JNZXNzYWdlID0gZXNjYXBlVGV4dEZvckJyb3dzZXIoZXJyb3JNZXNzYWdlKSksXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKGVycm9yTWVzc2FnZSksXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKFxuICAgICAgICAgICAgICBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvckF0dHJJbnRlcnN0aXRpYWxcbiAgICAgICAgICAgICkpO1xuICAgICAgICAgIHJvdyAmJlxuICAgICAgICAgICAgKGRlc3RpbmF0aW9uLnB1c2goY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxQyksXG4gICAgICAgICAgICAocm93ID0gZXNjYXBlVGV4dEZvckJyb3dzZXIocm93KSksXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKHJvdyksXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKFxuICAgICAgICAgICAgICBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvckF0dHJJbnRlcnN0aXRpYWxcbiAgICAgICAgICAgICkpO1xuICAgICAgICAgIGJvdW5kYXJ5ICYmXG4gICAgICAgICAgICAoZGVzdGluYXRpb24ucHVzaChjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjFEKSxcbiAgICAgICAgICAgIChyb3cgPSBlc2NhcGVUZXh0Rm9yQnJvd3Nlcihib3VuZGFyeSkpLFxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChyb3cpLFxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChcbiAgICAgICAgICAgICAgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3JBdHRySW50ZXJzdGl0aWFsXG4gICAgICAgICAgICApKTtcbiAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yMik7XG4gICAgICAgIH1cbiAgICAgICAgZmx1c2hTdWJ0cmVlKHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBzZWdtZW50LCBob2lzdGFibGVTdGF0ZSk7XG4gICAgICAgIHJlcXVlc3QgPSByZXF1ZXN0LnJlbmRlclN0YXRlLmdlbmVyYXRlU3RhdGljTWFya3VwXG4gICAgICAgICAgPyAhMFxuICAgICAgICAgIDogZGVzdGluYXRpb24ucHVzaChlbmRTdXNwZW5zZUJvdW5kYXJ5KTtcbiAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgICB9XG4gICAgICBpZiAoYm91bmRhcnkuc3RhdHVzICE9PSBDT01QTEVURUQpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgYm91bmRhcnkuc3RhdHVzID09PSBQRU5ESU5HICYmXG4gICAgICAgICAgICAoYm91bmRhcnkucm9vdFNlZ21lbnRJRCA9IHJlcXVlc3QubmV4dFNlZ21lbnRJZCsrKSxcbiAgICAgICAgICAwIDwgYm91bmRhcnkuY29tcGxldGVkU2VnbWVudHMubGVuZ3RoICYmXG4gICAgICAgICAgICByZXF1ZXN0LnBhcnRpYWxCb3VuZGFyaWVzLnB1c2goYm91bmRhcnkpLFxuICAgICAgICAgIHdyaXRlU3RhcnRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeShcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICAgICAgcmVxdWVzdC5yZW5kZXJTdGF0ZSxcbiAgICAgICAgICAgIGJvdW5kYXJ5LnJvb3RTZWdtZW50SURcbiAgICAgICAgICApLFxuICAgICAgICAgIGhvaXN0YWJsZVN0YXRlICYmXG4gICAgICAgICAgICBob2lzdEhvaXN0YWJsZXMoaG9pc3RhYmxlU3RhdGUsIGJvdW5kYXJ5LmZhbGxiYWNrU3RhdGUpLFxuICAgICAgICAgIGZsdXNoU3VidHJlZShyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgc2VnbWVudCwgaG9pc3RhYmxlU3RhdGUpLFxuICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2goZW5kU3VzcGVuc2VCb3VuZGFyeSlcbiAgICAgICAgKTtcbiAgICAgIGlmIChcbiAgICAgICAgIWZsdXNoaW5nUGFydGlhbEJvdW5kYXJpZXMgJiZcbiAgICAgICAgaXNFbGlnaWJsZUZvck91dGxpbmluZyhyZXF1ZXN0LCBib3VuZGFyeSkgJiZcbiAgICAgICAgZmx1c2hlZEJ5dGVTaXplICsgYm91bmRhcnkuYnl0ZVNpemUgPiByZXF1ZXN0LnByb2dyZXNzaXZlQ2h1bmtTaXplXG4gICAgICApXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgKGJvdW5kYXJ5LnJvb3RTZWdtZW50SUQgPSByZXF1ZXN0Lm5leHRTZWdtZW50SWQrKyksXG4gICAgICAgICAgcmVxdWVzdC5jb21wbGV0ZWRCb3VuZGFyaWVzLnB1c2goYm91bmRhcnkpLFxuICAgICAgICAgIHdyaXRlU3RhcnRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeShcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICAgICAgcmVxdWVzdC5yZW5kZXJTdGF0ZSxcbiAgICAgICAgICAgIGJvdW5kYXJ5LnJvb3RTZWdtZW50SURcbiAgICAgICAgICApLFxuICAgICAgICAgIGZsdXNoU3VidHJlZShyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgc2VnbWVudCwgaG9pc3RhYmxlU3RhdGUpLFxuICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2goZW5kU3VzcGVuc2VCb3VuZGFyeSlcbiAgICAgICAgKTtcbiAgICAgIGZsdXNoZWRCeXRlU2l6ZSArPSBib3VuZGFyeS5ieXRlU2l6ZTtcbiAgICAgIGhvaXN0YWJsZVN0YXRlICYmIGhvaXN0SG9pc3RhYmxlcyhob2lzdGFibGVTdGF0ZSwgYm91bmRhcnkuY29udGVudFN0YXRlKTtcbiAgICAgIHNlZ21lbnQgPSBib3VuZGFyeS5yb3c7XG4gICAgICBudWxsICE9PSBzZWdtZW50ICYmXG4gICAgICAgIGlzRWxpZ2libGVGb3JPdXRsaW5pbmcocmVxdWVzdCwgYm91bmRhcnkpICYmXG4gICAgICAgIDAgPT09IC0tc2VnbWVudC5wZW5kaW5nVGFza3MgJiZcbiAgICAgICAgZmluaXNoU3VzcGVuc2VMaXN0Um93KHJlcXVlc3QsIHNlZ21lbnQpO1xuICAgICAgcmVxdWVzdC5yZW5kZXJTdGF0ZS5nZW5lcmF0ZVN0YXRpY01hcmt1cCB8fFxuICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKHN0YXJ0Q29tcGxldGVkU3VzcGVuc2VCb3VuZGFyeSk7XG4gICAgICBzZWdtZW50ID0gYm91bmRhcnkuY29tcGxldGVkU2VnbWVudHM7XG4gICAgICBpZiAoMSAhPT0gc2VnbWVudC5sZW5ndGgpXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiQSBwcmV2aW91c2x5IHVudmlzaXRlZCBib3VuZGFyeSBtdXN0IGhhdmUgZXhhY3RseSBvbmUgcm9vdCBzZWdtZW50LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICk7XG4gICAgICBmbHVzaFNlZ21lbnQocmVxdWVzdCwgZGVzdGluYXRpb24sIHNlZ21lbnRbMF0sIGhvaXN0YWJsZVN0YXRlKTtcbiAgICAgIHJlcXVlc3QgPSByZXF1ZXN0LnJlbmRlclN0YXRlLmdlbmVyYXRlU3RhdGljTWFya3VwXG4gICAgICAgID8gITBcbiAgICAgICAgOiBkZXN0aW5hdGlvbi5wdXNoKGVuZFN1c3BlbnNlQm91bmRhcnkpO1xuICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZsdXNoU2VnbWVudENvbnRhaW5lcihcbiAgICAgIHJlcXVlc3QsXG4gICAgICBkZXN0aW5hdGlvbixcbiAgICAgIHNlZ21lbnQsXG4gICAgICBob2lzdGFibGVTdGF0ZVxuICAgICkge1xuICAgICAgd3JpdGVTdGFydFNlZ21lbnQoXG4gICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICByZXF1ZXN0LnJlbmRlclN0YXRlLFxuICAgICAgICBzZWdtZW50LnBhcmVudEZvcm1hdENvbnRleHQsXG4gICAgICAgIHNlZ21lbnQuaWRcbiAgICAgICk7XG4gICAgICBmbHVzaFNlZ21lbnQocmVxdWVzdCwgZGVzdGluYXRpb24sIHNlZ21lbnQsIGhvaXN0YWJsZVN0YXRlKTtcbiAgICAgIHJldHVybiB3cml0ZUVuZFNlZ21lbnQoZGVzdGluYXRpb24sIHNlZ21lbnQucGFyZW50Rm9ybWF0Q29udGV4dCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZsdXNoQ29tcGxldGVkQm91bmRhcnkocmVxdWVzdCwgZGVzdGluYXRpb24sIGJvdW5kYXJ5KSB7XG4gICAgICBmbHVzaGVkQnl0ZVNpemUgPSBib3VuZGFyeS5ieXRlU2l6ZTtcbiAgICAgIGZvciAoXG4gICAgICAgIHZhciBjb21wbGV0ZWRTZWdtZW50cyA9IGJvdW5kYXJ5LmNvbXBsZXRlZFNlZ21lbnRzLCBpID0gMDtcbiAgICAgICAgaSA8IGNvbXBsZXRlZFNlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgaSsrXG4gICAgICApXG4gICAgICAgIGZsdXNoUGFydGlhbGx5Q29tcGxldGVkU2VnbWVudChcbiAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICAgIGJvdW5kYXJ5LFxuICAgICAgICAgIGNvbXBsZXRlZFNlZ21lbnRzW2ldXG4gICAgICAgICk7XG4gICAgICBjb21wbGV0ZWRTZWdtZW50cy5sZW5ndGggPSAwO1xuICAgICAgY29tcGxldGVkU2VnbWVudHMgPSBib3VuZGFyeS5yb3c7XG4gICAgICBudWxsICE9PSBjb21wbGV0ZWRTZWdtZW50cyAmJlxuICAgICAgICBpc0VsaWdpYmxlRm9yT3V0bGluaW5nKHJlcXVlc3QsIGJvdW5kYXJ5KSAmJlxuICAgICAgICAwID09PSAtLWNvbXBsZXRlZFNlZ21lbnRzLnBlbmRpbmdUYXNrcyAmJlxuICAgICAgICBmaW5pc2hTdXNwZW5zZUxpc3RSb3cocmVxdWVzdCwgY29tcGxldGVkU2VnbWVudHMpO1xuICAgICAgd3JpdGVIb2lzdGFibGVzRm9yQm91bmRhcnkoXG4gICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICBib3VuZGFyeS5jb250ZW50U3RhdGUsXG4gICAgICAgIHJlcXVlc3QucmVuZGVyU3RhdGVcbiAgICAgICk7XG4gICAgICBjb21wbGV0ZWRTZWdtZW50cyA9IHJlcXVlc3QucmVzdW1hYmxlU3RhdGU7XG4gICAgICByZXF1ZXN0ID0gcmVxdWVzdC5yZW5kZXJTdGF0ZTtcbiAgICAgIGkgPSBib3VuZGFyeS5yb290U2VnbWVudElEO1xuICAgICAgYm91bmRhcnkgPSBib3VuZGFyeS5jb250ZW50U3RhdGU7XG4gICAgICB2YXIgcmVxdWlyZXNTdHlsZUluc2VydGlvbiA9IHJlcXVlc3Quc3R5bGVzVG9Ib2lzdDtcbiAgICAgIHJlcXVlc3Quc3R5bGVzVG9Ib2lzdCA9ICExO1xuICAgICAgZGVzdGluYXRpb24ucHVzaChyZXF1ZXN0LnN0YXJ0SW5saW5lU2NyaXB0KTtcbiAgICAgIGRlc3RpbmF0aW9uLnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gICAgICByZXF1aXJlc1N0eWxlSW5zZXJ0aW9uXG4gICAgICAgID8gKChjb21wbGV0ZWRTZWdtZW50cy5pbnN0cnVjdGlvbnMgJiBTZW50Q2xpZW50UmVuZGVyRnVuY3Rpb24pID09PVxuICAgICAgICAgICAgTm90aGluZ1NlbnQgJiZcbiAgICAgICAgICAgICgoY29tcGxldGVkU2VnbWVudHMuaW5zdHJ1Y3Rpb25zIHw9IFNlbnRDbGllbnRSZW5kZXJGdW5jdGlvbiksXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKGNsaWVudFJlbmRlclNjcmlwdEZ1bmN0aW9uT25seSkpLFxuICAgICAgICAgIChjb21wbGV0ZWRTZWdtZW50cy5pbnN0cnVjdGlvbnMgJiBTZW50Q29tcGxldGVCb3VuZGFyeUZ1bmN0aW9uKSA9PT1cbiAgICAgICAgICAgIE5vdGhpbmdTZW50ICYmXG4gICAgICAgICAgICAoKGNvbXBsZXRlZFNlZ21lbnRzLmluc3RydWN0aW9ucyB8PSBTZW50Q29tcGxldGVCb3VuZGFyeUZ1bmN0aW9uKSxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2goY29tcGxldGVCb3VuZGFyeVNjcmlwdEZ1bmN0aW9uT25seSkpLFxuICAgICAgICAgIChjb21wbGV0ZWRTZWdtZW50cy5pbnN0cnVjdGlvbnMgJiBTZW50U3R5bGVJbnNlcnRpb25GdW5jdGlvbikgPT09XG4gICAgICAgICAgTm90aGluZ1NlbnRcbiAgICAgICAgICAgID8gKChjb21wbGV0ZWRTZWdtZW50cy5pbnN0cnVjdGlvbnMgfD0gU2VudFN0eWxlSW5zZXJ0aW9uRnVuY3Rpb24pLFxuICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKGNvbXBsZXRlQm91bmRhcnlXaXRoU3R5bGVzU2NyaXB0MUZ1bGxQYXJ0aWFsKSlcbiAgICAgICAgICAgIDogZGVzdGluYXRpb24ucHVzaChjb21wbGV0ZUJvdW5kYXJ5V2l0aFN0eWxlc1NjcmlwdDFQYXJ0aWFsKSlcbiAgICAgICAgOiAoKGNvbXBsZXRlZFNlZ21lbnRzLmluc3RydWN0aW9ucyAmIFNlbnRDb21wbGV0ZUJvdW5kYXJ5RnVuY3Rpb24pID09PVxuICAgICAgICAgICAgTm90aGluZ1NlbnQgJiZcbiAgICAgICAgICAgICgoY29tcGxldGVkU2VnbWVudHMuaW5zdHJ1Y3Rpb25zIHw9IFNlbnRDb21wbGV0ZUJvdW5kYXJ5RnVuY3Rpb24pLFxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0RnVuY3Rpb25Pbmx5KSksXG4gICAgICAgICAgZGVzdGluYXRpb24ucHVzaChjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0MVBhcnRpYWwpKTtcbiAgICAgIGNvbXBsZXRlZFNlZ21lbnRzID0gaS50b1N0cmluZygxNik7XG4gICAgICBkZXN0aW5hdGlvbi5wdXNoKHJlcXVlc3QuYm91bmRhcnlQcmVmaXgpO1xuICAgICAgZGVzdGluYXRpb24ucHVzaChjb21wbGV0ZWRTZWdtZW50cyk7XG4gICAgICBkZXN0aW5hdGlvbi5wdXNoKGNvbXBsZXRlQm91bmRhcnlTY3JpcHQyKTtcbiAgICAgIGRlc3RpbmF0aW9uLnB1c2gocmVxdWVzdC5zZWdtZW50UHJlZml4KTtcbiAgICAgIGRlc3RpbmF0aW9uLnB1c2goY29tcGxldGVkU2VnbWVudHMpO1xuICAgICAgcmVxdWlyZXNTdHlsZUluc2VydGlvblxuICAgICAgICA/IChkZXN0aW5hdGlvbi5wdXNoKGNvbXBsZXRlQm91bmRhcnlTY3JpcHQzYSksXG4gICAgICAgICAgd3JpdGVTdHlsZVJlc291cmNlRGVwZW5kZW5jaWVzSW5KUyhkZXN0aW5hdGlvbiwgYm91bmRhcnkpKVxuICAgICAgICA6IGRlc3RpbmF0aW9uLnB1c2goY29tcGxldGVCb3VuZGFyeVNjcmlwdDNiKTtcbiAgICAgIGJvdW5kYXJ5ID0gZGVzdGluYXRpb24ucHVzaChjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0RW5kKTtcbiAgICAgIHJldHVybiB3cml0ZUJvb3RzdHJhcChkZXN0aW5hdGlvbiwgcmVxdWVzdCkgJiYgYm91bmRhcnk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZsdXNoUGFydGlhbGx5Q29tcGxldGVkU2VnbWVudChcbiAgICAgIHJlcXVlc3QsXG4gICAgICBkZXN0aW5hdGlvbixcbiAgICAgIGJvdW5kYXJ5LFxuICAgICAgc2VnbWVudFxuICAgICkge1xuICAgICAgaWYgKHNlZ21lbnQuc3RhdHVzID09PSBGTFVTSEVEKSByZXR1cm4gITA7XG4gICAgICB2YXIgaG9pc3RhYmxlU3RhdGUgPSBib3VuZGFyeS5jb250ZW50U3RhdGUsXG4gICAgICAgIHNlZ21lbnRJRCA9IHNlZ21lbnQuaWQ7XG4gICAgICBpZiAoLTEgPT09IHNlZ21lbnRJRCkge1xuICAgICAgICBpZiAoLTEgPT09IChzZWdtZW50LmlkID0gYm91bmRhcnkucm9vdFNlZ21lbnRJRCkpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIkEgcm9vdCBzZWdtZW50IElEIG11c3QgaGF2ZSBiZWVuIGFzc2lnbmVkIGJ5IG5vdy4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICk7XG4gICAgICAgIHJldHVybiBmbHVzaFNlZ21lbnRDb250YWluZXIoXG4gICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICBkZXN0aW5hdGlvbixcbiAgICAgICAgICBzZWdtZW50LFxuICAgICAgICAgIGhvaXN0YWJsZVN0YXRlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoc2VnbWVudElEID09PSBib3VuZGFyeS5yb290U2VnbWVudElEKVxuICAgICAgICByZXR1cm4gZmx1c2hTZWdtZW50Q29udGFpbmVyKFxuICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgZGVzdGluYXRpb24sXG4gICAgICAgICAgc2VnbWVudCxcbiAgICAgICAgICBob2lzdGFibGVTdGF0ZVxuICAgICAgICApO1xuICAgICAgZmx1c2hTZWdtZW50Q29udGFpbmVyKHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBzZWdtZW50LCBob2lzdGFibGVTdGF0ZSk7XG4gICAgICBib3VuZGFyeSA9IHJlcXVlc3QucmVzdW1hYmxlU3RhdGU7XG4gICAgICByZXF1ZXN0ID0gcmVxdWVzdC5yZW5kZXJTdGF0ZTtcbiAgICAgIGRlc3RpbmF0aW9uLnB1c2gocmVxdWVzdC5zdGFydElubGluZVNjcmlwdCk7XG4gICAgICBkZXN0aW5hdGlvbi5wdXNoKGVuZE9mU3RhcnRUYWcpO1xuICAgICAgKGJvdW5kYXJ5Lmluc3RydWN0aW9ucyAmIFNlbnRDb21wbGV0ZVNlZ21lbnRGdW5jdGlvbikgPT09IE5vdGhpbmdTZW50XG4gICAgICAgID8gKChib3VuZGFyeS5pbnN0cnVjdGlvbnMgfD0gU2VudENvbXBsZXRlU2VnbWVudEZ1bmN0aW9uKSxcbiAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKGNvbXBsZXRlU2VnbWVudFNjcmlwdDFGdWxsKSlcbiAgICAgICAgOiBkZXN0aW5hdGlvbi5wdXNoKGNvbXBsZXRlU2VnbWVudFNjcmlwdDFQYXJ0aWFsKTtcbiAgICAgIGRlc3RpbmF0aW9uLnB1c2gocmVxdWVzdC5zZWdtZW50UHJlZml4KTtcbiAgICAgIHNlZ21lbnRJRCA9IHNlZ21lbnRJRC50b1N0cmluZygxNik7XG4gICAgICBkZXN0aW5hdGlvbi5wdXNoKHNlZ21lbnRJRCk7XG4gICAgICBkZXN0aW5hdGlvbi5wdXNoKGNvbXBsZXRlU2VnbWVudFNjcmlwdDIpO1xuICAgICAgZGVzdGluYXRpb24ucHVzaChyZXF1ZXN0LnBsYWNlaG9sZGVyUHJlZml4KTtcbiAgICAgIGRlc3RpbmF0aW9uLnB1c2goc2VnbWVudElEKTtcbiAgICAgIGRlc3RpbmF0aW9uID0gZGVzdGluYXRpb24ucHVzaChjb21wbGV0ZVNlZ21lbnRTY3JpcHRFbmQpO1xuICAgICAgcmV0dXJuIGRlc3RpbmF0aW9uO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmbHVzaENvbXBsZXRlZFF1ZXVlcyhyZXF1ZXN0LCBkZXN0aW5hdGlvbikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCEoMCA8IHJlcXVlc3QucGVuZGluZ1Jvb3RUYXNrcykpIHtcbiAgICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGNvbXBsZXRlZFJvb3RTZWdtZW50ID0gcmVxdWVzdC5jb21wbGV0ZWRSb290U2VnbWVudDtcbiAgICAgICAgICBpZiAobnVsbCAhPT0gY29tcGxldGVkUm9vdFNlZ21lbnQpIHtcbiAgICAgICAgICAgIGlmIChjb21wbGV0ZWRSb290U2VnbWVudC5zdGF0dXMgPT09IFBPU1RQT05FRCkgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGNvbXBsZXRlZFByZWFtYmxlU2VnbWVudHMgPSByZXF1ZXN0LmNvbXBsZXRlZFByZWFtYmxlU2VnbWVudHM7XG4gICAgICAgICAgICBpZiAobnVsbCA9PT0gY29tcGxldGVkUHJlYW1ibGVTZWdtZW50cykgcmV0dXJuO1xuICAgICAgICAgICAgZmx1c2hlZEJ5dGVTaXplID0gcmVxdWVzdC5ieXRlU2l6ZTtcbiAgICAgICAgICAgIHZhciByZXN1bWFibGVTdGF0ZSA9IHJlcXVlc3QucmVzdW1hYmxlU3RhdGUsXG4gICAgICAgICAgICAgIHJlbmRlclN0YXRlID0gcmVxdWVzdC5yZW5kZXJTdGF0ZSxcbiAgICAgICAgICAgICAgcHJlYW1ibGUgPSByZW5kZXJTdGF0ZS5wcmVhbWJsZSxcbiAgICAgICAgICAgICAgaHRtbENodW5rcyA9IHByZWFtYmxlLmh0bWxDaHVua3MsXG4gICAgICAgICAgICAgIGhlYWRDaHVua3MgPSBwcmVhbWJsZS5oZWFkQ2h1bmtzLFxuICAgICAgICAgICAgICBpJGpzY29tcCQwO1xuICAgICAgICAgICAgaWYgKGh0bWxDaHVua3MpIHtcbiAgICAgICAgICAgICAgZm9yIChpJGpzY29tcCQwID0gMDsgaSRqc2NvbXAkMCA8IGh0bWxDaHVua3MubGVuZ3RoOyBpJGpzY29tcCQwKyspXG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChodG1sQ2h1bmtzW2kkanNjb21wJDBdKTtcbiAgICAgICAgICAgICAgaWYgKGhlYWRDaHVua3MpXG4gICAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICAgIGkkanNjb21wJDAgPSAwO1xuICAgICAgICAgICAgICAgICAgaSRqc2NvbXAkMCA8IGhlYWRDaHVua3MubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgaSRqc2NvbXAkMCsrXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChoZWFkQ2h1bmtzW2kkanNjb21wJDBdKTtcbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGNodW5rID0gc3RhcnRDaHVua0ZvclRhZyhcImhlYWRcIik7XG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChjaHVuayk7XG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChlbmRPZlN0YXJ0VGFnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChoZWFkQ2h1bmtzKVxuICAgICAgICAgICAgICBmb3IgKGkkanNjb21wJDAgPSAwOyBpJGpzY29tcCQwIDwgaGVhZENodW5rcy5sZW5ndGg7IGkkanNjb21wJDArKylcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKGhlYWRDaHVua3NbaSRqc2NvbXAkMF0pO1xuICAgICAgICAgICAgdmFyIGNoYXJzZXRDaHVua3MgPSByZW5kZXJTdGF0ZS5jaGFyc2V0Q2h1bmtzO1xuICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgaSRqc2NvbXAkMCA9IDA7XG4gICAgICAgICAgICAgIGkkanNjb21wJDAgPCBjaGFyc2V0Q2h1bmtzLmxlbmd0aDtcbiAgICAgICAgICAgICAgaSRqc2NvbXAkMCsrXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2goY2hhcnNldENodW5rc1tpJGpzY29tcCQwXSk7XG4gICAgICAgICAgICBjaGFyc2V0Q2h1bmtzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZS5wcmVjb25uZWN0cy5mb3JFYWNoKGZsdXNoUmVzb3VyY2UsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgIHJlbmRlclN0YXRlLnByZWNvbm5lY3RzLmNsZWFyKCk7XG4gICAgICAgICAgICB2YXIgdmlld3BvcnRDaHVua3MgPSByZW5kZXJTdGF0ZS52aWV3cG9ydENodW5rcztcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgIGkkanNjb21wJDAgPSAwO1xuICAgICAgICAgICAgICBpJGpzY29tcCQwIDwgdmlld3BvcnRDaHVua3MubGVuZ3RoO1xuICAgICAgICAgICAgICBpJGpzY29tcCQwKytcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaCh2aWV3cG9ydENodW5rc1tpJGpzY29tcCQwXSk7XG4gICAgICAgICAgICB2aWV3cG9ydENodW5rcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgcmVuZGVyU3RhdGUuZm9udFByZWxvYWRzLmZvckVhY2goZmx1c2hSZXNvdXJjZSwgZGVzdGluYXRpb24pO1xuICAgICAgICAgICAgcmVuZGVyU3RhdGUuZm9udFByZWxvYWRzLmNsZWFyKCk7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZS5oaWdoSW1hZ2VQcmVsb2Fkcy5mb3JFYWNoKGZsdXNoUmVzb3VyY2UsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgIHJlbmRlclN0YXRlLmhpZ2hJbWFnZVByZWxvYWRzLmNsZWFyKCk7XG4gICAgICAgICAgICBjdXJyZW50bHlGbHVzaGluZ1JlbmRlclN0YXRlID0gcmVuZGVyU3RhdGU7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZS5zdHlsZXMuZm9yRWFjaChmbHVzaFN0eWxlc0luUHJlYW1ibGUsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgIGN1cnJlbnRseUZsdXNoaW5nUmVuZGVyU3RhdGUgPSBudWxsO1xuICAgICAgICAgICAgdmFyIGltcG9ydE1hcENodW5rcyA9IHJlbmRlclN0YXRlLmltcG9ydE1hcENodW5rcztcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgIGkkanNjb21wJDAgPSAwO1xuICAgICAgICAgICAgICBpJGpzY29tcCQwIDwgaW1wb3J0TWFwQ2h1bmtzLmxlbmd0aDtcbiAgICAgICAgICAgICAgaSRqc2NvbXAkMCsrXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2goaW1wb3J0TWFwQ2h1bmtzW2kkanNjb21wJDBdKTtcbiAgICAgICAgICAgIGltcG9ydE1hcENodW5rcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgcmVuZGVyU3RhdGUuYm9vdHN0cmFwU2NyaXB0cy5mb3JFYWNoKGZsdXNoUmVzb3VyY2UsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgIHJlbmRlclN0YXRlLnNjcmlwdHMuZm9yRWFjaChmbHVzaFJlc291cmNlLCBkZXN0aW5hdGlvbik7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZS5zY3JpcHRzLmNsZWFyKCk7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZS5idWxrUHJlbG9hZHMuZm9yRWFjaChmbHVzaFJlc291cmNlLCBkZXN0aW5hdGlvbik7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZS5idWxrUHJlbG9hZHMuY2xlYXIoKTtcbiAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLmluc3RydWN0aW9ucyB8PSBTZW50Q29tcGxldGVkU2hlbGxJZDtcbiAgICAgICAgICAgIHZhciBob2lzdGFibGVDaHVua3MgPSByZW5kZXJTdGF0ZS5ob2lzdGFibGVDaHVua3M7XG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICBpJGpzY29tcCQwID0gMDtcbiAgICAgICAgICAgICAgaSRqc2NvbXAkMCA8IGhvaXN0YWJsZUNodW5rcy5sZW5ndGg7XG4gICAgICAgICAgICAgIGkkanNjb21wJDArK1xuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKGhvaXN0YWJsZUNodW5rc1tpJGpzY29tcCQwXSk7XG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZSA9IGhvaXN0YWJsZUNodW5rcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZSA8IGNvbXBsZXRlZFByZWFtYmxlU2VnbWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZSsrXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgdmFyIHNlZ21lbnRzID0gY29tcGxldGVkUHJlYW1ibGVTZWdtZW50c1tyZXN1bWFibGVTdGF0ZV07XG4gICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUgPSAwO1xuICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlIDwgc2VnbWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlKytcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIGZsdXNoU2VnbWVudChyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgc2VnbWVudHNbcmVuZGVyU3RhdGVdLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwcmVhbWJsZSRqc2NvbXAkMCA9IHJlcXVlc3QucmVuZGVyU3RhdGUucHJlYW1ibGUsXG4gICAgICAgICAgICAgIGhlYWRDaHVua3MkanNjb21wJDAgPSBwcmVhbWJsZSRqc2NvbXAkMC5oZWFkQ2h1bmtzO1xuICAgICAgICAgICAgaWYgKHByZWFtYmxlJGpzY29tcCQwLmh0bWxDaHVua3MgfHwgaGVhZENodW5rcyRqc2NvbXAkMCkge1xuICAgICAgICAgICAgICB2YXIgY2h1bmskanNjb21wJDAgPSBlbmRDaHVua0ZvclRhZyhcImhlYWRcIik7XG4gICAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2goY2h1bmskanNjb21wJDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGJvZHlDaHVua3MgPSBwcmVhbWJsZSRqc2NvbXAkMC5ib2R5Q2h1bmtzO1xuICAgICAgICAgICAgaWYgKGJvZHlDaHVua3MpXG4gICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgY29tcGxldGVkUHJlYW1ibGVTZWdtZW50cyA9IDA7XG4gICAgICAgICAgICAgICAgY29tcGxldGVkUHJlYW1ibGVTZWdtZW50cyA8IGJvZHlDaHVua3MubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlZFByZWFtYmxlU2VnbWVudHMrK1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChib2R5Q2h1bmtzW2NvbXBsZXRlZFByZWFtYmxlU2VnbWVudHNdKTtcbiAgICAgICAgICAgIGZsdXNoU2VnbWVudChyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgY29tcGxldGVkUm9vdFNlZ21lbnQsIG51bGwpO1xuICAgICAgICAgICAgcmVxdWVzdC5jb21wbGV0ZWRSb290U2VnbWVudCA9IG51bGw7XG4gICAgICAgICAgICB2YXIgcmVuZGVyU3RhdGUkanNjb21wJDAgPSByZXF1ZXN0LnJlbmRlclN0YXRlO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAwICE9PSByZXF1ZXN0LmFsbFBlbmRpbmdUYXNrcyB8fFxuICAgICAgICAgICAgICAwICE9PSByZXF1ZXN0LmNsaWVudFJlbmRlcmVkQm91bmRhcmllcy5sZW5ndGggfHxcbiAgICAgICAgICAgICAgMCAhPT0gcmVxdWVzdC5jb21wbGV0ZWRCb3VuZGFyaWVzLmxlbmd0aCB8fFxuICAgICAgICAgICAgICAobnVsbCAhPT0gcmVxdWVzdC50cmFja2VkUG9zdHBvbmVzICYmXG4gICAgICAgICAgICAgICAgKDAgIT09IHJlcXVlc3QudHJhY2tlZFBvc3Rwb25lcy5yb290Tm9kZXMubGVuZ3RoIHx8XG4gICAgICAgICAgICAgICAgICBudWxsICE9PSByZXF1ZXN0LnRyYWNrZWRQb3N0cG9uZXMucm9vdFNsb3RzKSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICB2YXIgcmVzdW1hYmxlU3RhdGUkanNjb21wJDAgPSByZXF1ZXN0LnJlc3VtYWJsZVN0YXRlO1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKHJlc3VtYWJsZVN0YXRlJGpzY29tcCQwLmluc3RydWN0aW9ucyAmIFNlbnRNYXJrU2hlbGxUaW1lKSA9PT1cbiAgICAgICAgICAgICAgICBOb3RoaW5nU2VudFxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZSRqc2NvbXAkMC5pbnN0cnVjdGlvbnMgfD0gU2VudE1hcmtTaGVsbFRpbWU7XG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChyZW5kZXJTdGF0ZSRqc2NvbXAkMC5zdGFydElubGluZVNjcmlwdCk7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgKHJlc3VtYWJsZVN0YXRlJGpzY29tcCQwLmluc3RydWN0aW9ucyAmXG4gICAgICAgICAgICAgICAgICAgIFNlbnRDb21wbGV0ZWRTaGVsbElkKSA9PT1cbiAgICAgICAgICAgICAgICAgIE5vdGhpbmdTZW50XG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZSRqc2NvbXAkMC5pbnN0cnVjdGlvbnMgfD0gU2VudENvbXBsZXRlZFNoZWxsSWQ7XG4gICAgICAgICAgICAgICAgICB2YXIgc2hlbGxJZCA9IFwiX1wiICsgcmVzdW1hYmxlU3RhdGUkanNjb21wJDAuaWRQcmVmaXggKyBcIlJfXCI7XG4gICAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKGNvbXBsZXRlZFNoZWxsSWRBdHRyaWJ1dGVTdGFydCk7XG4gICAgICAgICAgICAgICAgICB2YXIgY2h1bmskanNjb21wJDEgPSBlc2NhcGVUZXh0Rm9yQnJvd3NlcihzaGVsbElkKTtcbiAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2goY2h1bmskanNjb21wJDEpO1xuICAgICAgICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChhdHRyaWJ1dGVFbmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKGVuZE9mU3RhcnRUYWcpO1xuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2goc2hlbGxUaW1lUnVudGltZVNjcmlwdCk7XG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChlbmRJbmxpbmVTY3JpcHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3cml0ZUJvb3RzdHJhcChkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUkanNjb21wJDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcmVuZGVyU3RhdGUkanNjb21wJDEgPSByZXF1ZXN0LnJlbmRlclN0YXRlO1xuICAgICAgICAgIGNvbXBsZXRlZFJvb3RTZWdtZW50ID0gMDtcbiAgICAgICAgICB2YXIgdmlld3BvcnRDaHVua3MkanNjb21wJDAgPSByZW5kZXJTdGF0ZSRqc2NvbXAkMS52aWV3cG9ydENodW5rcztcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgY29tcGxldGVkUm9vdFNlZ21lbnQgPSAwO1xuICAgICAgICAgICAgY29tcGxldGVkUm9vdFNlZ21lbnQgPCB2aWV3cG9ydENodW5rcyRqc2NvbXAkMC5sZW5ndGg7XG4gICAgICAgICAgICBjb21wbGV0ZWRSb290U2VnbWVudCsrXG4gICAgICAgICAgKVxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaCh2aWV3cG9ydENodW5rcyRqc2NvbXAkMFtjb21wbGV0ZWRSb290U2VnbWVudF0pO1xuICAgICAgICAgIHZpZXdwb3J0Q2h1bmtzJGpzY29tcCQwLmxlbmd0aCA9IDA7XG4gICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDEucHJlY29ubmVjdHMuZm9yRWFjaChmbHVzaFJlc291cmNlLCBkZXN0aW5hdGlvbik7XG4gICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDEucHJlY29ubmVjdHMuY2xlYXIoKTtcbiAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMS5mb250UHJlbG9hZHMuZm9yRWFjaChmbHVzaFJlc291cmNlLCBkZXN0aW5hdGlvbik7XG4gICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDEuZm9udFByZWxvYWRzLmNsZWFyKCk7XG4gICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDEuaGlnaEltYWdlUHJlbG9hZHMuZm9yRWFjaChcbiAgICAgICAgICAgIGZsdXNoUmVzb3VyY2UsXG4gICAgICAgICAgICBkZXN0aW5hdGlvblxuICAgICAgICAgICk7XG4gICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDEuaGlnaEltYWdlUHJlbG9hZHMuY2xlYXIoKTtcbiAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMS5zdHlsZXMuZm9yRWFjaChwcmVsb2FkTGF0ZVN0eWxlcywgZGVzdGluYXRpb24pO1xuICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQxLnNjcmlwdHMuZm9yRWFjaChmbHVzaFJlc291cmNlLCBkZXN0aW5hdGlvbik7XG4gICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDEuc2NyaXB0cy5jbGVhcigpO1xuICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQxLmJ1bGtQcmVsb2Fkcy5mb3JFYWNoKGZsdXNoUmVzb3VyY2UsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMS5idWxrUHJlbG9hZHMuY2xlYXIoKTtcbiAgICAgICAgICB2YXIgaG9pc3RhYmxlQ2h1bmtzJGpzY29tcCQwID0gcmVuZGVyU3RhdGUkanNjb21wJDEuaG9pc3RhYmxlQ2h1bmtzO1xuICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICBjb21wbGV0ZWRSb290U2VnbWVudCA9IDA7XG4gICAgICAgICAgICBjb21wbGV0ZWRSb290U2VnbWVudCA8IGhvaXN0YWJsZUNodW5rcyRqc2NvbXAkMC5sZW5ndGg7XG4gICAgICAgICAgICBjb21wbGV0ZWRSb290U2VnbWVudCsrXG4gICAgICAgICAgKVxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChob2lzdGFibGVDaHVua3MkanNjb21wJDBbY29tcGxldGVkUm9vdFNlZ21lbnRdKTtcbiAgICAgICAgICBob2lzdGFibGVDaHVua3MkanNjb21wJDAubGVuZ3RoID0gMDtcbiAgICAgICAgICB2YXIgY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzID0gcmVxdWVzdC5jbGllbnRSZW5kZXJlZEJvdW5kYXJpZXM7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNsaWVudFJlbmRlcmVkQm91bmRhcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGJvdW5kYXJ5ID0gY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzW2ldO1xuICAgICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDEgPSBkZXN0aW5hdGlvbjtcbiAgICAgICAgICAgIHZhciByZXN1bWFibGVTdGF0ZSRqc2NvbXAkMSA9IHJlcXVlc3QucmVzdW1hYmxlU3RhdGUsXG4gICAgICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQyID0gcmVxdWVzdC5yZW5kZXJTdGF0ZSxcbiAgICAgICAgICAgICAgaWQgPSBib3VuZGFyeS5yb290U2VnbWVudElELFxuICAgICAgICAgICAgICBlcnJvckRpZ2VzdCA9IGJvdW5kYXJ5LmVycm9yRGlnZXN0LFxuICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBib3VuZGFyeS5lcnJvck1lc3NhZ2UsXG4gICAgICAgICAgICAgIGVycm9yU3RhY2sgPSBib3VuZGFyeS5lcnJvclN0YWNrLFxuICAgICAgICAgICAgICBlcnJvckNvbXBvbmVudFN0YWNrID0gYm91bmRhcnkuZXJyb3JDb21wb25lbnRTdGFjaztcbiAgICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQxLnB1c2gocmVuZGVyU3RhdGUkanNjb21wJDIuc3RhcnRJbmxpbmVTY3JpcHQpO1xuICAgICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDEucHVzaChlbmRPZlN0YXJ0VGFnKTtcbiAgICAgICAgICAgIChyZXN1bWFibGVTdGF0ZSRqc2NvbXAkMS5pbnN0cnVjdGlvbnMgJlxuICAgICAgICAgICAgICBTZW50Q2xpZW50UmVuZGVyRnVuY3Rpb24pID09PVxuICAgICAgICAgICAgTm90aGluZ1NlbnRcbiAgICAgICAgICAgICAgPyAoKHJlc3VtYWJsZVN0YXRlJGpzY29tcCQxLmluc3RydWN0aW9ucyB8PVxuICAgICAgICAgICAgICAgICAgU2VudENsaWVudFJlbmRlckZ1bmN0aW9uKSxcbiAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMS5wdXNoKGNsaWVudFJlbmRlclNjcmlwdDFGdWxsKSlcbiAgICAgICAgICAgICAgOiByZW5kZXJTdGF0ZSRqc2NvbXAkMS5wdXNoKGNsaWVudFJlbmRlclNjcmlwdDFQYXJ0aWFsKTtcbiAgICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQxLnB1c2gocmVuZGVyU3RhdGUkanNjb21wJDIuYm91bmRhcnlQcmVmaXgpO1xuICAgICAgICAgICAgdmFyIGNodW5rJGpzY29tcCQyID0gaWQudG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDEucHVzaChjaHVuayRqc2NvbXAkMik7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMS5wdXNoKGNsaWVudFJlbmRlclNjcmlwdDFBKTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgZXJyb3JEaWdlc3QgfHxcbiAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlIHx8XG4gICAgICAgICAgICAgIGVycm9yU3RhY2sgfHxcbiAgICAgICAgICAgICAgZXJyb3JDb21wb25lbnRTdGFja1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQxLnB1c2goY2xpZW50UmVuZGVyRXJyb3JTY3JpcHRBcmdJbnRlcnN0aXRpYWwpO1xuICAgICAgICAgICAgICB2YXIgY2h1bmskanNjb21wJDMgPSBlc2NhcGVKU1N0cmluZ3NGb3JJbnN0cnVjdGlvblNjcmlwdHMoXG4gICAgICAgICAgICAgICAgZXJyb3JEaWdlc3QgfHwgXCJcIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMS5wdXNoKGNodW5rJGpzY29tcCQzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlcnJvck1lc3NhZ2UgfHwgZXJyb3JTdGFjayB8fCBlcnJvckNvbXBvbmVudFN0YWNrKSB7XG4gICAgICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQxLnB1c2goY2xpZW50UmVuZGVyRXJyb3JTY3JpcHRBcmdJbnRlcnN0aXRpYWwpO1xuICAgICAgICAgICAgICB2YXIgY2h1bmskanNjb21wJDQgPSBlc2NhcGVKU1N0cmluZ3NGb3JJbnN0cnVjdGlvblNjcmlwdHMoXG4gICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlIHx8IFwiXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDEucHVzaChjaHVuayRqc2NvbXAkNCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJyb3JTdGFjayB8fCBlcnJvckNvbXBvbmVudFN0YWNrKSB7XG4gICAgICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQxLnB1c2goY2xpZW50UmVuZGVyRXJyb3JTY3JpcHRBcmdJbnRlcnN0aXRpYWwpO1xuICAgICAgICAgICAgICB2YXIgY2h1bmskanNjb21wJDUgPSBlc2NhcGVKU1N0cmluZ3NGb3JJbnN0cnVjdGlvblNjcmlwdHMoXG4gICAgICAgICAgICAgICAgZXJyb3JTdGFjayB8fCBcIlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQxLnB1c2goY2h1bmskanNjb21wJDUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVycm9yQ29tcG9uZW50U3RhY2spIHtcbiAgICAgICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDEucHVzaChjbGllbnRSZW5kZXJFcnJvclNjcmlwdEFyZ0ludGVyc3RpdGlhbCk7XG4gICAgICAgICAgICAgIHZhciBjaHVuayRqc2NvbXAkNiA9XG4gICAgICAgICAgICAgICAgZXNjYXBlSlNTdHJpbmdzRm9ySW5zdHJ1Y3Rpb25TY3JpcHRzKGVycm9yQ29tcG9uZW50U3RhY2spO1xuICAgICAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMS5wdXNoKGNodW5rJGpzY29tcCQ2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSByZW5kZXJTdGF0ZSRqc2NvbXAkMS5wdXNoKFxuICAgICAgICAgICAgICBjbGllbnRSZW5kZXJTY3JpcHRFbmRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoIUpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCkge1xuICAgICAgICAgICAgICByZXF1ZXN0LmRlc3RpbmF0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICBjbGllbnRSZW5kZXJlZEJvdW5kYXJpZXMuc3BsaWNlKDAsIGkpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNsaWVudFJlbmRlcmVkQm91bmRhcmllcy5zcGxpY2UoMCwgaSk7XG4gICAgICAgICAgdmFyIGNvbXBsZXRlZEJvdW5kYXJpZXMgPSByZXF1ZXN0LmNvbXBsZXRlZEJvdW5kYXJpZXM7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbXBsZXRlZEJvdW5kYXJpZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICFmbHVzaENvbXBsZXRlZEJvdW5kYXJ5KFxuICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb24sXG4gICAgICAgICAgICAgICAgY29tcGxldGVkQm91bmRhcmllc1tpXVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgcmVxdWVzdC5kZXN0aW5hdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgY29tcGxldGVkQm91bmRhcmllcy5zcGxpY2UoMCwgaSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjb21wbGV0ZWRCb3VuZGFyaWVzLnNwbGljZSgwLCBpKTtcbiAgICAgICAgICBmbHVzaGluZ1BhcnRpYWxCb3VuZGFyaWVzID0gITA7XG4gICAgICAgICAgdmFyIHBhcnRpYWxCb3VuZGFyaWVzID0gcmVxdWVzdC5wYXJ0aWFsQm91bmRhcmllcztcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFydGlhbEJvdW5kYXJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgICAgY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzID0gcmVxdWVzdDtcbiAgICAgICAgICAgICAgYm91bmRhcnkgPSBkZXN0aW5hdGlvbjtcbiAgICAgICAgICAgICAgdmFyIGJvdW5kYXJ5JGpzY29tcCQwID0gcGFydGlhbEJvdW5kYXJpZXNbaV07XG4gICAgICAgICAgICAgIGZsdXNoZWRCeXRlU2l6ZSA9IGJvdW5kYXJ5JGpzY29tcCQwLmJ5dGVTaXplO1xuICAgICAgICAgICAgICB2YXIgY29tcGxldGVkU2VnbWVudHMgPSBib3VuZGFyeSRqc2NvbXAkMC5jb21wbGV0ZWRTZWdtZW50cztcbiAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAwO1xuICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA8IGNvbXBsZXRlZFNlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQrK1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgIWZsdXNoUGFydGlhbGx5Q29tcGxldGVkU2VnbWVudChcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzLFxuICAgICAgICAgICAgICAgICAgICBib3VuZGFyeSxcbiAgICAgICAgICAgICAgICAgICAgYm91bmRhcnkkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlZFNlZ21lbnRzW0pTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdF1cbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCsrO1xuICAgICAgICAgICAgICAgICAgY29tcGxldGVkU2VnbWVudHMuc3BsaWNlKDAsIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCk7XG4gICAgICAgICAgICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwID0gITE7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29tcGxldGVkU2VnbWVudHMuc3BsaWNlKDAsIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCk7XG4gICAgICAgICAgICAgIHZhciByb3cgPSBib3VuZGFyeSRqc2NvbXAkMC5yb3c7XG4gICAgICAgICAgICAgIG51bGwgIT09IHJvdyAmJlxuICAgICAgICAgICAgICAgIHJvdy50b2dldGhlciAmJlxuICAgICAgICAgICAgICAgIDEgPT09IGJvdW5kYXJ5JGpzY29tcCQwLnBlbmRpbmdUYXNrcyAmJlxuICAgICAgICAgICAgICAgICgxID09PSByb3cucGVuZGluZ1Rhc2tzXG4gICAgICAgICAgICAgICAgICA/IHVuYmxvY2tTdXNwZW5zZUxpc3RSb3coXG4gICAgICAgICAgICAgICAgICAgICAgY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzLFxuICAgICAgICAgICAgICAgICAgICAgIHJvdyxcbiAgICAgICAgICAgICAgICAgICAgICByb3cuaG9pc3RhYmxlc1xuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICA6IHJvdy5wZW5kaW5nVGFza3MtLSk7XG4gICAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMCA9IHdyaXRlSG9pc3RhYmxlc0ZvckJvdW5kYXJ5KFxuICAgICAgICAgICAgICAgIGJvdW5kYXJ5LFxuICAgICAgICAgICAgICAgIGJvdW5kYXJ5JGpzY29tcCQwLmNvbnRlbnRTdGF0ZSxcbiAgICAgICAgICAgICAgICBjbGllbnRSZW5kZXJlZEJvdW5kYXJpZXMucmVuZGVyU3RhdGVcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwKSB7XG4gICAgICAgICAgICAgIHJlcXVlc3QuZGVzdGluYXRpb24gPSBudWxsO1xuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgIHBhcnRpYWxCb3VuZGFyaWVzLnNwbGljZSgwLCBpKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJ0aWFsQm91bmRhcmllcy5zcGxpY2UoMCwgaSk7XG4gICAgICAgICAgZmx1c2hpbmdQYXJ0aWFsQm91bmRhcmllcyA9ICExO1xuICAgICAgICAgIHZhciBsYXJnZUJvdW5kYXJpZXMgPSByZXF1ZXN0LmNvbXBsZXRlZEJvdW5kYXJpZXM7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxhcmdlQm91bmRhcmllcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgIWZsdXNoQ29tcGxldGVkQm91bmRhcnkocmVxdWVzdCwgZGVzdGluYXRpb24sIGxhcmdlQm91bmRhcmllc1tpXSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICByZXF1ZXN0LmRlc3RpbmF0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICBsYXJnZUJvdW5kYXJpZXMuc3BsaWNlKDAsIGkpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgbGFyZ2VCb3VuZGFyaWVzLnNwbGljZSgwLCBpKTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgKGZsdXNoaW5nUGFydGlhbEJvdW5kYXJpZXMgPSAhMSksXG4gICAgICAgICAgMCA9PT0gcmVxdWVzdC5hbGxQZW5kaW5nVGFza3MgJiZcbiAgICAgICAgICAgIDAgPT09IHJlcXVlc3QuY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzLmxlbmd0aCAmJlxuICAgICAgICAgICAgMCA9PT0gcmVxdWVzdC5jb21wbGV0ZWRCb3VuZGFyaWVzLmxlbmd0aCAmJlxuICAgICAgICAgICAgKChyZXF1ZXN0LmZsdXNoU2NoZWR1bGVkID0gITEpLFxuICAgICAgICAgICAgKGkgPSByZXF1ZXN0LnJlc3VtYWJsZVN0YXRlKSxcbiAgICAgICAgICAgIGkuaGFzQm9keSAmJlxuICAgICAgICAgICAgICAoKHBhcnRpYWxCb3VuZGFyaWVzID0gZW5kQ2h1bmtGb3JUYWcoXCJib2R5XCIpKSxcbiAgICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChwYXJ0aWFsQm91bmRhcmllcykpLFxuICAgICAgICAgICAgaS5oYXNIdG1sICYmICgoaSA9IGVuZENodW5rRm9yVGFnKFwiaHRtbFwiKSksIGRlc3RpbmF0aW9uLnB1c2goaSkpLFxuICAgICAgICAgICAgMCAhPT0gcmVxdWVzdC5hYm9ydGFibGVUYXNrcy5zaXplICYmXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJUaGVyZSB3YXMgc3RpbGwgYWJvcnRhYmxlIHRhc2sgYXQgdGhlIHJvb3Qgd2hlbiB3ZSBjbG9zZWQuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIChyZXF1ZXN0LnN0YXR1cyA9IENMT1NFRCksXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKG51bGwpLFxuICAgICAgICAgICAgKHJlcXVlc3QuZGVzdGluYXRpb24gPSBudWxsKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0YXJ0V29yayhyZXF1ZXN0KSB7XG4gICAgICByZXF1ZXN0LmZsdXNoU2NoZWR1bGVkID0gbnVsbCAhPT0gcmVxdWVzdC5kZXN0aW5hdGlvbjtcbiAgICAgIHBlcmZvcm1Xb3JrKHJlcXVlc3QpO1xuICAgICAgMTAgPT09IHJlcXVlc3Quc3RhdHVzICYmIChyZXF1ZXN0LnN0YXR1cyA9IDExKTtcbiAgICAgIG51bGwgPT09IHJlcXVlc3QudHJhY2tlZFBvc3Rwb25lcyAmJlxuICAgICAgICBzYWZlbHlFbWl0RWFybHlQcmVsb2FkcyhyZXF1ZXN0LCAwID09PSByZXF1ZXN0LnBlbmRpbmdSb290VGFza3MpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbnF1ZXVlRmx1c2gocmVxdWVzdCkge1xuICAgICAgaWYgKFxuICAgICAgICAhMSA9PT0gcmVxdWVzdC5mbHVzaFNjaGVkdWxlZCAmJlxuICAgICAgICAwID09PSByZXF1ZXN0LnBpbmdlZFRhc2tzLmxlbmd0aCAmJlxuICAgICAgICBudWxsICE9PSByZXF1ZXN0LmRlc3RpbmF0aW9uXG4gICAgICApIHtcbiAgICAgICAgcmVxdWVzdC5mbHVzaFNjaGVkdWxlZCA9ICEwO1xuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSByZXF1ZXN0LmRlc3RpbmF0aW9uO1xuICAgICAgICBkZXN0aW5hdGlvblxuICAgICAgICAgID8gZmx1c2hDb21wbGV0ZWRRdWV1ZXMocmVxdWVzdCwgZGVzdGluYXRpb24pXG4gICAgICAgICAgOiAocmVxdWVzdC5mbHVzaFNjaGVkdWxlZCA9ICExKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc3RhcnRGbG93aW5nKHJlcXVlc3QsIGRlc3RpbmF0aW9uKSB7XG4gICAgICBpZiAoMTMgPT09IHJlcXVlc3Quc3RhdHVzKVxuICAgICAgICAocmVxdWVzdC5zdGF0dXMgPSBDTE9TRUQpLCBkZXN0aW5hdGlvbi5kZXN0cm95KHJlcXVlc3QuZmF0YWxFcnJvcik7XG4gICAgICBlbHNlIGlmIChyZXF1ZXN0LnN0YXR1cyAhPT0gQ0xPU0VEICYmIG51bGwgPT09IHJlcXVlc3QuZGVzdGluYXRpb24pIHtcbiAgICAgICAgcmVxdWVzdC5kZXN0aW5hdGlvbiA9IGRlc3RpbmF0aW9uO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZsdXNoQ29tcGxldGVkUXVldWVzKHJlcXVlc3QsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAoZGVzdGluYXRpb24gPSB7fSksXG4gICAgICAgICAgICBsb2dSZWNvdmVyYWJsZUVycm9yKHJlcXVlc3QsIGVycm9yLCBkZXN0aW5hdGlvbiwgbnVsbCksXG4gICAgICAgICAgICBmYXRhbEVycm9yKHJlcXVlc3QsIGVycm9yLCBkZXN0aW5hdGlvbiwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYWJvcnQocmVxdWVzdCwgcmVhc29uKSB7XG4gICAgICBpZiAoMTEgPT09IHJlcXVlc3Quc3RhdHVzIHx8IDEwID09PSByZXF1ZXN0LnN0YXR1cykgcmVxdWVzdC5zdGF0dXMgPSAxMjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBhYm9ydGFibGVUYXNrcyA9IHJlcXVlc3QuYWJvcnRhYmxlVGFza3M7XG4gICAgICAgIGlmICgwIDwgYWJvcnRhYmxlVGFza3Muc2l6ZSkge1xuICAgICAgICAgIHZhciBlcnJvciA9XG4gICAgICAgICAgICB2b2lkIDAgPT09IHJlYXNvblxuICAgICAgICAgICAgICA/IEVycm9yKFwiVGhlIHJlbmRlciB3YXMgYWJvcnRlZCBieSB0aGUgc2VydmVyIHdpdGhvdXQgYSByZWFzb24uXCIpXG4gICAgICAgICAgICAgIDogXCJvYmplY3RcIiA9PT0gdHlwZW9mIHJlYXNvbiAmJlxuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gcmVhc29uICYmXG4gICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiByZWFzb24udGhlblxuICAgICAgICAgICAgICAgID8gRXJyb3IoXCJUaGUgcmVuZGVyIHdhcyBhYm9ydGVkIGJ5IHRoZSBzZXJ2ZXIgd2l0aCBhIHByb21pc2UuXCIpXG4gICAgICAgICAgICAgICAgOiByZWFzb247XG4gICAgICAgICAgcmVxdWVzdC5mYXRhbEVycm9yID0gZXJyb3I7XG4gICAgICAgICAgYWJvcnRhYmxlVGFza3MuZm9yRWFjaChmdW5jdGlvbiAodGFzaykge1xuICAgICAgICAgICAgdmFyIHByZXZUYXNrSW5ERVYgPSBjdXJyZW50VGFza0luREVWLFxuICAgICAgICAgICAgICBwcmV2R2V0Q3VycmVudFN0YWNrSW1wbCA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjaztcbiAgICAgICAgICAgIGN1cnJlbnRUYXNrSW5ERVYgPSB0YXNrO1xuICAgICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuZ2V0Q3VycmVudFN0YWNrID0gZ2V0Q3VycmVudFN0YWNrSW5ERVY7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBhYm9ydFRhc2sodGFzaywgcmVxdWVzdCwgZXJyb3IpO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgKGN1cnJlbnRUYXNrSW5ERVYgPSBwcmV2VGFza0luREVWKSxcbiAgICAgICAgICAgICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuZ2V0Q3VycmVudFN0YWNrID1cbiAgICAgICAgICAgICAgICAgIHByZXZHZXRDdXJyZW50U3RhY2tJbXBsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBhYm9ydGFibGVUYXNrcy5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIG51bGwgIT09IHJlcXVlc3QuZGVzdGluYXRpb24gJiZcbiAgICAgICAgICBmbHVzaENvbXBsZXRlZFF1ZXVlcyhyZXF1ZXN0LCByZXF1ZXN0LmRlc3RpbmF0aW9uKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yJDQpIHtcbiAgICAgICAgKHJlYXNvbiA9IHt9KSxcbiAgICAgICAgICBsb2dSZWNvdmVyYWJsZUVycm9yKHJlcXVlc3QsIGVycm9yJDQsIHJlYXNvbiwgbnVsbCksXG4gICAgICAgICAgZmF0YWxFcnJvcihyZXF1ZXN0LCBlcnJvciQ0LCByZWFzb24sIG51bGwpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBhZGRUb1JlcGxheVBhcmVudChub2RlLCBwYXJlbnRLZXlQYXRoLCB0cmFja2VkUG9zdHBvbmVzKSB7XG4gICAgICBpZiAobnVsbCA9PT0gcGFyZW50S2V5UGF0aCkgdHJhY2tlZFBvc3Rwb25lcy5yb290Tm9kZXMucHVzaChub2RlKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgd29ya2luZ01hcCA9IHRyYWNrZWRQb3N0cG9uZXMud29ya2luZ01hcCxcbiAgICAgICAgICBwYXJlbnROb2RlID0gd29ya2luZ01hcC5nZXQocGFyZW50S2V5UGF0aCk7XG4gICAgICAgIHZvaWQgMCA9PT0gcGFyZW50Tm9kZSAmJlxuICAgICAgICAgICgocGFyZW50Tm9kZSA9IFtwYXJlbnRLZXlQYXRoWzFdLCBwYXJlbnRLZXlQYXRoWzJdLCBbXSwgbnVsbF0pLFxuICAgICAgICAgIHdvcmtpbmdNYXAuc2V0KHBhcmVudEtleVBhdGgsIHBhcmVudE5vZGUpLFxuICAgICAgICAgIGFkZFRvUmVwbGF5UGFyZW50KHBhcmVudE5vZGUsIHBhcmVudEtleVBhdGhbMF0sIHRyYWNrZWRQb3N0cG9uZXMpKTtcbiAgICAgICAgcGFyZW50Tm9kZVsyXS5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBvbkVycm9yKCkge31cbiAgICBmdW5jdGlvbiByZW5kZXJUb1N0cmluZ0ltcGwoXG4gICAgICBjaGlsZHJlbixcbiAgICAgIG9wdGlvbnMsXG4gICAgICBnZW5lcmF0ZVN0YXRpY01hcmt1cCxcbiAgICAgIGFib3J0UmVhc29uXG4gICAgKSB7XG4gICAgICB2YXIgZGlkRmF0YWwgPSAhMSxcbiAgICAgICAgZmF0YWxFcnJvciA9IG51bGwsXG4gICAgICAgIHJlc3VsdCA9IFwiXCIsXG4gICAgICAgIHJlYWR5VG9TdHJlYW0gPSAhMTtcbiAgICAgIG9wdGlvbnMgPSBjcmVhdGVSZXN1bWFibGVTdGF0ZShcbiAgICAgICAgb3B0aW9ucyA/IG9wdGlvbnMuaWRlbnRpZmllclByZWZpeCA6IHZvaWQgMFxuICAgICAgKTtcbiAgICAgIGNoaWxkcmVuID0gY3JlYXRlUmVxdWVzdChcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIGNyZWF0ZVJlbmRlclN0YXRlKG9wdGlvbnMsIGdlbmVyYXRlU3RhdGljTWFya3VwKSxcbiAgICAgICAgY3JlYXRlRm9ybWF0Q29udGV4dChST09UX0hUTUxfTU9ERSwgbnVsbCwgMCwgbnVsbCksXG4gICAgICAgIEluZmluaXR5LFxuICAgICAgICBvbkVycm9yLFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZWFkeVRvU3RyZWFtID0gITA7XG4gICAgICAgIH0sXG4gICAgICAgIHZvaWQgMCxcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICB2b2lkIDBcbiAgICAgICk7XG4gICAgICBzdGFydFdvcmsoY2hpbGRyZW4pO1xuICAgICAgYWJvcnQoY2hpbGRyZW4sIGFib3J0UmVhc29uKTtcbiAgICAgIHN0YXJ0Rmxvd2luZyhjaGlsZHJlbiwge1xuICAgICAgICBwdXNoOiBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgICBudWxsICE9PSBjaHVuayAmJiAocmVzdWx0ICs9IGNodW5rKTtcbiAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgIH0sXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgIGRpZEZhdGFsID0gITA7XG4gICAgICAgICAgZmF0YWxFcnJvciA9IGVycm9yO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChkaWRGYXRhbCAmJiBmYXRhbEVycm9yICE9PSBhYm9ydFJlYXNvbikgdGhyb3cgZmF0YWxFcnJvcjtcbiAgICAgIGlmICghcmVhZHlUb1N0cmVhbSlcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJBIGNvbXBvbmVudCBzdXNwZW5kZWQgd2hpbGUgcmVzcG9uZGluZyB0byBzeW5jaHJvbm91cyBpbnB1dC4gVGhpcyB3aWxsIGNhdXNlIHRoZSBVSSB0byBiZSByZXBsYWNlZCB3aXRoIGEgbG9hZGluZyBpbmRpY2F0b3IuIFRvIGZpeCwgdXBkYXRlcyB0aGF0IHN1c3BlbmQgc2hvdWxkIGJlIHdyYXBwZWQgd2l0aCBzdGFydFRyYW5zaXRpb24uXCJcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHZhciBSZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKSxcbiAgICAgIFJlYWN0RE9NID0gcmVxdWlyZShcInJlYWN0LWRvbVwiKSxcbiAgICAgIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC50cmFuc2l0aW9uYWwuZWxlbWVudFwiKSxcbiAgICAgIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKSxcbiAgICAgIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIiksXG4gICAgICBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN0cmljdF9tb2RlXCIpLFxuICAgICAgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKSxcbiAgICAgIFJFQUNUX0NPTlNVTUVSX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29uc3VtZXJcIiksXG4gICAgICBSRUFDVF9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29udGV4dFwiKSxcbiAgICAgIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIiksXG4gICAgICBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpLFxuICAgICAgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlX2xpc3RcIiksXG4gICAgICBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb1wiKSxcbiAgICAgIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5sYXp5XCIpLFxuICAgICAgUkVBQ1RfU0NPUEVfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zY29wZVwiKSxcbiAgICAgIFJFQUNUX0FDVElWSVRZX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuYWN0aXZpdHlcIiksXG4gICAgICBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QubGVnYWN5X2hpZGRlblwiKSxcbiAgICAgIFJFQUNUX01FTU9fQ0FDSEVfU0VOVElORUwgPSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb19jYWNoZV9zZW50aW5lbFwiKSxcbiAgICAgIFJFQUNUX1ZJRVdfVFJBTlNJVElPTl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnZpZXdfdHJhbnNpdGlvblwiKSxcbiAgICAgIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcixcbiAgICAgIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheSxcbiAgICAgIGpzeFByb3BzUGFyZW50cyA9IG5ldyBXZWFrTWFwKCksXG4gICAgICBqc3hDaGlsZHJlblBhcmVudHMgPSBuZXcgV2Vha01hcCgpLFxuICAgICAgQ0xJRU5UX1JFRkVSRU5DRV9UQUcgPSBTeW1ib2wuZm9yKFwicmVhY3QuY2xpZW50LnJlZmVyZW5jZVwiKSxcbiAgICAgIGFzc2lnbiA9IE9iamVjdC5hc3NpZ24sXG4gICAgICBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksXG4gICAgICBWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWCA9IFJlZ0V4cChcbiAgICAgICAgXCJeWzpBLVpfYS16XFxcXHUwMEMwLVxcXFx1MDBENlxcXFx1MDBEOC1cXFxcdTAwRjZcXFxcdTAwRjgtXFxcXHUwMkZGXFxcXHUwMzcwLVxcXFx1MDM3RFxcXFx1MDM3Ri1cXFxcdTFGRkZcXFxcdTIwMEMtXFxcXHUyMDBEXFxcXHUyMDcwLVxcXFx1MjE4RlxcXFx1MkMwMC1cXFxcdTJGRUZcXFxcdTMwMDEtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRkRdWzpBLVpfYS16XFxcXHUwMEMwLVxcXFx1MDBENlxcXFx1MDBEOC1cXFxcdTAwRjZcXFxcdTAwRjgtXFxcXHUwMkZGXFxcXHUwMzcwLVxcXFx1MDM3RFxcXFx1MDM3Ri1cXFxcdTFGRkZcXFxcdTIwMEMtXFxcXHUyMDBEXFxcXHUyMDcwLVxcXFx1MjE4RlxcXFx1MkMwMC1cXFxcdTJGRUZcXFxcdTMwMDEtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRkRcXFxcLS4wLTlcXFxcdTAwQjdcXFxcdTAzMDAtXFxcXHUwMzZGXFxcXHUyMDNGLVxcXFx1MjA0MF0qJFwiXG4gICAgICApLFxuICAgICAgaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9LFxuICAgICAgdmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlID0ge30sXG4gICAgICB1bml0bGVzc051bWJlcnMgPSBuZXcgU2V0KFxuICAgICAgICBcImFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50IGFzcGVjdFJhdGlvIGJvcmRlckltYWdlT3V0c2V0IGJvcmRlckltYWdlU2xpY2UgYm9yZGVySW1hZ2VXaWR0aCBib3hGbGV4IGJveEZsZXhHcm91cCBib3hPcmRpbmFsR3JvdXAgY29sdW1uQ291bnQgY29sdW1ucyBmbGV4IGZsZXhHcm93IGZsZXhQb3NpdGl2ZSBmbGV4U2hyaW5rIGZsZXhOZWdhdGl2ZSBmbGV4T3JkZXIgZ3JpZEFyZWEgZ3JpZFJvdyBncmlkUm93RW5kIGdyaWRSb3dTcGFuIGdyaWRSb3dTdGFydCBncmlkQ29sdW1uIGdyaWRDb2x1bW5FbmQgZ3JpZENvbHVtblNwYW4gZ3JpZENvbHVtblN0YXJ0IGZvbnRXZWlnaHQgbGluZUNsYW1wIGxpbmVIZWlnaHQgb3BhY2l0eSBvcmRlciBvcnBoYW5zIHNjYWxlIHRhYlNpemUgd2lkb3dzIHpJbmRleCB6b29tIGZpbGxPcGFjaXR5IGZsb29kT3BhY2l0eSBzdG9wT3BhY2l0eSBzdHJva2VEYXNoYXJyYXkgc3Ryb2tlRGFzaG9mZnNldCBzdHJva2VNaXRlcmxpbWl0IHN0cm9rZU9wYWNpdHkgc3Ryb2tlV2lkdGggTW96QW5pbWF0aW9uSXRlcmF0aW9uQ291bnQgTW96Qm94RmxleCBNb3pCb3hGbGV4R3JvdXAgTW96TGluZUNsYW1wIG1zQW5pbWF0aW9uSXRlcmF0aW9uQ291bnQgbXNGbGV4IG1zWm9vbSBtc0ZsZXhHcm93IG1zRmxleE5lZ2F0aXZlIG1zRmxleE9yZGVyIG1zRmxleFBvc2l0aXZlIG1zRmxleFNocmluayBtc0dyaWRDb2x1bW4gbXNHcmlkQ29sdW1uU3BhbiBtc0dyaWRSb3cgbXNHcmlkUm93U3BhbiBXZWJraXRBbmltYXRpb25JdGVyYXRpb25Db3VudCBXZWJraXRCb3hGbGV4IFdlYktpdEJveEZsZXhHcm91cCBXZWJraXRCb3hPcmRpbmFsR3JvdXAgV2Via2l0Q29sdW1uQ291bnQgV2Via2l0Q29sdW1ucyBXZWJraXRGbGV4IFdlYmtpdEZsZXhHcm93IFdlYmtpdEZsZXhQb3NpdGl2ZSBXZWJraXRGbGV4U2hyaW5rIFdlYmtpdExpbmVDbGFtcFwiLnNwbGl0KFxuICAgICAgICAgIFwiIFwiXG4gICAgICAgIClcbiAgICAgICksXG4gICAgICBhbGlhc2VzID0gbmV3IE1hcChbXG4gICAgICAgIFtcImFjY2VwdENoYXJzZXRcIiwgXCJhY2NlcHQtY2hhcnNldFwiXSxcbiAgICAgICAgW1wiaHRtbEZvclwiLCBcImZvclwiXSxcbiAgICAgICAgW1wiaHR0cEVxdWl2XCIsIFwiaHR0cC1lcXVpdlwiXSxcbiAgICAgICAgW1wiY3Jvc3NPcmlnaW5cIiwgXCJjcm9zc29yaWdpblwiXSxcbiAgICAgICAgW1wiYWNjZW50SGVpZ2h0XCIsIFwiYWNjZW50LWhlaWdodFwiXSxcbiAgICAgICAgW1wiYWxpZ25tZW50QmFzZWxpbmVcIiwgXCJhbGlnbm1lbnQtYmFzZWxpbmVcIl0sXG4gICAgICAgIFtcImFyYWJpY0Zvcm1cIiwgXCJhcmFiaWMtZm9ybVwiXSxcbiAgICAgICAgW1wiYmFzZWxpbmVTaGlmdFwiLCBcImJhc2VsaW5lLXNoaWZ0XCJdLFxuICAgICAgICBbXCJjYXBIZWlnaHRcIiwgXCJjYXAtaGVpZ2h0XCJdLFxuICAgICAgICBbXCJjbGlwUGF0aFwiLCBcImNsaXAtcGF0aFwiXSxcbiAgICAgICAgW1wiY2xpcFJ1bGVcIiwgXCJjbGlwLXJ1bGVcIl0sXG4gICAgICAgIFtcImNvbG9ySW50ZXJwb2xhdGlvblwiLCBcImNvbG9yLWludGVycG9sYXRpb25cIl0sXG4gICAgICAgIFtcImNvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnNcIiwgXCJjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnNcIl0sXG4gICAgICAgIFtcImNvbG9yUHJvZmlsZVwiLCBcImNvbG9yLXByb2ZpbGVcIl0sXG4gICAgICAgIFtcImNvbG9yUmVuZGVyaW5nXCIsIFwiY29sb3ItcmVuZGVyaW5nXCJdLFxuICAgICAgICBbXCJkb21pbmFudEJhc2VsaW5lXCIsIFwiZG9taW5hbnQtYmFzZWxpbmVcIl0sXG4gICAgICAgIFtcImVuYWJsZUJhY2tncm91bmRcIiwgXCJlbmFibGUtYmFja2dyb3VuZFwiXSxcbiAgICAgICAgW1wiZmlsbE9wYWNpdHlcIiwgXCJmaWxsLW9wYWNpdHlcIl0sXG4gICAgICAgIFtcImZpbGxSdWxlXCIsIFwiZmlsbC1ydWxlXCJdLFxuICAgICAgICBbXCJmbG9vZENvbG9yXCIsIFwiZmxvb2QtY29sb3JcIl0sXG4gICAgICAgIFtcImZsb29kT3BhY2l0eVwiLCBcImZsb29kLW9wYWNpdHlcIl0sXG4gICAgICAgIFtcImZvbnRGYW1pbHlcIiwgXCJmb250LWZhbWlseVwiXSxcbiAgICAgICAgW1wiZm9udFNpemVcIiwgXCJmb250LXNpemVcIl0sXG4gICAgICAgIFtcImZvbnRTaXplQWRqdXN0XCIsIFwiZm9udC1zaXplLWFkanVzdFwiXSxcbiAgICAgICAgW1wiZm9udFN0cmV0Y2hcIiwgXCJmb250LXN0cmV0Y2hcIl0sXG4gICAgICAgIFtcImZvbnRTdHlsZVwiLCBcImZvbnQtc3R5bGVcIl0sXG4gICAgICAgIFtcImZvbnRWYXJpYW50XCIsIFwiZm9udC12YXJpYW50XCJdLFxuICAgICAgICBbXCJmb250V2VpZ2h0XCIsIFwiZm9udC13ZWlnaHRcIl0sXG4gICAgICAgIFtcImdseXBoTmFtZVwiLCBcImdseXBoLW5hbWVcIl0sXG4gICAgICAgIFtcImdseXBoT3JpZW50YXRpb25Ib3Jpem9udGFsXCIsIFwiZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbFwiXSxcbiAgICAgICAgW1wiZ2x5cGhPcmllbnRhdGlvblZlcnRpY2FsXCIsIFwiZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWxcIl0sXG4gICAgICAgIFtcImhvcml6QWR2WFwiLCBcImhvcml6LWFkdi14XCJdLFxuICAgICAgICBbXCJob3Jpek9yaWdpblhcIiwgXCJob3Jpei1vcmlnaW4teFwiXSxcbiAgICAgICAgW1wiaW1hZ2VSZW5kZXJpbmdcIiwgXCJpbWFnZS1yZW5kZXJpbmdcIl0sXG4gICAgICAgIFtcImxldHRlclNwYWNpbmdcIiwgXCJsZXR0ZXItc3BhY2luZ1wiXSxcbiAgICAgICAgW1wibGlnaHRpbmdDb2xvclwiLCBcImxpZ2h0aW5nLWNvbG9yXCJdLFxuICAgICAgICBbXCJtYXJrZXJFbmRcIiwgXCJtYXJrZXItZW5kXCJdLFxuICAgICAgICBbXCJtYXJrZXJNaWRcIiwgXCJtYXJrZXItbWlkXCJdLFxuICAgICAgICBbXCJtYXJrZXJTdGFydFwiLCBcIm1hcmtlci1zdGFydFwiXSxcbiAgICAgICAgW1wib3ZlcmxpbmVQb3NpdGlvblwiLCBcIm92ZXJsaW5lLXBvc2l0aW9uXCJdLFxuICAgICAgICBbXCJvdmVybGluZVRoaWNrbmVzc1wiLCBcIm92ZXJsaW5lLXRoaWNrbmVzc1wiXSxcbiAgICAgICAgW1wicGFpbnRPcmRlclwiLCBcInBhaW50LW9yZGVyXCJdLFxuICAgICAgICBbXCJwYW5vc2UtMVwiLCBcInBhbm9zZS0xXCJdLFxuICAgICAgICBbXCJwb2ludGVyRXZlbnRzXCIsIFwicG9pbnRlci1ldmVudHNcIl0sXG4gICAgICAgIFtcInJlbmRlcmluZ0ludGVudFwiLCBcInJlbmRlcmluZy1pbnRlbnRcIl0sXG4gICAgICAgIFtcInNoYXBlUmVuZGVyaW5nXCIsIFwic2hhcGUtcmVuZGVyaW5nXCJdLFxuICAgICAgICBbXCJzdG9wQ29sb3JcIiwgXCJzdG9wLWNvbG9yXCJdLFxuICAgICAgICBbXCJzdG9wT3BhY2l0eVwiLCBcInN0b3Atb3BhY2l0eVwiXSxcbiAgICAgICAgW1wic3RyaWtldGhyb3VnaFBvc2l0aW9uXCIsIFwic3RyaWtldGhyb3VnaC1wb3NpdGlvblwiXSxcbiAgICAgICAgW1wic3RyaWtldGhyb3VnaFRoaWNrbmVzc1wiLCBcInN0cmlrZXRocm91Z2gtdGhpY2tuZXNzXCJdLFxuICAgICAgICBbXCJzdHJva2VEYXNoYXJyYXlcIiwgXCJzdHJva2UtZGFzaGFycmF5XCJdLFxuICAgICAgICBbXCJzdHJva2VEYXNob2Zmc2V0XCIsIFwic3Ryb2tlLWRhc2hvZmZzZXRcIl0sXG4gICAgICAgIFtcInN0cm9rZUxpbmVjYXBcIiwgXCJzdHJva2UtbGluZWNhcFwiXSxcbiAgICAgICAgW1wic3Ryb2tlTGluZWpvaW5cIiwgXCJzdHJva2UtbGluZWpvaW5cIl0sXG4gICAgICAgIFtcInN0cm9rZU1pdGVybGltaXRcIiwgXCJzdHJva2UtbWl0ZXJsaW1pdFwiXSxcbiAgICAgICAgW1wic3Ryb2tlT3BhY2l0eVwiLCBcInN0cm9rZS1vcGFjaXR5XCJdLFxuICAgICAgICBbXCJzdHJva2VXaWR0aFwiLCBcInN0cm9rZS13aWR0aFwiXSxcbiAgICAgICAgW1widGV4dEFuY2hvclwiLCBcInRleHQtYW5jaG9yXCJdLFxuICAgICAgICBbXCJ0ZXh0RGVjb3JhdGlvblwiLCBcInRleHQtZGVjb3JhdGlvblwiXSxcbiAgICAgICAgW1widGV4dFJlbmRlcmluZ1wiLCBcInRleHQtcmVuZGVyaW5nXCJdLFxuICAgICAgICBbXCJ0cmFuc2Zvcm1PcmlnaW5cIiwgXCJ0cmFuc2Zvcm0tb3JpZ2luXCJdLFxuICAgICAgICBbXCJ1bmRlcmxpbmVQb3NpdGlvblwiLCBcInVuZGVybGluZS1wb3NpdGlvblwiXSxcbiAgICAgICAgW1widW5kZXJsaW5lVGhpY2tuZXNzXCIsIFwidW5kZXJsaW5lLXRoaWNrbmVzc1wiXSxcbiAgICAgICAgW1widW5pY29kZUJpZGlcIiwgXCJ1bmljb2RlLWJpZGlcIl0sXG4gICAgICAgIFtcInVuaWNvZGVSYW5nZVwiLCBcInVuaWNvZGUtcmFuZ2VcIl0sXG4gICAgICAgIFtcInVuaXRzUGVyRW1cIiwgXCJ1bml0cy1wZXItZW1cIl0sXG4gICAgICAgIFtcInZBbHBoYWJldGljXCIsIFwidi1hbHBoYWJldGljXCJdLFxuICAgICAgICBbXCJ2SGFuZ2luZ1wiLCBcInYtaGFuZ2luZ1wiXSxcbiAgICAgICAgW1widklkZW9ncmFwaGljXCIsIFwidi1pZGVvZ3JhcGhpY1wiXSxcbiAgICAgICAgW1widk1hdGhlbWF0aWNhbFwiLCBcInYtbWF0aGVtYXRpY2FsXCJdLFxuICAgICAgICBbXCJ2ZWN0b3JFZmZlY3RcIiwgXCJ2ZWN0b3ItZWZmZWN0XCJdLFxuICAgICAgICBbXCJ2ZXJ0QWR2WVwiLCBcInZlcnQtYWR2LXlcIl0sXG4gICAgICAgIFtcInZlcnRPcmlnaW5YXCIsIFwidmVydC1vcmlnaW4teFwiXSxcbiAgICAgICAgW1widmVydE9yaWdpbllcIiwgXCJ2ZXJ0LW9yaWdpbi15XCJdLFxuICAgICAgICBbXCJ3b3JkU3BhY2luZ1wiLCBcIndvcmQtc3BhY2luZ1wiXSxcbiAgICAgICAgW1wid3JpdGluZ01vZGVcIiwgXCJ3cml0aW5nLW1vZGVcIl0sXG4gICAgICAgIFtcInhtbG5zWGxpbmtcIiwgXCJ4bWxuczp4bGlua1wiXSxcbiAgICAgICAgW1wieEhlaWdodFwiLCBcIngtaGVpZ2h0XCJdXG4gICAgICBdKSxcbiAgICAgIGhhc1JlYWRPbmx5VmFsdWUgPSB7XG4gICAgICAgIGJ1dHRvbjogITAsXG4gICAgICAgIGNoZWNrYm94OiAhMCxcbiAgICAgICAgaW1hZ2U6ICEwLFxuICAgICAgICBoaWRkZW46ICEwLFxuICAgICAgICByYWRpbzogITAsXG4gICAgICAgIHJlc2V0OiAhMCxcbiAgICAgICAgc3VibWl0OiAhMFxuICAgICAgfSxcbiAgICAgIGFyaWFQcm9wZXJ0aWVzID0ge1xuICAgICAgICBcImFyaWEtY3VycmVudFwiOiAwLFxuICAgICAgICBcImFyaWEtZGVzY3JpcHRpb25cIjogMCxcbiAgICAgICAgXCJhcmlhLWRldGFpbHNcIjogMCxcbiAgICAgICAgXCJhcmlhLWRpc2FibGVkXCI6IDAsXG4gICAgICAgIFwiYXJpYS1oaWRkZW5cIjogMCxcbiAgICAgICAgXCJhcmlhLWludmFsaWRcIjogMCxcbiAgICAgICAgXCJhcmlhLWtleXNob3J0Y3V0c1wiOiAwLFxuICAgICAgICBcImFyaWEtbGFiZWxcIjogMCxcbiAgICAgICAgXCJhcmlhLXJvbGVkZXNjcmlwdGlvblwiOiAwLFxuICAgICAgICBcImFyaWEtYXV0b2NvbXBsZXRlXCI6IDAsXG4gICAgICAgIFwiYXJpYS1jaGVja2VkXCI6IDAsXG4gICAgICAgIFwiYXJpYS1leHBhbmRlZFwiOiAwLFxuICAgICAgICBcImFyaWEtaGFzcG9wdXBcIjogMCxcbiAgICAgICAgXCJhcmlhLWxldmVsXCI6IDAsXG4gICAgICAgIFwiYXJpYS1tb2RhbFwiOiAwLFxuICAgICAgICBcImFyaWEtbXVsdGlsaW5lXCI6IDAsXG4gICAgICAgIFwiYXJpYS1tdWx0aXNlbGVjdGFibGVcIjogMCxcbiAgICAgICAgXCJhcmlhLW9yaWVudGF0aW9uXCI6IDAsXG4gICAgICAgIFwiYXJpYS1wbGFjZWhvbGRlclwiOiAwLFxuICAgICAgICBcImFyaWEtcHJlc3NlZFwiOiAwLFxuICAgICAgICBcImFyaWEtcmVhZG9ubHlcIjogMCxcbiAgICAgICAgXCJhcmlhLXJlcXVpcmVkXCI6IDAsXG4gICAgICAgIFwiYXJpYS1zZWxlY3RlZFwiOiAwLFxuICAgICAgICBcImFyaWEtc29ydFwiOiAwLFxuICAgICAgICBcImFyaWEtdmFsdWVtYXhcIjogMCxcbiAgICAgICAgXCJhcmlhLXZhbHVlbWluXCI6IDAsXG4gICAgICAgIFwiYXJpYS12YWx1ZW5vd1wiOiAwLFxuICAgICAgICBcImFyaWEtdmFsdWV0ZXh0XCI6IDAsXG4gICAgICAgIFwiYXJpYS1hdG9taWNcIjogMCxcbiAgICAgICAgXCJhcmlhLWJ1c3lcIjogMCxcbiAgICAgICAgXCJhcmlhLWxpdmVcIjogMCxcbiAgICAgICAgXCJhcmlhLXJlbGV2YW50XCI6IDAsXG4gICAgICAgIFwiYXJpYS1kcm9wZWZmZWN0XCI6IDAsXG4gICAgICAgIFwiYXJpYS1ncmFiYmVkXCI6IDAsXG4gICAgICAgIFwiYXJpYS1hY3RpdmVkZXNjZW5kYW50XCI6IDAsXG4gICAgICAgIFwiYXJpYS1jb2xjb3VudFwiOiAwLFxuICAgICAgICBcImFyaWEtY29saW5kZXhcIjogMCxcbiAgICAgICAgXCJhcmlhLWNvbHNwYW5cIjogMCxcbiAgICAgICAgXCJhcmlhLWNvbnRyb2xzXCI6IDAsXG4gICAgICAgIFwiYXJpYS1kZXNjcmliZWRieVwiOiAwLFxuICAgICAgICBcImFyaWEtZXJyb3JtZXNzYWdlXCI6IDAsXG4gICAgICAgIFwiYXJpYS1mbG93dG9cIjogMCxcbiAgICAgICAgXCJhcmlhLWxhYmVsbGVkYnlcIjogMCxcbiAgICAgICAgXCJhcmlhLW93bnNcIjogMCxcbiAgICAgICAgXCJhcmlhLXBvc2luc2V0XCI6IDAsXG4gICAgICAgIFwiYXJpYS1yb3djb3VudFwiOiAwLFxuICAgICAgICBcImFyaWEtcm93aW5kZXhcIjogMCxcbiAgICAgICAgXCJhcmlhLXJvd3NwYW5cIjogMCxcbiAgICAgICAgXCJhcmlhLXNldHNpemVcIjogMCxcbiAgICAgICAgXCJhcmlhLWJyYWlsbGVsYWJlbFwiOiAwLFxuICAgICAgICBcImFyaWEtYnJhaWxsZXJvbGVkZXNjcmlwdGlvblwiOiAwLFxuICAgICAgICBcImFyaWEtY29saW5kZXh0ZXh0XCI6IDAsXG4gICAgICAgIFwiYXJpYS1yb3dpbmRleHRleHRcIjogMFxuICAgICAgfSxcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMSA9IHt9LFxuICAgICAgckFSSUEkMSA9IFJlZ0V4cChcbiAgICAgICAgXCJeKGFyaWEpLVs6QS1aX2EtelxcXFx1MDBDMC1cXFxcdTAwRDZcXFxcdTAwRDgtXFxcXHUwMEY2XFxcXHUwMEY4LVxcXFx1MDJGRlxcXFx1MDM3MC1cXFxcdTAzN0RcXFxcdTAzN0YtXFxcXHUxRkZGXFxcXHUyMDBDLVxcXFx1MjAwRFxcXFx1MjA3MC1cXFxcdTIxOEZcXFxcdTJDMDAtXFxcXHUyRkVGXFxcXHUzMDAxLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkZEXFxcXC0uMC05XFxcXHUwMEI3XFxcXHUwMzAwLVxcXFx1MDM2RlxcXFx1MjAzRi1cXFxcdTIwNDBdKiRcIlxuICAgICAgKSxcbiAgICAgIHJBUklBQ2FtZWwkMSA9IFJlZ0V4cChcbiAgICAgICAgXCJeKGFyaWEpW0EtWl1bOkEtWl9hLXpcXFxcdTAwQzAtXFxcXHUwMEQ2XFxcXHUwMEQ4LVxcXFx1MDBGNlxcXFx1MDBGOC1cXFxcdTAyRkZcXFxcdTAzNzAtXFxcXHUwMzdEXFxcXHUwMzdGLVxcXFx1MUZGRlxcXFx1MjAwQy1cXFxcdTIwMERcXFxcdTIwNzAtXFxcXHUyMThGXFxcXHUyQzAwLVxcXFx1MkZFRlxcXFx1MzAwMS1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZGRFxcXFwtLjAtOVxcXFx1MDBCN1xcXFx1MDMwMC1cXFxcdTAzNkZcXFxcdTIwM0YtXFxcXHUyMDQwXSokXCJcbiAgICAgICksXG4gICAgICBkaWRXYXJuVmFsdWVOdWxsID0gITEsXG4gICAgICBwb3NzaWJsZVN0YW5kYXJkTmFtZXMgPSB7XG4gICAgICAgIGFjY2VwdDogXCJhY2NlcHRcIixcbiAgICAgICAgYWNjZXB0Y2hhcnNldDogXCJhY2NlcHRDaGFyc2V0XCIsXG4gICAgICAgIFwiYWNjZXB0LWNoYXJzZXRcIjogXCJhY2NlcHRDaGFyc2V0XCIsXG4gICAgICAgIGFjY2Vzc2tleTogXCJhY2Nlc3NLZXlcIixcbiAgICAgICAgYWN0aW9uOiBcImFjdGlvblwiLFxuICAgICAgICBhbGxvd2Z1bGxzY3JlZW46IFwiYWxsb3dGdWxsU2NyZWVuXCIsXG4gICAgICAgIGFsdDogXCJhbHRcIixcbiAgICAgICAgYXM6IFwiYXNcIixcbiAgICAgICAgYXN5bmM6IFwiYXN5bmNcIixcbiAgICAgICAgYXV0b2NhcGl0YWxpemU6IFwiYXV0b0NhcGl0YWxpemVcIixcbiAgICAgICAgYXV0b2NvbXBsZXRlOiBcImF1dG9Db21wbGV0ZVwiLFxuICAgICAgICBhdXRvY29ycmVjdDogXCJhdXRvQ29ycmVjdFwiLFxuICAgICAgICBhdXRvZm9jdXM6IFwiYXV0b0ZvY3VzXCIsXG4gICAgICAgIGF1dG9wbGF5OiBcImF1dG9QbGF5XCIsXG4gICAgICAgIGF1dG9zYXZlOiBcImF1dG9TYXZlXCIsXG4gICAgICAgIGNhcHR1cmU6IFwiY2FwdHVyZVwiLFxuICAgICAgICBjZWxscGFkZGluZzogXCJjZWxsUGFkZGluZ1wiLFxuICAgICAgICBjZWxsc3BhY2luZzogXCJjZWxsU3BhY2luZ1wiLFxuICAgICAgICBjaGFsbGVuZ2U6IFwiY2hhbGxlbmdlXCIsXG4gICAgICAgIGNoYXJzZXQ6IFwiY2hhclNldFwiLFxuICAgICAgICBjaGVja2VkOiBcImNoZWNrZWRcIixcbiAgICAgICAgY2hpbGRyZW46IFwiY2hpbGRyZW5cIixcbiAgICAgICAgY2l0ZTogXCJjaXRlXCIsXG4gICAgICAgIGNsYXNzOiBcImNsYXNzTmFtZVwiLFxuICAgICAgICBjbGFzc2lkOiBcImNsYXNzSURcIixcbiAgICAgICAgY2xhc3NuYW1lOiBcImNsYXNzTmFtZVwiLFxuICAgICAgICBjb2xzOiBcImNvbHNcIixcbiAgICAgICAgY29sc3BhbjogXCJjb2xTcGFuXCIsXG4gICAgICAgIGNvbnRlbnQ6IFwiY29udGVudFwiLFxuICAgICAgICBjb250ZW50ZWRpdGFibGU6IFwiY29udGVudEVkaXRhYmxlXCIsXG4gICAgICAgIGNvbnRleHRtZW51OiBcImNvbnRleHRNZW51XCIsXG4gICAgICAgIGNvbnRyb2xzOiBcImNvbnRyb2xzXCIsXG4gICAgICAgIGNvbnRyb2xzbGlzdDogXCJjb250cm9sc0xpc3RcIixcbiAgICAgICAgY29vcmRzOiBcImNvb3Jkc1wiLFxuICAgICAgICBjcm9zc29yaWdpbjogXCJjcm9zc09yaWdpblwiLFxuICAgICAgICBkYW5nZXJvdXNseXNldGlubmVyaHRtbDogXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiLFxuICAgICAgICBkYXRhOiBcImRhdGFcIixcbiAgICAgICAgZGF0ZXRpbWU6IFwiZGF0ZVRpbWVcIixcbiAgICAgICAgZGVmYXVsdDogXCJkZWZhdWx0XCIsXG4gICAgICAgIGRlZmF1bHRjaGVja2VkOiBcImRlZmF1bHRDaGVja2VkXCIsXG4gICAgICAgIGRlZmF1bHR2YWx1ZTogXCJkZWZhdWx0VmFsdWVcIixcbiAgICAgICAgZGVmZXI6IFwiZGVmZXJcIixcbiAgICAgICAgZGlyOiBcImRpclwiLFxuICAgICAgICBkaXNhYmxlZDogXCJkaXNhYmxlZFwiLFxuICAgICAgICBkaXNhYmxlcGljdHVyZWlucGljdHVyZTogXCJkaXNhYmxlUGljdHVyZUluUGljdHVyZVwiLFxuICAgICAgICBkaXNhYmxlcmVtb3RlcGxheWJhY2s6IFwiZGlzYWJsZVJlbW90ZVBsYXliYWNrXCIsXG4gICAgICAgIGRvd25sb2FkOiBcImRvd25sb2FkXCIsXG4gICAgICAgIGRyYWdnYWJsZTogXCJkcmFnZ2FibGVcIixcbiAgICAgICAgZW5jdHlwZTogXCJlbmNUeXBlXCIsXG4gICAgICAgIGVudGVya2V5aGludDogXCJlbnRlcktleUhpbnRcIixcbiAgICAgICAgZmV0Y2hwcmlvcml0eTogXCJmZXRjaFByaW9yaXR5XCIsXG4gICAgICAgIGZvcjogXCJodG1sRm9yXCIsXG4gICAgICAgIGZvcm06IFwiZm9ybVwiLFxuICAgICAgICBmb3JtbWV0aG9kOiBcImZvcm1NZXRob2RcIixcbiAgICAgICAgZm9ybWFjdGlvbjogXCJmb3JtQWN0aW9uXCIsXG4gICAgICAgIGZvcm1lbmN0eXBlOiBcImZvcm1FbmNUeXBlXCIsXG4gICAgICAgIGZvcm1ub3ZhbGlkYXRlOiBcImZvcm1Ob1ZhbGlkYXRlXCIsXG4gICAgICAgIGZvcm10YXJnZXQ6IFwiZm9ybVRhcmdldFwiLFxuICAgICAgICBmcmFtZWJvcmRlcjogXCJmcmFtZUJvcmRlclwiLFxuICAgICAgICBoZWFkZXJzOiBcImhlYWRlcnNcIixcbiAgICAgICAgaGVpZ2h0OiBcImhlaWdodFwiLFxuICAgICAgICBoaWRkZW46IFwiaGlkZGVuXCIsXG4gICAgICAgIGhpZ2g6IFwiaGlnaFwiLFxuICAgICAgICBocmVmOiBcImhyZWZcIixcbiAgICAgICAgaHJlZmxhbmc6IFwiaHJlZkxhbmdcIixcbiAgICAgICAgaHRtbGZvcjogXCJodG1sRm9yXCIsXG4gICAgICAgIGh0dHBlcXVpdjogXCJodHRwRXF1aXZcIixcbiAgICAgICAgXCJodHRwLWVxdWl2XCI6IFwiaHR0cEVxdWl2XCIsXG4gICAgICAgIGljb246IFwiaWNvblwiLFxuICAgICAgICBpZDogXCJpZFwiLFxuICAgICAgICBpbWFnZXNpemVzOiBcImltYWdlU2l6ZXNcIixcbiAgICAgICAgaW1hZ2VzcmNzZXQ6IFwiaW1hZ2VTcmNTZXRcIixcbiAgICAgICAgaW5lcnQ6IFwiaW5lcnRcIixcbiAgICAgICAgaW5uZXJodG1sOiBcImlubmVySFRNTFwiLFxuICAgICAgICBpbnB1dG1vZGU6IFwiaW5wdXRNb2RlXCIsXG4gICAgICAgIGludGVncml0eTogXCJpbnRlZ3JpdHlcIixcbiAgICAgICAgaXM6IFwiaXNcIixcbiAgICAgICAgaXRlbWlkOiBcIml0ZW1JRFwiLFxuICAgICAgICBpdGVtcHJvcDogXCJpdGVtUHJvcFwiLFxuICAgICAgICBpdGVtcmVmOiBcIml0ZW1SZWZcIixcbiAgICAgICAgaXRlbXNjb3BlOiBcIml0ZW1TY29wZVwiLFxuICAgICAgICBpdGVtdHlwZTogXCJpdGVtVHlwZVwiLFxuICAgICAgICBrZXlwYXJhbXM6IFwia2V5UGFyYW1zXCIsXG4gICAgICAgIGtleXR5cGU6IFwia2V5VHlwZVwiLFxuICAgICAgICBraW5kOiBcImtpbmRcIixcbiAgICAgICAgbGFiZWw6IFwibGFiZWxcIixcbiAgICAgICAgbGFuZzogXCJsYW5nXCIsXG4gICAgICAgIGxpc3Q6IFwibGlzdFwiLFxuICAgICAgICBsb29wOiBcImxvb3BcIixcbiAgICAgICAgbG93OiBcImxvd1wiLFxuICAgICAgICBtYW5pZmVzdDogXCJtYW5pZmVzdFwiLFxuICAgICAgICBtYXJnaW53aWR0aDogXCJtYXJnaW5XaWR0aFwiLFxuICAgICAgICBtYXJnaW5oZWlnaHQ6IFwibWFyZ2luSGVpZ2h0XCIsXG4gICAgICAgIG1heDogXCJtYXhcIixcbiAgICAgICAgbWF4bGVuZ3RoOiBcIm1heExlbmd0aFwiLFxuICAgICAgICBtZWRpYTogXCJtZWRpYVwiLFxuICAgICAgICBtZWRpYWdyb3VwOiBcIm1lZGlhR3JvdXBcIixcbiAgICAgICAgbWV0aG9kOiBcIm1ldGhvZFwiLFxuICAgICAgICBtaW46IFwibWluXCIsXG4gICAgICAgIG1pbmxlbmd0aDogXCJtaW5MZW5ndGhcIixcbiAgICAgICAgbXVsdGlwbGU6IFwibXVsdGlwbGVcIixcbiAgICAgICAgbXV0ZWQ6IFwibXV0ZWRcIixcbiAgICAgICAgbmFtZTogXCJuYW1lXCIsXG4gICAgICAgIG5vbW9kdWxlOiBcIm5vTW9kdWxlXCIsXG4gICAgICAgIG5vbmNlOiBcIm5vbmNlXCIsXG4gICAgICAgIG5vdmFsaWRhdGU6IFwibm9WYWxpZGF0ZVwiLFxuICAgICAgICBvcGVuOiBcIm9wZW5cIixcbiAgICAgICAgb3B0aW11bTogXCJvcHRpbXVtXCIsXG4gICAgICAgIHBhdHRlcm46IFwicGF0dGVyblwiLFxuICAgICAgICBwbGFjZWhvbGRlcjogXCJwbGFjZWhvbGRlclwiLFxuICAgICAgICBwbGF5c2lubGluZTogXCJwbGF5c0lubGluZVwiLFxuICAgICAgICBwb3N0ZXI6IFwicG9zdGVyXCIsXG4gICAgICAgIHByZWxvYWQ6IFwicHJlbG9hZFwiLFxuICAgICAgICBwcm9maWxlOiBcInByb2ZpbGVcIixcbiAgICAgICAgcmFkaW9ncm91cDogXCJyYWRpb0dyb3VwXCIsXG4gICAgICAgIHJlYWRvbmx5OiBcInJlYWRPbmx5XCIsXG4gICAgICAgIHJlZmVycmVycG9saWN5OiBcInJlZmVycmVyUG9saWN5XCIsXG4gICAgICAgIHJlbDogXCJyZWxcIixcbiAgICAgICAgcmVxdWlyZWQ6IFwicmVxdWlyZWRcIixcbiAgICAgICAgcmV2ZXJzZWQ6IFwicmV2ZXJzZWRcIixcbiAgICAgICAgcm9sZTogXCJyb2xlXCIsXG4gICAgICAgIHJvd3M6IFwicm93c1wiLFxuICAgICAgICByb3dzcGFuOiBcInJvd1NwYW5cIixcbiAgICAgICAgc2FuZGJveDogXCJzYW5kYm94XCIsXG4gICAgICAgIHNjb3BlOiBcInNjb3BlXCIsXG4gICAgICAgIHNjb3BlZDogXCJzY29wZWRcIixcbiAgICAgICAgc2Nyb2xsaW5nOiBcInNjcm9sbGluZ1wiLFxuICAgICAgICBzZWFtbGVzczogXCJzZWFtbGVzc1wiLFxuICAgICAgICBzZWxlY3RlZDogXCJzZWxlY3RlZFwiLFxuICAgICAgICBzaGFwZTogXCJzaGFwZVwiLFxuICAgICAgICBzaXplOiBcInNpemVcIixcbiAgICAgICAgc2l6ZXM6IFwic2l6ZXNcIixcbiAgICAgICAgc3BhbjogXCJzcGFuXCIsXG4gICAgICAgIHNwZWxsY2hlY2s6IFwic3BlbGxDaGVja1wiLFxuICAgICAgICBzcmM6IFwic3JjXCIsXG4gICAgICAgIHNyY2RvYzogXCJzcmNEb2NcIixcbiAgICAgICAgc3JjbGFuZzogXCJzcmNMYW5nXCIsXG4gICAgICAgIHNyY3NldDogXCJzcmNTZXRcIixcbiAgICAgICAgc3RhcnQ6IFwic3RhcnRcIixcbiAgICAgICAgc3RlcDogXCJzdGVwXCIsXG4gICAgICAgIHN0eWxlOiBcInN0eWxlXCIsXG4gICAgICAgIHN1bW1hcnk6IFwic3VtbWFyeVwiLFxuICAgICAgICB0YWJpbmRleDogXCJ0YWJJbmRleFwiLFxuICAgICAgICB0YXJnZXQ6IFwidGFyZ2V0XCIsXG4gICAgICAgIHRpdGxlOiBcInRpdGxlXCIsXG4gICAgICAgIHR5cGU6IFwidHlwZVwiLFxuICAgICAgICB1c2VtYXA6IFwidXNlTWFwXCIsXG4gICAgICAgIHZhbHVlOiBcInZhbHVlXCIsXG4gICAgICAgIHdpZHRoOiBcIndpZHRoXCIsXG4gICAgICAgIHdtb2RlOiBcIndtb2RlXCIsXG4gICAgICAgIHdyYXA6IFwid3JhcFwiLFxuICAgICAgICBhYm91dDogXCJhYm91dFwiLFxuICAgICAgICBhY2NlbnRoZWlnaHQ6IFwiYWNjZW50SGVpZ2h0XCIsXG4gICAgICAgIFwiYWNjZW50LWhlaWdodFwiOiBcImFjY2VudEhlaWdodFwiLFxuICAgICAgICBhY2N1bXVsYXRlOiBcImFjY3VtdWxhdGVcIixcbiAgICAgICAgYWRkaXRpdmU6IFwiYWRkaXRpdmVcIixcbiAgICAgICAgYWxpZ25tZW50YmFzZWxpbmU6IFwiYWxpZ25tZW50QmFzZWxpbmVcIixcbiAgICAgICAgXCJhbGlnbm1lbnQtYmFzZWxpbmVcIjogXCJhbGlnbm1lbnRCYXNlbGluZVwiLFxuICAgICAgICBhbGxvd3Jlb3JkZXI6IFwiYWxsb3dSZW9yZGVyXCIsXG4gICAgICAgIGFscGhhYmV0aWM6IFwiYWxwaGFiZXRpY1wiLFxuICAgICAgICBhbXBsaXR1ZGU6IFwiYW1wbGl0dWRlXCIsXG4gICAgICAgIGFyYWJpY2Zvcm06IFwiYXJhYmljRm9ybVwiLFxuICAgICAgICBcImFyYWJpYy1mb3JtXCI6IFwiYXJhYmljRm9ybVwiLFxuICAgICAgICBhc2NlbnQ6IFwiYXNjZW50XCIsXG4gICAgICAgIGF0dHJpYnV0ZW5hbWU6IFwiYXR0cmlidXRlTmFtZVwiLFxuICAgICAgICBhdHRyaWJ1dGV0eXBlOiBcImF0dHJpYnV0ZVR5cGVcIixcbiAgICAgICAgYXV0b3JldmVyc2U6IFwiYXV0b1JldmVyc2VcIixcbiAgICAgICAgYXppbXV0aDogXCJhemltdXRoXCIsXG4gICAgICAgIGJhc2VmcmVxdWVuY3k6IFwiYmFzZUZyZXF1ZW5jeVwiLFxuICAgICAgICBiYXNlbGluZXNoaWZ0OiBcImJhc2VsaW5lU2hpZnRcIixcbiAgICAgICAgXCJiYXNlbGluZS1zaGlmdFwiOiBcImJhc2VsaW5lU2hpZnRcIixcbiAgICAgICAgYmFzZXByb2ZpbGU6IFwiYmFzZVByb2ZpbGVcIixcbiAgICAgICAgYmJveDogXCJiYm94XCIsXG4gICAgICAgIGJlZ2luOiBcImJlZ2luXCIsXG4gICAgICAgIGJpYXM6IFwiYmlhc1wiLFxuICAgICAgICBieTogXCJieVwiLFxuICAgICAgICBjYWxjbW9kZTogXCJjYWxjTW9kZVwiLFxuICAgICAgICBjYXBoZWlnaHQ6IFwiY2FwSGVpZ2h0XCIsXG4gICAgICAgIFwiY2FwLWhlaWdodFwiOiBcImNhcEhlaWdodFwiLFxuICAgICAgICBjbGlwOiBcImNsaXBcIixcbiAgICAgICAgY2xpcHBhdGg6IFwiY2xpcFBhdGhcIixcbiAgICAgICAgXCJjbGlwLXBhdGhcIjogXCJjbGlwUGF0aFwiLFxuICAgICAgICBjbGlwcGF0aHVuaXRzOiBcImNsaXBQYXRoVW5pdHNcIixcbiAgICAgICAgY2xpcHJ1bGU6IFwiY2xpcFJ1bGVcIixcbiAgICAgICAgXCJjbGlwLXJ1bGVcIjogXCJjbGlwUnVsZVwiLFxuICAgICAgICBjb2xvcjogXCJjb2xvclwiLFxuICAgICAgICBjb2xvcmludGVycG9sYXRpb246IFwiY29sb3JJbnRlcnBvbGF0aW9uXCIsXG4gICAgICAgIFwiY29sb3ItaW50ZXJwb2xhdGlvblwiOiBcImNvbG9ySW50ZXJwb2xhdGlvblwiLFxuICAgICAgICBjb2xvcmludGVycG9sYXRpb25maWx0ZXJzOiBcImNvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnNcIixcbiAgICAgICAgXCJjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnNcIjogXCJjb2xvckludGVycG9sYXRpb25GaWx0ZXJzXCIsXG4gICAgICAgIGNvbG9ycHJvZmlsZTogXCJjb2xvclByb2ZpbGVcIixcbiAgICAgICAgXCJjb2xvci1wcm9maWxlXCI6IFwiY29sb3JQcm9maWxlXCIsXG4gICAgICAgIGNvbG9ycmVuZGVyaW5nOiBcImNvbG9yUmVuZGVyaW5nXCIsXG4gICAgICAgIFwiY29sb3ItcmVuZGVyaW5nXCI6IFwiY29sb3JSZW5kZXJpbmdcIixcbiAgICAgICAgY29udGVudHNjcmlwdHR5cGU6IFwiY29udGVudFNjcmlwdFR5cGVcIixcbiAgICAgICAgY29udGVudHN0eWxldHlwZTogXCJjb250ZW50U3R5bGVUeXBlXCIsXG4gICAgICAgIGN1cnNvcjogXCJjdXJzb3JcIixcbiAgICAgICAgY3g6IFwiY3hcIixcbiAgICAgICAgY3k6IFwiY3lcIixcbiAgICAgICAgZDogXCJkXCIsXG4gICAgICAgIGRhdGF0eXBlOiBcImRhdGF0eXBlXCIsXG4gICAgICAgIGRlY2VsZXJhdGU6IFwiZGVjZWxlcmF0ZVwiLFxuICAgICAgICBkZXNjZW50OiBcImRlc2NlbnRcIixcbiAgICAgICAgZGlmZnVzZWNvbnN0YW50OiBcImRpZmZ1c2VDb25zdGFudFwiLFxuICAgICAgICBkaXJlY3Rpb246IFwiZGlyZWN0aW9uXCIsXG4gICAgICAgIGRpc3BsYXk6IFwiZGlzcGxheVwiLFxuICAgICAgICBkaXZpc29yOiBcImRpdmlzb3JcIixcbiAgICAgICAgZG9taW5hbnRiYXNlbGluZTogXCJkb21pbmFudEJhc2VsaW5lXCIsXG4gICAgICAgIFwiZG9taW5hbnQtYmFzZWxpbmVcIjogXCJkb21pbmFudEJhc2VsaW5lXCIsXG4gICAgICAgIGR1cjogXCJkdXJcIixcbiAgICAgICAgZHg6IFwiZHhcIixcbiAgICAgICAgZHk6IFwiZHlcIixcbiAgICAgICAgZWRnZW1vZGU6IFwiZWRnZU1vZGVcIixcbiAgICAgICAgZWxldmF0aW9uOiBcImVsZXZhdGlvblwiLFxuICAgICAgICBlbmFibGViYWNrZ3JvdW5kOiBcImVuYWJsZUJhY2tncm91bmRcIixcbiAgICAgICAgXCJlbmFibGUtYmFja2dyb3VuZFwiOiBcImVuYWJsZUJhY2tncm91bmRcIixcbiAgICAgICAgZW5kOiBcImVuZFwiLFxuICAgICAgICBleHBvbmVudDogXCJleHBvbmVudFwiLFxuICAgICAgICBleHRlcm5hbHJlc291cmNlc3JlcXVpcmVkOiBcImV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWRcIixcbiAgICAgICAgZmlsbDogXCJmaWxsXCIsXG4gICAgICAgIGZpbGxvcGFjaXR5OiBcImZpbGxPcGFjaXR5XCIsXG4gICAgICAgIFwiZmlsbC1vcGFjaXR5XCI6IFwiZmlsbE9wYWNpdHlcIixcbiAgICAgICAgZmlsbHJ1bGU6IFwiZmlsbFJ1bGVcIixcbiAgICAgICAgXCJmaWxsLXJ1bGVcIjogXCJmaWxsUnVsZVwiLFxuICAgICAgICBmaWx0ZXI6IFwiZmlsdGVyXCIsXG4gICAgICAgIGZpbHRlcnJlczogXCJmaWx0ZXJSZXNcIixcbiAgICAgICAgZmlsdGVydW5pdHM6IFwiZmlsdGVyVW5pdHNcIixcbiAgICAgICAgZmxvb2RvcGFjaXR5OiBcImZsb29kT3BhY2l0eVwiLFxuICAgICAgICBcImZsb29kLW9wYWNpdHlcIjogXCJmbG9vZE9wYWNpdHlcIixcbiAgICAgICAgZmxvb2Rjb2xvcjogXCJmbG9vZENvbG9yXCIsXG4gICAgICAgIFwiZmxvb2QtY29sb3JcIjogXCJmbG9vZENvbG9yXCIsXG4gICAgICAgIGZvY3VzYWJsZTogXCJmb2N1c2FibGVcIixcbiAgICAgICAgZm9udGZhbWlseTogXCJmb250RmFtaWx5XCIsXG4gICAgICAgIFwiZm9udC1mYW1pbHlcIjogXCJmb250RmFtaWx5XCIsXG4gICAgICAgIGZvbnRzaXplOiBcImZvbnRTaXplXCIsXG4gICAgICAgIFwiZm9udC1zaXplXCI6IFwiZm9udFNpemVcIixcbiAgICAgICAgZm9udHNpemVhZGp1c3Q6IFwiZm9udFNpemVBZGp1c3RcIixcbiAgICAgICAgXCJmb250LXNpemUtYWRqdXN0XCI6IFwiZm9udFNpemVBZGp1c3RcIixcbiAgICAgICAgZm9udHN0cmV0Y2g6IFwiZm9udFN0cmV0Y2hcIixcbiAgICAgICAgXCJmb250LXN0cmV0Y2hcIjogXCJmb250U3RyZXRjaFwiLFxuICAgICAgICBmb250c3R5bGU6IFwiZm9udFN0eWxlXCIsXG4gICAgICAgIFwiZm9udC1zdHlsZVwiOiBcImZvbnRTdHlsZVwiLFxuICAgICAgICBmb250dmFyaWFudDogXCJmb250VmFyaWFudFwiLFxuICAgICAgICBcImZvbnQtdmFyaWFudFwiOiBcImZvbnRWYXJpYW50XCIsXG4gICAgICAgIGZvbnR3ZWlnaHQ6IFwiZm9udFdlaWdodFwiLFxuICAgICAgICBcImZvbnQtd2VpZ2h0XCI6IFwiZm9udFdlaWdodFwiLFxuICAgICAgICBmb3JtYXQ6IFwiZm9ybWF0XCIsXG4gICAgICAgIGZyb206IFwiZnJvbVwiLFxuICAgICAgICBmeDogXCJmeFwiLFxuICAgICAgICBmeTogXCJmeVwiLFxuICAgICAgICBnMTogXCJnMVwiLFxuICAgICAgICBnMjogXCJnMlwiLFxuICAgICAgICBnbHlwaG5hbWU6IFwiZ2x5cGhOYW1lXCIsXG4gICAgICAgIFwiZ2x5cGgtbmFtZVwiOiBcImdseXBoTmFtZVwiLFxuICAgICAgICBnbHlwaG9yaWVudGF0aW9uaG9yaXpvbnRhbDogXCJnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbFwiLFxuICAgICAgICBcImdseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWxcIjogXCJnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbFwiLFxuICAgICAgICBnbHlwaG9yaWVudGF0aW9udmVydGljYWw6IFwiZ2x5cGhPcmllbnRhdGlvblZlcnRpY2FsXCIsXG4gICAgICAgIFwiZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWxcIjogXCJnbHlwaE9yaWVudGF0aW9uVmVydGljYWxcIixcbiAgICAgICAgZ2x5cGhyZWY6IFwiZ2x5cGhSZWZcIixcbiAgICAgICAgZ3JhZGllbnR0cmFuc2Zvcm06IFwiZ3JhZGllbnRUcmFuc2Zvcm1cIixcbiAgICAgICAgZ3JhZGllbnR1bml0czogXCJncmFkaWVudFVuaXRzXCIsXG4gICAgICAgIGhhbmdpbmc6IFwiaGFuZ2luZ1wiLFxuICAgICAgICBob3JpemFkdng6IFwiaG9yaXpBZHZYXCIsXG4gICAgICAgIFwiaG9yaXotYWR2LXhcIjogXCJob3JpekFkdlhcIixcbiAgICAgICAgaG9yaXpvcmlnaW54OiBcImhvcml6T3JpZ2luWFwiLFxuICAgICAgICBcImhvcml6LW9yaWdpbi14XCI6IFwiaG9yaXpPcmlnaW5YXCIsXG4gICAgICAgIGlkZW9ncmFwaGljOiBcImlkZW9ncmFwaGljXCIsXG4gICAgICAgIGltYWdlcmVuZGVyaW5nOiBcImltYWdlUmVuZGVyaW5nXCIsXG4gICAgICAgIFwiaW1hZ2UtcmVuZGVyaW5nXCI6IFwiaW1hZ2VSZW5kZXJpbmdcIixcbiAgICAgICAgaW4yOiBcImluMlwiLFxuICAgICAgICBpbjogXCJpblwiLFxuICAgICAgICBpbmxpc3Q6IFwiaW5saXN0XCIsXG4gICAgICAgIGludGVyY2VwdDogXCJpbnRlcmNlcHRcIixcbiAgICAgICAgazE6IFwiazFcIixcbiAgICAgICAgazI6IFwiazJcIixcbiAgICAgICAgazM6IFwiazNcIixcbiAgICAgICAgazQ6IFwiazRcIixcbiAgICAgICAgazogXCJrXCIsXG4gICAgICAgIGtlcm5lbG1hdHJpeDogXCJrZXJuZWxNYXRyaXhcIixcbiAgICAgICAga2VybmVsdW5pdGxlbmd0aDogXCJrZXJuZWxVbml0TGVuZ3RoXCIsXG4gICAgICAgIGtlcm5pbmc6IFwia2VybmluZ1wiLFxuICAgICAgICBrZXlwb2ludHM6IFwia2V5UG9pbnRzXCIsXG4gICAgICAgIGtleXNwbGluZXM6IFwia2V5U3BsaW5lc1wiLFxuICAgICAgICBrZXl0aW1lczogXCJrZXlUaW1lc1wiLFxuICAgICAgICBsZW5ndGhhZGp1c3Q6IFwibGVuZ3RoQWRqdXN0XCIsXG4gICAgICAgIGxldHRlcnNwYWNpbmc6IFwibGV0dGVyU3BhY2luZ1wiLFxuICAgICAgICBcImxldHRlci1zcGFjaW5nXCI6IFwibGV0dGVyU3BhY2luZ1wiLFxuICAgICAgICBsaWdodGluZ2NvbG9yOiBcImxpZ2h0aW5nQ29sb3JcIixcbiAgICAgICAgXCJsaWdodGluZy1jb2xvclwiOiBcImxpZ2h0aW5nQ29sb3JcIixcbiAgICAgICAgbGltaXRpbmdjb25lYW5nbGU6IFwibGltaXRpbmdDb25lQW5nbGVcIixcbiAgICAgICAgbG9jYWw6IFwibG9jYWxcIixcbiAgICAgICAgbWFya2VyZW5kOiBcIm1hcmtlckVuZFwiLFxuICAgICAgICBcIm1hcmtlci1lbmRcIjogXCJtYXJrZXJFbmRcIixcbiAgICAgICAgbWFya2VyaGVpZ2h0OiBcIm1hcmtlckhlaWdodFwiLFxuICAgICAgICBtYXJrZXJtaWQ6IFwibWFya2VyTWlkXCIsXG4gICAgICAgIFwibWFya2VyLW1pZFwiOiBcIm1hcmtlck1pZFwiLFxuICAgICAgICBtYXJrZXJzdGFydDogXCJtYXJrZXJTdGFydFwiLFxuICAgICAgICBcIm1hcmtlci1zdGFydFwiOiBcIm1hcmtlclN0YXJ0XCIsXG4gICAgICAgIG1hcmtlcnVuaXRzOiBcIm1hcmtlclVuaXRzXCIsXG4gICAgICAgIG1hcmtlcndpZHRoOiBcIm1hcmtlcldpZHRoXCIsXG4gICAgICAgIG1hc2s6IFwibWFza1wiLFxuICAgICAgICBtYXNrY29udGVudHVuaXRzOiBcIm1hc2tDb250ZW50VW5pdHNcIixcbiAgICAgICAgbWFza3VuaXRzOiBcIm1hc2tVbml0c1wiLFxuICAgICAgICBtYXRoZW1hdGljYWw6IFwibWF0aGVtYXRpY2FsXCIsXG4gICAgICAgIG1vZGU6IFwibW9kZVwiLFxuICAgICAgICBudW1vY3RhdmVzOiBcIm51bU9jdGF2ZXNcIixcbiAgICAgICAgb2Zmc2V0OiBcIm9mZnNldFwiLFxuICAgICAgICBvcGFjaXR5OiBcIm9wYWNpdHlcIixcbiAgICAgICAgb3BlcmF0b3I6IFwib3BlcmF0b3JcIixcbiAgICAgICAgb3JkZXI6IFwib3JkZXJcIixcbiAgICAgICAgb3JpZW50OiBcIm9yaWVudFwiLFxuICAgICAgICBvcmllbnRhdGlvbjogXCJvcmllbnRhdGlvblwiLFxuICAgICAgICBvcmlnaW46IFwib3JpZ2luXCIsXG4gICAgICAgIG92ZXJmbG93OiBcIm92ZXJmbG93XCIsXG4gICAgICAgIG92ZXJsaW5lcG9zaXRpb246IFwib3ZlcmxpbmVQb3NpdGlvblwiLFxuICAgICAgICBcIm92ZXJsaW5lLXBvc2l0aW9uXCI6IFwib3ZlcmxpbmVQb3NpdGlvblwiLFxuICAgICAgICBvdmVybGluZXRoaWNrbmVzczogXCJvdmVybGluZVRoaWNrbmVzc1wiLFxuICAgICAgICBcIm92ZXJsaW5lLXRoaWNrbmVzc1wiOiBcIm92ZXJsaW5lVGhpY2tuZXNzXCIsXG4gICAgICAgIHBhaW50b3JkZXI6IFwicGFpbnRPcmRlclwiLFxuICAgICAgICBcInBhaW50LW9yZGVyXCI6IFwicGFpbnRPcmRlclwiLFxuICAgICAgICBwYW5vc2UxOiBcInBhbm9zZTFcIixcbiAgICAgICAgXCJwYW5vc2UtMVwiOiBcInBhbm9zZTFcIixcbiAgICAgICAgcGF0aGxlbmd0aDogXCJwYXRoTGVuZ3RoXCIsXG4gICAgICAgIHBhdHRlcm5jb250ZW50dW5pdHM6IFwicGF0dGVybkNvbnRlbnRVbml0c1wiLFxuICAgICAgICBwYXR0ZXJudHJhbnNmb3JtOiBcInBhdHRlcm5UcmFuc2Zvcm1cIixcbiAgICAgICAgcGF0dGVybnVuaXRzOiBcInBhdHRlcm5Vbml0c1wiLFxuICAgICAgICBwb2ludGVyZXZlbnRzOiBcInBvaW50ZXJFdmVudHNcIixcbiAgICAgICAgXCJwb2ludGVyLWV2ZW50c1wiOiBcInBvaW50ZXJFdmVudHNcIixcbiAgICAgICAgcG9pbnRzOiBcInBvaW50c1wiLFxuICAgICAgICBwb2ludHNhdHg6IFwicG9pbnRzQXRYXCIsXG4gICAgICAgIHBvaW50c2F0eTogXCJwb2ludHNBdFlcIixcbiAgICAgICAgcG9pbnRzYXR6OiBcInBvaW50c0F0WlwiLFxuICAgICAgICBwb3BvdmVyOiBcInBvcG92ZXJcIixcbiAgICAgICAgcG9wb3ZlcnRhcmdldDogXCJwb3BvdmVyVGFyZ2V0XCIsXG4gICAgICAgIHBvcG92ZXJ0YXJnZXRhY3Rpb246IFwicG9wb3ZlclRhcmdldEFjdGlvblwiLFxuICAgICAgICBwcmVmaXg6IFwicHJlZml4XCIsXG4gICAgICAgIHByZXNlcnZlYWxwaGE6IFwicHJlc2VydmVBbHBoYVwiLFxuICAgICAgICBwcmVzZXJ2ZWFzcGVjdHJhdGlvOiBcInByZXNlcnZlQXNwZWN0UmF0aW9cIixcbiAgICAgICAgcHJpbWl0aXZldW5pdHM6IFwicHJpbWl0aXZlVW5pdHNcIixcbiAgICAgICAgcHJvcGVydHk6IFwicHJvcGVydHlcIixcbiAgICAgICAgcjogXCJyXCIsXG4gICAgICAgIHJhZGl1czogXCJyYWRpdXNcIixcbiAgICAgICAgcmVmeDogXCJyZWZYXCIsXG4gICAgICAgIHJlZnk6IFwicmVmWVwiLFxuICAgICAgICByZW5kZXJpbmdpbnRlbnQ6IFwicmVuZGVyaW5nSW50ZW50XCIsXG4gICAgICAgIFwicmVuZGVyaW5nLWludGVudFwiOiBcInJlbmRlcmluZ0ludGVudFwiLFxuICAgICAgICByZXBlYXRjb3VudDogXCJyZXBlYXRDb3VudFwiLFxuICAgICAgICByZXBlYXRkdXI6IFwicmVwZWF0RHVyXCIsXG4gICAgICAgIHJlcXVpcmVkZXh0ZW5zaW9uczogXCJyZXF1aXJlZEV4dGVuc2lvbnNcIixcbiAgICAgICAgcmVxdWlyZWRmZWF0dXJlczogXCJyZXF1aXJlZEZlYXR1cmVzXCIsXG4gICAgICAgIHJlc291cmNlOiBcInJlc291cmNlXCIsXG4gICAgICAgIHJlc3RhcnQ6IFwicmVzdGFydFwiLFxuICAgICAgICByZXN1bHQ6IFwicmVzdWx0XCIsXG4gICAgICAgIHJlc3VsdHM6IFwicmVzdWx0c1wiLFxuICAgICAgICByb3RhdGU6IFwicm90YXRlXCIsXG4gICAgICAgIHJ4OiBcInJ4XCIsXG4gICAgICAgIHJ5OiBcInJ5XCIsXG4gICAgICAgIHNjYWxlOiBcInNjYWxlXCIsXG4gICAgICAgIHNlY3VyaXR5OiBcInNlY3VyaXR5XCIsXG4gICAgICAgIHNlZWQ6IFwic2VlZFwiLFxuICAgICAgICBzaGFwZXJlbmRlcmluZzogXCJzaGFwZVJlbmRlcmluZ1wiLFxuICAgICAgICBcInNoYXBlLXJlbmRlcmluZ1wiOiBcInNoYXBlUmVuZGVyaW5nXCIsXG4gICAgICAgIHNsb3BlOiBcInNsb3BlXCIsXG4gICAgICAgIHNwYWNpbmc6IFwic3BhY2luZ1wiLFxuICAgICAgICBzcGVjdWxhcmNvbnN0YW50OiBcInNwZWN1bGFyQ29uc3RhbnRcIixcbiAgICAgICAgc3BlY3VsYXJleHBvbmVudDogXCJzcGVjdWxhckV4cG9uZW50XCIsXG4gICAgICAgIHNwZWVkOiBcInNwZWVkXCIsXG4gICAgICAgIHNwcmVhZG1ldGhvZDogXCJzcHJlYWRNZXRob2RcIixcbiAgICAgICAgc3RhcnRvZmZzZXQ6IFwic3RhcnRPZmZzZXRcIixcbiAgICAgICAgc3RkZGV2aWF0aW9uOiBcInN0ZERldmlhdGlvblwiLFxuICAgICAgICBzdGVtaDogXCJzdGVtaFwiLFxuICAgICAgICBzdGVtdjogXCJzdGVtdlwiLFxuICAgICAgICBzdGl0Y2h0aWxlczogXCJzdGl0Y2hUaWxlc1wiLFxuICAgICAgICBzdG9wY29sb3I6IFwic3RvcENvbG9yXCIsXG4gICAgICAgIFwic3RvcC1jb2xvclwiOiBcInN0b3BDb2xvclwiLFxuICAgICAgICBzdG9wb3BhY2l0eTogXCJzdG9wT3BhY2l0eVwiLFxuICAgICAgICBcInN0b3Atb3BhY2l0eVwiOiBcInN0b3BPcGFjaXR5XCIsXG4gICAgICAgIHN0cmlrZXRocm91Z2hwb3NpdGlvbjogXCJzdHJpa2V0aHJvdWdoUG9zaXRpb25cIixcbiAgICAgICAgXCJzdHJpa2V0aHJvdWdoLXBvc2l0aW9uXCI6IFwic3RyaWtldGhyb3VnaFBvc2l0aW9uXCIsXG4gICAgICAgIHN0cmlrZXRocm91Z2h0aGlja25lc3M6IFwic3RyaWtldGhyb3VnaFRoaWNrbmVzc1wiLFxuICAgICAgICBcInN0cmlrZXRocm91Z2gtdGhpY2tuZXNzXCI6IFwic3RyaWtldGhyb3VnaFRoaWNrbmVzc1wiLFxuICAgICAgICBzdHJpbmc6IFwic3RyaW5nXCIsXG4gICAgICAgIHN0cm9rZTogXCJzdHJva2VcIixcbiAgICAgICAgc3Ryb2tlZGFzaGFycmF5OiBcInN0cm9rZURhc2hhcnJheVwiLFxuICAgICAgICBcInN0cm9rZS1kYXNoYXJyYXlcIjogXCJzdHJva2VEYXNoYXJyYXlcIixcbiAgICAgICAgc3Ryb2tlZGFzaG9mZnNldDogXCJzdHJva2VEYXNob2Zmc2V0XCIsXG4gICAgICAgIFwic3Ryb2tlLWRhc2hvZmZzZXRcIjogXCJzdHJva2VEYXNob2Zmc2V0XCIsXG4gICAgICAgIHN0cm9rZWxpbmVjYXA6IFwic3Ryb2tlTGluZWNhcFwiLFxuICAgICAgICBcInN0cm9rZS1saW5lY2FwXCI6IFwic3Ryb2tlTGluZWNhcFwiLFxuICAgICAgICBzdHJva2VsaW5lam9pbjogXCJzdHJva2VMaW5lam9pblwiLFxuICAgICAgICBcInN0cm9rZS1saW5lam9pblwiOiBcInN0cm9rZUxpbmVqb2luXCIsXG4gICAgICAgIHN0cm9rZW1pdGVybGltaXQ6IFwic3Ryb2tlTWl0ZXJsaW1pdFwiLFxuICAgICAgICBcInN0cm9rZS1taXRlcmxpbWl0XCI6IFwic3Ryb2tlTWl0ZXJsaW1pdFwiLFxuICAgICAgICBzdHJva2V3aWR0aDogXCJzdHJva2VXaWR0aFwiLFxuICAgICAgICBcInN0cm9rZS13aWR0aFwiOiBcInN0cm9rZVdpZHRoXCIsXG4gICAgICAgIHN0cm9rZW9wYWNpdHk6IFwic3Ryb2tlT3BhY2l0eVwiLFxuICAgICAgICBcInN0cm9rZS1vcGFjaXR5XCI6IFwic3Ryb2tlT3BhY2l0eVwiLFxuICAgICAgICBzdXBwcmVzc2NvbnRlbnRlZGl0YWJsZXdhcm5pbmc6IFwic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nXCIsXG4gICAgICAgIHN1cHByZXNzaHlkcmF0aW9ud2FybmluZzogXCJzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmdcIixcbiAgICAgICAgc3VyZmFjZXNjYWxlOiBcInN1cmZhY2VTY2FsZVwiLFxuICAgICAgICBzeXN0ZW1sYW5ndWFnZTogXCJzeXN0ZW1MYW5ndWFnZVwiLFxuICAgICAgICB0YWJsZXZhbHVlczogXCJ0YWJsZVZhbHVlc1wiLFxuICAgICAgICB0YXJnZXR4OiBcInRhcmdldFhcIixcbiAgICAgICAgdGFyZ2V0eTogXCJ0YXJnZXRZXCIsXG4gICAgICAgIHRleHRhbmNob3I6IFwidGV4dEFuY2hvclwiLFxuICAgICAgICBcInRleHQtYW5jaG9yXCI6IFwidGV4dEFuY2hvclwiLFxuICAgICAgICB0ZXh0ZGVjb3JhdGlvbjogXCJ0ZXh0RGVjb3JhdGlvblwiLFxuICAgICAgICBcInRleHQtZGVjb3JhdGlvblwiOiBcInRleHREZWNvcmF0aW9uXCIsXG4gICAgICAgIHRleHRsZW5ndGg6IFwidGV4dExlbmd0aFwiLFxuICAgICAgICB0ZXh0cmVuZGVyaW5nOiBcInRleHRSZW5kZXJpbmdcIixcbiAgICAgICAgXCJ0ZXh0LXJlbmRlcmluZ1wiOiBcInRleHRSZW5kZXJpbmdcIixcbiAgICAgICAgdG86IFwidG9cIixcbiAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zZm9ybVwiLFxuICAgICAgICB0cmFuc2Zvcm1vcmlnaW46IFwidHJhbnNmb3JtT3JpZ2luXCIsXG4gICAgICAgIFwidHJhbnNmb3JtLW9yaWdpblwiOiBcInRyYW5zZm9ybU9yaWdpblwiLFxuICAgICAgICB0eXBlb2Y6IFwidHlwZW9mXCIsXG4gICAgICAgIHUxOiBcInUxXCIsXG4gICAgICAgIHUyOiBcInUyXCIsXG4gICAgICAgIHVuZGVybGluZXBvc2l0aW9uOiBcInVuZGVybGluZVBvc2l0aW9uXCIsXG4gICAgICAgIFwidW5kZXJsaW5lLXBvc2l0aW9uXCI6IFwidW5kZXJsaW5lUG9zaXRpb25cIixcbiAgICAgICAgdW5kZXJsaW5ldGhpY2tuZXNzOiBcInVuZGVybGluZVRoaWNrbmVzc1wiLFxuICAgICAgICBcInVuZGVybGluZS10aGlja25lc3NcIjogXCJ1bmRlcmxpbmVUaGlja25lc3NcIixcbiAgICAgICAgdW5pY29kZTogXCJ1bmljb2RlXCIsXG4gICAgICAgIHVuaWNvZGViaWRpOiBcInVuaWNvZGVCaWRpXCIsXG4gICAgICAgIFwidW5pY29kZS1iaWRpXCI6IFwidW5pY29kZUJpZGlcIixcbiAgICAgICAgdW5pY29kZXJhbmdlOiBcInVuaWNvZGVSYW5nZVwiLFxuICAgICAgICBcInVuaWNvZGUtcmFuZ2VcIjogXCJ1bmljb2RlUmFuZ2VcIixcbiAgICAgICAgdW5pdHNwZXJlbTogXCJ1bml0c1BlckVtXCIsXG4gICAgICAgIFwidW5pdHMtcGVyLWVtXCI6IFwidW5pdHNQZXJFbVwiLFxuICAgICAgICB1bnNlbGVjdGFibGU6IFwidW5zZWxlY3RhYmxlXCIsXG4gICAgICAgIHZhbHBoYWJldGljOiBcInZBbHBoYWJldGljXCIsXG4gICAgICAgIFwidi1hbHBoYWJldGljXCI6IFwidkFscGhhYmV0aWNcIixcbiAgICAgICAgdmFsdWVzOiBcInZhbHVlc1wiLFxuICAgICAgICB2ZWN0b3JlZmZlY3Q6IFwidmVjdG9yRWZmZWN0XCIsXG4gICAgICAgIFwidmVjdG9yLWVmZmVjdFwiOiBcInZlY3RvckVmZmVjdFwiLFxuICAgICAgICB2ZXJzaW9uOiBcInZlcnNpb25cIixcbiAgICAgICAgdmVydGFkdnk6IFwidmVydEFkdllcIixcbiAgICAgICAgXCJ2ZXJ0LWFkdi15XCI6IFwidmVydEFkdllcIixcbiAgICAgICAgdmVydG9yaWdpbng6IFwidmVydE9yaWdpblhcIixcbiAgICAgICAgXCJ2ZXJ0LW9yaWdpbi14XCI6IFwidmVydE9yaWdpblhcIixcbiAgICAgICAgdmVydG9yaWdpbnk6IFwidmVydE9yaWdpbllcIixcbiAgICAgICAgXCJ2ZXJ0LW9yaWdpbi15XCI6IFwidmVydE9yaWdpbllcIixcbiAgICAgICAgdmhhbmdpbmc6IFwidkhhbmdpbmdcIixcbiAgICAgICAgXCJ2LWhhbmdpbmdcIjogXCJ2SGFuZ2luZ1wiLFxuICAgICAgICB2aWRlb2dyYXBoaWM6IFwidklkZW9ncmFwaGljXCIsXG4gICAgICAgIFwidi1pZGVvZ3JhcGhpY1wiOiBcInZJZGVvZ3JhcGhpY1wiLFxuICAgICAgICB2aWV3Ym94OiBcInZpZXdCb3hcIixcbiAgICAgICAgdmlld3RhcmdldDogXCJ2aWV3VGFyZ2V0XCIsXG4gICAgICAgIHZpc2liaWxpdHk6IFwidmlzaWJpbGl0eVwiLFxuICAgICAgICB2bWF0aGVtYXRpY2FsOiBcInZNYXRoZW1hdGljYWxcIixcbiAgICAgICAgXCJ2LW1hdGhlbWF0aWNhbFwiOiBcInZNYXRoZW1hdGljYWxcIixcbiAgICAgICAgdm9jYWI6IFwidm9jYWJcIixcbiAgICAgICAgd2lkdGhzOiBcIndpZHRoc1wiLFxuICAgICAgICB3b3Jkc3BhY2luZzogXCJ3b3JkU3BhY2luZ1wiLFxuICAgICAgICBcIndvcmQtc3BhY2luZ1wiOiBcIndvcmRTcGFjaW5nXCIsXG4gICAgICAgIHdyaXRpbmdtb2RlOiBcIndyaXRpbmdNb2RlXCIsXG4gICAgICAgIFwid3JpdGluZy1tb2RlXCI6IFwid3JpdGluZ01vZGVcIixcbiAgICAgICAgeDE6IFwieDFcIixcbiAgICAgICAgeDI6IFwieDJcIixcbiAgICAgICAgeDogXCJ4XCIsXG4gICAgICAgIHhjaGFubmVsc2VsZWN0b3I6IFwieENoYW5uZWxTZWxlY3RvclwiLFxuICAgICAgICB4aGVpZ2h0OiBcInhIZWlnaHRcIixcbiAgICAgICAgXCJ4LWhlaWdodFwiOiBcInhIZWlnaHRcIixcbiAgICAgICAgeGxpbmthY3R1YXRlOiBcInhsaW5rQWN0dWF0ZVwiLFxuICAgICAgICBcInhsaW5rOmFjdHVhdGVcIjogXCJ4bGlua0FjdHVhdGVcIixcbiAgICAgICAgeGxpbmthcmNyb2xlOiBcInhsaW5rQXJjcm9sZVwiLFxuICAgICAgICBcInhsaW5rOmFyY3JvbGVcIjogXCJ4bGlua0FyY3JvbGVcIixcbiAgICAgICAgeGxpbmtocmVmOiBcInhsaW5rSHJlZlwiLFxuICAgICAgICBcInhsaW5rOmhyZWZcIjogXCJ4bGlua0hyZWZcIixcbiAgICAgICAgeGxpbmtyb2xlOiBcInhsaW5rUm9sZVwiLFxuICAgICAgICBcInhsaW5rOnJvbGVcIjogXCJ4bGlua1JvbGVcIixcbiAgICAgICAgeGxpbmtzaG93OiBcInhsaW5rU2hvd1wiLFxuICAgICAgICBcInhsaW5rOnNob3dcIjogXCJ4bGlua1Nob3dcIixcbiAgICAgICAgeGxpbmt0aXRsZTogXCJ4bGlua1RpdGxlXCIsXG4gICAgICAgIFwieGxpbms6dGl0bGVcIjogXCJ4bGlua1RpdGxlXCIsXG4gICAgICAgIHhsaW5rdHlwZTogXCJ4bGlua1R5cGVcIixcbiAgICAgICAgXCJ4bGluazp0eXBlXCI6IFwieGxpbmtUeXBlXCIsXG4gICAgICAgIHhtbGJhc2U6IFwieG1sQmFzZVwiLFxuICAgICAgICBcInhtbDpiYXNlXCI6IFwieG1sQmFzZVwiLFxuICAgICAgICB4bWxsYW5nOiBcInhtbExhbmdcIixcbiAgICAgICAgXCJ4bWw6bGFuZ1wiOiBcInhtbExhbmdcIixcbiAgICAgICAgeG1sbnM6IFwieG1sbnNcIixcbiAgICAgICAgXCJ4bWw6c3BhY2VcIjogXCJ4bWxTcGFjZVwiLFxuICAgICAgICB4bWxuc3hsaW5rOiBcInhtbG5zWGxpbmtcIixcbiAgICAgICAgXCJ4bWxuczp4bGlua1wiOiBcInhtbG5zWGxpbmtcIixcbiAgICAgICAgeG1sc3BhY2U6IFwieG1sU3BhY2VcIixcbiAgICAgICAgeTE6IFwieTFcIixcbiAgICAgICAgeTI6IFwieTJcIixcbiAgICAgICAgeTogXCJ5XCIsXG4gICAgICAgIHljaGFubmVsc2VsZWN0b3I6IFwieUNoYW5uZWxTZWxlY3RvclwiLFxuICAgICAgICB6OiBcInpcIixcbiAgICAgICAgem9vbWFuZHBhbjogXCJ6b29tQW5kUGFuXCJcbiAgICAgIH0sXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzID0ge30sXG4gICAgICBFVkVOVF9OQU1FX1JFR0VYID0gL15vbi4vLFxuICAgICAgSU5WQUxJRF9FVkVOVF9OQU1FX1JFR0VYID0gL15vblteQS1aXS8sXG4gICAgICByQVJJQSA9IFJlZ0V4cChcbiAgICAgICAgXCJeKGFyaWEpLVs6QS1aX2EtelxcXFx1MDBDMC1cXFxcdTAwRDZcXFxcdTAwRDgtXFxcXHUwMEY2XFxcXHUwMEY4LVxcXFx1MDJGRlxcXFx1MDM3MC1cXFxcdTAzN0RcXFxcdTAzN0YtXFxcXHUxRkZGXFxcXHUyMDBDLVxcXFx1MjAwRFxcXFx1MjA3MC1cXFxcdTIxOEZcXFxcdTJDMDAtXFxcXHUyRkVGXFxcXHUzMDAxLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkZEXFxcXC0uMC05XFxcXHUwMEI3XFxcXHUwMzAwLVxcXFx1MDM2RlxcXFx1MjAzRi1cXFxcdTIwNDBdKiRcIlxuICAgICAgKSxcbiAgICAgIHJBUklBQ2FtZWwgPSBSZWdFeHAoXG4gICAgICAgIFwiXihhcmlhKVtBLVpdWzpBLVpfYS16XFxcXHUwMEMwLVxcXFx1MDBENlxcXFx1MDBEOC1cXFxcdTAwRjZcXFxcdTAwRjgtXFxcXHUwMkZGXFxcXHUwMzcwLVxcXFx1MDM3RFxcXFx1MDM3Ri1cXFxcdTFGRkZcXFxcdTIwMEMtXFxcXHUyMDBEXFxcXHUyMDcwLVxcXFx1MjE4RlxcXFx1MkMwMC1cXFxcdTJGRUZcXFxcdTMwMDEtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRkRcXFxcLS4wLTlcXFxcdTAwQjdcXFxcdTAzMDAtXFxcXHUwMzZGXFxcXHUyMDNGLVxcXFx1MjA0MF0qJFwiXG4gICAgICApLFxuICAgICAgYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuID0gL14oPzp3ZWJraXR8bW96fG8pW0EtWl0vLFxuICAgICAgbXNQYXR0ZXJuJDEgPSAvXi1tcy0vLFxuICAgICAgaHlwaGVuUGF0dGVybiA9IC8tKC4pL2csXG4gICAgICBiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4gPSAvO1xccyokLyxcbiAgICAgIHdhcm5lZFN0eWxlTmFtZXMgPSB7fSxcbiAgICAgIHdhcm5lZFN0eWxlVmFsdWVzID0ge30sXG4gICAgICB3YXJuZWRGb3JOYU5WYWx1ZSA9ICExLFxuICAgICAgd2FybmVkRm9ySW5maW5pdHlWYWx1ZSA9ICExLFxuICAgICAgbWF0Y2hIdG1sUmVnRXhwID0gL1tcIicmPD5dLyxcbiAgICAgIHVwcGVyY2FzZVBhdHRlcm4gPSAvKFtBLVpdKS9nLFxuICAgICAgbXNQYXR0ZXJuID0gL15tcy0vLFxuICAgICAgaXNKYXZhU2NyaXB0UHJvdG9jb2wgPVxuICAgICAgICAvXltcXHUwMDAwLVxcdTAwMUYgXSpqW1xcclxcblxcdF0qYVtcXHJcXG5cXHRdKnZbXFxyXFxuXFx0XSphW1xcclxcblxcdF0qc1tcXHJcXG5cXHRdKmNbXFxyXFxuXFx0XSpyW1xcclxcblxcdF0qaVtcXHJcXG5cXHRdKnBbXFxyXFxuXFx0XSp0W1xcclxcblxcdF0qOi9pLFxuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPVxuICAgICAgICBSZWFjdC5fX0NMSUVOVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREUsXG4gICAgICBSZWFjdERPTVNoYXJlZEludGVybmFscyA9XG4gICAgICAgIFJlYWN0RE9NLl9fRE9NX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1dBUk5fVVNFUlNfVEhFWV9DQU5OT1RfVVBHUkFERSxcbiAgICAgIE5vdFBlbmRpbmcgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgcGVuZGluZzogITEsXG4gICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgIG1ldGhvZDogbnVsbCxcbiAgICAgICAgYWN0aW9uOiBudWxsXG4gICAgICB9KSxcbiAgICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0RE9NU2hhcmVkSW50ZXJuYWxzLmQ7XG4gICAgUmVhY3RET01TaGFyZWRJbnRlcm5hbHMuZCA9IHtcbiAgICAgIGY6IHByZXZpb3VzRGlzcGF0Y2hlci5mLFxuICAgICAgcjogcHJldmlvdXNEaXNwYXRjaGVyLnIsXG4gICAgICBEOiBmdW5jdGlvbiAoaHJlZikge1xuICAgICAgICB2YXIgcmVxdWVzdCA9IGN1cnJlbnRSZXF1ZXN0ID8gY3VycmVudFJlcXVlc3QgOiBudWxsO1xuICAgICAgICBpZiAocmVxdWVzdCkge1xuICAgICAgICAgIHZhciByZXN1bWFibGVTdGF0ZSA9IHJlcXVlc3QucmVzdW1hYmxlU3RhdGUsXG4gICAgICAgICAgICByZW5kZXJTdGF0ZSA9IHJlcXVlc3QucmVuZGVyU3RhdGU7XG4gICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBocmVmICYmIGhyZWYpIHtcbiAgICAgICAgICAgIGlmICghcmVzdW1hYmxlU3RhdGUuZG5zUmVzb3VyY2VzLmhhc093blByb3BlcnR5KGhyZWYpKSB7XG4gICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLmRuc1Jlc291cmNlc1tocmVmXSA9IEVYSVNUUztcbiAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUgPSByZW5kZXJTdGF0ZS5oZWFkZXJzO1xuICAgICAgICAgICAgICB2YXIgaGVhZGVyLCBKU0NvbXBpbGVyX3RlbXA7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoSlNDb21waWxlcl90ZW1wID1cbiAgICAgICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlICYmIDAgPCByZXN1bWFibGVTdGF0ZS5yZW1haW5pbmdDYXBhY2l0eSlcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcCA9XG4gICAgICAgICAgICAgICAgICAoKGhlYWRlciA9XG4gICAgICAgICAgICAgICAgICAgIFwiPFwiICtcbiAgICAgICAgICAgICAgICAgICAgZXNjYXBlSHJlZkZvckxpbmtIZWFkZXJVUkxDb250ZXh0KGhyZWYpICtcbiAgICAgICAgICAgICAgICAgICAgXCI+OyByZWw9ZG5zLXByZWZldGNoXCIpLFxuICAgICAgICAgICAgICAgICAgMCA8PSAocmVzdW1hYmxlU3RhdGUucmVtYWluaW5nQ2FwYWNpdHkgLT0gaGVhZGVyLmxlbmd0aCArIDIpKTtcbiAgICAgICAgICAgICAgSlNDb21waWxlcl90ZW1wXG4gICAgICAgICAgICAgICAgPyAoKHJlbmRlclN0YXRlLnJlc2V0cy5kbnNbaHJlZl0gPSBFWElTVFMpLFxuICAgICAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUucHJlY29ubmVjdHMgJiZcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VtYWJsZVN0YXRlLnByZWNvbm5lY3RzICs9IFwiLCBcIiksXG4gICAgICAgICAgICAgICAgICAocmVzdW1hYmxlU3RhdGUucHJlY29ubmVjdHMgKz0gaGVhZGVyKSlcbiAgICAgICAgICAgICAgICA6ICgoaGVhZGVyID0gW10pLFxuICAgICAgICAgICAgICAgICAgcHVzaExpbmtJbXBsKGhlYWRlciwgeyBocmVmOiBocmVmLCByZWw6IFwiZG5zLXByZWZldGNoXCIgfSksXG4gICAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5wcmVjb25uZWN0cy5hZGQoaGVhZGVyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbnF1ZXVlRmx1c2gocmVxdWVzdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgcHJldmlvdXNEaXNwYXRjaGVyLkQoaHJlZik7XG4gICAgICB9LFxuICAgICAgQzogZnVuY3Rpb24gKGhyZWYsIGNyb3NzT3JpZ2luKSB7XG4gICAgICAgIHZhciByZXF1ZXN0ID0gY3VycmVudFJlcXVlc3QgPyBjdXJyZW50UmVxdWVzdCA6IG51bGw7XG4gICAgICAgIGlmIChyZXF1ZXN0KSB7XG4gICAgICAgICAgdmFyIHJlc3VtYWJsZVN0YXRlID0gcmVxdWVzdC5yZXN1bWFibGVTdGF0ZSxcbiAgICAgICAgICAgIHJlbmRlclN0YXRlID0gcmVxdWVzdC5yZW5kZXJTdGF0ZTtcbiAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGhyZWYgJiYgaHJlZikge1xuICAgICAgICAgICAgdmFyIGJ1Y2tldCA9XG4gICAgICAgICAgICAgIFwidXNlLWNyZWRlbnRpYWxzXCIgPT09IGNyb3NzT3JpZ2luXG4gICAgICAgICAgICAgICAgPyBcImNyZWRlbnRpYWxzXCJcbiAgICAgICAgICAgICAgICA6IFwic3RyaW5nXCIgPT09IHR5cGVvZiBjcm9zc09yaWdpblxuICAgICAgICAgICAgICAgICAgPyBcImFub255bW91c1wiXG4gICAgICAgICAgICAgICAgICA6IFwiZGVmYXVsdFwiO1xuICAgICAgICAgICAgaWYgKCFyZXN1bWFibGVTdGF0ZS5jb25uZWN0UmVzb3VyY2VzW2J1Y2tldF0uaGFzT3duUHJvcGVydHkoaHJlZikpIHtcbiAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUuY29ubmVjdFJlc291cmNlc1tidWNrZXRdW2hyZWZdID0gRVhJU1RTO1xuICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZSA9IHJlbmRlclN0YXRlLmhlYWRlcnM7XG4gICAgICAgICAgICAgIHZhciBoZWFkZXIsIEpTQ29tcGlsZXJfdGVtcDtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIChKU0NvbXBpbGVyX3RlbXAgPVxuICAgICAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUgJiYgMCA8IHJlc3VtYWJsZVN0YXRlLnJlbWFpbmluZ0NhcGFjaXR5KVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAgPVxuICAgICAgICAgICAgICAgICAgXCI8XCIgK1xuICAgICAgICAgICAgICAgICAgZXNjYXBlSHJlZkZvckxpbmtIZWFkZXJVUkxDb250ZXh0KGhyZWYpICtcbiAgICAgICAgICAgICAgICAgIFwiPjsgcmVsPXByZWNvbm5lY3RcIjtcbiAgICAgICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGNyb3NzT3JpZ2luKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZXNjYXBlZENyb3NzT3JpZ2luID1cbiAgICAgICAgICAgICAgICAgICAgZXNjYXBlU3RyaW5nRm9yTGlua0hlYWRlclF1b3RlZFBhcmFtVmFsdWVDb250ZXh0KFxuICAgICAgICAgICAgICAgICAgICAgIGNyb3NzT3JpZ2luLFxuICAgICAgICAgICAgICAgICAgICAgIFwiY3Jvc3NPcmlnaW5cIlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgSlNDb21waWxlcl90ZW1wICs9XG4gICAgICAgICAgICAgICAgICAgICc7IGNyb3Nzb3JpZ2luPVwiJyArIGVzY2FwZWRDcm9zc09yaWdpbiArICdcIic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcCA9XG4gICAgICAgICAgICAgICAgICAoKGhlYWRlciA9IEpTQ29tcGlsZXJfdGVtcCksXG4gICAgICAgICAgICAgICAgICAwIDw9IChyZXN1bWFibGVTdGF0ZS5yZW1haW5pbmdDYXBhY2l0eSAtPSBoZWFkZXIubGVuZ3RoICsgMikpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcFxuICAgICAgICAgICAgICAgID8gKChyZW5kZXJTdGF0ZS5yZXNldHMuY29ubmVjdFtidWNrZXRdW2hyZWZdID0gRVhJU1RTKSxcbiAgICAgICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLnByZWNvbm5lY3RzICYmXG4gICAgICAgICAgICAgICAgICAgIChyZXN1bWFibGVTdGF0ZS5wcmVjb25uZWN0cyArPSBcIiwgXCIpLFxuICAgICAgICAgICAgICAgICAgKHJlc3VtYWJsZVN0YXRlLnByZWNvbm5lY3RzICs9IGhlYWRlcikpXG4gICAgICAgICAgICAgICAgOiAoKGJ1Y2tldCA9IFtdKSxcbiAgICAgICAgICAgICAgICAgIHB1c2hMaW5rSW1wbChidWNrZXQsIHtcbiAgICAgICAgICAgICAgICAgICAgcmVsOiBcInByZWNvbm5lY3RcIixcbiAgICAgICAgICAgICAgICAgICAgaHJlZjogaHJlZixcbiAgICAgICAgICAgICAgICAgICAgY3Jvc3NPcmlnaW46IGNyb3NzT3JpZ2luXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlLnByZWNvbm5lY3RzLmFkZChidWNrZXQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVucXVldWVGbHVzaChyZXF1ZXN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBwcmV2aW91c0Rpc3BhdGNoZXIuQyhocmVmLCBjcm9zc09yaWdpbik7XG4gICAgICB9LFxuICAgICAgTDogZnVuY3Rpb24gKGhyZWYsIGFzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciByZXF1ZXN0ID0gY3VycmVudFJlcXVlc3QgPyBjdXJyZW50UmVxdWVzdCA6IG51bGw7XG4gICAgICAgIGlmIChyZXF1ZXN0KSB7XG4gICAgICAgICAgdmFyIHJlc3VtYWJsZVN0YXRlID0gcmVxdWVzdC5yZXN1bWFibGVTdGF0ZSxcbiAgICAgICAgICAgIHJlbmRlclN0YXRlID0gcmVxdWVzdC5yZW5kZXJTdGF0ZTtcbiAgICAgICAgICBpZiAoYXMgJiYgaHJlZikge1xuICAgICAgICAgICAgc3dpdGNoIChhcykge1xuICAgICAgICAgICAgICBjYXNlIFwiaW1hZ2VcIjpcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgdmFyIGltYWdlU3JjU2V0ID0gb3B0aW9ucy5pbWFnZVNyY1NldDtcbiAgICAgICAgICAgICAgICAgIHZhciBpbWFnZVNpemVzID0gb3B0aW9ucy5pbWFnZVNpemVzO1xuICAgICAgICAgICAgICAgICAgdmFyIGZldGNoUHJpb3JpdHkgPSBvcHRpb25zLmZldGNoUHJpb3JpdHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBpbWFnZVNyY1NldFxuICAgICAgICAgICAgICAgICAgPyBpbWFnZVNyY1NldCArIFwiXFxuXCIgKyAoaW1hZ2VTaXplcyB8fCBcIlwiKVxuICAgICAgICAgICAgICAgICAgOiBocmVmO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bWFibGVTdGF0ZS5pbWFnZVJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSByZXR1cm47XG4gICAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUuaW1hZ2VSZXNvdXJjZXNba2V5XSA9IFBSRUxPQURfTk9fQ1JFRFM7XG4gICAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUgPSByZW5kZXJTdGF0ZS5oZWFkZXJzO1xuICAgICAgICAgICAgICAgIHZhciBoZWFkZXI7XG4gICAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUgJiZcbiAgICAgICAgICAgICAgICAwIDwgcmVzdW1hYmxlU3RhdGUucmVtYWluaW5nQ2FwYWNpdHkgJiZcbiAgICAgICAgICAgICAgICBcInN0cmluZ1wiICE9PSB0eXBlb2YgaW1hZ2VTcmNTZXQgJiZcbiAgICAgICAgICAgICAgICBcImhpZ2hcIiA9PT0gZmV0Y2hQcmlvcml0eSAmJlxuICAgICAgICAgICAgICAgICgoaGVhZGVyID0gZ2V0UHJlbG9hZEFzSGVhZGVyKGhyZWYsIGFzLCBvcHRpb25zKSksXG4gICAgICAgICAgICAgICAgMCA8PSAocmVzdW1hYmxlU3RhdGUucmVtYWluaW5nQ2FwYWNpdHkgLT0gaGVhZGVyLmxlbmd0aCArIDIpKVxuICAgICAgICAgICAgICAgICAgPyAoKHJlbmRlclN0YXRlLnJlc2V0cy5pbWFnZVtrZXldID0gUFJFTE9BRF9OT19DUkVEUyksXG4gICAgICAgICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLmhpZ2hJbWFnZVByZWxvYWRzICYmXG4gICAgICAgICAgICAgICAgICAgICAgKHJlc3VtYWJsZVN0YXRlLmhpZ2hJbWFnZVByZWxvYWRzICs9IFwiLCBcIiksXG4gICAgICAgICAgICAgICAgICAgIChyZXN1bWFibGVTdGF0ZS5oaWdoSW1hZ2VQcmVsb2FkcyArPSBoZWFkZXIpKVxuICAgICAgICAgICAgICAgICAgOiAoKHJlc3VtYWJsZVN0YXRlID0gW10pLFxuICAgICAgICAgICAgICAgICAgICBwdXNoTGlua0ltcGwoXG4gICAgICAgICAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgYXNzaWduKFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZWw6IFwicHJlbG9hZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBocmVmOiBpbWFnZVNyY1NldCA/IHZvaWQgMCA6IGhyZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFzOiBhc1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIFwiaGlnaFwiID09PSBmZXRjaFByaW9yaXR5XG4gICAgICAgICAgICAgICAgICAgICAgPyByZW5kZXJTdGF0ZS5oaWdoSW1hZ2VQcmVsb2Fkcy5hZGQocmVzdW1hYmxlU3RhdGUpXG4gICAgICAgICAgICAgICAgICAgICAgOiAocmVuZGVyU3RhdGUuYnVsa1ByZWxvYWRzLmFkZChyZXN1bWFibGVTdGF0ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5wcmVsb2Fkcy5pbWFnZXMuc2V0KGtleSwgcmVzdW1hYmxlU3RhdGUpKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJzdHlsZVwiOlxuICAgICAgICAgICAgICAgIGlmIChyZXN1bWFibGVTdGF0ZS5zdHlsZVJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShocmVmKSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGltYWdlU3JjU2V0ID0gW107XG4gICAgICAgICAgICAgICAgcHVzaExpbmtJbXBsKFxuICAgICAgICAgICAgICAgICAgaW1hZ2VTcmNTZXQsXG4gICAgICAgICAgICAgICAgICBhc3NpZ24oeyByZWw6IFwicHJlbG9hZFwiLCBocmVmOiBocmVmLCBhczogYXMgfSwgb3B0aW9ucylcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLnN0eWxlUmVzb3VyY2VzW2hyZWZdID1cbiAgICAgICAgICAgICAgICAgICFvcHRpb25zIHx8XG4gICAgICAgICAgICAgICAgICAoXCJzdHJpbmdcIiAhPT0gdHlwZW9mIG9wdGlvbnMuY3Jvc3NPcmlnaW4gJiZcbiAgICAgICAgICAgICAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIG9wdGlvbnMuaW50ZWdyaXR5KVxuICAgICAgICAgICAgICAgICAgICA/IFBSRUxPQURfTk9fQ1JFRFNcbiAgICAgICAgICAgICAgICAgICAgOiBbb3B0aW9ucy5jcm9zc09yaWdpbiwgb3B0aW9ucy5pbnRlZ3JpdHldO1xuICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlLnByZWxvYWRzLnN0eWxlc2hlZXRzLnNldChocmVmLCBpbWFnZVNyY1NldCk7XG4gICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUuYnVsa1ByZWxvYWRzLmFkZChpbWFnZVNyY1NldCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJzY3JpcHRcIjpcbiAgICAgICAgICAgICAgICBpZiAocmVzdW1hYmxlU3RhdGUuc2NyaXB0UmVzb3VyY2VzLmhhc093blByb3BlcnR5KGhyZWYpKSByZXR1cm47XG4gICAgICAgICAgICAgICAgaW1hZ2VTcmNTZXQgPSBbXTtcbiAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5wcmVsb2Fkcy5zY3JpcHRzLnNldChocmVmLCBpbWFnZVNyY1NldCk7XG4gICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUuYnVsa1ByZWxvYWRzLmFkZChpbWFnZVNyY1NldCk7XG4gICAgICAgICAgICAgICAgcHVzaExpbmtJbXBsKFxuICAgICAgICAgICAgICAgICAgaW1hZ2VTcmNTZXQsXG4gICAgICAgICAgICAgICAgICBhc3NpZ24oeyByZWw6IFwicHJlbG9hZFwiLCBocmVmOiBocmVmLCBhczogYXMgfSwgb3B0aW9ucylcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLnNjcmlwdFJlc291cmNlc1tocmVmXSA9XG4gICAgICAgICAgICAgICAgICAhb3B0aW9ucyB8fFxuICAgICAgICAgICAgICAgICAgKFwic3RyaW5nXCIgIT09IHR5cGVvZiBvcHRpb25zLmNyb3NzT3JpZ2luICYmXG4gICAgICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgIT09IHR5cGVvZiBvcHRpb25zLmludGVncml0eSlcbiAgICAgICAgICAgICAgICAgICAgPyBQUkVMT0FEX05PX0NSRURTXG4gICAgICAgICAgICAgICAgICAgIDogW29wdGlvbnMuY3Jvc3NPcmlnaW4sIG9wdGlvbnMuaW50ZWdyaXR5XTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAocmVzdW1hYmxlU3RhdGUudW5rbm93blJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShhcykpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgKChpbWFnZVNyY1NldCA9IHJlc3VtYWJsZVN0YXRlLnVua25vd25SZXNvdXJjZXNbYXNdKSxcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VTcmNTZXQuaGFzT3duUHJvcGVydHkoaHJlZikpXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgIChpbWFnZVNyY1NldCA9IHt9KSxcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VtYWJsZVN0YXRlLnVua25vd25SZXNvdXJjZXNbYXNdID0gaW1hZ2VTcmNTZXQpO1xuICAgICAgICAgICAgICAgIGltYWdlU3JjU2V0W2hyZWZdID0gUFJFTE9BRF9OT19DUkVEUztcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAocmVzdW1hYmxlU3RhdGUgPSByZW5kZXJTdGF0ZS5oZWFkZXJzKSAmJlxuICAgICAgICAgICAgICAgICAgMCA8IHJlc3VtYWJsZVN0YXRlLnJlbWFpbmluZ0NhcGFjaXR5ICYmXG4gICAgICAgICAgICAgICAgICBcImZvbnRcIiA9PT0gYXMgJiZcbiAgICAgICAgICAgICAgICAgICgoa2V5ID0gZ2V0UHJlbG9hZEFzSGVhZGVyKGhyZWYsIGFzLCBvcHRpb25zKSksXG4gICAgICAgICAgICAgICAgICAwIDw9IChyZXN1bWFibGVTdGF0ZS5yZW1haW5pbmdDYXBhY2l0eSAtPSBrZXkubGVuZ3RoICsgMikpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgKHJlbmRlclN0YXRlLnJlc2V0cy5mb250W2hyZWZdID0gUFJFTE9BRF9OT19DUkVEUyksXG4gICAgICAgICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLmZvbnRQcmVsb2FkcyAmJlxuICAgICAgICAgICAgICAgICAgICAgIChyZXN1bWFibGVTdGF0ZS5mb250UHJlbG9hZHMgKz0gXCIsIFwiKSxcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VtYWJsZVN0YXRlLmZvbnRQcmVsb2FkcyArPSBrZXkpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgIHN3aXRjaCAoXG4gICAgICAgICAgICAgICAgICAgICgocmVzdW1hYmxlU3RhdGUgPSBbXSksXG4gICAgICAgICAgICAgICAgICAgIChocmVmID0gYXNzaWduKFxuICAgICAgICAgICAgICAgICAgICAgIHsgcmVsOiBcInByZWxvYWRcIiwgaHJlZjogaHJlZiwgYXM6IGFzIH0sXG4gICAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAgICAgcHVzaExpbmtJbXBsKHJlc3VtYWJsZVN0YXRlLCBocmVmKSxcbiAgICAgICAgICAgICAgICAgICAgYXMpXG4gICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImZvbnRcIjpcbiAgICAgICAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5mb250UHJlbG9hZHMuYWRkKHJlc3VtYWJsZVN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5idWxrUHJlbG9hZHMuYWRkKHJlc3VtYWJsZVN0YXRlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVucXVldWVGbHVzaChyZXF1ZXN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBwcmV2aW91c0Rpc3BhdGNoZXIuTChocmVmLCBhcywgb3B0aW9ucyk7XG4gICAgICB9LFxuICAgICAgbTogZnVuY3Rpb24gKGhyZWYsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHJlcXVlc3QgPSBjdXJyZW50UmVxdWVzdCA/IGN1cnJlbnRSZXF1ZXN0IDogbnVsbDtcbiAgICAgICAgaWYgKHJlcXVlc3QpIHtcbiAgICAgICAgICB2YXIgcmVzdW1hYmxlU3RhdGUgPSByZXF1ZXN0LnJlc3VtYWJsZVN0YXRlLFxuICAgICAgICAgICAgcmVuZGVyU3RhdGUgPSByZXF1ZXN0LnJlbmRlclN0YXRlO1xuICAgICAgICAgIGlmIChocmVmKSB7XG4gICAgICAgICAgICB2YXIgYXMgPVxuICAgICAgICAgICAgICBvcHRpb25zICYmIFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLmFzID8gb3B0aW9ucy5hcyA6IFwic2NyaXB0XCI7XG4gICAgICAgICAgICBzd2l0Y2ggKGFzKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJzY3JpcHRcIjpcbiAgICAgICAgICAgICAgICBpZiAocmVzdW1hYmxlU3RhdGUubW9kdWxlU2NyaXB0UmVzb3VyY2VzLmhhc093blByb3BlcnR5KGhyZWYpKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGFzID0gW107XG4gICAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUubW9kdWxlU2NyaXB0UmVzb3VyY2VzW2hyZWZdID1cbiAgICAgICAgICAgICAgICAgICFvcHRpb25zIHx8XG4gICAgICAgICAgICAgICAgICAoXCJzdHJpbmdcIiAhPT0gdHlwZW9mIG9wdGlvbnMuY3Jvc3NPcmlnaW4gJiZcbiAgICAgICAgICAgICAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIG9wdGlvbnMuaW50ZWdyaXR5KVxuICAgICAgICAgICAgICAgICAgICA/IFBSRUxPQURfTk9fQ1JFRFNcbiAgICAgICAgICAgICAgICAgICAgOiBbb3B0aW9ucy5jcm9zc09yaWdpbiwgb3B0aW9ucy5pbnRlZ3JpdHldO1xuICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlLnByZWxvYWRzLm1vZHVsZVNjcmlwdHMuc2V0KGhyZWYsIGFzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAocmVzdW1hYmxlU3RhdGUubW9kdWxlVW5rbm93blJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShhcykpIHtcbiAgICAgICAgICAgICAgICAgIHZhciByZXNvdXJjZXMgPSByZXN1bWFibGVTdGF0ZS51bmtub3duUmVzb3VyY2VzW2FzXTtcbiAgICAgICAgICAgICAgICAgIGlmIChyZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoaHJlZikpIHJldHVybjtcbiAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgIChyZXNvdXJjZXMgPSB7fSksXG4gICAgICAgICAgICAgICAgICAgIChyZXN1bWFibGVTdGF0ZS5tb2R1bGVVbmtub3duUmVzb3VyY2VzW2FzXSA9IHJlc291cmNlcyk7XG4gICAgICAgICAgICAgICAgYXMgPSBbXTtcbiAgICAgICAgICAgICAgICByZXNvdXJjZXNbaHJlZl0gPSBQUkVMT0FEX05PX0NSRURTO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHVzaExpbmtJbXBsKFxuICAgICAgICAgICAgICBhcyxcbiAgICAgICAgICAgICAgYXNzaWduKHsgcmVsOiBcIm1vZHVsZXByZWxvYWRcIiwgaHJlZjogaHJlZiB9LCBvcHRpb25zKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJlbmRlclN0YXRlLmJ1bGtQcmVsb2Fkcy5hZGQoYXMpO1xuICAgICAgICAgICAgZW5xdWV1ZUZsdXNoKHJlcXVlc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHByZXZpb3VzRGlzcGF0Y2hlci5tKGhyZWYsIG9wdGlvbnMpO1xuICAgICAgfSxcbiAgICAgIFg6IGZ1bmN0aW9uIChzcmMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHJlcXVlc3QgPSBjdXJyZW50UmVxdWVzdCA/IGN1cnJlbnRSZXF1ZXN0IDogbnVsbDtcbiAgICAgICAgaWYgKHJlcXVlc3QpIHtcbiAgICAgICAgICB2YXIgcmVzdW1hYmxlU3RhdGUgPSByZXF1ZXN0LnJlc3VtYWJsZVN0YXRlLFxuICAgICAgICAgICAgcmVuZGVyU3RhdGUgPSByZXF1ZXN0LnJlbmRlclN0YXRlO1xuICAgICAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgICAgIHZhciByZXNvdXJjZVN0YXRlID0gcmVzdW1hYmxlU3RhdGUuc2NyaXB0UmVzb3VyY2VzLmhhc093blByb3BlcnR5KFxuICAgICAgICAgICAgICBzcmNcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgPyByZXN1bWFibGVTdGF0ZS5zY3JpcHRSZXNvdXJjZXNbc3JjXVxuICAgICAgICAgICAgICA6IHZvaWQgMDtcbiAgICAgICAgICAgIHJlc291cmNlU3RhdGUgIT09IEVYSVNUUyAmJlxuICAgICAgICAgICAgICAoKHJlc3VtYWJsZVN0YXRlLnNjcmlwdFJlc291cmNlc1tzcmNdID0gRVhJU1RTKSxcbiAgICAgICAgICAgICAgKG9wdGlvbnMgPSBhc3NpZ24oeyBzcmM6IHNyYywgYXN5bmM6ICEwIH0sIG9wdGlvbnMpKSxcbiAgICAgICAgICAgICAgcmVzb3VyY2VTdGF0ZSAmJlxuICAgICAgICAgICAgICAgICgyID09PSByZXNvdXJjZVN0YXRlLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgYWRvcHRQcmVsb2FkQ3JlZGVudGlhbHMob3B0aW9ucywgcmVzb3VyY2VTdGF0ZSksXG4gICAgICAgICAgICAgICAgKHNyYyA9IHJlbmRlclN0YXRlLnByZWxvYWRzLnNjcmlwdHMuZ2V0KHNyYykpKSAmJlxuICAgICAgICAgICAgICAgIChzcmMubGVuZ3RoID0gMCksXG4gICAgICAgICAgICAgIChzcmMgPSBbXSksXG4gICAgICAgICAgICAgIHJlbmRlclN0YXRlLnNjcmlwdHMuYWRkKHNyYyksXG4gICAgICAgICAgICAgIHB1c2hTY3JpcHRJbXBsKHNyYywgb3B0aW9ucyksXG4gICAgICAgICAgICAgIGVucXVldWVGbHVzaChyZXF1ZXN0KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgcHJldmlvdXNEaXNwYXRjaGVyLlgoc3JjLCBvcHRpb25zKTtcbiAgICAgIH0sXG4gICAgICBTOiBmdW5jdGlvbiAoaHJlZiwgcHJlY2VkZW5jZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgcmVxdWVzdCA9IGN1cnJlbnRSZXF1ZXN0ID8gY3VycmVudFJlcXVlc3QgOiBudWxsO1xuICAgICAgICBpZiAocmVxdWVzdCkge1xuICAgICAgICAgIHZhciByZXN1bWFibGVTdGF0ZSA9IHJlcXVlc3QucmVzdW1hYmxlU3RhdGUsXG4gICAgICAgICAgICByZW5kZXJTdGF0ZSA9IHJlcXVlc3QucmVuZGVyU3RhdGU7XG4gICAgICAgICAgaWYgKGhyZWYpIHtcbiAgICAgICAgICAgIHByZWNlZGVuY2UgPSBwcmVjZWRlbmNlIHx8IFwiZGVmYXVsdFwiO1xuICAgICAgICAgICAgdmFyIHN0eWxlUXVldWUgPSByZW5kZXJTdGF0ZS5zdHlsZXMuZ2V0KHByZWNlZGVuY2UpLFxuICAgICAgICAgICAgICByZXNvdXJjZVN0YXRlID0gcmVzdW1hYmxlU3RhdGUuc3R5bGVSZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoaHJlZilcbiAgICAgICAgICAgICAgICA/IHJlc3VtYWJsZVN0YXRlLnN0eWxlUmVzb3VyY2VzW2hyZWZdXG4gICAgICAgICAgICAgICAgOiB2b2lkIDA7XG4gICAgICAgICAgICByZXNvdXJjZVN0YXRlICE9PSBFWElTVFMgJiZcbiAgICAgICAgICAgICAgKChyZXN1bWFibGVTdGF0ZS5zdHlsZVJlc291cmNlc1tocmVmXSA9IEVYSVNUUyksXG4gICAgICAgICAgICAgIHN0eWxlUXVldWUgfHxcbiAgICAgICAgICAgICAgICAoKHN0eWxlUXVldWUgPSB7XG4gICAgICAgICAgICAgICAgICBwcmVjZWRlbmNlOiBlc2NhcGVUZXh0Rm9yQnJvd3NlcihwcmVjZWRlbmNlKSxcbiAgICAgICAgICAgICAgICAgIHJ1bGVzOiBbXSxcbiAgICAgICAgICAgICAgICAgIGhyZWZzOiBbXSxcbiAgICAgICAgICAgICAgICAgIHNoZWV0czogbmV3IE1hcCgpXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUuc3R5bGVzLnNldChwcmVjZWRlbmNlLCBzdHlsZVF1ZXVlKSksXG4gICAgICAgICAgICAgIChwcmVjZWRlbmNlID0ge1xuICAgICAgICAgICAgICAgIHN0YXRlOiBQRU5ESU5HJDEsXG4gICAgICAgICAgICAgICAgcHJvcHM6IGFzc2lnbihcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcmVsOiBcInN0eWxlc2hlZXRcIixcbiAgICAgICAgICAgICAgICAgICAgaHJlZjogaHJlZixcbiAgICAgICAgICAgICAgICAgICAgXCJkYXRhLXByZWNlZGVuY2VcIjogcHJlY2VkZW5jZVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICByZXNvdXJjZVN0YXRlICYmXG4gICAgICAgICAgICAgICAgKDIgPT09IHJlc291cmNlU3RhdGUubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICBhZG9wdFByZWxvYWRDcmVkZW50aWFscyhwcmVjZWRlbmNlLnByb3BzLCByZXNvdXJjZVN0YXRlKSxcbiAgICAgICAgICAgICAgICAocmVuZGVyU3RhdGUgPSByZW5kZXJTdGF0ZS5wcmVsb2Fkcy5zdHlsZXNoZWV0cy5nZXQoaHJlZikpICYmXG4gICAgICAgICAgICAgICAgMCA8IHJlbmRlclN0YXRlLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgPyAocmVuZGVyU3RhdGUubGVuZ3RoID0gMClcbiAgICAgICAgICAgICAgICAgIDogKHByZWNlZGVuY2Uuc3RhdGUgPSBQUkVMT0FERUQpKSxcbiAgICAgICAgICAgICAgc3R5bGVRdWV1ZS5zaGVldHMuc2V0KGhyZWYsIHByZWNlZGVuY2UpLFxuICAgICAgICAgICAgICBlbnF1ZXVlRmx1c2gocmVxdWVzdCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHByZXZpb3VzRGlzcGF0Y2hlci5TKGhyZWYsIHByZWNlZGVuY2UsIG9wdGlvbnMpO1xuICAgICAgfSxcbiAgICAgIE06IGZ1bmN0aW9uIChzcmMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHJlcXVlc3QgPSBjdXJyZW50UmVxdWVzdCA/IGN1cnJlbnRSZXF1ZXN0IDogbnVsbDtcbiAgICAgICAgaWYgKHJlcXVlc3QpIHtcbiAgICAgICAgICB2YXIgcmVzdW1hYmxlU3RhdGUgPSByZXF1ZXN0LnJlc3VtYWJsZVN0YXRlLFxuICAgICAgICAgICAgcmVuZGVyU3RhdGUgPSByZXF1ZXN0LnJlbmRlclN0YXRlO1xuICAgICAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgICAgIHZhciByZXNvdXJjZVN0YXRlID1cbiAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUubW9kdWxlU2NyaXB0UmVzb3VyY2VzLmhhc093blByb3BlcnR5KHNyYylcbiAgICAgICAgICAgICAgICA/IHJlc3VtYWJsZVN0YXRlLm1vZHVsZVNjcmlwdFJlc291cmNlc1tzcmNdXG4gICAgICAgICAgICAgICAgOiB2b2lkIDA7XG4gICAgICAgICAgICByZXNvdXJjZVN0YXRlICE9PSBFWElTVFMgJiZcbiAgICAgICAgICAgICAgKChyZXN1bWFibGVTdGF0ZS5tb2R1bGVTY3JpcHRSZXNvdXJjZXNbc3JjXSA9IEVYSVNUUyksXG4gICAgICAgICAgICAgIChvcHRpb25zID0gYXNzaWduKFxuICAgICAgICAgICAgICAgIHsgc3JjOiBzcmMsIHR5cGU6IFwibW9kdWxlXCIsIGFzeW5jOiAhMCB9LFxuICAgICAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIHJlc291cmNlU3RhdGUgJiZcbiAgICAgICAgICAgICAgICAoMiA9PT0gcmVzb3VyY2VTdGF0ZS5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgIGFkb3B0UHJlbG9hZENyZWRlbnRpYWxzKG9wdGlvbnMsIHJlc291cmNlU3RhdGUpLFxuICAgICAgICAgICAgICAgIChzcmMgPSByZW5kZXJTdGF0ZS5wcmVsb2Fkcy5tb2R1bGVTY3JpcHRzLmdldChzcmMpKSkgJiZcbiAgICAgICAgICAgICAgICAoc3JjLmxlbmd0aCA9IDApLFxuICAgICAgICAgICAgICAoc3JjID0gW10pLFxuICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5zY3JpcHRzLmFkZChzcmMpLFxuICAgICAgICAgICAgICBwdXNoU2NyaXB0SW1wbChzcmMsIG9wdGlvbnMpLFxuICAgICAgICAgICAgICBlbnF1ZXVlRmx1c2gocmVxdWVzdCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHByZXZpb3VzRGlzcGF0Y2hlci5NKHNyYywgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgTm90aGluZ1NlbnQgPSAwLFxuICAgICAgU2VudENvbXBsZXRlU2VnbWVudEZ1bmN0aW9uID0gMSxcbiAgICAgIFNlbnRDb21wbGV0ZUJvdW5kYXJ5RnVuY3Rpb24gPSAyLFxuICAgICAgU2VudENsaWVudFJlbmRlckZ1bmN0aW9uID0gNCxcbiAgICAgIFNlbnRTdHlsZUluc2VydGlvbkZ1bmN0aW9uID0gOCxcbiAgICAgIFNlbnRDb21wbGV0ZWRTaGVsbElkID0gMzIsXG4gICAgICBTZW50TWFya1NoZWxsVGltZSA9IDY0LFxuICAgICAgRVhJU1RTID0gbnVsbCxcbiAgICAgIFBSRUxPQURfTk9fQ1JFRFMgPSBbXTtcbiAgICBPYmplY3QuZnJlZXplKFBSRUxPQURfTk9fQ1JFRFMpO1xuICAgIHZhciBjdXJyZW50bHlGbHVzaGluZ1JlbmRlclN0YXRlID0gbnVsbCxcbiAgICAgIGVuZElubGluZVNjcmlwdCA9IFwiXFx4M2Mvc2NyaXB0PlwiLFxuICAgICAgc2NyaXB0UmVnZXggPSAvKDxcXC98PCkocykoY3JpcHQpL2dpO1xuICAgIHZhciBkaWRXYXJuRm9yTmV3Qm9vbGVhblByb3BzV2l0aEVtcHR5VmFsdWUgPSB7fTtcbiAgICB2YXIgUk9PVF9IVE1MX01PREUgPSAwLFxuICAgICAgSFRNTF9IVE1MX01PREUgPSAxLFxuICAgICAgSFRNTF9NT0RFID0gMixcbiAgICAgIEhUTUxfSEVBRF9NT0RFID0gMyxcbiAgICAgIFNWR19NT0RFID0gNCxcbiAgICAgIE1BVEhNTF9NT0RFID0gNSxcbiAgICAgIEhUTUxfVEFCTEVfTU9ERSA9IDYsXG4gICAgICBIVE1MX1RBQkxFX0JPRFlfTU9ERSA9IDcsXG4gICAgICBIVE1MX1RBQkxFX1JPV19NT0RFID0gOCxcbiAgICAgIEhUTUxfQ09MR1JPVVBfTU9ERSA9IDksXG4gICAgICBzdHlsZU5hbWVDYWNoZSA9IG5ldyBNYXAoKSxcbiAgICAgIHN0eWxlQXR0cmlidXRlU3RhcnQgPSAnIHN0eWxlPVwiJyxcbiAgICAgIHN0eWxlQXNzaWduID0gXCI6XCIsXG4gICAgICBzdHlsZVNlcGFyYXRvciA9IFwiO1wiLFxuICAgICAgYXR0cmlidXRlU2VwYXJhdG9yID0gXCIgXCIsXG4gICAgICBhdHRyaWJ1dGVBc3NpZ24gPSAnPVwiJyxcbiAgICAgIGF0dHJpYnV0ZUVuZCA9ICdcIicsXG4gICAgICBhdHRyaWJ1dGVFbXB0eVN0cmluZyA9ICc9XCJcIicsXG4gICAgICBhY3Rpb25KYXZhU2NyaXB0VVJMID0gZXNjYXBlVGV4dEZvckJyb3dzZXIoXG4gICAgICAgIFwiamF2YXNjcmlwdDp0aHJvdyBuZXcgRXJyb3IoJ1JlYWN0IGZvcm0gdW5leHBlY3RlZGx5IHN1Ym1pdHRlZC4nKVwiXG4gICAgICApLFxuICAgICAgZW5kT2ZTdGFydFRhZyA9IFwiPlwiLFxuICAgICAgZW5kT2ZTdGFydFRhZ1NlbGZDbG9zaW5nID0gXCIvPlwiLFxuICAgICAgZGlkV2FybkRlZmF1bHRJbnB1dFZhbHVlID0gITEsXG4gICAgICBkaWRXYXJuRGVmYXVsdENoZWNrZWQgPSAhMSxcbiAgICAgIGRpZFdhcm5EZWZhdWx0U2VsZWN0VmFsdWUgPSAhMSxcbiAgICAgIGRpZFdhcm5EZWZhdWx0VGV4dGFyZWFWYWx1ZSA9ICExLFxuICAgICAgZGlkV2FybkludmFsaWRPcHRpb25DaGlsZHJlbiA9ICExLFxuICAgICAgZGlkV2FybkludmFsaWRPcHRpb25Jbm5lckhUTUwgPSAhMSxcbiAgICAgIGRpZFdhcm5TZWxlY3RlZFNldE9uT3B0aW9uID0gITEsXG4gICAgICBkaWRXYXJuRm9ybUFjdGlvblR5cGUgPSAhMSxcbiAgICAgIGRpZFdhcm5Gb3JtQWN0aW9uTmFtZSA9ICExLFxuICAgICAgZGlkV2FybkZvcm1BY3Rpb25UYXJnZXQgPSAhMSxcbiAgICAgIGRpZFdhcm5Gb3JtQWN0aW9uTWV0aG9kID0gITEsXG4gICAgICBmb3JtUmVwbGF5aW5nUnVudGltZVNjcmlwdCA9XG4gICAgICAgICdhZGRFdmVudExpc3RlbmVyKFwic3VibWl0XCIsZnVuY3Rpb24oYSl7aWYoIWEuZGVmYXVsdFByZXZlbnRlZCl7dmFyIGM9YS50YXJnZXQsZD1hLnN1Ym1pdHRlcixlPWMuYWN0aW9uLGI9ZDtpZihkKXt2YXIgZj1kLmdldEF0dHJpYnV0ZShcImZvcm1BY3Rpb25cIik7bnVsbCE9ZiYmKGU9ZixiPW51bGwpfVwiamF2YXNjcmlwdDp0aHJvdyBuZXcgRXJyb3IoXFwnUmVhY3QgZm9ybSB1bmV4cGVjdGVkbHkgc3VibWl0dGVkLlxcJylcIj09PWUmJihhLnByZXZlbnREZWZhdWx0KCksYj8oYT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIiksYS5uYW1lPWIubmFtZSxhLnZhbHVlPWIudmFsdWUsYi5wYXJlbnROb2RlLmluc2VydEJlZm9yZShhLGIpLGI9bmV3IEZvcm1EYXRhKGMpLGEucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChhKSk6Yj1uZXcgRm9ybURhdGEoYyksYT1jLm93bmVyRG9jdW1lbnR8fGMsKGEuJCRyZWFjdEZvcm1SZXBsYXk9YS4kJHJlYWN0Rm9ybVJlcGxheXx8W10pLnB1c2goYyxkLGIpKX19KTsnLFxuICAgICAgc3R5bGVSZWdleCA9IC8oPFxcL3w8KShzKSh0eWxlKS9naSxcbiAgICAgIGxlYWRpbmdOZXdsaW5lID0gXCJcXG5cIixcbiAgICAgIFZBTElEX1RBR19SRUdFWCA9IC9eW2EtekEtWl1bYS16QS1aOl9cXC5cXC1cXGRdKiQvLFxuICAgICAgdmFsaWRhdGVkVGFnQ2FjaGUgPSBuZXcgTWFwKCksXG4gICAgICBlbmRUYWdDYWNoZSA9IG5ldyBNYXAoKSxcbiAgICAgIHNoZWxsVGltZVJ1bnRpbWVTY3JpcHQgPVxuICAgICAgICBcInJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpeyRSVD1wZXJmb3JtYW5jZS5ub3coKX0pO1wiLFxuICAgICAgcGxhY2Vob2xkZXIxID0gJzx0ZW1wbGF0ZSBpZD1cIicsXG4gICAgICBwbGFjZWhvbGRlcjIgPSAnXCI+PC90ZW1wbGF0ZT4nLFxuICAgICAgc3RhcnRDb21wbGV0ZWRTdXNwZW5zZUJvdW5kYXJ5ID0gXCJcXHgzYyEtLSQtLVxceDNlXCIsXG4gICAgICBzdGFydFBlbmRpbmdTdXNwZW5zZUJvdW5kYXJ5MSA9ICdcXHgzYyEtLSQ/LS1cXHgzZTx0ZW1wbGF0ZSBpZD1cIicsXG4gICAgICBzdGFydFBlbmRpbmdTdXNwZW5zZUJvdW5kYXJ5MiA9ICdcIj48L3RlbXBsYXRlPicsXG4gICAgICBzdGFydENsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeSA9IFwiXFx4M2MhLS0kIS0tXFx4M2VcIixcbiAgICAgIGVuZFN1c3BlbnNlQm91bmRhcnkgPSBcIlxceDNjIS0tLyQtLVxceDNlXCIsXG4gICAgICBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjEgPSBcIjx0ZW1wbGF0ZVwiLFxuICAgICAgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3JBdHRySW50ZXJzdGl0aWFsID0gJ1wiJyxcbiAgICAgIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yMUEgPSAnIGRhdGEtZGdzdD1cIicsXG4gICAgICBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjFCID0gJyBkYXRhLW1zZz1cIicsXG4gICAgICBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjFDID0gJyBkYXRhLXN0Y2s9XCInLFxuICAgICAgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxRCA9ICcgZGF0YS1jc3Rjaz1cIicsXG4gICAgICBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjIgPSBcIj48L3RlbXBsYXRlPlwiLFxuICAgICAgc3RhcnRTZWdtZW50SFRNTCA9ICc8ZGl2IGhpZGRlbiBpZD1cIicsXG4gICAgICBzdGFydFNlZ21lbnRIVE1MMiA9ICdcIj4nLFxuICAgICAgZW5kU2VnbWVudEhUTUwgPSBcIjwvZGl2PlwiLFxuICAgICAgc3RhcnRTZWdtZW50U1ZHID0gJzxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgc3R5bGU9XCJkaXNwbGF5Om5vbmVcIiBpZD1cIicsXG4gICAgICBzdGFydFNlZ21lbnRTVkcyID0gJ1wiPicsXG4gICAgICBlbmRTZWdtZW50U1ZHID0gXCI8L3N2Zz5cIixcbiAgICAgIHN0YXJ0U2VnbWVudE1hdGhNTCA9ICc8bWF0aCBhcmlhLWhpZGRlbj1cInRydWVcIiBzdHlsZT1cImRpc3BsYXk6bm9uZVwiIGlkPVwiJyxcbiAgICAgIHN0YXJ0U2VnbWVudE1hdGhNTDIgPSAnXCI+JyxcbiAgICAgIGVuZFNlZ21lbnRNYXRoTUwgPSBcIjwvbWF0aD5cIixcbiAgICAgIHN0YXJ0U2VnbWVudFRhYmxlID0gJzx0YWJsZSBoaWRkZW4gaWQ9XCInLFxuICAgICAgc3RhcnRTZWdtZW50VGFibGUyID0gJ1wiPicsXG4gICAgICBlbmRTZWdtZW50VGFibGUgPSBcIjwvdGFibGU+XCIsXG4gICAgICBzdGFydFNlZ21lbnRUYWJsZUJvZHkgPSAnPHRhYmxlIGhpZGRlbj48dGJvZHkgaWQ9XCInLFxuICAgICAgc3RhcnRTZWdtZW50VGFibGVCb2R5MiA9ICdcIj4nLFxuICAgICAgZW5kU2VnbWVudFRhYmxlQm9keSA9IFwiPC90Ym9keT48L3RhYmxlPlwiLFxuICAgICAgc3RhcnRTZWdtZW50VGFibGVSb3cgPSAnPHRhYmxlIGhpZGRlbj48dHIgaWQ9XCInLFxuICAgICAgc3RhcnRTZWdtZW50VGFibGVSb3cyID0gJ1wiPicsXG4gICAgICBlbmRTZWdtZW50VGFibGVSb3cgPSBcIjwvdHI+PC90YWJsZT5cIixcbiAgICAgIHN0YXJ0U2VnbWVudENvbEdyb3VwID0gJzx0YWJsZSBoaWRkZW4+PGNvbGdyb3VwIGlkPVwiJyxcbiAgICAgIHN0YXJ0U2VnbWVudENvbEdyb3VwMiA9ICdcIj4nLFxuICAgICAgZW5kU2VnbWVudENvbEdyb3VwID0gXCI8L2NvbGdyb3VwPjwvdGFibGU+XCIsXG4gICAgICBjb21wbGV0ZVNlZ21lbnRTY3JpcHQxRnVsbCA9XG4gICAgICAgICckUlM9ZnVuY3Rpb24oYSxiKXthPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGEpO2I9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYik7Zm9yKGEucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChhKTthLmZpcnN0Q2hpbGQ7KWIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoYS5maXJzdENoaWxkLGIpO2IucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChiKX07JFJTKFwiJyxcbiAgICAgIGNvbXBsZXRlU2VnbWVudFNjcmlwdDFQYXJ0aWFsID0gJyRSUyhcIicsXG4gICAgICBjb21wbGV0ZVNlZ21lbnRTY3JpcHQyID0gJ1wiLFwiJyxcbiAgICAgIGNvbXBsZXRlU2VnbWVudFNjcmlwdEVuZCA9ICdcIilcXHgzYy9zY3JpcHQ+JyxcbiAgICAgIGNvbXBsZXRlQm91bmRhcnlTY3JpcHRGdW5jdGlvbk9ubHkgPVxuICAgICAgICAnJFJCPVtdOyRSVj1mdW5jdGlvbihhKXskUlQ9cGVyZm9ybWFuY2Uubm93KCk7Zm9yKHZhciBiPTA7YjxhLmxlbmd0aDtiKz0yKXt2YXIgYz1hW2JdLGU9YVtiKzFdO251bGwhPT1lLnBhcmVudE5vZGUmJmUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlKTt2YXIgZj1jLnBhcmVudE5vZGU7aWYoZil7dmFyIGc9Yy5wcmV2aW91c1NpYmxpbmcsaD0wO2Rve2lmKGMmJjg9PT1jLm5vZGVUeXBlKXt2YXIgZD1jLmRhdGE7aWYoXCIvJFwiPT09ZHx8XCIvJlwiPT09ZClpZigwPT09aClicmVhaztlbHNlIGgtLTtlbHNlXCIkXCIhPT1kJiZcIiQ/XCIhPT1kJiZcIiR+XCIhPT1kJiZcIiQhXCIhPT1kJiZcIiZcIiE9PWR8fGgrK31kPWMubmV4dFNpYmxpbmc7Zi5yZW1vdmVDaGlsZChjKTtjPWR9d2hpbGUoYyk7Zm9yKDtlLmZpcnN0Q2hpbGQ7KWYuaW5zZXJ0QmVmb3JlKGUuZmlyc3RDaGlsZCxjKTtnLmRhdGE9XCIkXCI7Zy5fcmVhY3RSZXRyeSYmcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGcuX3JlYWN0UmV0cnkpfX1hLmxlbmd0aD0wfTtcXG4kUkM9ZnVuY3Rpb24oYSxiKXtpZihiPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGIpKShhPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGEpKT8oYS5wcmV2aW91c1NpYmxpbmcuZGF0YT1cIiR+XCIsJFJCLnB1c2goYSxiKSwyPT09JFJCLmxlbmd0aCYmKFwibnVtYmVyXCIhPT10eXBlb2YgJFJUP3JlcXVlc3RBbmltYXRpb25GcmFtZSgkUlYuYmluZChudWxsLCRSQikpOihhPXBlcmZvcm1hbmNlLm5vdygpLHNldFRpbWVvdXQoJFJWLmJpbmQobnVsbCwkUkIpLDIzMDA+YSYmMkUzPGE/MjMwMC1hOiRSVCszMDAtYSkpKSk6Yi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGIpfTsnLFxuICAgICAgY29tcGxldGVCb3VuZGFyeVNjcmlwdDFQYXJ0aWFsID0gJyRSQyhcIicsXG4gICAgICBjb21wbGV0ZUJvdW5kYXJ5V2l0aFN0eWxlc1NjcmlwdDFGdWxsUGFydGlhbCA9XG4gICAgICAgICckUk09bmV3IE1hcDskUlI9ZnVuY3Rpb24obix3LHApe2Z1bmN0aW9uIHUocSl7dGhpcy5fcD1udWxsO3EoKX1mb3IodmFyIHI9bmV3IE1hcCx0PWRvY3VtZW50LGgsYixlPXQucXVlcnlTZWxlY3RvckFsbChcImxpbmtbZGF0YS1wcmVjZWRlbmNlXSxzdHlsZVtkYXRhLXByZWNlZGVuY2VdXCIpLHY9W10saz0wO2I9ZVtrKytdOylcIm5vdCBhbGxcIj09PWIuZ2V0QXR0cmlidXRlKFwibWVkaWFcIik/di5wdXNoKGIpOihcIkxJTktcIj09PWIudGFnTmFtZSYmJFJNLnNldChiLmdldEF0dHJpYnV0ZShcImhyZWZcIiksYiksci5zZXQoYi5kYXRhc2V0LnByZWNlZGVuY2UsaD1iKSk7ZT0wO2I9W107dmFyIGwsYTtmb3Ioaz0hMDs7KXtpZihrKXt2YXIgZj1wW2UrK107aWYoIWYpe2s9ITE7ZT0wO2NvbnRpbnVlfXZhciBjPSExLG09MDt2YXIgZD1mW20rK107aWYoYT0kUk0uZ2V0KGQpKXt2YXIgZz1hLl9wO2M9ITB9ZWxzZXthPXQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7YS5ocmVmPWQ7YS5yZWw9XFxuXCJzdHlsZXNoZWV0XCI7Zm9yKGEuZGF0YXNldC5wcmVjZWRlbmNlPWw9ZlttKytdO2c9ZlttKytdOylhLnNldEF0dHJpYnV0ZShnLGZbbSsrXSk7Zz1hLl9wPW5ldyBQcm9taXNlKGZ1bmN0aW9uKHEseCl7YS5vbmxvYWQ9dS5iaW5kKGEscSk7YS5vbmVycm9yPXUuYmluZChhLHgpfSk7JFJNLnNldChkLGEpfWQ9YS5nZXRBdHRyaWJ1dGUoXCJtZWRpYVwiKTshZ3x8ZCYmIW1hdGNoTWVkaWEoZCkubWF0Y2hlc3x8Yi5wdXNoKGcpO2lmKGMpY29udGludWV9ZWxzZXthPXZbZSsrXTtpZighYSlicmVhaztsPWEuZ2V0QXR0cmlidXRlKFwiZGF0YS1wcmVjZWRlbmNlXCIpO2EucmVtb3ZlQXR0cmlidXRlKFwibWVkaWFcIil9Yz1yLmdldChsKXx8aDtjPT09aCYmKGg9YSk7ci5zZXQobCxhKTtjP2MucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoYSxjLm5leHRTaWJsaW5nKTooYz10LmhlYWQsYy5pbnNlcnRCZWZvcmUoYSxjLmZpcnN0Q2hpbGQpKX1pZihwPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG4pKXAucHJldmlvdXNTaWJsaW5nLmRhdGE9XFxuXCIkflwiO1Byb21pc2UuYWxsKGIpLnRoZW4oJFJDLmJpbmQobnVsbCxuLHcpLCRSWC5iaW5kKG51bGwsbixcIkNTUyBmYWlsZWQgdG8gbG9hZFwiKSl9OyRSUihcIicsXG4gICAgICBjb21wbGV0ZUJvdW5kYXJ5V2l0aFN0eWxlc1NjcmlwdDFQYXJ0aWFsID0gJyRSUihcIicsXG4gICAgICBjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0MiA9ICdcIixcIicsXG4gICAgICBjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0M2EgPSAnXCIsJyxcbiAgICAgIGNvbXBsZXRlQm91bmRhcnlTY3JpcHQzYiA9ICdcIicsXG4gICAgICBjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0RW5kID0gXCIpXFx4M2Mvc2NyaXB0PlwiLFxuICAgICAgY2xpZW50UmVuZGVyU2NyaXB0RnVuY3Rpb25Pbmx5ID1cbiAgICAgICAgJyRSWD1mdW5jdGlvbihiLGMsZCxlLGYpe3ZhciBhPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGIpO2EmJihiPWEucHJldmlvdXNTaWJsaW5nLGIuZGF0YT1cIiQhXCIsYT1hLmRhdGFzZXQsYyYmKGEuZGdzdD1jKSxkJiYoYS5tc2c9ZCksZSYmKGEuc3Rjaz1lKSxmJiYoYS5jc3Rjaz1mKSxiLl9yZWFjdFJldHJ5JiZiLl9yZWFjdFJldHJ5KCkpfTsnLFxuICAgICAgY2xpZW50UmVuZGVyU2NyaXB0MUZ1bGwgPVxuICAgICAgICAnJFJYPWZ1bmN0aW9uKGIsYyxkLGUsZil7dmFyIGE9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYik7YSYmKGI9YS5wcmV2aW91c1NpYmxpbmcsYi5kYXRhPVwiJCFcIixhPWEuZGF0YXNldCxjJiYoYS5kZ3N0PWMpLGQmJihhLm1zZz1kKSxlJiYoYS5zdGNrPWUpLGYmJihhLmNzdGNrPWYpLGIuX3JlYWN0UmV0cnkmJmIuX3JlYWN0UmV0cnkoKSl9OzskUlgoXCInLFxuICAgICAgY2xpZW50UmVuZGVyU2NyaXB0MVBhcnRpYWwgPSAnJFJYKFwiJyxcbiAgICAgIGNsaWVudFJlbmRlclNjcmlwdDFBID0gJ1wiJyxcbiAgICAgIGNsaWVudFJlbmRlckVycm9yU2NyaXB0QXJnSW50ZXJzdGl0aWFsID0gXCIsXCIsXG4gICAgICBjbGllbnRSZW5kZXJTY3JpcHRFbmQgPSBcIilcXHgzYy9zY3JpcHQ+XCIsXG4gICAgICByZWdleEZvckpTU3RyaW5nc0luSW5zdHJ1Y3Rpb25TY3JpcHRzID0gL1s8XFx1MjAyOFxcdTIwMjldL2csXG4gICAgICByZWdleEZvckpTU3RyaW5nc0luU2NyaXB0cyA9IC9bJj48XFx1MjAyOFxcdTIwMjldL2csXG4gICAgICBsYXRlU3R5bGVUYWdSZXNvdXJjZU9wZW4xID0gJyBtZWRpYT1cIm5vdCBhbGxcIiBkYXRhLXByZWNlZGVuY2U9XCInLFxuICAgICAgbGF0ZVN0eWxlVGFnUmVzb3VyY2VPcGVuMiA9ICdcIiBkYXRhLWhyZWY9XCInLFxuICAgICAgbGF0ZVN0eWxlVGFnUmVzb3VyY2VPcGVuMyA9ICdcIj4nLFxuICAgICAgbGF0ZVN0eWxlVGFnVGVtcGxhdGVDbG9zZSA9IFwiPC9zdHlsZT5cIixcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0JvdW5kYXJ5SGFzU3R5bGVzVG9Ib2lzdCA9ICExLFxuICAgICAgZGVzdGluYXRpb25IYXNDYXBhY2l0eSA9ICEwLFxuICAgICAgc3R5bGVzaGVldEZsdXNoaW5nUXVldWUgPSBbXSxcbiAgICAgIHN0eWxlVGFnUmVzb3VyY2VPcGVuMSA9ICcgZGF0YS1wcmVjZWRlbmNlPVwiJyxcbiAgICAgIHN0eWxlVGFnUmVzb3VyY2VPcGVuMiA9ICdcIiBkYXRhLWhyZWY9XCInLFxuICAgICAgc3BhY2VTZXBhcmF0b3IgPSBcIiBcIixcbiAgICAgIHN0eWxlVGFnUmVzb3VyY2VPcGVuMyA9ICdcIj4nLFxuICAgICAgc3R5bGVUYWdSZXNvdXJjZUNsb3NlID0gXCI8L3N0eWxlPlwiLFxuICAgICAgY29tcGxldGVkU2hlbGxJZEF0dHJpYnV0ZVN0YXJ0ID0gJyBpZD1cIicsXG4gICAgICBhcnJheUZpcnN0T3BlbkJyYWNrZXQgPSBcIltcIixcbiAgICAgIGFycmF5U3Vic2VxdWVudE9wZW5CcmFja2V0ID0gXCIsW1wiLFxuICAgICAgYXJyYXlJbnRlcnN0aXRpYWwgPSBcIixcIixcbiAgICAgIGFycmF5Q2xvc2VCcmFja2V0ID0gXCJdXCIsXG4gICAgICBQRU5ESU5HJDEgPSAwLFxuICAgICAgUFJFTE9BREVEID0gMSxcbiAgICAgIFBSRUFNQkxFID0gMixcbiAgICAgIExBVEUgPSAzLFxuICAgICAgcmVnZXhGb3JIcmVmSW5MaW5rSGVhZGVyVVJMQ29udGV4dCA9IC9bPD5cXHJcXG5dL2csXG4gICAgICByZWdleEZvckxpbmtIZWFkZXJRdW90ZWRQYXJhbVZhbHVlQ29udGV4dCA9IC9bXCInOyxcXHJcXG5dL2csXG4gICAgICBkb2N0eXBlQ2h1bmsgPSBcIlwiLFxuICAgICAgYmluZCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLFxuICAgICAgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jbGllbnQucmVmZXJlbmNlXCIpLFxuICAgICAgZW1wdHlDb250ZXh0T2JqZWN0ID0ge307XG4gICAgT2JqZWN0LmZyZWV6ZShlbXB0eUNvbnRleHRPYmplY3QpO1xuICAgIHZhciByZW5kZXJlclNpZ2lsID0ge307XG4gICAgdmFyIGN1cnJlbnRBY3RpdmVTbmFwc2hvdCA9IG51bGwsXG4gICAgICBkaWRXYXJuQWJvdXROb29wVXBkYXRlRm9yQ29tcG9uZW50ID0ge30sXG4gICAgICBkaWRXYXJuQWJvdXREZXByZWNhdGVkV2lsbE1vdW50ID0ge307XG4gICAgdmFyIGRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZSA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlID0gbmV3IFNldCgpO1xuICAgIHZhciBkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlID0gbmV3IFNldCgpO1xuICAgIHZhciBkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZSA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlID0gbmV3IFNldCgpO1xuICAgIHZhciBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZXMkMSA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZGlkV2FybkFib3V0Q2hpbGRDb250ZXh0VHlwZXMgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZSA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZGlkV2Fybk9uSW52YWxpZENhbGxiYWNrID0gbmV3IFNldCgpO1xuICAgIHZhciBjbGFzc0NvbXBvbmVudFVwZGF0ZXIgPSB7XG4gICAgICAgIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKGluc3QsIHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIGludGVybmFscyA9IGluc3QuX3JlYWN0SW50ZXJuYWxzO1xuICAgICAgICAgIG51bGwgPT09IGludGVybmFscy5xdWV1ZVxuICAgICAgICAgICAgPyB3YXJuTm9vcChpbnN0LCBcInNldFN0YXRlXCIpXG4gICAgICAgICAgICA6IChpbnRlcm5hbHMucXVldWUucHVzaChwYXlsb2FkKSxcbiAgICAgICAgICAgICAgdm9pZCAwICE9PSBjYWxsYmFjayAmJlxuICAgICAgICAgICAgICAgIG51bGwgIT09IGNhbGxiYWNrICYmXG4gICAgICAgICAgICAgICAgd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChpbnN0LCBwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgICAgICAgIGluc3QgPSBpbnN0Ll9yZWFjdEludGVybmFscztcbiAgICAgICAgICBpbnN0LnJlcGxhY2UgPSAhMDtcbiAgICAgICAgICBpbnN0LnF1ZXVlID0gW3BheWxvYWRdO1xuICAgICAgICAgIHZvaWQgMCAhPT0gY2FsbGJhY2sgJiZcbiAgICAgICAgICAgIG51bGwgIT09IGNhbGxiYWNrICYmXG4gICAgICAgICAgICB3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2spO1xuICAgICAgICB9LFxuICAgICAgICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChpbnN0LCBjYWxsYmFjaykge1xuICAgICAgICAgIG51bGwgPT09IGluc3QuX3JlYWN0SW50ZXJuYWxzLnF1ZXVlXG4gICAgICAgICAgICA/IHdhcm5Ob29wKGluc3QsIFwiZm9yY2VVcGRhdGVcIilcbiAgICAgICAgICAgIDogdm9pZCAwICE9PSBjYWxsYmFjayAmJlxuICAgICAgICAgICAgICBudWxsICE9PSBjYWxsYmFjayAmJlxuICAgICAgICAgICAgICB3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZW1wdHlUcmVlQ29udGV4dCA9IHsgaWQ6IDEsIG92ZXJmbG93OiBcIlwiIH0sXG4gICAgICBjbHozMiA9IE1hdGguY2x6MzIgPyBNYXRoLmNsejMyIDogY2x6MzJGYWxsYmFjayxcbiAgICAgIGxvZyA9IE1hdGgubG9nLFxuICAgICAgTE4yID0gTWF0aC5MTjIsXG4gICAgICBTdXNwZW5zZUV4Y2VwdGlvbiA9IEVycm9yKFxuICAgICAgICBcIlN1c3BlbnNlIEV4Y2VwdGlvbjogVGhpcyBpcyBub3QgYSByZWFsIGVycm9yISBJdCdzIGFuIGltcGxlbWVudGF0aW9uIGRldGFpbCBvZiBgdXNlYCB0byBpbnRlcnJ1cHQgdGhlIGN1cnJlbnQgcmVuZGVyLiBZb3UgbXVzdCBlaXRoZXIgcmV0aHJvdyBpdCBpbW1lZGlhdGVseSwgb3IgbW92ZSB0aGUgYHVzZWAgY2FsbCBvdXRzaWRlIG9mIHRoZSBgdHJ5L2NhdGNoYCBibG9jay4gQ2FwdHVyaW5nIHdpdGhvdXQgcmV0aHJvd2luZyB3aWxsIGxlYWQgdG8gdW5leHBlY3RlZCBiZWhhdmlvci5cXG5cXG5UbyBoYW5kbGUgYXN5bmMgZXJyb3JzLCB3cmFwIHlvdXIgY29tcG9uZW50IGluIGFuIGVycm9yIGJvdW5kYXJ5LCBvciBjYWxsIHRoZSBwcm9taXNlJ3MgYC5jYXRjaGAgbWV0aG9kIGFuZCBwYXNzIHRoZSByZXN1bHQgdG8gYHVzZWAuXCJcbiAgICAgICksXG4gICAgICBzdXNwZW5kZWRUaGVuYWJsZSA9IG51bGwsXG4gICAgICBvYmplY3RJcyA9IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIE9iamVjdC5pcyA/IE9iamVjdC5pcyA6IGlzLFxuICAgICAgY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50ID0gbnVsbCxcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ1Rhc2sgPSBudWxsLFxuICAgICAgY3VycmVudGx5UmVuZGVyaW5nUmVxdWVzdCA9IG51bGwsXG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdLZXlQYXRoID0gbnVsbCxcbiAgICAgIGZpcnN0V29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbCxcbiAgICAgIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGwsXG4gICAgICBpc1JlUmVuZGVyID0gITEsXG4gICAgICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gITEsXG4gICAgICBsb2NhbElkQ291bnRlciA9IDAsXG4gICAgICBhY3Rpb25TdGF0ZUNvdW50ZXIgPSAwLFxuICAgICAgYWN0aW9uU3RhdGVNYXRjaGluZ0luZGV4ID0gLTEsXG4gICAgICB0aGVuYWJsZUluZGV4Q291bnRlciA9IDAsXG4gICAgICB0aGVuYWJsZVN0YXRlID0gbnVsbCxcbiAgICAgIHJlbmRlclBoYXNlVXBkYXRlcyA9IG51bGwsXG4gICAgICBudW1iZXJPZlJlUmVuZGVycyA9IDAsXG4gICAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSAhMSxcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2LFxuICAgICAgSG9va3NEaXNwYXRjaGVyID0ge1xuICAgICAgICByZWFkQ29udGV4dDogcmVhZENvbnRleHQsXG4gICAgICAgIHVzZTogZnVuY3Rpb24gKHVzYWJsZSkge1xuICAgICAgICAgIGlmIChudWxsICE9PSB1c2FibGUgJiYgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHVzYWJsZSkge1xuICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHVzYWJsZS50aGVuKVxuICAgICAgICAgICAgICByZXR1cm4gdW53cmFwVGhlbmFibGUodXNhYmxlKTtcbiAgICAgICAgICAgIGlmICh1c2FibGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSlcbiAgICAgICAgICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KHVzYWJsZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJBbiB1bnN1cHBvcnRlZCB0eXBlIHdhcyBwYXNzZWQgdG8gdXNlKCk6IFwiICsgU3RyaW5nKHVzYWJsZSlcbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICB1c2VDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VDb250ZXh0XCI7XG4gICAgICAgICAgcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpO1xuICAgICAgICAgIHJldHVybiBjb250ZXh0Ll9jdXJyZW50VmFsdWUyO1xuICAgICAgICB9LFxuICAgICAgICB1c2VNZW1vOiB1c2VNZW1vLFxuICAgICAgICB1c2VSZWR1Y2VyOiB1c2VSZWR1Y2VyLFxuICAgICAgICB1c2VSZWY6IGZ1bmN0aW9uIChpbml0aWFsVmFsdWUpIHtcbiAgICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQgPSByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3NIb29rID0gY3JlYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICAgICAgdmFyIHByZXZpb3VzUmVmID0gd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgcmV0dXJuIG51bGwgPT09IHByZXZpb3VzUmVmXG4gICAgICAgICAgICA/ICgoaW5pdGlhbFZhbHVlID0geyBjdXJyZW50OiBpbml0aWFsVmFsdWUgfSksXG4gICAgICAgICAgICAgIE9iamVjdC5zZWFsKGluaXRpYWxWYWx1ZSksXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZSA9IGluaXRpYWxWYWx1ZSkpXG4gICAgICAgICAgICA6IHByZXZpb3VzUmVmO1xuICAgICAgICB9LFxuICAgICAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuICAgICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VTdGF0ZVwiO1xuICAgICAgICAgIHJldHVybiB1c2VSZWR1Y2VyKGJhc2ljU3RhdGVSZWR1Y2VyLCBpbml0aWFsU3RhdGUpO1xuICAgICAgICB9LFxuICAgICAgICB1c2VJbnNlcnRpb25FZmZlY3Q6IG5vb3AsXG4gICAgICAgIHVzZUxheW91dEVmZmVjdDogbm9vcCxcbiAgICAgICAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICAgICAgICAgIHJldHVybiB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaztcbiAgICAgICAgICB9LCBkZXBzKTtcbiAgICAgICAgfSxcbiAgICAgICAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogbm9vcCxcbiAgICAgICAgdXNlRWZmZWN0OiBub29wLFxuICAgICAgICB1c2VEZWJ1Z1ZhbHVlOiBub29wLFxuICAgICAgICB1c2VEZWZlcnJlZFZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICAgICAgICAgIHJlc29sdmVDdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQoKTtcbiAgICAgICAgICByZXR1cm4gdm9pZCAwICE9PSBpbml0aWFsVmFsdWUgPyBpbml0aWFsVmFsdWUgOiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgdXNlVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJlc29sdmVDdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQoKTtcbiAgICAgICAgICByZXR1cm4gWyExLCB1bnN1cHBvcnRlZFN0YXJ0VHJhbnNpdGlvbl07XG4gICAgICAgIH0sXG4gICAgICAgIHVzZUlkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHRyZWVJZCA9IGN1cnJlbnRseVJlbmRlcmluZ1Rhc2sudHJlZUNvbnRleHQ7XG4gICAgICAgICAgdmFyIG92ZXJmbG93ID0gdHJlZUlkLm92ZXJmbG93O1xuICAgICAgICAgIHRyZWVJZCA9IHRyZWVJZC5pZDtcbiAgICAgICAgICB0cmVlSWQgPVxuICAgICAgICAgICAgKHRyZWVJZCAmIH4oMSA8PCAoMzIgLSBjbHozMih0cmVlSWQpIC0gMSkpKS50b1N0cmluZygzMikgKyBvdmVyZmxvdztcbiAgICAgICAgICB2YXIgcmVzdW1hYmxlU3RhdGUgPSBjdXJyZW50UmVzdW1hYmxlU3RhdGU7XG4gICAgICAgICAgaWYgKG51bGwgPT09IHJlc3VtYWJsZVN0YXRlKVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgIFwiSW52YWxpZCBob29rIGNhbGwuIEhvb2tzIGNhbiBvbmx5IGJlIGNhbGxlZCBpbnNpZGUgb2YgdGhlIGJvZHkgb2YgYSBmdW5jdGlvbiBjb21wb25lbnQuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgb3ZlcmZsb3cgPSBsb2NhbElkQ291bnRlcisrO1xuICAgICAgICAgIHRyZWVJZCA9IFwiX1wiICsgcmVzdW1hYmxlU3RhdGUuaWRQcmVmaXggKyBcIlJfXCIgKyB0cmVlSWQ7XG4gICAgICAgICAgMCA8IG92ZXJmbG93ICYmICh0cmVlSWQgKz0gXCJIXCIgKyBvdmVyZmxvdy50b1N0cmluZygzMikpO1xuICAgICAgICAgIHJldHVybiB0cmVlSWQgKyBcIl9cIjtcbiAgICAgICAgfSxcbiAgICAgICAgdXNlU3luY0V4dGVybmFsU3RvcmU6IGZ1bmN0aW9uIChcbiAgICAgICAgICBzdWJzY3JpYmUsXG4gICAgICAgICAgZ2V0U25hcHNob3QsXG4gICAgICAgICAgZ2V0U2VydmVyU25hcHNob3RcbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKHZvaWQgMCA9PT0gZ2V0U2VydmVyU25hcHNob3QpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgXCJNaXNzaW5nIGdldFNlcnZlclNuYXBzaG90LCB3aGljaCBpcyByZXF1aXJlZCBmb3Igc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQuIFdpbGwgcmV2ZXJ0IHRvIGNsaWVudCByZW5kZXJpbmcuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIGdldFNlcnZlclNuYXBzaG90KCk7XG4gICAgICAgIH0sXG4gICAgICAgIHVzZU9wdGltaXN0aWM6IGZ1bmN0aW9uIChwYXNzdGhyb3VnaCkge1xuICAgICAgICAgIHJlc29sdmVDdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQoKTtcbiAgICAgICAgICByZXR1cm4gW3Bhc3N0aHJvdWdoLCB1bnN1cHBvcnRlZFNldE9wdGltaXN0aWNTdGF0ZV07XG4gICAgICAgIH0sXG4gICAgICAgIHVzZUFjdGlvblN0YXRlOiB1c2VBY3Rpb25TdGF0ZSxcbiAgICAgICAgdXNlRm9ybVN0YXRlOiB1c2VBY3Rpb25TdGF0ZSxcbiAgICAgICAgdXNlSG9zdFRyYW5zaXRpb25TdGF0dXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gICAgICAgICAgcmV0dXJuIE5vdFBlbmRpbmc7XG4gICAgICAgIH0sXG4gICAgICAgIHVzZU1lbW9DYWNoZTogZnVuY3Rpb24gKHNpemUpIHtcbiAgICAgICAgICBmb3IgKHZhciBkYXRhID0gQXJyYXkoc2l6ZSksIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKVxuICAgICAgICAgICAgZGF0YVtpXSA9IFJFQUNUX01FTU9fQ0FDSEVfU0VOVElORUw7XG4gICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0sXG4gICAgICAgIHVzZUNhY2hlUmVmcmVzaDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB1bnN1cHBvcnRlZFJlZnJlc2g7XG4gICAgICAgIH0sXG4gICAgICAgIHVzZUVmZmVjdEV2ZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRocm93T25Vc2VFZmZlY3RFdmVudENhbGw7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjdXJyZW50UmVzdW1hYmxlU3RhdGUgPSBudWxsLFxuICAgICAgY3VycmVudFRhc2tJbkRFViA9IG51bGwsXG4gICAgICBEZWZhdWx0QXN5bmNEaXNwYXRjaGVyID0ge1xuICAgICAgICBnZXRDYWNoZUZvclR5cGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZC5cIik7XG4gICAgICAgIH0sXG4gICAgICAgIGNhY2hlU2lnbmFsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWQuXCIpO1xuICAgICAgICB9LFxuICAgICAgICBnZXRPd25lcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBudWxsID09PSBjdXJyZW50VGFza0luREVWXG4gICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgIDogY3VycmVudFRhc2tJbkRFVi5jb21wb25lbnRTdGFjaztcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRpc2FibGVkRGVwdGggPSAwLFxuICAgICAgcHJldkxvZyxcbiAgICAgIHByZXZJbmZvLFxuICAgICAgcHJldldhcm4sXG4gICAgICBwcmV2RXJyb3IsXG4gICAgICBwcmV2R3JvdXAsXG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQsXG4gICAgICBwcmV2R3JvdXBFbmQ7XG4gICAgZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gITA7XG4gICAgdmFyIHByZWZpeCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIHJlZW50cnkgPSAhMTtcbiAgICB2YXIgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyAoXG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBXZWFrTWFwID8gV2Vha01hcCA6IE1hcFxuICAgICkoKTtcbiAgICB2YXIgY2FsbENvbXBvbmVudCA9IHtcbiAgICAgICAgcmVhY3Rfc3RhY2tfYm90dG9tX2ZyYW1lOiBmdW5jdGlvbiAoQ29tcG9uZW50LCBwcm9wcywgc2Vjb25kQXJnKSB7XG4gICAgICAgICAgcmV0dXJuIENvbXBvbmVudChwcm9wcywgc2Vjb25kQXJnKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNhbGxDb21wb25lbnRJbkRFViA9XG4gICAgICAgIGNhbGxDb21wb25lbnQucmVhY3Rfc3RhY2tfYm90dG9tX2ZyYW1lLmJpbmQoY2FsbENvbXBvbmVudCksXG4gICAgICBjYWxsUmVuZGVyID0ge1xuICAgICAgICByZWFjdF9zdGFja19ib3R0b21fZnJhbWU6IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgICAgIHJldHVybiBpbnN0YW5jZS5yZW5kZXIoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNhbGxSZW5kZXJJbkRFViA9IGNhbGxSZW5kZXIucmVhY3Rfc3RhY2tfYm90dG9tX2ZyYW1lLmJpbmQoY2FsbFJlbmRlciksXG4gICAgICBjYWxsTGF6eUluaXQgPSB7XG4gICAgICAgIHJlYWN0X3N0YWNrX2JvdHRvbV9mcmFtZTogZnVuY3Rpb24gKGxhenkpIHtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenkuX2luaXQ7XG4gICAgICAgICAgcmV0dXJuIGluaXQobGF6eS5fcGF5bG9hZCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjYWxsTGF6eUluaXRJbkRFViA9XG4gICAgICAgIGNhbGxMYXp5SW5pdC5yZWFjdF9zdGFja19ib3R0b21fZnJhbWUuYmluZChjYWxsTGF6eUluaXQpLFxuICAgICAgbGFzdFJlc2V0VGltZSA9IDA7XG4gICAgaWYgKFxuICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHBlcmZvcm1hbmNlICYmXG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBwZXJmb3JtYW5jZS5ub3dcbiAgICApIHtcbiAgICAgIHZhciBsb2NhbFBlcmZvcm1hbmNlID0gcGVyZm9ybWFuY2U7XG4gICAgICB2YXIgZ2V0Q3VycmVudFRpbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBsb2NhbFBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGxvY2FsRGF0ZSA9IERhdGU7XG4gICAgICBnZXRDdXJyZW50VGltZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsRGF0ZS5ub3coKTtcbiAgICAgIH07XG4gICAgfVxuICAgIHZhciBDTElFTlRfUkVOREVSRUQgPSA0LFxuICAgICAgUEVORElORyA9IDAsXG4gICAgICBDT01QTEVURUQgPSAxLFxuICAgICAgRkxVU0hFRCA9IDIsXG4gICAgICBBQk9SVEVEID0gMyxcbiAgICAgIEVSUk9SRUQgPSA0LFxuICAgICAgUE9TVFBPTkVEID0gNSxcbiAgICAgIENMT1NFRCA9IDE0LFxuICAgICAgY3VycmVudFJlcXVlc3QgPSBudWxsLFxuICAgICAgZGlkV2FybkFib3V0QmFkQ2xhc3MgPSB7fSxcbiAgICAgIGRpZFdhcm5BYm91dENvbnRleHRUeXBlcyA9IHt9LFxuICAgICAgZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50ID0ge30sXG4gICAgICBkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50ID0ge30sXG4gICAgICBkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzID0gITEsXG4gICAgICBkaWRXYXJuQWJvdXRHZW5lcmF0b3JzID0gITEsXG4gICAgICBkaWRXYXJuQWJvdXRNYXBzID0gITEsXG4gICAgICBmbHVzaGVkQnl0ZVNpemUgPSAwLFxuICAgICAgZmx1c2hpbmdQYXJ0aWFsQm91bmRhcmllcyA9ICExO1xuICAgIGV4cG9ydHMucmVuZGVyVG9TdGF0aWNNYXJrdXAgPSBmdW5jdGlvbiAoY2hpbGRyZW4sIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiByZW5kZXJUb1N0cmluZ0ltcGwoXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICAhMCxcbiAgICAgICAgJ1RoZSBzZXJ2ZXIgdXNlZCBcInJlbmRlclRvU3RhdGljTWFya3VwXCIgd2hpY2ggZG9lcyBub3Qgc3VwcG9ydCBTdXNwZW5zZS4gSWYgeW91IGludGVuZGVkIHRvIGhhdmUgdGhlIHNlcnZlciB3YWl0IGZvciB0aGUgc3VzcGVuZGVkIGNvbXBvbmVudCBwbGVhc2Ugc3dpdGNoIHRvIFwicmVuZGVyVG9SZWFkYWJsZVN0cmVhbVwiIHdoaWNoIHN1cHBvcnRzIFN1c3BlbnNlIG9uIHRoZSBzZXJ2ZXInXG4gICAgICApO1xuICAgIH07XG4gICAgZXhwb3J0cy5yZW5kZXJUb1N0cmluZyA9IGZ1bmN0aW9uIChjaGlsZHJlbiwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHJlbmRlclRvU3RyaW5nSW1wbChcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgICExLFxuICAgICAgICAnVGhlIHNlcnZlciB1c2VkIFwicmVuZGVyVG9TdHJpbmdcIiB3aGljaCBkb2VzIG5vdCBzdXBwb3J0IFN1c3BlbnNlLiBJZiB5b3UgaW50ZW5kZWQgZm9yIHRoaXMgU3VzcGVuc2UgYm91bmRhcnkgdG8gcmVuZGVyIHRoZSBmYWxsYmFjayBjb250ZW50IG9uIHRoZSBzZXJ2ZXIgY29uc2lkZXIgdGhyb3dpbmcgYW4gRXJyb3Igc29tZXdoZXJlIHdpdGhpbiB0aGUgU3VzcGVuc2UgYm91bmRhcnkuIElmIHlvdSBpbnRlbmRlZCB0byBoYXZlIHRoZSBzZXJ2ZXIgd2FpdCBmb3IgdGhlIHN1c3BlbmRlZCBjb21wb25lbnQgcGxlYXNlIHN3aXRjaCB0byBcInJlbmRlclRvUmVhZGFibGVTdHJlYW1cIiB3aGljaCBzdXBwb3J0cyBTdXNwZW5zZSBvbiB0aGUgc2VydmVyJ1xuICAgICAgKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudmVyc2lvbiA9IFwiMTkuMi4wXCI7XG4gIH0pKCk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-dom/cjs/react-dom-server-legacy.browser.development.js\n\n}");

/***/ }),

/***/ "./node_modules/react-dom/cjs/react-dom-server.browser.development.js":
/*!****************************************************************************!*\
  !*** ./node_modules/react-dom/cjs/react-dom-server.browser.development.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{/**\n * @license React\n * react-dom-server.browser.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/*\n\n\n JS Implementation of MurmurHash3 (r136) (as of May 20, 2011)\n\n Copyright (c) 2011 Gary Court\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n SOFTWARE.\n*/\n\n true &&\n  (function () {\n    function styleReplacer(match, prefix, s, suffix) {\n      return \"\" + prefix + (\"s\" === s ? \"\\\\73 \" : \"\\\\53 \") + suffix;\n    }\n    function scriptReplacer(match, prefix, s, suffix) {\n      return \"\" + prefix + (\"s\" === s ? \"\\\\u0073\" : \"\\\\u0053\") + suffix;\n    }\n    function getIteratorFn(maybeIterable) {\n      if (null === maybeIterable || \"object\" !== typeof maybeIterable)\n        return null;\n      maybeIterable =\n        (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||\n        maybeIterable[\"@@iterator\"];\n      return \"function\" === typeof maybeIterable ? maybeIterable : null;\n    }\n    function objectName(object) {\n      object = Object.prototype.toString.call(object);\n      return object.slice(8, object.length - 1);\n    }\n    function describeKeyForErrorMessage(key) {\n      var encodedKey = JSON.stringify(key);\n      return '\"' + key + '\"' === encodedKey ? key : encodedKey;\n    }\n    function describeValueForErrorMessage(value) {\n      switch (typeof value) {\n        case \"string\":\n          return JSON.stringify(\n            10 >= value.length ? value : value.slice(0, 10) + \"...\"\n          );\n        case \"object\":\n          if (isArrayImpl(value)) return \"[...]\";\n          if (null !== value && value.$$typeof === CLIENT_REFERENCE_TAG)\n            return \"client\";\n          value = objectName(value);\n          return \"Object\" === value ? \"{...}\" : value;\n        case \"function\":\n          return value.$$typeof === CLIENT_REFERENCE_TAG\n            ? \"client\"\n            : (value = value.displayName || value.name)\n              ? \"function \" + value\n              : \"function\";\n        default:\n          return String(value);\n      }\n    }\n    function describeElementType(type) {\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n      }\n      if (\"object\" === typeof type)\n        switch (type.$$typeof) {\n          case REACT_FORWARD_REF_TYPE:\n            return describeElementType(type.render);\n          case REACT_MEMO_TYPE:\n            return describeElementType(type.type);\n          case REACT_LAZY_TYPE:\n            var payload = type._payload;\n            type = type._init;\n            try {\n              return describeElementType(type(payload));\n            } catch (x) {}\n        }\n      return \"\";\n    }\n    function describeObjectForErrorMessage(objectOrArray, expandedName) {\n      var objKind = objectName(objectOrArray);\n      if (\"Object\" !== objKind && \"Array\" !== objKind) return objKind;\n      var start = -1,\n        length = 0;\n      if (isArrayImpl(objectOrArray))\n        if (jsxChildrenParents.has(objectOrArray)) {\n          var type = jsxChildrenParents.get(objectOrArray);\n          objKind = \"<\" + describeElementType(type) + \">\";\n          for (var i = 0; i < objectOrArray.length; i++) {\n            var value = objectOrArray[i];\n            value =\n              \"string\" === typeof value\n                ? value\n                : \"object\" === typeof value && null !== value\n                  ? \"{\" + describeObjectForErrorMessage(value) + \"}\"\n                  : \"{\" + describeValueForErrorMessage(value) + \"}\";\n            \"\" + i === expandedName\n              ? ((start = objKind.length),\n                (length = value.length),\n                (objKind += value))\n              : (objKind =\n                  15 > value.length && 40 > objKind.length + value.length\n                    ? objKind + value\n                    : objKind + \"{...}\");\n          }\n          objKind += \"</\" + describeElementType(type) + \">\";\n        } else {\n          objKind = \"[\";\n          for (type = 0; type < objectOrArray.length; type++)\n            0 < type && (objKind += \", \"),\n              (i = objectOrArray[type]),\n              (i =\n                \"object\" === typeof i && null !== i\n                  ? describeObjectForErrorMessage(i)\n                  : describeValueForErrorMessage(i)),\n              \"\" + type === expandedName\n                ? ((start = objKind.length),\n                  (length = i.length),\n                  (objKind += i))\n                : (objKind =\n                    10 > i.length && 40 > objKind.length + i.length\n                      ? objKind + i\n                      : objKind + \"...\");\n          objKind += \"]\";\n        }\n      else if (objectOrArray.$$typeof === REACT_ELEMENT_TYPE)\n        objKind = \"<\" + describeElementType(objectOrArray.type) + \"/>\";\n      else {\n        if (objectOrArray.$$typeof === CLIENT_REFERENCE_TAG) return \"client\";\n        if (jsxPropsParents.has(objectOrArray)) {\n          objKind = jsxPropsParents.get(objectOrArray);\n          objKind = \"<\" + (describeElementType(objKind) || \"...\");\n          type = Object.keys(objectOrArray);\n          for (i = 0; i < type.length; i++) {\n            objKind += \" \";\n            value = type[i];\n            objKind += describeKeyForErrorMessage(value) + \"=\";\n            var _value2 = objectOrArray[value];\n            var _substr2 =\n              value === expandedName &&\n              \"object\" === typeof _value2 &&\n              null !== _value2\n                ? describeObjectForErrorMessage(_value2)\n                : describeValueForErrorMessage(_value2);\n            \"string\" !== typeof _value2 && (_substr2 = \"{\" + _substr2 + \"}\");\n            value === expandedName\n              ? ((start = objKind.length),\n                (length = _substr2.length),\n                (objKind += _substr2))\n              : (objKind =\n                  10 > _substr2.length && 40 > objKind.length + _substr2.length\n                    ? objKind + _substr2\n                    : objKind + \"...\");\n          }\n          objKind += \">\";\n        } else {\n          objKind = \"{\";\n          type = Object.keys(objectOrArray);\n          for (i = 0; i < type.length; i++)\n            0 < i && (objKind += \", \"),\n              (value = type[i]),\n              (objKind += describeKeyForErrorMessage(value) + \": \"),\n              (_value2 = objectOrArray[value]),\n              (_value2 =\n                \"object\" === typeof _value2 && null !== _value2\n                  ? describeObjectForErrorMessage(_value2)\n                  : describeValueForErrorMessage(_value2)),\n              value === expandedName\n                ? ((start = objKind.length),\n                  (length = _value2.length),\n                  (objKind += _value2))\n                : (objKind =\n                    10 > _value2.length && 40 > objKind.length + _value2.length\n                      ? objKind + _value2\n                      : objKind + \"...\");\n          objKind += \"}\";\n        }\n      }\n      return void 0 === expandedName\n        ? objKind\n        : -1 < start && 0 < length\n          ? ((objectOrArray = \" \".repeat(start) + \"^\".repeat(length)),\n            \"\\n  \" + objKind + \"\\n  \" + objectOrArray)\n          : \"\\n  \" + objKind;\n    }\n    function murmurhash3_32_gc(key, seed) {\n      var remainder = key.length & 3;\n      var bytes = key.length - remainder;\n      var h1 = seed;\n      for (seed = 0; seed < bytes; ) {\n        var k1 =\n          (key.charCodeAt(seed) & 255) |\n          ((key.charCodeAt(++seed) & 255) << 8) |\n          ((key.charCodeAt(++seed) & 255) << 16) |\n          ((key.charCodeAt(++seed) & 255) << 24);\n        ++seed;\n        k1 =\n          (3432918353 * (k1 & 65535) +\n            (((3432918353 * (k1 >>> 16)) & 65535) << 16)) &\n          4294967295;\n        k1 = (k1 << 15) | (k1 >>> 17);\n        k1 =\n          (461845907 * (k1 & 65535) +\n            (((461845907 * (k1 >>> 16)) & 65535) << 16)) &\n          4294967295;\n        h1 ^= k1;\n        h1 = (h1 << 13) | (h1 >>> 19);\n        h1 =\n          (5 * (h1 & 65535) + (((5 * (h1 >>> 16)) & 65535) << 16)) & 4294967295;\n        h1 = (h1 & 65535) + 27492 + ((((h1 >>> 16) + 58964) & 65535) << 16);\n      }\n      k1 = 0;\n      switch (remainder) {\n        case 3:\n          k1 ^= (key.charCodeAt(seed + 2) & 255) << 16;\n        case 2:\n          k1 ^= (key.charCodeAt(seed + 1) & 255) << 8;\n        case 1:\n          (k1 ^= key.charCodeAt(seed) & 255),\n            (k1 =\n              (3432918353 * (k1 & 65535) +\n                (((3432918353 * (k1 >>> 16)) & 65535) << 16)) &\n              4294967295),\n            (k1 = (k1 << 15) | (k1 >>> 17)),\n            (h1 ^=\n              (461845907 * (k1 & 65535) +\n                (((461845907 * (k1 >>> 16)) & 65535) << 16)) &\n              4294967295);\n      }\n      h1 ^= key.length;\n      h1 ^= h1 >>> 16;\n      h1 =\n        (2246822507 * (h1 & 65535) +\n          (((2246822507 * (h1 >>> 16)) & 65535) << 16)) &\n        4294967295;\n      h1 ^= h1 >>> 13;\n      h1 =\n        (3266489909 * (h1 & 65535) +\n          (((3266489909 * (h1 >>> 16)) & 65535) << 16)) &\n        4294967295;\n      return (h1 ^ (h1 >>> 16)) >>> 0;\n    }\n    function scheduleWork(callback) {\n      taskQueue.push(callback);\n      channel.port2.postMessage(null);\n    }\n    function handleErrorInNextTick(error) {\n      setTimeout(function () {\n        throw error;\n      });\n    }\n    function writeChunk(destination, chunk) {\n      if (0 !== chunk.byteLength)\n        if (2048 < chunk.byteLength)\n          0 < writtenBytes &&\n            (destination.enqueue(\n              new Uint8Array(currentView.buffer, 0, writtenBytes)\n            ),\n            (currentView = new Uint8Array(2048)),\n            (writtenBytes = 0)),\n            destination.enqueue(chunk);\n        else {\n          var allowableBytes = currentView.length - writtenBytes;\n          allowableBytes < chunk.byteLength &&\n            (0 === allowableBytes\n              ? destination.enqueue(currentView)\n              : (currentView.set(\n                  chunk.subarray(0, allowableBytes),\n                  writtenBytes\n                ),\n                destination.enqueue(currentView),\n                (chunk = chunk.subarray(allowableBytes))),\n            (currentView = new Uint8Array(2048)),\n            (writtenBytes = 0));\n          currentView.set(chunk, writtenBytes);\n          writtenBytes += chunk.byteLength;\n        }\n    }\n    function writeChunkAndReturn(destination, chunk) {\n      writeChunk(destination, chunk);\n      return !0;\n    }\n    function completeWriting(destination) {\n      currentView &&\n        0 < writtenBytes &&\n        (destination.enqueue(\n          new Uint8Array(currentView.buffer, 0, writtenBytes)\n        ),\n        (currentView = null),\n        (writtenBytes = 0));\n    }\n    function stringToChunk(content) {\n      return textEncoder.encode(content);\n    }\n    function stringToPrecomputedChunk(content) {\n      content = textEncoder.encode(content);\n      2048 < content.byteLength &&\n        console.error(\n          \"precomputed chunks must be smaller than the view size configured for this host. This is a bug in React.\"\n        );\n      return content;\n    }\n    function byteLengthOfChunk(chunk) {\n      return chunk.byteLength;\n    }\n    function closeWithError(destination, error) {\n      \"function\" === typeof destination.error\n        ? destination.error(error)\n        : destination.close();\n    }\n    function typeName(value) {\n      return (\n        (\"function\" === typeof Symbol &&\n          Symbol.toStringTag &&\n          value[Symbol.toStringTag]) ||\n        value.constructor.name ||\n        \"Object\"\n      );\n    }\n    function willCoercionThrow(value) {\n      try {\n        return testStringCoercion(value), !1;\n      } catch (e) {\n        return !0;\n      }\n    }\n    function testStringCoercion(value) {\n      return \"\" + value;\n    }\n    function checkAttributeStringCoercion(value, attributeName) {\n      if (willCoercionThrow(value))\n        return (\n          console.error(\n            \"The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before using it here.\",\n            attributeName,\n            typeName(value)\n          ),\n          testStringCoercion(value)\n        );\n    }\n    function checkCSSPropertyStringCoercion(value, propName) {\n      if (willCoercionThrow(value))\n        return (\n          console.error(\n            \"The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before using it here.\",\n            propName,\n            typeName(value)\n          ),\n          testStringCoercion(value)\n        );\n    }\n    function checkHtmlStringCoercion(value) {\n      if (willCoercionThrow(value))\n        return (\n          console.error(\n            \"The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before using it here.\",\n            typeName(value)\n          ),\n          testStringCoercion(value)\n        );\n    }\n    function isAttributeNameSafe(attributeName) {\n      if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))\n        return !0;\n      if (hasOwnProperty.call(illegalAttributeNameCache, attributeName))\n        return !1;\n      if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))\n        return (validatedAttributeNameCache[attributeName] = !0);\n      illegalAttributeNameCache[attributeName] = !0;\n      console.error(\"Invalid attribute name: `%s`\", attributeName);\n      return !1;\n    }\n    function checkControlledValueProps(tagName, props) {\n      hasReadOnlyValue[props.type] ||\n        props.onChange ||\n        props.onInput ||\n        props.readOnly ||\n        props.disabled ||\n        null == props.value ||\n        (\"select\" === tagName\n          ? console.error(\n              \"You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set `onChange`.\"\n            )\n          : console.error(\n              \"You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.\"\n            ));\n      props.onChange ||\n        props.readOnly ||\n        props.disabled ||\n        null == props.checked ||\n        console.error(\n          \"You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.\"\n        );\n    }\n    function validateProperty$1(tagName, name) {\n      if (\n        hasOwnProperty.call(warnedProperties$1, name) &&\n        warnedProperties$1[name]\n      )\n        return !0;\n      if (rARIACamel$1.test(name)) {\n        tagName = \"aria-\" + name.slice(4).toLowerCase();\n        tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;\n        if (null == tagName)\n          return (\n            console.error(\n              \"Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.\",\n              name\n            ),\n            (warnedProperties$1[name] = !0)\n          );\n        if (name !== tagName)\n          return (\n            console.error(\n              \"Invalid ARIA attribute `%s`. Did you mean `%s`?\",\n              name,\n              tagName\n            ),\n            (warnedProperties$1[name] = !0)\n          );\n      }\n      if (rARIA$1.test(name)) {\n        tagName = name.toLowerCase();\n        tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;\n        if (null == tagName) return (warnedProperties$1[name] = !0), !1;\n        name !== tagName &&\n          (console.error(\n            \"Unknown ARIA attribute `%s`. Did you mean `%s`?\",\n            name,\n            tagName\n          ),\n          (warnedProperties$1[name] = !0));\n      }\n      return !0;\n    }\n    function validateProperties$2(type, props) {\n      var invalidProps = [],\n        key;\n      for (key in props)\n        validateProperty$1(type, key) || invalidProps.push(key);\n      props = invalidProps\n        .map(function (prop) {\n          return \"`\" + prop + \"`\";\n        })\n        .join(\", \");\n      1 === invalidProps.length\n        ? console.error(\n            \"Invalid aria prop %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props\",\n            props,\n            type\n          )\n        : 1 < invalidProps.length &&\n          console.error(\n            \"Invalid aria props %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props\",\n            props,\n            type\n          );\n    }\n    function validateProperty(tagName, name, value, eventRegistry) {\n      if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name])\n        return !0;\n      var lowerCasedName = name.toLowerCase();\n      if (\"onfocusin\" === lowerCasedName || \"onfocusout\" === lowerCasedName)\n        return (\n          console.error(\n            \"React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.\"\n          ),\n          (warnedProperties[name] = !0)\n        );\n      if (\n        \"function\" === typeof value &&\n        ((\"form\" === tagName && \"action\" === name) ||\n          (\"input\" === tagName && \"formAction\" === name) ||\n          (\"button\" === tagName && \"formAction\" === name))\n      )\n        return !0;\n      if (null != eventRegistry) {\n        tagName = eventRegistry.possibleRegistrationNames;\n        if (eventRegistry.registrationNameDependencies.hasOwnProperty(name))\n          return !0;\n        eventRegistry = tagName.hasOwnProperty(lowerCasedName)\n          ? tagName[lowerCasedName]\n          : null;\n        if (null != eventRegistry)\n          return (\n            console.error(\n              \"Invalid event handler property `%s`. Did you mean `%s`?\",\n              name,\n              eventRegistry\n            ),\n            (warnedProperties[name] = !0)\n          );\n        if (EVENT_NAME_REGEX.test(name))\n          return (\n            console.error(\n              \"Unknown event handler property `%s`. It will be ignored.\",\n              name\n            ),\n            (warnedProperties[name] = !0)\n          );\n      } else if (EVENT_NAME_REGEX.test(name))\n        return (\n          INVALID_EVENT_NAME_REGEX.test(name) &&\n            console.error(\n              \"Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.\",\n              name\n            ),\n          (warnedProperties[name] = !0)\n        );\n      if (rARIA.test(name) || rARIACamel.test(name)) return !0;\n      if (\"innerhtml\" === lowerCasedName)\n        return (\n          console.error(\n            \"Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.\"\n          ),\n          (warnedProperties[name] = !0)\n        );\n      if (\"aria\" === lowerCasedName)\n        return (\n          console.error(\n            \"The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.\"\n          ),\n          (warnedProperties[name] = !0)\n        );\n      if (\n        \"is\" === lowerCasedName &&\n        null !== value &&\n        void 0 !== value &&\n        \"string\" !== typeof value\n      )\n        return (\n          console.error(\n            \"Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.\",\n            typeof value\n          ),\n          (warnedProperties[name] = !0)\n        );\n      if (\"number\" === typeof value && isNaN(value))\n        return (\n          console.error(\n            \"Received NaN for the `%s` attribute. If this is expected, cast the value to a string.\",\n            name\n          ),\n          (warnedProperties[name] = !0)\n        );\n      if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {\n        if (\n          ((lowerCasedName = possibleStandardNames[lowerCasedName]),\n          lowerCasedName !== name)\n        )\n          return (\n            console.error(\n              \"Invalid DOM property `%s`. Did you mean `%s`?\",\n              name,\n              lowerCasedName\n            ),\n            (warnedProperties[name] = !0)\n          );\n      } else if (name !== lowerCasedName)\n        return (\n          console.error(\n            \"React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.\",\n            name,\n            lowerCasedName\n          ),\n          (warnedProperties[name] = !0)\n        );\n      switch (name) {\n        case \"dangerouslySetInnerHTML\":\n        case \"children\":\n        case \"style\":\n        case \"suppressContentEditableWarning\":\n        case \"suppressHydrationWarning\":\n        case \"defaultValue\":\n        case \"defaultChecked\":\n        case \"innerHTML\":\n        case \"ref\":\n          return !0;\n        case \"innerText\":\n        case \"textContent\":\n          return !0;\n      }\n      switch (typeof value) {\n        case \"boolean\":\n          switch (name) {\n            case \"autoFocus\":\n            case \"checked\":\n            case \"multiple\":\n            case \"muted\":\n            case \"selected\":\n            case \"contentEditable\":\n            case \"spellCheck\":\n            case \"draggable\":\n            case \"value\":\n            case \"autoReverse\":\n            case \"externalResourcesRequired\":\n            case \"focusable\":\n            case \"preserveAlpha\":\n            case \"allowFullScreen\":\n            case \"async\":\n            case \"autoPlay\":\n            case \"controls\":\n            case \"default\":\n            case \"defer\":\n            case \"disabled\":\n            case \"disablePictureInPicture\":\n            case \"disableRemotePlayback\":\n            case \"formNoValidate\":\n            case \"hidden\":\n            case \"loop\":\n            case \"noModule\":\n            case \"noValidate\":\n            case \"open\":\n            case \"playsInline\":\n            case \"readOnly\":\n            case \"required\":\n            case \"reversed\":\n            case \"scoped\":\n            case \"seamless\":\n            case \"itemScope\":\n            case \"capture\":\n            case \"download\":\n            case \"inert\":\n              return !0;\n            default:\n              lowerCasedName = name.toLowerCase().slice(0, 5);\n              if (\"data-\" === lowerCasedName || \"aria-\" === lowerCasedName)\n                return !0;\n              value\n                ? console.error(\n                    'Received `%s` for a non-boolean attribute `%s`.\\n\\nIf you want to write it to the DOM, pass a string instead: %s=\"%s\" or %s={value.toString()}.',\n                    value,\n                    name,\n                    name,\n                    value,\n                    name\n                  )\n                : console.error(\n                    'Received `%s` for a non-boolean attribute `%s`.\\n\\nIf you want to write it to the DOM, pass a string instead: %s=\"%s\" or %s={value.toString()}.\\n\\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.',\n                    value,\n                    name,\n                    name,\n                    value,\n                    name,\n                    name,\n                    name\n                  );\n              return (warnedProperties[name] = !0);\n          }\n        case \"function\":\n        case \"symbol\":\n          return (warnedProperties[name] = !0), !1;\n        case \"string\":\n          if (\"false\" === value || \"true\" === value) {\n            switch (name) {\n              case \"checked\":\n              case \"selected\":\n              case \"multiple\":\n              case \"muted\":\n              case \"allowFullScreen\":\n              case \"async\":\n              case \"autoPlay\":\n              case \"controls\":\n              case \"default\":\n              case \"defer\":\n              case \"disabled\":\n              case \"disablePictureInPicture\":\n              case \"disableRemotePlayback\":\n              case \"formNoValidate\":\n              case \"hidden\":\n              case \"loop\":\n              case \"noModule\":\n              case \"noValidate\":\n              case \"open\":\n              case \"playsInline\":\n              case \"readOnly\":\n              case \"required\":\n              case \"reversed\":\n              case \"scoped\":\n              case \"seamless\":\n              case \"itemScope\":\n              case \"inert\":\n                break;\n              default:\n                return !0;\n            }\n            console.error(\n              \"Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?\",\n              value,\n              name,\n              \"false\" === value\n                ? \"The browser will interpret it as a truthy value.\"\n                : 'Although this works, it will not work as expected if you pass the string \"false\".',\n              name,\n              value\n            );\n            warnedProperties[name] = !0;\n          }\n      }\n      return !0;\n    }\n    function warnUnknownProperties(type, props, eventRegistry) {\n      var unknownProps = [],\n        key;\n      for (key in props)\n        validateProperty(type, key, props[key], eventRegistry) ||\n          unknownProps.push(key);\n      props = unknownProps\n        .map(function (prop) {\n          return \"`\" + prop + \"`\";\n        })\n        .join(\", \");\n      1 === unknownProps.length\n        ? console.error(\n            \"Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://react.dev/link/attribute-behavior \",\n            props,\n            type\n          )\n        : 1 < unknownProps.length &&\n          console.error(\n            \"Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://react.dev/link/attribute-behavior \",\n            props,\n            type\n          );\n    }\n    function camelize(string) {\n      return string.replace(hyphenPattern, function (_, character) {\n        return character.toUpperCase();\n      });\n    }\n    function escapeTextForBrowser(text) {\n      if (\n        \"boolean\" === typeof text ||\n        \"number\" === typeof text ||\n        \"bigint\" === typeof text\n      )\n        return \"\" + text;\n      checkHtmlStringCoercion(text);\n      text = \"\" + text;\n      var match = matchHtmlRegExp.exec(text);\n      if (match) {\n        var html = \"\",\n          index,\n          lastIndex = 0;\n        for (index = match.index; index < text.length; index++) {\n          switch (text.charCodeAt(index)) {\n            case 34:\n              match = \"&quot;\";\n              break;\n            case 38:\n              match = \"&amp;\";\n              break;\n            case 39:\n              match = \"&#x27;\";\n              break;\n            case 60:\n              match = \"&lt;\";\n              break;\n            case 62:\n              match = \"&gt;\";\n              break;\n            default:\n              continue;\n          }\n          lastIndex !== index && (html += text.slice(lastIndex, index));\n          lastIndex = index + 1;\n          html += match;\n        }\n        text = lastIndex !== index ? html + text.slice(lastIndex, index) : html;\n      }\n      return text;\n    }\n    function sanitizeURL(url) {\n      return isJavaScriptProtocol.test(\"\" + url)\n        ? \"javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')\"\n        : url;\n    }\n    function escapeEntireInlineScriptContent(scriptText) {\n      checkHtmlStringCoercion(scriptText);\n      return (\"\" + scriptText).replace(scriptRegex, scriptReplacer);\n    }\n    function createRenderState(\n      resumableState,\n      nonce,\n      externalRuntimeConfig,\n      importMap,\n      onHeaders,\n      maxHeadersLength\n    ) {\n      externalRuntimeConfig =\n        \"string\" === typeof nonce ? nonce : nonce && nonce.script;\n      var inlineScriptWithNonce =\n          void 0 === externalRuntimeConfig\n            ? startInlineScript\n            : stringToPrecomputedChunk(\n                '<script nonce=\"' +\n                  escapeTextForBrowser(externalRuntimeConfig) +\n                  '\"'\n              ),\n        nonceStyle = \"string\" === typeof nonce ? void 0 : nonce && nonce.style,\n        inlineStyleWithNonce =\n          void 0 === nonceStyle\n            ? startInlineStyle\n            : stringToPrecomputedChunk(\n                '<style nonce=\"' + escapeTextForBrowser(nonceStyle) + '\"'\n              ),\n        idPrefix = resumableState.idPrefix,\n        bootstrapChunks = [],\n        bootstrapScriptContent = resumableState.bootstrapScriptContent,\n        bootstrapScripts = resumableState.bootstrapScripts,\n        bootstrapModules = resumableState.bootstrapModules;\n      void 0 !== bootstrapScriptContent &&\n        (bootstrapChunks.push(inlineScriptWithNonce),\n        pushCompletedShellIdAttribute(bootstrapChunks, resumableState),\n        bootstrapChunks.push(\n          endOfStartTag,\n          stringToChunk(\n            escapeEntireInlineScriptContent(bootstrapScriptContent)\n          ),\n          endInlineScript\n        ));\n      bootstrapScriptContent = [];\n      void 0 !== importMap &&\n        (bootstrapScriptContent.push(importMapScriptStart),\n        bootstrapScriptContent.push(\n          stringToChunk(\n            escapeEntireInlineScriptContent(JSON.stringify(importMap))\n          )\n        ),\n        bootstrapScriptContent.push(importMapScriptEnd));\n      onHeaders &&\n        \"number\" === typeof maxHeadersLength &&\n        0 >= maxHeadersLength &&\n        console.error(\n          \"React expected a positive non-zero `maxHeadersLength` option but found %s instead. When using the `onHeaders` option you may supply an optional `maxHeadersLength` option as well however, when setting this value to zero or less no headers will be captured.\",\n          0 === maxHeadersLength ? \"zero\" : maxHeadersLength\n        );\n      importMap = onHeaders\n        ? {\n            preconnects: \"\",\n            fontPreloads: \"\",\n            highImagePreloads: \"\",\n            remainingCapacity:\n              2 +\n              (\"number\" === typeof maxHeadersLength ? maxHeadersLength : 2e3)\n          }\n        : null;\n      onHeaders = {\n        placeholderPrefix: stringToPrecomputedChunk(idPrefix + \"P:\"),\n        segmentPrefix: stringToPrecomputedChunk(idPrefix + \"S:\"),\n        boundaryPrefix: stringToPrecomputedChunk(idPrefix + \"B:\"),\n        startInlineScript: inlineScriptWithNonce,\n        startInlineStyle: inlineStyleWithNonce,\n        preamble: createPreambleState(),\n        externalRuntimeScript: null,\n        bootstrapChunks: bootstrapChunks,\n        importMapChunks: bootstrapScriptContent,\n        onHeaders: onHeaders,\n        headers: importMap,\n        resets: {\n          font: {},\n          dns: {},\n          connect: { default: {}, anonymous: {}, credentials: {} },\n          image: {},\n          style: {}\n        },\n        charsetChunks: [],\n        viewportChunks: [],\n        hoistableChunks: [],\n        preconnects: new Set(),\n        fontPreloads: new Set(),\n        highImagePreloads: new Set(),\n        styles: new Map(),\n        bootstrapScripts: new Set(),\n        scripts: new Set(),\n        bulkPreloads: new Set(),\n        preloads: {\n          images: new Map(),\n          stylesheets: new Map(),\n          scripts: new Map(),\n          moduleScripts: new Map()\n        },\n        nonce: { script: externalRuntimeConfig, style: nonceStyle },\n        hoistableState: null,\n        stylesToHoist: !1\n      };\n      if (void 0 !== bootstrapScripts)\n        for (importMap = 0; importMap < bootstrapScripts.length; importMap++)\n          (maxHeadersLength = bootstrapScripts[importMap]),\n            (inlineStyleWithNonce = nonceStyle = void 0),\n            (idPrefix = {\n              rel: \"preload\",\n              as: \"script\",\n              fetchPriority: \"low\",\n              nonce: nonce\n            }),\n            \"string\" === typeof maxHeadersLength\n              ? (idPrefix.href = inlineScriptWithNonce = maxHeadersLength)\n              : ((idPrefix.href = inlineScriptWithNonce = maxHeadersLength.src),\n                (idPrefix.integrity = inlineStyleWithNonce =\n                  \"string\" === typeof maxHeadersLength.integrity\n                    ? maxHeadersLength.integrity\n                    : void 0),\n                (idPrefix.crossOrigin = nonceStyle =\n                  \"string\" === typeof maxHeadersLength ||\n                  null == maxHeadersLength.crossOrigin\n                    ? void 0\n                    : \"use-credentials\" === maxHeadersLength.crossOrigin\n                      ? \"use-credentials\"\n                      : \"\")),\n            preloadBootstrapScriptOrModule(\n              resumableState,\n              onHeaders,\n              inlineScriptWithNonce,\n              idPrefix\n            ),\n            bootstrapChunks.push(\n              startScriptSrc,\n              stringToChunk(escapeTextForBrowser(inlineScriptWithNonce)),\n              attributeEnd\n            ),\n            externalRuntimeConfig &&\n              bootstrapChunks.push(\n                scriptNonce,\n                stringToChunk(escapeTextForBrowser(externalRuntimeConfig)),\n                attributeEnd\n              ),\n            \"string\" === typeof inlineStyleWithNonce &&\n              bootstrapChunks.push(\n                scriptIntegirty,\n                stringToChunk(escapeTextForBrowser(inlineStyleWithNonce)),\n                attributeEnd\n              ),\n            \"string\" === typeof nonceStyle &&\n              bootstrapChunks.push(\n                scriptCrossOrigin,\n                stringToChunk(escapeTextForBrowser(nonceStyle)),\n                attributeEnd\n              ),\n            pushCompletedShellIdAttribute(bootstrapChunks, resumableState),\n            bootstrapChunks.push(endAsyncScript);\n      if (void 0 !== bootstrapModules)\n        for (nonce = 0; nonce < bootstrapModules.length; nonce++)\n          (bootstrapScripts = bootstrapModules[nonce]),\n            (inlineScriptWithNonce = maxHeadersLength = void 0),\n            (nonceStyle = {\n              rel: \"modulepreload\",\n              fetchPriority: \"low\",\n              nonce: externalRuntimeConfig\n            }),\n            \"string\" === typeof bootstrapScripts\n              ? (nonceStyle.href = importMap = bootstrapScripts)\n              : ((nonceStyle.href = importMap = bootstrapScripts.src),\n                (nonceStyle.integrity = inlineScriptWithNonce =\n                  \"string\" === typeof bootstrapScripts.integrity\n                    ? bootstrapScripts.integrity\n                    : void 0),\n                (nonceStyle.crossOrigin = maxHeadersLength =\n                  \"string\" === typeof bootstrapScripts ||\n                  null == bootstrapScripts.crossOrigin\n                    ? void 0\n                    : \"use-credentials\" === bootstrapScripts.crossOrigin\n                      ? \"use-credentials\"\n                      : \"\")),\n            preloadBootstrapScriptOrModule(\n              resumableState,\n              onHeaders,\n              importMap,\n              nonceStyle\n            ),\n            bootstrapChunks.push(\n              startModuleSrc,\n              stringToChunk(escapeTextForBrowser(importMap)),\n              attributeEnd\n            ),\n            externalRuntimeConfig &&\n              bootstrapChunks.push(\n                scriptNonce,\n                stringToChunk(escapeTextForBrowser(externalRuntimeConfig)),\n                attributeEnd\n              ),\n            \"string\" === typeof inlineScriptWithNonce &&\n              bootstrapChunks.push(\n                scriptIntegirty,\n                stringToChunk(escapeTextForBrowser(inlineScriptWithNonce)),\n                attributeEnd\n              ),\n            \"string\" === typeof maxHeadersLength &&\n              bootstrapChunks.push(\n                scriptCrossOrigin,\n                stringToChunk(escapeTextForBrowser(maxHeadersLength)),\n                attributeEnd\n              ),\n            pushCompletedShellIdAttribute(bootstrapChunks, resumableState),\n            bootstrapChunks.push(endAsyncScript);\n      return onHeaders;\n    }\n    function createResumableState(\n      identifierPrefix,\n      externalRuntimeConfig,\n      bootstrapScriptContent,\n      bootstrapScripts,\n      bootstrapModules\n    ) {\n      return {\n        idPrefix: void 0 === identifierPrefix ? \"\" : identifierPrefix,\n        nextFormID: 0,\n        streamingFormat: 0,\n        bootstrapScriptContent: bootstrapScriptContent,\n        bootstrapScripts: bootstrapScripts,\n        bootstrapModules: bootstrapModules,\n        instructions: NothingSent,\n        hasBody: !1,\n        hasHtml: !1,\n        unknownResources: {},\n        dnsResources: {},\n        connectResources: { default: {}, anonymous: {}, credentials: {} },\n        imageResources: {},\n        styleResources: {},\n        scriptResources: {},\n        moduleUnknownResources: {},\n        moduleScriptResources: {}\n      };\n    }\n    function createPreambleState() {\n      return { htmlChunks: null, headChunks: null, bodyChunks: null };\n    }\n    function createFormatContext(\n      insertionMode,\n      selectedValue,\n      tagScope,\n      viewTransition\n    ) {\n      return {\n        insertionMode: insertionMode,\n        selectedValue: selectedValue,\n        tagScope: tagScope,\n        viewTransition: viewTransition\n      };\n    }\n    function createRootFormatContext(namespaceURI) {\n      return createFormatContext(\n        \"http://www.w3.org/2000/svg\" === namespaceURI\n          ? SVG_MODE\n          : \"http://www.w3.org/1998/Math/MathML\" === namespaceURI\n            ? MATHML_MODE\n            : ROOT_HTML_MODE,\n        null,\n        0,\n        null\n      );\n    }\n    function getChildFormatContext(parentContext, type, props) {\n      var subtreeScope = parentContext.tagScope & -25;\n      switch (type) {\n        case \"noscript\":\n          return createFormatContext(HTML_MODE, null, subtreeScope | 1, null);\n        case \"select\":\n          return createFormatContext(\n            HTML_MODE,\n            null != props.value ? props.value : props.defaultValue,\n            subtreeScope,\n            null\n          );\n        case \"svg\":\n          return createFormatContext(SVG_MODE, null, subtreeScope, null);\n        case \"picture\":\n          return createFormatContext(HTML_MODE, null, subtreeScope | 2, null);\n        case \"math\":\n          return createFormatContext(MATHML_MODE, null, subtreeScope, null);\n        case \"foreignObject\":\n          return createFormatContext(HTML_MODE, null, subtreeScope, null);\n        case \"table\":\n          return createFormatContext(HTML_TABLE_MODE, null, subtreeScope, null);\n        case \"thead\":\n        case \"tbody\":\n        case \"tfoot\":\n          return createFormatContext(\n            HTML_TABLE_BODY_MODE,\n            null,\n            subtreeScope,\n            null\n          );\n        case \"colgroup\":\n          return createFormatContext(\n            HTML_COLGROUP_MODE,\n            null,\n            subtreeScope,\n            null\n          );\n        case \"tr\":\n          return createFormatContext(\n            HTML_TABLE_ROW_MODE,\n            null,\n            subtreeScope,\n            null\n          );\n        case \"head\":\n          if (parentContext.insertionMode < HTML_MODE)\n            return createFormatContext(\n              HTML_HEAD_MODE,\n              null,\n              subtreeScope,\n              null\n            );\n          break;\n        case \"html\":\n          if (parentContext.insertionMode === ROOT_HTML_MODE)\n            return createFormatContext(\n              HTML_HTML_MODE,\n              null,\n              subtreeScope,\n              null\n            );\n      }\n      return parentContext.insertionMode >= HTML_TABLE_MODE ||\n        parentContext.insertionMode < HTML_MODE\n        ? createFormatContext(HTML_MODE, null, subtreeScope, null)\n        : parentContext.tagScope !== subtreeScope\n          ? createFormatContext(\n              parentContext.insertionMode,\n              parentContext.selectedValue,\n              subtreeScope,\n              null\n            )\n          : parentContext;\n    }\n    function getSuspenseViewTransition(parentViewTransition) {\n      return null === parentViewTransition\n        ? null\n        : {\n            update: parentViewTransition.update,\n            enter: \"none\",\n            exit: \"none\",\n            share: parentViewTransition.update,\n            name: parentViewTransition.autoName,\n            autoName: parentViewTransition.autoName,\n            nameIdx: 0\n          };\n    }\n    function getSuspenseFallbackFormatContext(resumableState, parentContext) {\n      parentContext.tagScope & 32 && (resumableState.instructions |= 128);\n      return createFormatContext(\n        parentContext.insertionMode,\n        parentContext.selectedValue,\n        parentContext.tagScope | 12,\n        getSuspenseViewTransition(parentContext.viewTransition)\n      );\n    }\n    function getSuspenseContentFormatContext(resumableState, parentContext) {\n      resumableState = getSuspenseViewTransition(parentContext.viewTransition);\n      var subtreeScope = parentContext.tagScope | 16;\n      null !== resumableState &&\n        \"none\" !== resumableState.share &&\n        (subtreeScope |= 64);\n      return createFormatContext(\n        parentContext.insertionMode,\n        parentContext.selectedValue,\n        subtreeScope,\n        resumableState\n      );\n    }\n    function pushTextInstance(target, text, renderState, textEmbedded) {\n      if (\"\" === text) return textEmbedded;\n      textEmbedded && target.push(textSeparator);\n      target.push(stringToChunk(escapeTextForBrowser(text)));\n      return !0;\n    }\n    function pushStyleAttribute(target, style) {\n      if (\"object\" !== typeof style)\n        throw Error(\n          \"The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.\"\n        );\n      var isFirst = !0,\n        styleName;\n      for (styleName in style)\n        if (hasOwnProperty.call(style, styleName)) {\n          var styleValue = style[styleName];\n          if (\n            null != styleValue &&\n            \"boolean\" !== typeof styleValue &&\n            \"\" !== styleValue\n          ) {\n            if (0 === styleName.indexOf(\"--\")) {\n              var nameChunk = stringToChunk(escapeTextForBrowser(styleName));\n              checkCSSPropertyStringCoercion(styleValue, styleName);\n              styleValue = stringToChunk(\n                escapeTextForBrowser((\"\" + styleValue).trim())\n              );\n            } else {\n              nameChunk = styleName;\n              var value = styleValue;\n              if (-1 < nameChunk.indexOf(\"-\")) {\n                var name = nameChunk;\n                (warnedStyleNames.hasOwnProperty(name) &&\n                  warnedStyleNames[name]) ||\n                  ((warnedStyleNames[name] = !0),\n                  console.error(\n                    \"Unsupported style property %s. Did you mean %s?\",\n                    name,\n                    camelize(name.replace(msPattern$1, \"ms-\"))\n                  ));\n              } else if (badVendoredStyleNamePattern.test(nameChunk))\n                (name = nameChunk),\n                  (warnedStyleNames.hasOwnProperty(name) &&\n                    warnedStyleNames[name]) ||\n                    ((warnedStyleNames[name] = !0),\n                    console.error(\n                      \"Unsupported vendor-prefixed style property %s. Did you mean %s?\",\n                      name,\n                      name.charAt(0).toUpperCase() + name.slice(1)\n                    ));\n              else if (badStyleValueWithSemicolonPattern.test(value)) {\n                name = nameChunk;\n                var value$jscomp$0 = value;\n                (warnedStyleValues.hasOwnProperty(value$jscomp$0) &&\n                  warnedStyleValues[value$jscomp$0]) ||\n                  ((warnedStyleValues[value$jscomp$0] = !0),\n                  console.error(\n                    'Style property values shouldn\\'t contain a semicolon. Try \"%s: %s\" instead.',\n                    name,\n                    value$jscomp$0.replace(\n                      badStyleValueWithSemicolonPattern,\n                      \"\"\n                    )\n                  ));\n              }\n              \"number\" === typeof value &&\n                (isNaN(value)\n                  ? warnedForNaNValue ||\n                    ((warnedForNaNValue = !0),\n                    console.error(\n                      \"`NaN` is an invalid value for the `%s` css style property.\",\n                      nameChunk\n                    ))\n                  : isFinite(value) ||\n                    warnedForInfinityValue ||\n                    ((warnedForInfinityValue = !0),\n                    console.error(\n                      \"`Infinity` is an invalid value for the `%s` css style property.\",\n                      nameChunk\n                    )));\n              nameChunk = styleName;\n              value = styleNameCache.get(nameChunk);\n              void 0 !== value\n                ? (nameChunk = value)\n                : ((value = stringToPrecomputedChunk(\n                    escapeTextForBrowser(\n                      nameChunk\n                        .replace(uppercasePattern, \"-$1\")\n                        .toLowerCase()\n                        .replace(msPattern, \"-ms-\")\n                    )\n                  )),\n                  styleNameCache.set(nameChunk, value),\n                  (nameChunk = value));\n              \"number\" === typeof styleValue\n                ? (styleValue =\n                    0 === styleValue || unitlessNumbers.has(styleName)\n                      ? stringToChunk(\"\" + styleValue)\n                      : stringToChunk(styleValue + \"px\"))\n                : (checkCSSPropertyStringCoercion(styleValue, styleName),\n                  (styleValue = stringToChunk(\n                    escapeTextForBrowser((\"\" + styleValue).trim())\n                  )));\n            }\n            isFirst\n              ? ((isFirst = !1),\n                target.push(\n                  styleAttributeStart,\n                  nameChunk,\n                  styleAssign,\n                  styleValue\n                ))\n              : target.push(styleSeparator, nameChunk, styleAssign, styleValue);\n          }\n        }\n      isFirst || target.push(attributeEnd);\n    }\n    function pushBooleanAttribute(target, name, value) {\n      value &&\n        \"function\" !== typeof value &&\n        \"symbol\" !== typeof value &&\n        target.push(\n          attributeSeparator,\n          stringToChunk(name),\n          attributeEmptyString\n        );\n    }\n    function pushStringAttribute(target, name, value) {\n      \"function\" !== typeof value &&\n        \"symbol\" !== typeof value &&\n        \"boolean\" !== typeof value &&\n        target.push(\n          attributeSeparator,\n          stringToChunk(name),\n          attributeAssign,\n          stringToChunk(escapeTextForBrowser(value)),\n          attributeEnd\n        );\n    }\n    function pushAdditionalFormField(value, key) {\n      this.push(startHiddenInputChunk);\n      validateAdditionalFormField(value);\n      pushStringAttribute(this, \"name\", key);\n      pushStringAttribute(this, \"value\", value);\n      this.push(endOfStartTagSelfClosing);\n    }\n    function validateAdditionalFormField(value) {\n      if (\"string\" !== typeof value)\n        throw Error(\n          \"File/Blob fields are not yet supported in progressive forms. Will fallback to client hydration.\"\n        );\n    }\n    function getCustomFormFields(resumableState, formAction) {\n      if (\"function\" === typeof formAction.$$FORM_ACTION) {\n        var id = resumableState.nextFormID++;\n        resumableState = resumableState.idPrefix + id;\n        try {\n          var customFields = formAction.$$FORM_ACTION(resumableState);\n          if (customFields) {\n            var formData = customFields.data;\n            null != formData && formData.forEach(validateAdditionalFormField);\n          }\n          return customFields;\n        } catch (x) {\n          if (\n            \"object\" === typeof x &&\n            null !== x &&\n            \"function\" === typeof x.then\n          )\n            throw x;\n          console.error(\n            \"Failed to serialize an action for progressive enhancement:\\n%s\",\n            x\n          );\n        }\n      }\n      return null;\n    }\n    function pushFormActionAttribute(\n      target,\n      resumableState,\n      renderState,\n      formAction,\n      formEncType,\n      formMethod,\n      formTarget,\n      name\n    ) {\n      var formData = null;\n      if (\"function\" === typeof formAction) {\n        null === name ||\n          didWarnFormActionName ||\n          ((didWarnFormActionName = !0),\n          console.error(\n            'Cannot specify a \"name\" prop for a button that specifies a function as a formAction. React needs it to encode which action should be invoked. It will get overridden.'\n          ));\n        (null === formEncType && null === formMethod) ||\n          didWarnFormActionMethod ||\n          ((didWarnFormActionMethod = !0),\n          console.error(\n            \"Cannot specify a formEncType or formMethod for a button that specifies a function as a formAction. React provides those automatically. They will get overridden.\"\n          ));\n        null === formTarget ||\n          didWarnFormActionTarget ||\n          ((didWarnFormActionTarget = !0),\n          console.error(\n            \"Cannot specify a formTarget for a button that specifies a function as a formAction. The function will always be executed in the same window.\"\n          ));\n        var customFields = getCustomFormFields(resumableState, formAction);\n        null !== customFields\n          ? ((name = customFields.name),\n            (formAction = customFields.action || \"\"),\n            (formEncType = customFields.encType),\n            (formMethod = customFields.method),\n            (formTarget = customFields.target),\n            (formData = customFields.data))\n          : (target.push(\n              attributeSeparator,\n              stringToChunk(\"formAction\"),\n              attributeAssign,\n              actionJavaScriptURL,\n              attributeEnd\n            ),\n            (formTarget = formMethod = formEncType = formAction = name = null),\n            injectFormReplayingRuntime(resumableState, renderState));\n      }\n      null != name && pushAttribute(target, \"name\", name);\n      null != formAction && pushAttribute(target, \"formAction\", formAction);\n      null != formEncType && pushAttribute(target, \"formEncType\", formEncType);\n      null != formMethod && pushAttribute(target, \"formMethod\", formMethod);\n      null != formTarget && pushAttribute(target, \"formTarget\", formTarget);\n      return formData;\n    }\n    function pushAttribute(target, name, value) {\n      switch (name) {\n        case \"className\":\n          pushStringAttribute(target, \"class\", value);\n          break;\n        case \"tabIndex\":\n          pushStringAttribute(target, \"tabindex\", value);\n          break;\n        case \"dir\":\n        case \"role\":\n        case \"viewBox\":\n        case \"width\":\n        case \"height\":\n          pushStringAttribute(target, name, value);\n          break;\n        case \"style\":\n          pushStyleAttribute(target, value);\n          break;\n        case \"src\":\n        case \"href\":\n          if (\"\" === value) {\n            \"src\" === name\n              ? console.error(\n                  'An empty string (\"\") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',\n                  name,\n                  name\n                )\n              : console.error(\n                  'An empty string (\"\") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',\n                  name,\n                  name\n                );\n            break;\n          }\n        case \"action\":\n        case \"formAction\":\n          if (\n            null == value ||\n            \"function\" === typeof value ||\n            \"symbol\" === typeof value ||\n            \"boolean\" === typeof value\n          )\n            break;\n          checkAttributeStringCoercion(value, name);\n          value = sanitizeURL(\"\" + value);\n          target.push(\n            attributeSeparator,\n            stringToChunk(name),\n            attributeAssign,\n            stringToChunk(escapeTextForBrowser(value)),\n            attributeEnd\n          );\n          break;\n        case \"defaultValue\":\n        case \"defaultChecked\":\n        case \"innerHTML\":\n        case \"suppressContentEditableWarning\":\n        case \"suppressHydrationWarning\":\n        case \"ref\":\n          break;\n        case \"autoFocus\":\n        case \"multiple\":\n        case \"muted\":\n          pushBooleanAttribute(target, name.toLowerCase(), value);\n          break;\n        case \"xlinkHref\":\n          if (\n            \"function\" === typeof value ||\n            \"symbol\" === typeof value ||\n            \"boolean\" === typeof value\n          )\n            break;\n          checkAttributeStringCoercion(value, name);\n          value = sanitizeURL(\"\" + value);\n          target.push(\n            attributeSeparator,\n            stringToChunk(\"xlink:href\"),\n            attributeAssign,\n            stringToChunk(escapeTextForBrowser(value)),\n            attributeEnd\n          );\n          break;\n        case \"contentEditable\":\n        case \"spellCheck\":\n        case \"draggable\":\n        case \"value\":\n        case \"autoReverse\":\n        case \"externalResourcesRequired\":\n        case \"focusable\":\n        case \"preserveAlpha\":\n          \"function\" !== typeof value &&\n            \"symbol\" !== typeof value &&\n            target.push(\n              attributeSeparator,\n              stringToChunk(name),\n              attributeAssign,\n              stringToChunk(escapeTextForBrowser(value)),\n              attributeEnd\n            );\n          break;\n        case \"inert\":\n          \"\" !== value ||\n            didWarnForNewBooleanPropsWithEmptyValue[name] ||\n            ((didWarnForNewBooleanPropsWithEmptyValue[name] = !0),\n            console.error(\n              \"Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.\",\n              name\n            ));\n        case \"allowFullScreen\":\n        case \"async\":\n        case \"autoPlay\":\n        case \"controls\":\n        case \"default\":\n        case \"defer\":\n        case \"disabled\":\n        case \"disablePictureInPicture\":\n        case \"disableRemotePlayback\":\n        case \"formNoValidate\":\n        case \"hidden\":\n        case \"loop\":\n        case \"noModule\":\n        case \"noValidate\":\n        case \"open\":\n        case \"playsInline\":\n        case \"readOnly\":\n        case \"required\":\n        case \"reversed\":\n        case \"scoped\":\n        case \"seamless\":\n        case \"itemScope\":\n          value &&\n            \"function\" !== typeof value &&\n            \"symbol\" !== typeof value &&\n            target.push(\n              attributeSeparator,\n              stringToChunk(name),\n              attributeEmptyString\n            );\n          break;\n        case \"capture\":\n        case \"download\":\n          !0 === value\n            ? target.push(\n                attributeSeparator,\n                stringToChunk(name),\n                attributeEmptyString\n              )\n            : !1 !== value &&\n              \"function\" !== typeof value &&\n              \"symbol\" !== typeof value &&\n              target.push(\n                attributeSeparator,\n                stringToChunk(name),\n                attributeAssign,\n                stringToChunk(escapeTextForBrowser(value)),\n                attributeEnd\n              );\n          break;\n        case \"cols\":\n        case \"rows\":\n        case \"size\":\n        case \"span\":\n          \"function\" !== typeof value &&\n            \"symbol\" !== typeof value &&\n            !isNaN(value) &&\n            1 <= value &&\n            target.push(\n              attributeSeparator,\n              stringToChunk(name),\n              attributeAssign,\n              stringToChunk(escapeTextForBrowser(value)),\n              attributeEnd\n            );\n          break;\n        case \"rowSpan\":\n        case \"start\":\n          \"function\" === typeof value ||\n            \"symbol\" === typeof value ||\n            isNaN(value) ||\n            target.push(\n              attributeSeparator,\n              stringToChunk(name),\n              attributeAssign,\n              stringToChunk(escapeTextForBrowser(value)),\n              attributeEnd\n            );\n          break;\n        case \"xlinkActuate\":\n          pushStringAttribute(target, \"xlink:actuate\", value);\n          break;\n        case \"xlinkArcrole\":\n          pushStringAttribute(target, \"xlink:arcrole\", value);\n          break;\n        case \"xlinkRole\":\n          pushStringAttribute(target, \"xlink:role\", value);\n          break;\n        case \"xlinkShow\":\n          pushStringAttribute(target, \"xlink:show\", value);\n          break;\n        case \"xlinkTitle\":\n          pushStringAttribute(target, \"xlink:title\", value);\n          break;\n        case \"xlinkType\":\n          pushStringAttribute(target, \"xlink:type\", value);\n          break;\n        case \"xmlBase\":\n          pushStringAttribute(target, \"xml:base\", value);\n          break;\n        case \"xmlLang\":\n          pushStringAttribute(target, \"xml:lang\", value);\n          break;\n        case \"xmlSpace\":\n          pushStringAttribute(target, \"xml:space\", value);\n          break;\n        default:\n          if (\n            !(2 < name.length) ||\n            (\"o\" !== name[0] && \"O\" !== name[0]) ||\n            (\"n\" !== name[1] && \"N\" !== name[1])\n          )\n            if (\n              ((name = aliases.get(name) || name), isAttributeNameSafe(name))\n            ) {\n              switch (typeof value) {\n                case \"function\":\n                case \"symbol\":\n                  return;\n                case \"boolean\":\n                  var prefix = name.toLowerCase().slice(0, 5);\n                  if (\"data-\" !== prefix && \"aria-\" !== prefix) return;\n              }\n              target.push(\n                attributeSeparator,\n                stringToChunk(name),\n                attributeAssign,\n                stringToChunk(escapeTextForBrowser(value)),\n                attributeEnd\n              );\n            }\n      }\n    }\n    function pushInnerHTML(target, innerHTML, children) {\n      if (null != innerHTML) {\n        if (null != children)\n          throw Error(\n            \"Can only set one of `children` or `props.dangerouslySetInnerHTML`.\"\n          );\n        if (\"object\" !== typeof innerHTML || !(\"__html\" in innerHTML))\n          throw Error(\n            \"`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information.\"\n          );\n        innerHTML = innerHTML.__html;\n        null !== innerHTML &&\n          void 0 !== innerHTML &&\n          (checkHtmlStringCoercion(innerHTML),\n          target.push(stringToChunk(\"\" + innerHTML)));\n      }\n    }\n    function checkSelectProp(props, propName) {\n      var value = props[propName];\n      null != value &&\n        ((value = isArrayImpl(value)),\n        props.multiple && !value\n          ? console.error(\n              \"The `%s` prop supplied to <select> must be an array if `multiple` is true.\",\n              propName\n            )\n          : !props.multiple &&\n            value &&\n            console.error(\n              \"The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.\",\n              propName\n            ));\n    }\n    function flattenOptionChildren(children) {\n      var content = \"\";\n      React.Children.forEach(children, function (child) {\n        null != child &&\n          ((content += child),\n          didWarnInvalidOptionChildren ||\n            \"string\" === typeof child ||\n            \"number\" === typeof child ||\n            \"bigint\" === typeof child ||\n            ((didWarnInvalidOptionChildren = !0),\n            console.error(\n              \"Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.\"\n            )));\n      });\n      return content;\n    }\n    function injectFormReplayingRuntime(resumableState, renderState) {\n      if ((resumableState.instructions & 16) === NothingSent) {\n        resumableState.instructions |= 16;\n        var preamble = renderState.preamble,\n          bootstrapChunks = renderState.bootstrapChunks;\n        (preamble.htmlChunks || preamble.headChunks) &&\n        0 === bootstrapChunks.length\n          ? (bootstrapChunks.push(renderState.startInlineScript),\n            pushCompletedShellIdAttribute(bootstrapChunks, resumableState),\n            bootstrapChunks.push(\n              endOfStartTag,\n              formReplayingRuntimeScript,\n              endInlineScript\n            ))\n          : bootstrapChunks.unshift(\n              renderState.startInlineScript,\n              endOfStartTag,\n              formReplayingRuntimeScript,\n              endInlineScript\n            );\n      }\n    }\n    function pushLinkImpl(target, props) {\n      target.push(startChunkForTag(\"link\"));\n      for (var propKey in props)\n        if (hasOwnProperty.call(props, propKey)) {\n          var propValue = props[propKey];\n          if (null != propValue)\n            switch (propKey) {\n              case \"children\":\n              case \"dangerouslySetInnerHTML\":\n                throw Error(\n                  \"link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.\"\n                );\n              default:\n                pushAttribute(target, propKey, propValue);\n            }\n        }\n      target.push(endOfStartTagSelfClosing);\n      return null;\n    }\n    function escapeStyleTextContent(styleText) {\n      checkHtmlStringCoercion(styleText);\n      return (\"\" + styleText).replace(styleRegex, styleReplacer);\n    }\n    function pushSelfClosing(target, props, tag) {\n      target.push(startChunkForTag(tag));\n      for (var propKey in props)\n        if (hasOwnProperty.call(props, propKey)) {\n          var propValue = props[propKey];\n          if (null != propValue)\n            switch (propKey) {\n              case \"children\":\n              case \"dangerouslySetInnerHTML\":\n                throw Error(\n                  tag +\n                    \" is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.\"\n                );\n              default:\n                pushAttribute(target, propKey, propValue);\n            }\n        }\n      target.push(endOfStartTagSelfClosing);\n      return null;\n    }\n    function pushTitleImpl(target, props) {\n      target.push(startChunkForTag(\"title\"));\n      var children = null,\n        innerHTML = null,\n        propKey;\n      for (propKey in props)\n        if (hasOwnProperty.call(props, propKey)) {\n          var propValue = props[propKey];\n          if (null != propValue)\n            switch (propKey) {\n              case \"children\":\n                children = propValue;\n                break;\n              case \"dangerouslySetInnerHTML\":\n                innerHTML = propValue;\n                break;\n              default:\n                pushAttribute(target, propKey, propValue);\n            }\n        }\n      target.push(endOfStartTag);\n      props = Array.isArray(children)\n        ? 2 > children.length\n          ? children[0]\n          : null\n        : children;\n      \"function\" !== typeof props &&\n        \"symbol\" !== typeof props &&\n        null !== props &&\n        void 0 !== props &&\n        target.push(stringToChunk(escapeTextForBrowser(\"\" + props)));\n      pushInnerHTML(target, innerHTML, children);\n      target.push(endChunkForTag(\"title\"));\n      return null;\n    }\n    function pushScriptImpl(target, props) {\n      target.push(startChunkForTag(\"script\"));\n      var children = null,\n        innerHTML = null,\n        propKey;\n      for (propKey in props)\n        if (hasOwnProperty.call(props, propKey)) {\n          var propValue = props[propKey];\n          if (null != propValue)\n            switch (propKey) {\n              case \"children\":\n                children = propValue;\n                break;\n              case \"dangerouslySetInnerHTML\":\n                innerHTML = propValue;\n                break;\n              default:\n                pushAttribute(target, propKey, propValue);\n            }\n        }\n      target.push(endOfStartTag);\n      null != children &&\n        \"string\" !== typeof children &&\n        ((props =\n          \"number\" === typeof children\n            ? \"a number for children\"\n            : Array.isArray(children)\n              ? \"an array for children\"\n              : \"something unexpected for children\"),\n        console.error(\n          \"A script element was rendered with %s. If script element has children it must be a single string. Consider using dangerouslySetInnerHTML or passing a plain string as children.\",\n          props\n        ));\n      pushInnerHTML(target, innerHTML, children);\n      \"string\" === typeof children &&\n        target.push(stringToChunk(escapeEntireInlineScriptContent(children)));\n      target.push(endChunkForTag(\"script\"));\n      return null;\n    }\n    function pushStartSingletonElement(target, props, tag) {\n      target.push(startChunkForTag(tag));\n      var innerHTML = (tag = null),\n        propKey;\n      for (propKey in props)\n        if (hasOwnProperty.call(props, propKey)) {\n          var propValue = props[propKey];\n          if (null != propValue)\n            switch (propKey) {\n              case \"children\":\n                tag = propValue;\n                break;\n              case \"dangerouslySetInnerHTML\":\n                innerHTML = propValue;\n                break;\n              default:\n                pushAttribute(target, propKey, propValue);\n            }\n        }\n      target.push(endOfStartTag);\n      pushInnerHTML(target, innerHTML, tag);\n      return tag;\n    }\n    function pushStartGenericElement(target, props, tag) {\n      target.push(startChunkForTag(tag));\n      var innerHTML = (tag = null),\n        propKey;\n      for (propKey in props)\n        if (hasOwnProperty.call(props, propKey)) {\n          var propValue = props[propKey];\n          if (null != propValue)\n            switch (propKey) {\n              case \"children\":\n                tag = propValue;\n                break;\n              case \"dangerouslySetInnerHTML\":\n                innerHTML = propValue;\n                break;\n              default:\n                pushAttribute(target, propKey, propValue);\n            }\n        }\n      target.push(endOfStartTag);\n      pushInnerHTML(target, innerHTML, tag);\n      return \"string\" === typeof tag\n        ? (target.push(stringToChunk(escapeTextForBrowser(tag))), null)\n        : tag;\n    }\n    function startChunkForTag(tag) {\n      var tagStartChunk = validatedTagCache.get(tag);\n      if (void 0 === tagStartChunk) {\n        if (!VALID_TAG_REGEX.test(tag)) throw Error(\"Invalid tag: \" + tag);\n        tagStartChunk = stringToPrecomputedChunk(\"<\" + tag);\n        validatedTagCache.set(tag, tagStartChunk);\n      }\n      return tagStartChunk;\n    }\n    function pushStartInstance(\n      target$jscomp$0,\n      type,\n      props,\n      resumableState,\n      renderState,\n      preambleState,\n      hoistableState,\n      formatContext,\n      textEmbedded\n    ) {\n      validateProperties$2(type, props);\n      (\"input\" !== type && \"textarea\" !== type && \"select\" !== type) ||\n        null == props ||\n        null !== props.value ||\n        didWarnValueNull ||\n        ((didWarnValueNull = !0),\n        \"select\" === type && props.multiple\n          ? console.error(\n              \"`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.\",\n              type\n            )\n          : console.error(\n              \"`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.\",\n              type\n            ));\n      b: if (-1 === type.indexOf(\"-\")) var JSCompiler_inline_result = !1;\n      else\n        switch (type) {\n          case \"annotation-xml\":\n          case \"color-profile\":\n          case \"font-face\":\n          case \"font-face-src\":\n          case \"font-face-uri\":\n          case \"font-face-format\":\n          case \"font-face-name\":\n          case \"missing-glyph\":\n            JSCompiler_inline_result = !1;\n            break b;\n          default:\n            JSCompiler_inline_result = !0;\n        }\n      JSCompiler_inline_result ||\n        \"string\" === typeof props.is ||\n        warnUnknownProperties(type, props, null);\n      !props.suppressContentEditableWarning &&\n        props.contentEditable &&\n        null != props.children &&\n        console.error(\n          \"A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.\"\n        );\n      formatContext.insertionMode !== SVG_MODE &&\n        formatContext.insertionMode !== MATHML_MODE &&\n        -1 === type.indexOf(\"-\") &&\n        type.toLowerCase() !== type &&\n        console.error(\n          \"<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.\",\n          type\n        );\n      switch (type) {\n        case \"div\":\n        case \"span\":\n        case \"svg\":\n        case \"path\":\n          break;\n        case \"a\":\n          target$jscomp$0.push(startChunkForTag(\"a\"));\n          var children = null,\n            innerHTML = null,\n            propKey;\n          for (propKey in props)\n            if (hasOwnProperty.call(props, propKey)) {\n              var propValue = props[propKey];\n              if (null != propValue)\n                switch (propKey) {\n                  case \"children\":\n                    children = propValue;\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    innerHTML = propValue;\n                    break;\n                  case \"href\":\n                    \"\" === propValue\n                      ? pushStringAttribute(target$jscomp$0, \"href\", \"\")\n                      : pushAttribute(target$jscomp$0, propKey, propValue);\n                    break;\n                  default:\n                    pushAttribute(target$jscomp$0, propKey, propValue);\n                }\n            }\n          target$jscomp$0.push(endOfStartTag);\n          pushInnerHTML(target$jscomp$0, innerHTML, children);\n          if (\"string\" === typeof children) {\n            target$jscomp$0.push(stringToChunk(escapeTextForBrowser(children)));\n            var JSCompiler_inline_result$jscomp$0 = null;\n          } else JSCompiler_inline_result$jscomp$0 = children;\n          return JSCompiler_inline_result$jscomp$0;\n        case \"g\":\n        case \"p\":\n        case \"li\":\n          break;\n        case \"select\":\n          checkControlledValueProps(\"select\", props);\n          checkSelectProp(props, \"value\");\n          checkSelectProp(props, \"defaultValue\");\n          void 0 === props.value ||\n            void 0 === props.defaultValue ||\n            didWarnDefaultSelectValue ||\n            (console.error(\n              \"Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://react.dev/link/controlled-components\"\n            ),\n            (didWarnDefaultSelectValue = !0));\n          target$jscomp$0.push(startChunkForTag(\"select\"));\n          var children$jscomp$0 = null,\n            innerHTML$jscomp$0 = null,\n            propKey$jscomp$0;\n          for (propKey$jscomp$0 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$0)) {\n              var propValue$jscomp$0 = props[propKey$jscomp$0];\n              if (null != propValue$jscomp$0)\n                switch (propKey$jscomp$0) {\n                  case \"children\":\n                    children$jscomp$0 = propValue$jscomp$0;\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    innerHTML$jscomp$0 = propValue$jscomp$0;\n                    break;\n                  case \"defaultValue\":\n                  case \"value\":\n                    break;\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$0,\n                      propValue$jscomp$0\n                    );\n                }\n            }\n          target$jscomp$0.push(endOfStartTag);\n          pushInnerHTML(target$jscomp$0, innerHTML$jscomp$0, children$jscomp$0);\n          return children$jscomp$0;\n        case \"option\":\n          var selectedValue = formatContext.selectedValue;\n          target$jscomp$0.push(startChunkForTag(\"option\"));\n          var children$jscomp$1 = null,\n            value = null,\n            selected = null,\n            innerHTML$jscomp$1 = null,\n            propKey$jscomp$1;\n          for (propKey$jscomp$1 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$1)) {\n              var propValue$jscomp$1 = props[propKey$jscomp$1];\n              if (null != propValue$jscomp$1)\n                switch (propKey$jscomp$1) {\n                  case \"children\":\n                    children$jscomp$1 = propValue$jscomp$1;\n                    break;\n                  case \"selected\":\n                    selected = propValue$jscomp$1;\n                    didWarnSelectedSetOnOption ||\n                      (console.error(\n                        \"Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.\"\n                      ),\n                      (didWarnSelectedSetOnOption = !0));\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    innerHTML$jscomp$1 = propValue$jscomp$1;\n                    break;\n                  case \"value\":\n                    value = propValue$jscomp$1;\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$1,\n                      propValue$jscomp$1\n                    );\n                }\n            }\n          if (null != selectedValue) {\n            if (null !== value) {\n              checkAttributeStringCoercion(value, \"value\");\n              var stringValue = \"\" + value;\n            } else\n              null === innerHTML$jscomp$1 ||\n                didWarnInvalidOptionInnerHTML ||\n                ((didWarnInvalidOptionInnerHTML = !0),\n                console.error(\n                  \"Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.\"\n                )),\n                (stringValue = flattenOptionChildren(children$jscomp$1));\n            if (isArrayImpl(selectedValue))\n              for (var i = 0; i < selectedValue.length; i++) {\n                if (\n                  (checkAttributeStringCoercion(selectedValue[i], \"value\"),\n                  \"\" + selectedValue[i] === stringValue)\n                ) {\n                  target$jscomp$0.push(selectedMarkerAttribute);\n                  break;\n                }\n              }\n            else\n              checkAttributeStringCoercion(selectedValue, \"select.value\"),\n                \"\" + selectedValue === stringValue &&\n                  target$jscomp$0.push(selectedMarkerAttribute);\n          } else selected && target$jscomp$0.push(selectedMarkerAttribute);\n          target$jscomp$0.push(endOfStartTag);\n          pushInnerHTML(target$jscomp$0, innerHTML$jscomp$1, children$jscomp$1);\n          return children$jscomp$1;\n        case \"textarea\":\n          checkControlledValueProps(\"textarea\", props);\n          void 0 === props.value ||\n            void 0 === props.defaultValue ||\n            didWarnDefaultTextareaValue ||\n            (console.error(\n              \"Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://react.dev/link/controlled-components\"\n            ),\n            (didWarnDefaultTextareaValue = !0));\n          target$jscomp$0.push(startChunkForTag(\"textarea\"));\n          var value$jscomp$0 = null,\n            defaultValue = null,\n            children$jscomp$2 = null,\n            propKey$jscomp$2;\n          for (propKey$jscomp$2 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$2)) {\n              var propValue$jscomp$2 = props[propKey$jscomp$2];\n              if (null != propValue$jscomp$2)\n                switch (propKey$jscomp$2) {\n                  case \"children\":\n                    children$jscomp$2 = propValue$jscomp$2;\n                    break;\n                  case \"value\":\n                    value$jscomp$0 = propValue$jscomp$2;\n                    break;\n                  case \"defaultValue\":\n                    defaultValue = propValue$jscomp$2;\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    throw Error(\n                      \"`dangerouslySetInnerHTML` does not make sense on <textarea>.\"\n                    );\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$2,\n                      propValue$jscomp$2\n                    );\n                }\n            }\n          null === value$jscomp$0 &&\n            null !== defaultValue &&\n            (value$jscomp$0 = defaultValue);\n          target$jscomp$0.push(endOfStartTag);\n          if (null != children$jscomp$2) {\n            console.error(\n              \"Use the `defaultValue` or `value` props instead of setting children on <textarea>.\"\n            );\n            if (null != value$jscomp$0)\n              throw Error(\n                \"If you supply `defaultValue` on a <textarea>, do not pass children.\"\n              );\n            if (isArrayImpl(children$jscomp$2)) {\n              if (1 < children$jscomp$2.length)\n                throw Error(\"<textarea> can only have at most one child.\");\n              checkHtmlStringCoercion(children$jscomp$2[0]);\n              value$jscomp$0 = \"\" + children$jscomp$2[0];\n            }\n            checkHtmlStringCoercion(children$jscomp$2);\n            value$jscomp$0 = \"\" + children$jscomp$2;\n          }\n          \"string\" === typeof value$jscomp$0 &&\n            \"\\n\" === value$jscomp$0[0] &&\n            target$jscomp$0.push(leadingNewline);\n          null !== value$jscomp$0 &&\n            (checkAttributeStringCoercion(value$jscomp$0, \"value\"),\n            target$jscomp$0.push(\n              stringToChunk(escapeTextForBrowser(\"\" + value$jscomp$0))\n            ));\n          return null;\n        case \"input\":\n          checkControlledValueProps(\"input\", props);\n          target$jscomp$0.push(startChunkForTag(\"input\"));\n          var name = null,\n            formAction = null,\n            formEncType = null,\n            formMethod = null,\n            formTarget = null,\n            value$jscomp$1 = null,\n            defaultValue$jscomp$0 = null,\n            checked = null,\n            defaultChecked = null,\n            propKey$jscomp$3;\n          for (propKey$jscomp$3 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$3)) {\n              var propValue$jscomp$3 = props[propKey$jscomp$3];\n              if (null != propValue$jscomp$3)\n                switch (propKey$jscomp$3) {\n                  case \"children\":\n                  case \"dangerouslySetInnerHTML\":\n                    throw Error(\n                      \"input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.\"\n                    );\n                  case \"name\":\n                    name = propValue$jscomp$3;\n                    break;\n                  case \"formAction\":\n                    formAction = propValue$jscomp$3;\n                    break;\n                  case \"formEncType\":\n                    formEncType = propValue$jscomp$3;\n                    break;\n                  case \"formMethod\":\n                    formMethod = propValue$jscomp$3;\n                    break;\n                  case \"formTarget\":\n                    formTarget = propValue$jscomp$3;\n                    break;\n                  case \"defaultChecked\":\n                    defaultChecked = propValue$jscomp$3;\n                    break;\n                  case \"defaultValue\":\n                    defaultValue$jscomp$0 = propValue$jscomp$3;\n                    break;\n                  case \"checked\":\n                    checked = propValue$jscomp$3;\n                    break;\n                  case \"value\":\n                    value$jscomp$1 = propValue$jscomp$3;\n                    break;\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$3,\n                      propValue$jscomp$3\n                    );\n                }\n            }\n          null === formAction ||\n            \"image\" === props.type ||\n            \"submit\" === props.type ||\n            didWarnFormActionType ||\n            ((didWarnFormActionType = !0),\n            console.error(\n              'An input can only specify a formAction along with type=\"submit\" or type=\"image\".'\n            ));\n          var formData = pushFormActionAttribute(\n            target$jscomp$0,\n            resumableState,\n            renderState,\n            formAction,\n            formEncType,\n            formMethod,\n            formTarget,\n            name\n          );\n          null === checked ||\n            null === defaultChecked ||\n            didWarnDefaultChecked ||\n            (console.error(\n              \"%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components\",\n              \"A component\",\n              props.type\n            ),\n            (didWarnDefaultChecked = !0));\n          null === value$jscomp$1 ||\n            null === defaultValue$jscomp$0 ||\n            didWarnDefaultInputValue ||\n            (console.error(\n              \"%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components\",\n              \"A component\",\n              props.type\n            ),\n            (didWarnDefaultInputValue = !0));\n          null !== checked\n            ? pushBooleanAttribute(target$jscomp$0, \"checked\", checked)\n            : null !== defaultChecked &&\n              pushBooleanAttribute(target$jscomp$0, \"checked\", defaultChecked);\n          null !== value$jscomp$1\n            ? pushAttribute(target$jscomp$0, \"value\", value$jscomp$1)\n            : null !== defaultValue$jscomp$0 &&\n              pushAttribute(target$jscomp$0, \"value\", defaultValue$jscomp$0);\n          target$jscomp$0.push(endOfStartTagSelfClosing);\n          null != formData &&\n            formData.forEach(pushAdditionalFormField, target$jscomp$0);\n          return null;\n        case \"button\":\n          target$jscomp$0.push(startChunkForTag(\"button\"));\n          var children$jscomp$3 = null,\n            innerHTML$jscomp$2 = null,\n            name$jscomp$0 = null,\n            formAction$jscomp$0 = null,\n            formEncType$jscomp$0 = null,\n            formMethod$jscomp$0 = null,\n            formTarget$jscomp$0 = null,\n            propKey$jscomp$4;\n          for (propKey$jscomp$4 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$4)) {\n              var propValue$jscomp$4 = props[propKey$jscomp$4];\n              if (null != propValue$jscomp$4)\n                switch (propKey$jscomp$4) {\n                  case \"children\":\n                    children$jscomp$3 = propValue$jscomp$4;\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    innerHTML$jscomp$2 = propValue$jscomp$4;\n                    break;\n                  case \"name\":\n                    name$jscomp$0 = propValue$jscomp$4;\n                    break;\n                  case \"formAction\":\n                    formAction$jscomp$0 = propValue$jscomp$4;\n                    break;\n                  case \"formEncType\":\n                    formEncType$jscomp$0 = propValue$jscomp$4;\n                    break;\n                  case \"formMethod\":\n                    formMethod$jscomp$0 = propValue$jscomp$4;\n                    break;\n                  case \"formTarget\":\n                    formTarget$jscomp$0 = propValue$jscomp$4;\n                    break;\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$4,\n                      propValue$jscomp$4\n                    );\n                }\n            }\n          null === formAction$jscomp$0 ||\n            null == props.type ||\n            \"submit\" === props.type ||\n            didWarnFormActionType ||\n            ((didWarnFormActionType = !0),\n            console.error(\n              'A button can only specify a formAction along with type=\"submit\" or no type.'\n            ));\n          var formData$jscomp$0 = pushFormActionAttribute(\n            target$jscomp$0,\n            resumableState,\n            renderState,\n            formAction$jscomp$0,\n            formEncType$jscomp$0,\n            formMethod$jscomp$0,\n            formTarget$jscomp$0,\n            name$jscomp$0\n          );\n          target$jscomp$0.push(endOfStartTag);\n          null != formData$jscomp$0 &&\n            formData$jscomp$0.forEach(pushAdditionalFormField, target$jscomp$0);\n          pushInnerHTML(target$jscomp$0, innerHTML$jscomp$2, children$jscomp$3);\n          if (\"string\" === typeof children$jscomp$3) {\n            target$jscomp$0.push(\n              stringToChunk(escapeTextForBrowser(children$jscomp$3))\n            );\n            var JSCompiler_inline_result$jscomp$1 = null;\n          } else JSCompiler_inline_result$jscomp$1 = children$jscomp$3;\n          return JSCompiler_inline_result$jscomp$1;\n        case \"form\":\n          target$jscomp$0.push(startChunkForTag(\"form\"));\n          var children$jscomp$4 = null,\n            innerHTML$jscomp$3 = null,\n            formAction$jscomp$1 = null,\n            formEncType$jscomp$1 = null,\n            formMethod$jscomp$1 = null,\n            formTarget$jscomp$1 = null,\n            propKey$jscomp$5;\n          for (propKey$jscomp$5 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$5)) {\n              var propValue$jscomp$5 = props[propKey$jscomp$5];\n              if (null != propValue$jscomp$5)\n                switch (propKey$jscomp$5) {\n                  case \"children\":\n                    children$jscomp$4 = propValue$jscomp$5;\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    innerHTML$jscomp$3 = propValue$jscomp$5;\n                    break;\n                  case \"action\":\n                    formAction$jscomp$1 = propValue$jscomp$5;\n                    break;\n                  case \"encType\":\n                    formEncType$jscomp$1 = propValue$jscomp$5;\n                    break;\n                  case \"method\":\n                    formMethod$jscomp$1 = propValue$jscomp$5;\n                    break;\n                  case \"target\":\n                    formTarget$jscomp$1 = propValue$jscomp$5;\n                    break;\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$5,\n                      propValue$jscomp$5\n                    );\n                }\n            }\n          var formData$jscomp$1 = null,\n            formActionName = null;\n          if (\"function\" === typeof formAction$jscomp$1) {\n            (null === formEncType$jscomp$1 && null === formMethod$jscomp$1) ||\n              didWarnFormActionMethod ||\n              ((didWarnFormActionMethod = !0),\n              console.error(\n                \"Cannot specify a encType or method for a form that specifies a function as the action. React provides those automatically. They will get overridden.\"\n              ));\n            null === formTarget$jscomp$1 ||\n              didWarnFormActionTarget ||\n              ((didWarnFormActionTarget = !0),\n              console.error(\n                \"Cannot specify a target for a form that specifies a function as the action. The function will always be executed in the same window.\"\n              ));\n            var customFields = getCustomFormFields(\n              resumableState,\n              formAction$jscomp$1\n            );\n            null !== customFields\n              ? ((formAction$jscomp$1 = customFields.action || \"\"),\n                (formEncType$jscomp$1 = customFields.encType),\n                (formMethod$jscomp$1 = customFields.method),\n                (formTarget$jscomp$1 = customFields.target),\n                (formData$jscomp$1 = customFields.data),\n                (formActionName = customFields.name))\n              : (target$jscomp$0.push(\n                  attributeSeparator,\n                  stringToChunk(\"action\"),\n                  attributeAssign,\n                  actionJavaScriptURL,\n                  attributeEnd\n                ),\n                (formTarget$jscomp$1 =\n                  formMethod$jscomp$1 =\n                  formEncType$jscomp$1 =\n                  formAction$jscomp$1 =\n                    null),\n                injectFormReplayingRuntime(resumableState, renderState));\n          }\n          null != formAction$jscomp$1 &&\n            pushAttribute(target$jscomp$0, \"action\", formAction$jscomp$1);\n          null != formEncType$jscomp$1 &&\n            pushAttribute(target$jscomp$0, \"encType\", formEncType$jscomp$1);\n          null != formMethod$jscomp$1 &&\n            pushAttribute(target$jscomp$0, \"method\", formMethod$jscomp$1);\n          null != formTarget$jscomp$1 &&\n            pushAttribute(target$jscomp$0, \"target\", formTarget$jscomp$1);\n          target$jscomp$0.push(endOfStartTag);\n          null !== formActionName &&\n            (target$jscomp$0.push(startHiddenInputChunk),\n            pushStringAttribute(target$jscomp$0, \"name\", formActionName),\n            target$jscomp$0.push(endOfStartTagSelfClosing),\n            null != formData$jscomp$1 &&\n              formData$jscomp$1.forEach(\n                pushAdditionalFormField,\n                target$jscomp$0\n              ));\n          pushInnerHTML(target$jscomp$0, innerHTML$jscomp$3, children$jscomp$4);\n          if (\"string\" === typeof children$jscomp$4) {\n            target$jscomp$0.push(\n              stringToChunk(escapeTextForBrowser(children$jscomp$4))\n            );\n            var JSCompiler_inline_result$jscomp$2 = null;\n          } else JSCompiler_inline_result$jscomp$2 = children$jscomp$4;\n          return JSCompiler_inline_result$jscomp$2;\n        case \"menuitem\":\n          target$jscomp$0.push(startChunkForTag(\"menuitem\"));\n          for (var propKey$jscomp$6 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$6)) {\n              var propValue$jscomp$6 = props[propKey$jscomp$6];\n              if (null != propValue$jscomp$6)\n                switch (propKey$jscomp$6) {\n                  case \"children\":\n                  case \"dangerouslySetInnerHTML\":\n                    throw Error(\n                      \"menuitems cannot have `children` nor `dangerouslySetInnerHTML`.\"\n                    );\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$6,\n                      propValue$jscomp$6\n                    );\n                }\n            }\n          target$jscomp$0.push(endOfStartTag);\n          return null;\n        case \"object\":\n          target$jscomp$0.push(startChunkForTag(\"object\"));\n          var children$jscomp$5 = null,\n            innerHTML$jscomp$4 = null,\n            propKey$jscomp$7;\n          for (propKey$jscomp$7 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$7)) {\n              var propValue$jscomp$7 = props[propKey$jscomp$7];\n              if (null != propValue$jscomp$7)\n                switch (propKey$jscomp$7) {\n                  case \"children\":\n                    children$jscomp$5 = propValue$jscomp$7;\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    innerHTML$jscomp$4 = propValue$jscomp$7;\n                    break;\n                  case \"data\":\n                    checkAttributeStringCoercion(propValue$jscomp$7, \"data\");\n                    var sanitizedValue = sanitizeURL(\"\" + propValue$jscomp$7);\n                    if (\"\" === sanitizedValue) {\n                      console.error(\n                        'An empty string (\"\") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',\n                        propKey$jscomp$7,\n                        propKey$jscomp$7\n                      );\n                      break;\n                    }\n                    target$jscomp$0.push(\n                      attributeSeparator,\n                      stringToChunk(\"data\"),\n                      attributeAssign,\n                      stringToChunk(escapeTextForBrowser(sanitizedValue)),\n                      attributeEnd\n                    );\n                    break;\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$7,\n                      propValue$jscomp$7\n                    );\n                }\n            }\n          target$jscomp$0.push(endOfStartTag);\n          pushInnerHTML(target$jscomp$0, innerHTML$jscomp$4, children$jscomp$5);\n          if (\"string\" === typeof children$jscomp$5) {\n            target$jscomp$0.push(\n              stringToChunk(escapeTextForBrowser(children$jscomp$5))\n            );\n            var JSCompiler_inline_result$jscomp$3 = null;\n          } else JSCompiler_inline_result$jscomp$3 = children$jscomp$5;\n          return JSCompiler_inline_result$jscomp$3;\n        case \"title\":\n          var noscriptTagInScope = formatContext.tagScope & 1,\n            isFallback = formatContext.tagScope & 4;\n          if (hasOwnProperty.call(props, \"children\")) {\n            var children$jscomp$6 = props.children,\n              child = Array.isArray(children$jscomp$6)\n                ? 2 > children$jscomp$6.length\n                  ? children$jscomp$6[0]\n                  : null\n                : children$jscomp$6;\n            Array.isArray(children$jscomp$6) && 1 < children$jscomp$6.length\n              ? console.error(\n                  \"React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an Array with length %s instead. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert `children` of <title> tags to a single string value which is why Arrays of length greater than 1 are not supported. When using JSX it can be common to combine text nodes and value nodes. For example: <title>hello {nameOfUser}</title>. While not immediately apparent, `children` in this case is an Array with length 2. If your `children` prop is using this form try rewriting it using a template string: <title>{`hello ${nameOfUser}`}</title>.\",\n                  children$jscomp$6.length\n                )\n              : \"function\" === typeof child || \"symbol\" === typeof child\n                ? console.error(\n                    \"React expect children of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found %s instead. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value.\",\n                    \"function\" === typeof child ? \"a Function\" : \"a Sybmol\"\n                  )\n                : child &&\n                  child.toString === {}.toString &&\n                  (null != child.$$typeof\n                    ? console.error(\n                        \"React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an object that appears to be a React element which never implements a suitable `toString` method. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value which is why rendering React elements is not supported. If the `children` of <title> is a React Component try moving the <title> tag into that component. If the `children` of <title> is some HTML markup change it to be Text only to be valid HTML.\"\n                      )\n                    : console.error(\n                        \"React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an object that does not implement a suitable `toString` method. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value. Using the default `toString` method available on every object is almost certainly an error. Consider whether the `children` of this <title> is an object in error and change it to a string or number value if so. Otherwise implement a `toString` method that React can use to produce a valid <title>.\"\n                      ));\n          }\n          if (\n            formatContext.insertionMode === SVG_MODE ||\n            noscriptTagInScope ||\n            null != props.itemProp\n          )\n            var JSCompiler_inline_result$jscomp$4 = pushTitleImpl(\n              target$jscomp$0,\n              props\n            );\n          else\n            isFallback\n              ? (JSCompiler_inline_result$jscomp$4 = null)\n              : (pushTitleImpl(renderState.hoistableChunks, props),\n                (JSCompiler_inline_result$jscomp$4 = void 0));\n          return JSCompiler_inline_result$jscomp$4;\n        case \"link\":\n          var noscriptTagInScope$jscomp$0 = formatContext.tagScope & 1,\n            isFallback$jscomp$0 = formatContext.tagScope & 4,\n            rel = props.rel,\n            href = props.href,\n            precedence = props.precedence;\n          if (\n            formatContext.insertionMode === SVG_MODE ||\n            noscriptTagInScope$jscomp$0 ||\n            null != props.itemProp ||\n            \"string\" !== typeof rel ||\n            \"string\" !== typeof href ||\n            \"\" === href\n          ) {\n            \"stylesheet\" === rel &&\n              \"string\" === typeof props.precedence &&\n              ((\"string\" === typeof href && href) ||\n                console.error(\n                  'React encountered a `<link rel=\"stylesheet\" .../>` with a `precedence` prop and expected the `href` prop to be a non-empty string but ecountered %s instead. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop ensure there is a non-empty string `href` prop as well, otherwise remove the `precedence` prop.',\n                  null === href\n                    ? \"`null`\"\n                    : void 0 === href\n                      ? \"`undefined`\"\n                      : \"\" === href\n                        ? \"an empty string\"\n                        : 'something with type \"' + typeof href + '\"'\n                ));\n            pushLinkImpl(target$jscomp$0, props);\n            var JSCompiler_inline_result$jscomp$5 = null;\n          } else if (\"stylesheet\" === props.rel)\n            if (\n              \"string\" !== typeof precedence ||\n              null != props.disabled ||\n              props.onLoad ||\n              props.onError\n            ) {\n              if (\"string\" === typeof precedence)\n                if (null != props.disabled)\n                  console.error(\n                    'React encountered a `<link rel=\"stylesheet\" .../>` with a `precedence` prop and a `disabled` prop. The presence of the `disabled` prop indicates an intent to manage the stylesheet active state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the `disabled` prop, otherwise remove the `precedence` prop.'\n                  );\n                else if (props.onLoad || props.onError) {\n                  var propDescription =\n                    props.onLoad && props.onError\n                      ? \"`onLoad` and `onError` props\"\n                      : props.onLoad\n                        ? \"`onLoad` prop\"\n                        : \"`onError` prop\";\n                  console.error(\n                    'React encountered a `<link rel=\"stylesheet\" .../>` with a `precedence` prop and %s. The presence of loading and error handlers indicates an intent to manage the stylesheet loading state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the %s, otherwise remove the `precedence` prop.',\n                    propDescription,\n                    propDescription\n                  );\n                }\n              JSCompiler_inline_result$jscomp$5 = pushLinkImpl(\n                target$jscomp$0,\n                props\n              );\n            } else {\n              var styleQueue = renderState.styles.get(precedence),\n                resourceState = resumableState.styleResources.hasOwnProperty(\n                  href\n                )\n                  ? resumableState.styleResources[href]\n                  : void 0;\n              if (resourceState !== EXISTS) {\n                resumableState.styleResources[href] = EXISTS;\n                styleQueue ||\n                  ((styleQueue = {\n                    precedence: stringToChunk(escapeTextForBrowser(precedence)),\n                    rules: [],\n                    hrefs: [],\n                    sheets: new Map()\n                  }),\n                  renderState.styles.set(precedence, styleQueue));\n                var resource = {\n                  state: PENDING$1,\n                  props: assign({}, props, {\n                    \"data-precedence\": props.precedence,\n                    precedence: null\n                  })\n                };\n                if (resourceState) {\n                  2 === resourceState.length &&\n                    adoptPreloadCredentials(resource.props, resourceState);\n                  var preloadResource =\n                    renderState.preloads.stylesheets.get(href);\n                  preloadResource && 0 < preloadResource.length\n                    ? (preloadResource.length = 0)\n                    : (resource.state = PRELOADED);\n                }\n                styleQueue.sheets.set(href, resource);\n                hoistableState && hoistableState.stylesheets.add(resource);\n              } else if (styleQueue) {\n                var _resource = styleQueue.sheets.get(href);\n                _resource &&\n                  hoistableState &&\n                  hoistableState.stylesheets.add(_resource);\n              }\n              textEmbedded && target$jscomp$0.push(textSeparator);\n              JSCompiler_inline_result$jscomp$5 = null;\n            }\n          else\n            props.onLoad || props.onError\n              ? (JSCompiler_inline_result$jscomp$5 = pushLinkImpl(\n                  target$jscomp$0,\n                  props\n                ))\n              : (textEmbedded && target$jscomp$0.push(textSeparator),\n                (JSCompiler_inline_result$jscomp$5 = isFallback$jscomp$0\n                  ? null\n                  : pushLinkImpl(renderState.hoistableChunks, props)));\n          return JSCompiler_inline_result$jscomp$5;\n        case \"script\":\n          var noscriptTagInScope$jscomp$1 = formatContext.tagScope & 1,\n            asyncProp = props.async;\n          if (\n            \"string\" !== typeof props.src ||\n            !props.src ||\n            !asyncProp ||\n            \"function\" === typeof asyncProp ||\n            \"symbol\" === typeof asyncProp ||\n            props.onLoad ||\n            props.onError ||\n            formatContext.insertionMode === SVG_MODE ||\n            noscriptTagInScope$jscomp$1 ||\n            null != props.itemProp\n          )\n            var JSCompiler_inline_result$jscomp$6 = pushScriptImpl(\n              target$jscomp$0,\n              props\n            );\n          else {\n            var key = props.src;\n            if (\"module\" === props.type) {\n              var resources = resumableState.moduleScriptResources;\n              var preloads = renderState.preloads.moduleScripts;\n            } else\n              (resources = resumableState.scriptResources),\n                (preloads = renderState.preloads.scripts);\n            var resourceState$jscomp$0 = resources.hasOwnProperty(key)\n              ? resources[key]\n              : void 0;\n            if (resourceState$jscomp$0 !== EXISTS) {\n              resources[key] = EXISTS;\n              var scriptProps = props;\n              if (resourceState$jscomp$0) {\n                2 === resourceState$jscomp$0.length &&\n                  ((scriptProps = assign({}, props)),\n                  adoptPreloadCredentials(scriptProps, resourceState$jscomp$0));\n                var preloadResource$jscomp$0 = preloads.get(key);\n                preloadResource$jscomp$0 &&\n                  (preloadResource$jscomp$0.length = 0);\n              }\n              var resource$jscomp$0 = [];\n              renderState.scripts.add(resource$jscomp$0);\n              pushScriptImpl(resource$jscomp$0, scriptProps);\n            }\n            textEmbedded && target$jscomp$0.push(textSeparator);\n            JSCompiler_inline_result$jscomp$6 = null;\n          }\n          return JSCompiler_inline_result$jscomp$6;\n        case \"style\":\n          var noscriptTagInScope$jscomp$2 = formatContext.tagScope & 1;\n          if (hasOwnProperty.call(props, \"children\")) {\n            var children$jscomp$7 = props.children,\n              child$jscomp$0 = Array.isArray(children$jscomp$7)\n                ? 2 > children$jscomp$7.length\n                  ? children$jscomp$7[0]\n                  : null\n                : children$jscomp$7;\n            (\"function\" === typeof child$jscomp$0 ||\n              \"symbol\" === typeof child$jscomp$0 ||\n              Array.isArray(child$jscomp$0)) &&\n              console.error(\n                \"React expect children of <style> tags to be a string, number, or object with a `toString` method but found %s instead. In browsers style Elements can only have `Text` Nodes as children.\",\n                \"function\" === typeof child$jscomp$0\n                  ? \"a Function\"\n                  : \"symbol\" === typeof child$jscomp$0\n                    ? \"a Sybmol\"\n                    : \"an Array\"\n              );\n          }\n          var precedence$jscomp$0 = props.precedence,\n            href$jscomp$0 = props.href,\n            nonce = props.nonce;\n          if (\n            formatContext.insertionMode === SVG_MODE ||\n            noscriptTagInScope$jscomp$2 ||\n            null != props.itemProp ||\n            \"string\" !== typeof precedence$jscomp$0 ||\n            \"string\" !== typeof href$jscomp$0 ||\n            \"\" === href$jscomp$0\n          ) {\n            target$jscomp$0.push(startChunkForTag(\"style\"));\n            var children$jscomp$8 = null,\n              innerHTML$jscomp$5 = null,\n              propKey$jscomp$8;\n            for (propKey$jscomp$8 in props)\n              if (hasOwnProperty.call(props, propKey$jscomp$8)) {\n                var propValue$jscomp$8 = props[propKey$jscomp$8];\n                if (null != propValue$jscomp$8)\n                  switch (propKey$jscomp$8) {\n                    case \"children\":\n                      children$jscomp$8 = propValue$jscomp$8;\n                      break;\n                    case \"dangerouslySetInnerHTML\":\n                      innerHTML$jscomp$5 = propValue$jscomp$8;\n                      break;\n                    default:\n                      pushAttribute(\n                        target$jscomp$0,\n                        propKey$jscomp$8,\n                        propValue$jscomp$8\n                      );\n                  }\n              }\n            target$jscomp$0.push(endOfStartTag);\n            var child$jscomp$1 = Array.isArray(children$jscomp$8)\n              ? 2 > children$jscomp$8.length\n                ? children$jscomp$8[0]\n                : null\n              : children$jscomp$8;\n            \"function\" !== typeof child$jscomp$1 &&\n              \"symbol\" !== typeof child$jscomp$1 &&\n              null !== child$jscomp$1 &&\n              void 0 !== child$jscomp$1 &&\n              target$jscomp$0.push(\n                stringToChunk(escapeStyleTextContent(child$jscomp$1))\n              );\n            pushInnerHTML(\n              target$jscomp$0,\n              innerHTML$jscomp$5,\n              children$jscomp$8\n            );\n            target$jscomp$0.push(endChunkForTag(\"style\"));\n            var JSCompiler_inline_result$jscomp$7 = null;\n          } else {\n            href$jscomp$0.includes(\" \") &&\n              console.error(\n                'React expected the `href` prop for a <style> tag opting into hoisting semantics using the `precedence` prop to not have any spaces but ecountered spaces instead. using spaces in this prop will cause hydration of this style to fail on the client. The href for the <style> where this ocurred is \"%s\".',\n                href$jscomp$0\n              );\n            var styleQueue$jscomp$0 =\n                renderState.styles.get(precedence$jscomp$0),\n              resourceState$jscomp$1 =\n                resumableState.styleResources.hasOwnProperty(href$jscomp$0)\n                  ? resumableState.styleResources[href$jscomp$0]\n                  : void 0;\n            if (resourceState$jscomp$1 !== EXISTS) {\n              resumableState.styleResources[href$jscomp$0] = EXISTS;\n              resourceState$jscomp$1 &&\n                console.error(\n                  'React encountered a hoistable style tag for the same href as a preload: \"%s\". When using a style tag to inline styles you should not also preload it as a stylsheet.',\n                  href$jscomp$0\n                );\n              styleQueue$jscomp$0 ||\n                ((styleQueue$jscomp$0 = {\n                  precedence: stringToChunk(\n                    escapeTextForBrowser(precedence$jscomp$0)\n                  ),\n                  rules: [],\n                  hrefs: [],\n                  sheets: new Map()\n                }),\n                renderState.styles.set(\n                  precedence$jscomp$0,\n                  styleQueue$jscomp$0\n                ));\n              var nonceStyle = renderState.nonce.style;\n              if (nonceStyle && nonceStyle !== nonce)\n                console.error(\n                  'React encountered a style tag with `precedence` \"%s\" and `nonce` \"%s\". When React manages style rules using `precedence` it will only include rules if the nonce matches the style nonce \"%s\" that was included with this render.',\n                  precedence$jscomp$0,\n                  nonce,\n                  nonceStyle\n                );\n              else {\n                !nonceStyle &&\n                  nonce &&\n                  console.error(\n                    'React encountered a style tag with `precedence` \"%s\" and `nonce` \"%s\". When React manages style rules using `precedence` it will only include a nonce attributes if you also provide the same style nonce value as a render option.',\n                    precedence$jscomp$0,\n                    nonce\n                  );\n                styleQueue$jscomp$0.hrefs.push(\n                  stringToChunk(escapeTextForBrowser(href$jscomp$0))\n                );\n                var target = styleQueue$jscomp$0.rules,\n                  children$jscomp$9 = null,\n                  innerHTML$jscomp$6 = null,\n                  propKey$jscomp$9;\n                for (propKey$jscomp$9 in props)\n                  if (hasOwnProperty.call(props, propKey$jscomp$9)) {\n                    var propValue$jscomp$9 = props[propKey$jscomp$9];\n                    if (null != propValue$jscomp$9)\n                      switch (propKey$jscomp$9) {\n                        case \"children\":\n                          children$jscomp$9 = propValue$jscomp$9;\n                          break;\n                        case \"dangerouslySetInnerHTML\":\n                          innerHTML$jscomp$6 = propValue$jscomp$9;\n                      }\n                  }\n                var child$jscomp$2 = Array.isArray(children$jscomp$9)\n                  ? 2 > children$jscomp$9.length\n                    ? children$jscomp$9[0]\n                    : null\n                  : children$jscomp$9;\n                \"function\" !== typeof child$jscomp$2 &&\n                  \"symbol\" !== typeof child$jscomp$2 &&\n                  null !== child$jscomp$2 &&\n                  void 0 !== child$jscomp$2 &&\n                  target.push(\n                    stringToChunk(escapeStyleTextContent(child$jscomp$2))\n                  );\n                pushInnerHTML(target, innerHTML$jscomp$6, children$jscomp$9);\n              }\n            }\n            styleQueue$jscomp$0 &&\n              hoistableState &&\n              hoistableState.styles.add(styleQueue$jscomp$0);\n            textEmbedded && target$jscomp$0.push(textSeparator);\n            JSCompiler_inline_result$jscomp$7 = void 0;\n          }\n          return JSCompiler_inline_result$jscomp$7;\n        case \"meta\":\n          var noscriptTagInScope$jscomp$3 = formatContext.tagScope & 1,\n            isFallback$jscomp$1 = formatContext.tagScope & 4;\n          if (\n            formatContext.insertionMode === SVG_MODE ||\n            noscriptTagInScope$jscomp$3 ||\n            null != props.itemProp\n          )\n            var JSCompiler_inline_result$jscomp$8 = pushSelfClosing(\n              target$jscomp$0,\n              props,\n              \"meta\"\n            );\n          else\n            textEmbedded && target$jscomp$0.push(textSeparator),\n              (JSCompiler_inline_result$jscomp$8 = isFallback$jscomp$1\n                ? null\n                : \"string\" === typeof props.charSet\n                  ? pushSelfClosing(renderState.charsetChunks, props, \"meta\")\n                  : \"viewport\" === props.name\n                    ? pushSelfClosing(renderState.viewportChunks, props, \"meta\")\n                    : pushSelfClosing(\n                        renderState.hoistableChunks,\n                        props,\n                        \"meta\"\n                      ));\n          return JSCompiler_inline_result$jscomp$8;\n        case \"listing\":\n        case \"pre\":\n          target$jscomp$0.push(startChunkForTag(type));\n          var children$jscomp$10 = null,\n            innerHTML$jscomp$7 = null,\n            propKey$jscomp$10;\n          for (propKey$jscomp$10 in props)\n            if (hasOwnProperty.call(props, propKey$jscomp$10)) {\n              var propValue$jscomp$10 = props[propKey$jscomp$10];\n              if (null != propValue$jscomp$10)\n                switch (propKey$jscomp$10) {\n                  case \"children\":\n                    children$jscomp$10 = propValue$jscomp$10;\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    innerHTML$jscomp$7 = propValue$jscomp$10;\n                    break;\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$10,\n                      propValue$jscomp$10\n                    );\n                }\n            }\n          target$jscomp$0.push(endOfStartTag);\n          if (null != innerHTML$jscomp$7) {\n            if (null != children$jscomp$10)\n              throw Error(\n                \"Can only set one of `children` or `props.dangerouslySetInnerHTML`.\"\n              );\n            if (\n              \"object\" !== typeof innerHTML$jscomp$7 ||\n              !(\"__html\" in innerHTML$jscomp$7)\n            )\n              throw Error(\n                \"`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information.\"\n              );\n            var html = innerHTML$jscomp$7.__html;\n            null !== html &&\n              void 0 !== html &&\n              (\"string\" === typeof html && 0 < html.length && \"\\n\" === html[0]\n                ? target$jscomp$0.push(leadingNewline, stringToChunk(html))\n                : (checkHtmlStringCoercion(html),\n                  target$jscomp$0.push(stringToChunk(\"\" + html))));\n          }\n          \"string\" === typeof children$jscomp$10 &&\n            \"\\n\" === children$jscomp$10[0] &&\n            target$jscomp$0.push(leadingNewline);\n          return children$jscomp$10;\n        case \"img\":\n          var pictureOrNoScriptTagInScope = formatContext.tagScope & 3,\n            src = props.src,\n            srcSet = props.srcSet;\n          if (\n            !(\n              \"lazy\" === props.loading ||\n              (!src && !srcSet) ||\n              (\"string\" !== typeof src && null != src) ||\n              (\"string\" !== typeof srcSet && null != srcSet) ||\n              \"low\" === props.fetchPriority ||\n              pictureOrNoScriptTagInScope\n            ) &&\n            (\"string\" !== typeof src ||\n              \":\" !== src[4] ||\n              (\"d\" !== src[0] && \"D\" !== src[0]) ||\n              (\"a\" !== src[1] && \"A\" !== src[1]) ||\n              (\"t\" !== src[2] && \"T\" !== src[2]) ||\n              (\"a\" !== src[3] && \"A\" !== src[3])) &&\n            (\"string\" !== typeof srcSet ||\n              \":\" !== srcSet[4] ||\n              (\"d\" !== srcSet[0] && \"D\" !== srcSet[0]) ||\n              (\"a\" !== srcSet[1] && \"A\" !== srcSet[1]) ||\n              (\"t\" !== srcSet[2] && \"T\" !== srcSet[2]) ||\n              (\"a\" !== srcSet[3] && \"A\" !== srcSet[3]))\n          ) {\n            null !== hoistableState &&\n              formatContext.tagScope & 64 &&\n              (hoistableState.suspenseyImages = !0);\n            var sizes = \"string\" === typeof props.sizes ? props.sizes : void 0,\n              key$jscomp$0 = srcSet ? srcSet + \"\\n\" + (sizes || \"\") : src,\n              promotablePreloads = renderState.preloads.images,\n              resource$jscomp$1 = promotablePreloads.get(key$jscomp$0);\n            if (resource$jscomp$1) {\n              if (\n                \"high\" === props.fetchPriority ||\n                10 > renderState.highImagePreloads.size\n              )\n                promotablePreloads.delete(key$jscomp$0),\n                  renderState.highImagePreloads.add(resource$jscomp$1);\n            } else if (\n              !resumableState.imageResources.hasOwnProperty(key$jscomp$0)\n            ) {\n              resumableState.imageResources[key$jscomp$0] = PRELOAD_NO_CREDS;\n              var input = props.crossOrigin;\n              var crossOrigin =\n                \"string\" === typeof input\n                  ? \"use-credentials\" === input\n                    ? input\n                    : \"\"\n                  : void 0;\n              var headers = renderState.headers,\n                header;\n              headers &&\n              0 < headers.remainingCapacity &&\n              \"string\" !== typeof props.srcSet &&\n              (\"high\" === props.fetchPriority ||\n                500 > headers.highImagePreloads.length) &&\n              ((header = getPreloadAsHeader(src, \"image\", {\n                imageSrcSet: props.srcSet,\n                imageSizes: props.sizes,\n                crossOrigin: crossOrigin,\n                integrity: props.integrity,\n                nonce: props.nonce,\n                type: props.type,\n                fetchPriority: props.fetchPriority,\n                referrerPolicy: props.refererPolicy\n              })),\n              0 <= (headers.remainingCapacity -= header.length + 2))\n                ? ((renderState.resets.image[key$jscomp$0] = PRELOAD_NO_CREDS),\n                  headers.highImagePreloads &&\n                    (headers.highImagePreloads += \", \"),\n                  (headers.highImagePreloads += header))\n                : ((resource$jscomp$1 = []),\n                  pushLinkImpl(resource$jscomp$1, {\n                    rel: \"preload\",\n                    as: \"image\",\n                    href: srcSet ? void 0 : src,\n                    imageSrcSet: srcSet,\n                    imageSizes: sizes,\n                    crossOrigin: crossOrigin,\n                    integrity: props.integrity,\n                    type: props.type,\n                    fetchPriority: props.fetchPriority,\n                    referrerPolicy: props.referrerPolicy\n                  }),\n                  \"high\" === props.fetchPriority ||\n                  10 > renderState.highImagePreloads.size\n                    ? renderState.highImagePreloads.add(resource$jscomp$1)\n                    : (renderState.bulkPreloads.add(resource$jscomp$1),\n                      promotablePreloads.set(key$jscomp$0, resource$jscomp$1)));\n            }\n          }\n          return pushSelfClosing(target$jscomp$0, props, \"img\");\n        case \"base\":\n        case \"area\":\n        case \"br\":\n        case \"col\":\n        case \"embed\":\n        case \"hr\":\n        case \"keygen\":\n        case \"param\":\n        case \"source\":\n        case \"track\":\n        case \"wbr\":\n          return pushSelfClosing(target$jscomp$0, props, type);\n        case \"annotation-xml\":\n        case \"color-profile\":\n        case \"font-face\":\n        case \"font-face-src\":\n        case \"font-face-uri\":\n        case \"font-face-format\":\n        case \"font-face-name\":\n        case \"missing-glyph\":\n          break;\n        case \"head\":\n          if (formatContext.insertionMode < HTML_MODE) {\n            var preamble = preambleState || renderState.preamble;\n            if (preamble.headChunks)\n              throw Error(\"The `<head>` tag may only be rendered once.\");\n            null !== preambleState &&\n              target$jscomp$0.push(headPreambleContributionChunk);\n            preamble.headChunks = [];\n            var JSCompiler_inline_result$jscomp$9 = pushStartSingletonElement(\n              preamble.headChunks,\n              props,\n              \"head\"\n            );\n          } else\n            JSCompiler_inline_result$jscomp$9 = pushStartGenericElement(\n              target$jscomp$0,\n              props,\n              \"head\"\n            );\n          return JSCompiler_inline_result$jscomp$9;\n        case \"body\":\n          if (formatContext.insertionMode < HTML_MODE) {\n            var preamble$jscomp$0 = preambleState || renderState.preamble;\n            if (preamble$jscomp$0.bodyChunks)\n              throw Error(\"The `<body>` tag may only be rendered once.\");\n            null !== preambleState &&\n              target$jscomp$0.push(bodyPreambleContributionChunk);\n            preamble$jscomp$0.bodyChunks = [];\n            var JSCompiler_inline_result$jscomp$10 = pushStartSingletonElement(\n              preamble$jscomp$0.bodyChunks,\n              props,\n              \"body\"\n            );\n          } else\n            JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(\n              target$jscomp$0,\n              props,\n              \"body\"\n            );\n          return JSCompiler_inline_result$jscomp$10;\n        case \"html\":\n          if (formatContext.insertionMode === ROOT_HTML_MODE) {\n            var preamble$jscomp$1 = preambleState || renderState.preamble;\n            if (preamble$jscomp$1.htmlChunks)\n              throw Error(\"The `<html>` tag may only be rendered once.\");\n            null !== preambleState &&\n              target$jscomp$0.push(htmlPreambleContributionChunk);\n            preamble$jscomp$1.htmlChunks = [doctypeChunk];\n            var JSCompiler_inline_result$jscomp$11 = pushStartSingletonElement(\n              preamble$jscomp$1.htmlChunks,\n              props,\n              \"html\"\n            );\n          } else\n            JSCompiler_inline_result$jscomp$11 = pushStartGenericElement(\n              target$jscomp$0,\n              props,\n              \"html\"\n            );\n          return JSCompiler_inline_result$jscomp$11;\n        default:\n          if (-1 !== type.indexOf(\"-\")) {\n            target$jscomp$0.push(startChunkForTag(type));\n            var children$jscomp$11 = null,\n              innerHTML$jscomp$8 = null,\n              propKey$jscomp$11;\n            for (propKey$jscomp$11 in props)\n              if (hasOwnProperty.call(props, propKey$jscomp$11)) {\n                var propValue$jscomp$11 = props[propKey$jscomp$11];\n                if (null != propValue$jscomp$11) {\n                  var attributeName = propKey$jscomp$11;\n                  switch (propKey$jscomp$11) {\n                    case \"children\":\n                      children$jscomp$11 = propValue$jscomp$11;\n                      break;\n                    case \"dangerouslySetInnerHTML\":\n                      innerHTML$jscomp$8 = propValue$jscomp$11;\n                      break;\n                    case \"style\":\n                      pushStyleAttribute(target$jscomp$0, propValue$jscomp$11);\n                      break;\n                    case \"suppressContentEditableWarning\":\n                    case \"suppressHydrationWarning\":\n                    case \"ref\":\n                      break;\n                    case \"className\":\n                      attributeName = \"class\";\n                    default:\n                      if (\n                        isAttributeNameSafe(propKey$jscomp$11) &&\n                        \"function\" !== typeof propValue$jscomp$11 &&\n                        \"symbol\" !== typeof propValue$jscomp$11 &&\n                        !1 !== propValue$jscomp$11\n                      ) {\n                        if (!0 === propValue$jscomp$11)\n                          propValue$jscomp$11 = \"\";\n                        else if (\"object\" === typeof propValue$jscomp$11)\n                          continue;\n                        target$jscomp$0.push(\n                          attributeSeparator,\n                          stringToChunk(attributeName),\n                          attributeAssign,\n                          stringToChunk(\n                            escapeTextForBrowser(propValue$jscomp$11)\n                          ),\n                          attributeEnd\n                        );\n                      }\n                  }\n                }\n              }\n            target$jscomp$0.push(endOfStartTag);\n            pushInnerHTML(\n              target$jscomp$0,\n              innerHTML$jscomp$8,\n              children$jscomp$11\n            );\n            return children$jscomp$11;\n          }\n      }\n      return pushStartGenericElement(target$jscomp$0, props, type);\n    }\n    function endChunkForTag(tag) {\n      var chunk = endTagCache.get(tag);\n      void 0 === chunk &&\n        ((chunk = stringToPrecomputedChunk(\"</\" + tag + \">\")),\n        endTagCache.set(tag, chunk));\n      return chunk;\n    }\n    function hoistPreambleState(renderState, preambleState) {\n      renderState = renderState.preamble;\n      null === renderState.htmlChunks &&\n        preambleState.htmlChunks &&\n        (renderState.htmlChunks = preambleState.htmlChunks);\n      null === renderState.headChunks &&\n        preambleState.headChunks &&\n        (renderState.headChunks = preambleState.headChunks);\n      null === renderState.bodyChunks &&\n        preambleState.bodyChunks &&\n        (renderState.bodyChunks = preambleState.bodyChunks);\n    }\n    function writeBootstrap(destination, renderState) {\n      renderState = renderState.bootstrapChunks;\n      for (var i = 0; i < renderState.length - 1; i++)\n        writeChunk(destination, renderState[i]);\n      return i < renderState.length\n        ? ((i = renderState[i]),\n          (renderState.length = 0),\n          writeChunkAndReturn(destination, i))\n        : !0;\n    }\n    function writeStartPendingSuspenseBoundary(destination, renderState, id) {\n      writeChunk(destination, startPendingSuspenseBoundary1);\n      if (null === id)\n        throw Error(\n          \"An ID must have been assigned before we can complete the boundary.\"\n        );\n      writeChunk(destination, renderState.boundaryPrefix);\n      writeChunk(destination, stringToChunk(id.toString(16)));\n      return writeChunkAndReturn(destination, startPendingSuspenseBoundary2);\n    }\n    function writeStartSegment(destination, renderState, formatContext, id) {\n      switch (formatContext.insertionMode) {\n        case ROOT_HTML_MODE:\n        case HTML_HTML_MODE:\n        case HTML_HEAD_MODE:\n        case HTML_MODE:\n          return (\n            writeChunk(destination, startSegmentHTML),\n            writeChunk(destination, renderState.segmentPrefix),\n            writeChunk(destination, stringToChunk(id.toString(16))),\n            writeChunkAndReturn(destination, startSegmentHTML2)\n          );\n        case SVG_MODE:\n          return (\n            writeChunk(destination, startSegmentSVG),\n            writeChunk(destination, renderState.segmentPrefix),\n            writeChunk(destination, stringToChunk(id.toString(16))),\n            writeChunkAndReturn(destination, startSegmentSVG2)\n          );\n        case MATHML_MODE:\n          return (\n            writeChunk(destination, startSegmentMathML),\n            writeChunk(destination, renderState.segmentPrefix),\n            writeChunk(destination, stringToChunk(id.toString(16))),\n            writeChunkAndReturn(destination, startSegmentMathML2)\n          );\n        case HTML_TABLE_MODE:\n          return (\n            writeChunk(destination, startSegmentTable),\n            writeChunk(destination, renderState.segmentPrefix),\n            writeChunk(destination, stringToChunk(id.toString(16))),\n            writeChunkAndReturn(destination, startSegmentTable2)\n          );\n        case HTML_TABLE_BODY_MODE:\n          return (\n            writeChunk(destination, startSegmentTableBody),\n            writeChunk(destination, renderState.segmentPrefix),\n            writeChunk(destination, stringToChunk(id.toString(16))),\n            writeChunkAndReturn(destination, startSegmentTableBody2)\n          );\n        case HTML_TABLE_ROW_MODE:\n          return (\n            writeChunk(destination, startSegmentTableRow),\n            writeChunk(destination, renderState.segmentPrefix),\n            writeChunk(destination, stringToChunk(id.toString(16))),\n            writeChunkAndReturn(destination, startSegmentTableRow2)\n          );\n        case HTML_COLGROUP_MODE:\n          return (\n            writeChunk(destination, startSegmentColGroup),\n            writeChunk(destination, renderState.segmentPrefix),\n            writeChunk(destination, stringToChunk(id.toString(16))),\n            writeChunkAndReturn(destination, startSegmentColGroup2)\n          );\n        default:\n          throw Error(\"Unknown insertion mode. This is a bug in React.\");\n      }\n    }\n    function writeEndSegment(destination, formatContext) {\n      switch (formatContext.insertionMode) {\n        case ROOT_HTML_MODE:\n        case HTML_HTML_MODE:\n        case HTML_HEAD_MODE:\n        case HTML_MODE:\n          return writeChunkAndReturn(destination, endSegmentHTML);\n        case SVG_MODE:\n          return writeChunkAndReturn(destination, endSegmentSVG);\n        case MATHML_MODE:\n          return writeChunkAndReturn(destination, endSegmentMathML);\n        case HTML_TABLE_MODE:\n          return writeChunkAndReturn(destination, endSegmentTable);\n        case HTML_TABLE_BODY_MODE:\n          return writeChunkAndReturn(destination, endSegmentTableBody);\n        case HTML_TABLE_ROW_MODE:\n          return writeChunkAndReturn(destination, endSegmentTableRow);\n        case HTML_COLGROUP_MODE:\n          return writeChunkAndReturn(destination, endSegmentColGroup);\n        default:\n          throw Error(\"Unknown insertion mode. This is a bug in React.\");\n      }\n    }\n    function escapeJSStringsForInstructionScripts(input) {\n      return JSON.stringify(input).replace(\n        regexForJSStringsInInstructionScripts,\n        function (match) {\n          switch (match) {\n            case \"<\":\n              return \"\\\\u003c\";\n            case \"\\u2028\":\n              return \"\\\\u2028\";\n            case \"\\u2029\":\n              return \"\\\\u2029\";\n            default:\n              throw Error(\n                \"escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React\"\n              );\n          }\n        }\n      );\n    }\n    function escapeJSObjectForInstructionScripts(input) {\n      return JSON.stringify(input).replace(\n        regexForJSStringsInScripts,\n        function (match) {\n          switch (match) {\n            case \"&\":\n              return \"\\\\u0026\";\n            case \">\":\n              return \"\\\\u003e\";\n            case \"<\":\n              return \"\\\\u003c\";\n            case \"\\u2028\":\n              return \"\\\\u2028\";\n            case \"\\u2029\":\n              return \"\\\\u2029\";\n            default:\n              throw Error(\n                \"escapeJSObjectForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React\"\n              );\n          }\n        }\n      );\n    }\n    function flushStyleTagsLateForBoundary(styleQueue) {\n      var rules = styleQueue.rules,\n        hrefs = styleQueue.hrefs;\n      0 < rules.length &&\n        0 === hrefs.length &&\n        console.error(\n          \"React expected to have at least one href for an a hoistable style but found none. This is a bug in React.\"\n        );\n      var i = 0;\n      if (hrefs.length) {\n        writeChunk(this, currentlyFlushingRenderState.startInlineStyle);\n        writeChunk(this, lateStyleTagResourceOpen1);\n        writeChunk(this, styleQueue.precedence);\n        for (\n          writeChunk(this, lateStyleTagResourceOpen2);\n          i < hrefs.length - 1;\n          i++\n        )\n          writeChunk(this, hrefs[i]), writeChunk(this, spaceSeparator);\n        writeChunk(this, hrefs[i]);\n        writeChunk(this, lateStyleTagResourceOpen3);\n        for (i = 0; i < rules.length; i++) writeChunk(this, rules[i]);\n        destinationHasCapacity = writeChunkAndReturn(\n          this,\n          lateStyleTagTemplateClose\n        );\n        currentlyRenderingBoundaryHasStylesToHoist = !0;\n        rules.length = 0;\n        hrefs.length = 0;\n      }\n    }\n    function hasStylesToHoist(stylesheet) {\n      return stylesheet.state !== PREAMBLE\n        ? (currentlyRenderingBoundaryHasStylesToHoist = !0)\n        : !1;\n    }\n    function writeHoistablesForBoundary(\n      destination,\n      hoistableState,\n      renderState\n    ) {\n      currentlyRenderingBoundaryHasStylesToHoist = !1;\n      destinationHasCapacity = !0;\n      currentlyFlushingRenderState = renderState;\n      hoistableState.styles.forEach(flushStyleTagsLateForBoundary, destination);\n      currentlyFlushingRenderState = null;\n      hoistableState.stylesheets.forEach(hasStylesToHoist);\n      currentlyRenderingBoundaryHasStylesToHoist &&\n        (renderState.stylesToHoist = !0);\n      return destinationHasCapacity;\n    }\n    function flushResource(resource) {\n      for (var i = 0; i < resource.length; i++) writeChunk(this, resource[i]);\n      resource.length = 0;\n    }\n    function flushStyleInPreamble(stylesheet) {\n      pushLinkImpl(stylesheetFlushingQueue, stylesheet.props);\n      for (var i = 0; i < stylesheetFlushingQueue.length; i++)\n        writeChunk(this, stylesheetFlushingQueue[i]);\n      stylesheetFlushingQueue.length = 0;\n      stylesheet.state = PREAMBLE;\n    }\n    function flushStylesInPreamble(styleQueue) {\n      var hasStylesheets = 0 < styleQueue.sheets.size;\n      styleQueue.sheets.forEach(flushStyleInPreamble, this);\n      styleQueue.sheets.clear();\n      var rules = styleQueue.rules,\n        hrefs = styleQueue.hrefs;\n      if (!hasStylesheets || hrefs.length) {\n        writeChunk(this, currentlyFlushingRenderState.startInlineStyle);\n        writeChunk(this, styleTagResourceOpen1);\n        writeChunk(this, styleQueue.precedence);\n        styleQueue = 0;\n        if (hrefs.length) {\n          for (\n            writeChunk(this, styleTagResourceOpen2);\n            styleQueue < hrefs.length - 1;\n            styleQueue++\n          )\n            writeChunk(this, hrefs[styleQueue]),\n              writeChunk(this, spaceSeparator);\n          writeChunk(this, hrefs[styleQueue]);\n        }\n        writeChunk(this, styleTagResourceOpen3);\n        for (styleQueue = 0; styleQueue < rules.length; styleQueue++)\n          writeChunk(this, rules[styleQueue]);\n        writeChunk(this, styleTagResourceClose);\n        rules.length = 0;\n        hrefs.length = 0;\n      }\n    }\n    function preloadLateStyle(stylesheet) {\n      if (stylesheet.state === PENDING$1) {\n        stylesheet.state = PRELOADED;\n        var props = stylesheet.props;\n        pushLinkImpl(stylesheetFlushingQueue, {\n          rel: \"preload\",\n          as: \"style\",\n          href: stylesheet.props.href,\n          crossOrigin: props.crossOrigin,\n          fetchPriority: props.fetchPriority,\n          integrity: props.integrity,\n          media: props.media,\n          hrefLang: props.hrefLang,\n          referrerPolicy: props.referrerPolicy\n        });\n        for (\n          stylesheet = 0;\n          stylesheet < stylesheetFlushingQueue.length;\n          stylesheet++\n        )\n          writeChunk(this, stylesheetFlushingQueue[stylesheet]);\n        stylesheetFlushingQueue.length = 0;\n      }\n    }\n    function preloadLateStyles(styleQueue) {\n      styleQueue.sheets.forEach(preloadLateStyle, this);\n      styleQueue.sheets.clear();\n    }\n    function pushCompletedShellIdAttribute(target, resumableState) {\n      (resumableState.instructions & SentCompletedShellId) === NothingSent &&\n        ((resumableState.instructions |= SentCompletedShellId),\n        target.push(\n          completedShellIdAttributeStart,\n          stringToChunk(\n            escapeTextForBrowser(\"_\" + resumableState.idPrefix + \"R_\")\n          ),\n          attributeEnd\n        ));\n    }\n    function writeStyleResourceDependenciesInJS(destination, hoistableState) {\n      writeChunk(destination, arrayFirstOpenBracket);\n      var nextArrayOpenBrackChunk = arrayFirstOpenBracket;\n      hoistableState.stylesheets.forEach(function (resource) {\n        if (resource.state !== PREAMBLE)\n          if (resource.state === LATE)\n            writeChunk(destination, nextArrayOpenBrackChunk),\n              (resource = resource.props.href),\n              checkAttributeStringCoercion(resource, \"href\"),\n              writeChunk(\n                destination,\n                stringToChunk(\n                  escapeJSObjectForInstructionScripts(\"\" + resource)\n                )\n              ),\n              writeChunk(destination, arrayCloseBracket),\n              (nextArrayOpenBrackChunk = arraySubsequentOpenBracket);\n          else {\n            writeChunk(destination, nextArrayOpenBrackChunk);\n            var precedence = resource.props[\"data-precedence\"],\n              props = resource.props,\n              coercedHref = sanitizeURL(\"\" + resource.props.href);\n            writeChunk(\n              destination,\n              stringToChunk(escapeJSObjectForInstructionScripts(coercedHref))\n            );\n            checkAttributeStringCoercion(precedence, \"precedence\");\n            precedence = \"\" + precedence;\n            writeChunk(destination, arrayInterstitial);\n            writeChunk(\n              destination,\n              stringToChunk(escapeJSObjectForInstructionScripts(precedence))\n            );\n            for (var propKey in props)\n              if (\n                hasOwnProperty.call(props, propKey) &&\n                ((precedence = props[propKey]), null != precedence)\n              )\n                switch (propKey) {\n                  case \"href\":\n                  case \"rel\":\n                  case \"precedence\":\n                  case \"data-precedence\":\n                    break;\n                  case \"children\":\n                  case \"dangerouslySetInnerHTML\":\n                    throw Error(\n                      \"link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.\"\n                    );\n                  default:\n                    writeStyleResourceAttributeInJS(\n                      destination,\n                      propKey,\n                      precedence\n                    );\n                }\n            writeChunk(destination, arrayCloseBracket);\n            nextArrayOpenBrackChunk = arraySubsequentOpenBracket;\n            resource.state = LATE;\n          }\n      });\n      writeChunk(destination, arrayCloseBracket);\n    }\n    function writeStyleResourceAttributeInJS(destination, name, value) {\n      var attributeName = name.toLowerCase();\n      switch (typeof value) {\n        case \"function\":\n        case \"symbol\":\n          return;\n      }\n      switch (name) {\n        case \"innerHTML\":\n        case \"dangerouslySetInnerHTML\":\n        case \"suppressContentEditableWarning\":\n        case \"suppressHydrationWarning\":\n        case \"style\":\n        case \"ref\":\n          return;\n        case \"className\":\n          attributeName = \"class\";\n          checkAttributeStringCoercion(value, attributeName);\n          name = \"\" + value;\n          break;\n        case \"hidden\":\n          if (!1 === value) return;\n          name = \"\";\n          break;\n        case \"src\":\n        case \"href\":\n          value = sanitizeURL(value);\n          checkAttributeStringCoercion(value, attributeName);\n          name = \"\" + value;\n          break;\n        default:\n          if (\n            (2 < name.length &&\n              (\"o\" === name[0] || \"O\" === name[0]) &&\n              (\"n\" === name[1] || \"N\" === name[1])) ||\n            !isAttributeNameSafe(name)\n          )\n            return;\n          checkAttributeStringCoercion(value, attributeName);\n          name = \"\" + value;\n      }\n      writeChunk(destination, arrayInterstitial);\n      writeChunk(\n        destination,\n        stringToChunk(escapeJSObjectForInstructionScripts(attributeName))\n      );\n      writeChunk(destination, arrayInterstitial);\n      writeChunk(\n        destination,\n        stringToChunk(escapeJSObjectForInstructionScripts(name))\n      );\n    }\n    function createHoistableState() {\n      return { styles: new Set(), stylesheets: new Set(), suspenseyImages: !1 };\n    }\n    function preloadBootstrapScriptOrModule(\n      resumableState,\n      renderState,\n      href,\n      props\n    ) {\n      (resumableState.scriptResources.hasOwnProperty(href) ||\n        resumableState.moduleScriptResources.hasOwnProperty(href)) &&\n        console.error(\n          'Internal React Error: React expected bootstrap script or module with src \"%s\" to not have been preloaded already. please file an issue',\n          href\n        );\n      resumableState.scriptResources[href] = EXISTS;\n      resumableState.moduleScriptResources[href] = EXISTS;\n      resumableState = [];\n      pushLinkImpl(resumableState, props);\n      renderState.bootstrapScripts.add(resumableState);\n    }\n    function adoptPreloadCredentials(target, preloadState) {\n      null == target.crossOrigin && (target.crossOrigin = preloadState[0]);\n      null == target.integrity && (target.integrity = preloadState[1]);\n    }\n    function getPreloadAsHeader(href, as, params) {\n      href = escapeHrefForLinkHeaderURLContext(href);\n      as = escapeStringForLinkHeaderQuotedParamValueContext(as, \"as\");\n      as = \"<\" + href + '>; rel=preload; as=\"' + as + '\"';\n      for (var paramName in params)\n        hasOwnProperty.call(params, paramName) &&\n          ((href = params[paramName]),\n          \"string\" === typeof href &&\n            (as +=\n              \"; \" +\n              paramName.toLowerCase() +\n              '=\"' +\n              escapeStringForLinkHeaderQuotedParamValueContext(\n                href,\n                paramName\n              ) +\n              '\"'));\n      return as;\n    }\n    function escapeHrefForLinkHeaderURLContext(hrefInput) {\n      checkAttributeStringCoercion(hrefInput, \"href\");\n      return (\"\" + hrefInput).replace(\n        regexForHrefInLinkHeaderURLContext,\n        escapeHrefForLinkHeaderURLContextReplacer\n      );\n    }\n    function escapeHrefForLinkHeaderURLContextReplacer(match) {\n      switch (match) {\n        case \"<\":\n          return \"%3C\";\n        case \">\":\n          return \"%3E\";\n        case \"\\n\":\n          return \"%0A\";\n        case \"\\r\":\n          return \"%0D\";\n        default:\n          throw Error(\n            \"escapeLinkHrefForHeaderContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React\"\n          );\n      }\n    }\n    function escapeStringForLinkHeaderQuotedParamValueContext(value, name) {\n      willCoercionThrow(value) &&\n        (console.error(\n          \"The provided `%s` option is an unsupported type %s. This value must be coerced to a string before using it here.\",\n          name,\n          typeName(value)\n        ),\n        testStringCoercion(value));\n      return (\"\" + value).replace(\n        regexForLinkHeaderQuotedParamValueContext,\n        escapeStringForLinkHeaderQuotedParamValueContextReplacer\n      );\n    }\n    function escapeStringForLinkHeaderQuotedParamValueContextReplacer(match) {\n      switch (match) {\n        case '\"':\n          return \"%22\";\n        case \"'\":\n          return \"%27\";\n        case \";\":\n          return \"%3B\";\n        case \",\":\n          return \"%2C\";\n        case \"\\n\":\n          return \"%0A\";\n        case \"\\r\":\n          return \"%0D\";\n        default:\n          throw Error(\n            \"escapeStringForLinkHeaderQuotedParamValueContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React\"\n          );\n      }\n    }\n    function hoistStyleQueueDependency(styleQueue) {\n      this.styles.add(styleQueue);\n    }\n    function hoistStylesheetDependency(stylesheet) {\n      this.stylesheets.add(stylesheet);\n    }\n    function hoistHoistables(parentState, childState) {\n      childState.styles.forEach(hoistStyleQueueDependency, parentState);\n      childState.stylesheets.forEach(hoistStylesheetDependency, parentState);\n      childState.suspenseyImages && (parentState.suspenseyImages = !0);\n    }\n    function hasSuspenseyContent(hoistableState) {\n      return (\n        0 < hoistableState.stylesheets.size || hoistableState.suspenseyImages\n      );\n    }\n    function getComponentNameFromType(type) {\n      if (null == type) return null;\n      if (\"function\" === typeof type)\n        return type.$$typeof === REACT_CLIENT_REFERENCE\n          ? null\n          : type.displayName || type.name || null;\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return \"Fragment\";\n        case REACT_PROFILER_TYPE:\n          return \"Profiler\";\n        case REACT_STRICT_MODE_TYPE:\n          return \"StrictMode\";\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n        case REACT_ACTIVITY_TYPE:\n          return \"Activity\";\n      }\n      if (\"object\" === typeof type)\n        switch (\n          (\"number\" === typeof type.tag &&\n            console.error(\n              \"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"\n            ),\n          type.$$typeof)\n        ) {\n          case REACT_PORTAL_TYPE:\n            return \"Portal\";\n          case REACT_CONTEXT_TYPE:\n            return type.displayName || \"Context\";\n          case REACT_CONSUMER_TYPE:\n            return (type._context.displayName || \"Context\") + \".Consumer\";\n          case REACT_FORWARD_REF_TYPE:\n            var innerType = type.render;\n            type = type.displayName;\n            type ||\n              ((type = innerType.displayName || innerType.name || \"\"),\n              (type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\"));\n            return type;\n          case REACT_MEMO_TYPE:\n            return (\n              (innerType = type.displayName || null),\n              null !== innerType\n                ? innerType\n                : getComponentNameFromType(type.type) || \"Memo\"\n            );\n          case REACT_LAZY_TYPE:\n            innerType = type._payload;\n            type = type._init;\n            try {\n              return getComponentNameFromType(type(innerType));\n            } catch (x) {}\n        }\n      return null;\n    }\n    function popToNearestCommonAncestor(prev, next) {\n      if (prev !== next) {\n        prev.context._currentValue = prev.parentValue;\n        prev = prev.parent;\n        var parentNext = next.parent;\n        if (null === prev) {\n          if (null !== parentNext)\n            throw Error(\n              \"The stacks must reach the root at the same time. This is a bug in React.\"\n            );\n        } else {\n          if (null === parentNext)\n            throw Error(\n              \"The stacks must reach the root at the same time. This is a bug in React.\"\n            );\n          popToNearestCommonAncestor(prev, parentNext);\n        }\n        next.context._currentValue = next.value;\n      }\n    }\n    function popAllPrevious(prev) {\n      prev.context._currentValue = prev.parentValue;\n      prev = prev.parent;\n      null !== prev && popAllPrevious(prev);\n    }\n    function pushAllNext(next) {\n      var parentNext = next.parent;\n      null !== parentNext && pushAllNext(parentNext);\n      next.context._currentValue = next.value;\n    }\n    function popPreviousToCommonLevel(prev, next) {\n      prev.context._currentValue = prev.parentValue;\n      prev = prev.parent;\n      if (null === prev)\n        throw Error(\n          \"The depth must equal at least at zero before reaching the root. This is a bug in React.\"\n        );\n      prev.depth === next.depth\n        ? popToNearestCommonAncestor(prev, next)\n        : popPreviousToCommonLevel(prev, next);\n    }\n    function popNextToCommonLevel(prev, next) {\n      var parentNext = next.parent;\n      if (null === parentNext)\n        throw Error(\n          \"The depth must equal at least at zero before reaching the root. This is a bug in React.\"\n        );\n      prev.depth === parentNext.depth\n        ? popToNearestCommonAncestor(prev, parentNext)\n        : popNextToCommonLevel(prev, parentNext);\n      next.context._currentValue = next.value;\n    }\n    function switchContext(newSnapshot) {\n      var prev = currentActiveSnapshot;\n      prev !== newSnapshot &&\n        (null === prev\n          ? pushAllNext(newSnapshot)\n          : null === newSnapshot\n            ? popAllPrevious(prev)\n            : prev.depth === newSnapshot.depth\n              ? popToNearestCommonAncestor(prev, newSnapshot)\n              : prev.depth > newSnapshot.depth\n                ? popPreviousToCommonLevel(prev, newSnapshot)\n                : popNextToCommonLevel(prev, newSnapshot),\n        (currentActiveSnapshot = newSnapshot));\n    }\n    function warnOnInvalidCallback(callback) {\n      if (null !== callback && \"function\" !== typeof callback) {\n        var key = String(callback);\n        didWarnOnInvalidCallback.has(key) ||\n          (didWarnOnInvalidCallback.add(key),\n          console.error(\n            \"Expected the last optional `callback` argument to be a function. Instead received: %s.\",\n            callback\n          ));\n      }\n    }\n    function warnNoop(publicInstance, callerName) {\n      publicInstance =\n        ((publicInstance = publicInstance.constructor) &&\n          getComponentNameFromType(publicInstance)) ||\n        \"ReactClass\";\n      var warningKey = publicInstance + \".\" + callerName;\n      didWarnAboutNoopUpdateForComponent[warningKey] ||\n        (console.error(\n          \"Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.\\n\\nPlease check the code for the %s component.\",\n          callerName,\n          publicInstance\n        ),\n        (didWarnAboutNoopUpdateForComponent[warningKey] = !0));\n    }\n    function pushTreeContext(baseContext, totalChildren, index) {\n      var baseIdWithLeadingBit = baseContext.id;\n      baseContext = baseContext.overflow;\n      var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;\n      baseIdWithLeadingBit &= ~(1 << baseLength);\n      index += 1;\n      var length = 32 - clz32(totalChildren) + baseLength;\n      if (30 < length) {\n        var numberOfOverflowBits = baseLength - (baseLength % 5);\n        length = (\n          baseIdWithLeadingBit &\n          ((1 << numberOfOverflowBits) - 1)\n        ).toString(32);\n        baseIdWithLeadingBit >>= numberOfOverflowBits;\n        baseLength -= numberOfOverflowBits;\n        return {\n          id:\n            (1 << (32 - clz32(totalChildren) + baseLength)) |\n            (index << baseLength) |\n            baseIdWithLeadingBit,\n          overflow: length + baseContext\n        };\n      }\n      return {\n        id: (1 << length) | (index << baseLength) | baseIdWithLeadingBit,\n        overflow: baseContext\n      };\n    }\n    function clz32Fallback(x) {\n      x >>>= 0;\n      return 0 === x ? 32 : (31 - ((log(x) / LN2) | 0)) | 0;\n    }\n    function noop() {}\n    function trackUsedThenable(thenableState, thenable, index) {\n      index = thenableState[index];\n      void 0 === index\n        ? thenableState.push(thenable)\n        : index !== thenable && (thenable.then(noop, noop), (thenable = index));\n      switch (thenable.status) {\n        case \"fulfilled\":\n          return thenable.value;\n        case \"rejected\":\n          throw thenable.reason;\n        default:\n          \"string\" === typeof thenable.status\n            ? thenable.then(noop, noop)\n            : ((thenableState = thenable),\n              (thenableState.status = \"pending\"),\n              thenableState.then(\n                function (fulfilledValue) {\n                  if (\"pending\" === thenable.status) {\n                    var fulfilledThenable = thenable;\n                    fulfilledThenable.status = \"fulfilled\";\n                    fulfilledThenable.value = fulfilledValue;\n                  }\n                },\n                function (error) {\n                  if (\"pending\" === thenable.status) {\n                    var rejectedThenable = thenable;\n                    rejectedThenable.status = \"rejected\";\n                    rejectedThenable.reason = error;\n                  }\n                }\n              ));\n          switch (thenable.status) {\n            case \"fulfilled\":\n              return thenable.value;\n            case \"rejected\":\n              throw thenable.reason;\n          }\n          suspendedThenable = thenable;\n          throw SuspenseException;\n      }\n    }\n    function getSuspendedThenable() {\n      if (null === suspendedThenable)\n        throw Error(\n          \"Expected a suspended thenable. This is a bug in React. Please file an issue.\"\n        );\n      var thenable = suspendedThenable;\n      suspendedThenable = null;\n      return thenable;\n    }\n    function is(x, y) {\n      return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);\n    }\n    function resolveCurrentlyRenderingComponent() {\n      if (null === currentlyRenderingComponent)\n        throw Error(\n          \"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\\n1. You might have mismatching versions of React and the renderer (such as React DOM)\\n2. You might be breaking the Rules of Hooks\\n3. You might have more than one copy of React in the same app\\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.\"\n        );\n      isInHookUserCodeInDev &&\n        console.error(\n          \"Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks\"\n        );\n      return currentlyRenderingComponent;\n    }\n    function createHook() {\n      if (0 < numberOfReRenders)\n        throw Error(\"Rendered more hooks than during the previous render\");\n      return { memoizedState: null, queue: null, next: null };\n    }\n    function createWorkInProgressHook() {\n      null === workInProgressHook\n        ? null === firstWorkInProgressHook\n          ? ((isReRender = !1),\n            (firstWorkInProgressHook = workInProgressHook = createHook()))\n          : ((isReRender = !0), (workInProgressHook = firstWorkInProgressHook))\n        : null === workInProgressHook.next\n          ? ((isReRender = !1),\n            (workInProgressHook = workInProgressHook.next = createHook()))\n          : ((isReRender = !0), (workInProgressHook = workInProgressHook.next));\n      return workInProgressHook;\n    }\n    function getThenableStateAfterSuspending() {\n      var state = thenableState;\n      thenableState = null;\n      return state;\n    }\n    function resetHooksState() {\n      isInHookUserCodeInDev = !1;\n      currentlyRenderingKeyPath =\n        currentlyRenderingRequest =\n        currentlyRenderingTask =\n        currentlyRenderingComponent =\n          null;\n      didScheduleRenderPhaseUpdate = !1;\n      firstWorkInProgressHook = null;\n      numberOfReRenders = 0;\n      workInProgressHook = renderPhaseUpdates = null;\n    }\n    function readContext(context) {\n      isInHookUserCodeInDev &&\n        console.error(\n          \"Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().\"\n        );\n      return context._currentValue;\n    }\n    function basicStateReducer(state, action) {\n      return \"function\" === typeof action ? action(state) : action;\n    }\n    function useReducer(reducer, initialArg, init) {\n      reducer !== basicStateReducer && (currentHookNameInDev = \"useReducer\");\n      currentlyRenderingComponent = resolveCurrentlyRenderingComponent();\n      workInProgressHook = createWorkInProgressHook();\n      if (isReRender) {\n        init = workInProgressHook.queue;\n        initialArg = init.dispatch;\n        if (null !== renderPhaseUpdates) {\n          var firstRenderPhaseUpdate = renderPhaseUpdates.get(init);\n          if (void 0 !== firstRenderPhaseUpdate) {\n            renderPhaseUpdates.delete(init);\n            init = workInProgressHook.memoizedState;\n            do {\n              var action = firstRenderPhaseUpdate.action;\n              isInHookUserCodeInDev = !0;\n              init = reducer(init, action);\n              isInHookUserCodeInDev = !1;\n              firstRenderPhaseUpdate = firstRenderPhaseUpdate.next;\n            } while (null !== firstRenderPhaseUpdate);\n            workInProgressHook.memoizedState = init;\n            return [init, initialArg];\n          }\n        }\n        return [workInProgressHook.memoizedState, initialArg];\n      }\n      isInHookUserCodeInDev = !0;\n      reducer =\n        reducer === basicStateReducer\n          ? \"function\" === typeof initialArg\n            ? initialArg()\n            : initialArg\n          : void 0 !== init\n            ? init(initialArg)\n            : initialArg;\n      isInHookUserCodeInDev = !1;\n      workInProgressHook.memoizedState = reducer;\n      reducer = workInProgressHook.queue = { last: null, dispatch: null };\n      reducer = reducer.dispatch = dispatchAction.bind(\n        null,\n        currentlyRenderingComponent,\n        reducer\n      );\n      return [workInProgressHook.memoizedState, reducer];\n    }\n    function useMemo(nextCreate, deps) {\n      currentlyRenderingComponent = resolveCurrentlyRenderingComponent();\n      workInProgressHook = createWorkInProgressHook();\n      deps = void 0 === deps ? null : deps;\n      if (null !== workInProgressHook) {\n        var prevState = workInProgressHook.memoizedState;\n        if (null !== prevState && null !== deps) {\n          a: {\n            var JSCompiler_inline_result = prevState[1];\n            if (null === JSCompiler_inline_result)\n              console.error(\n                \"%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.\",\n                currentHookNameInDev\n              ),\n                (JSCompiler_inline_result = !1);\n            else {\n              deps.length !== JSCompiler_inline_result.length &&\n                console.error(\n                  \"The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\\n\\nPrevious: %s\\nIncoming: %s\",\n                  currentHookNameInDev,\n                  \"[\" + deps.join(\", \") + \"]\",\n                  \"[\" + JSCompiler_inline_result.join(\", \") + \"]\"\n                );\n              for (\n                var i = 0;\n                i < JSCompiler_inline_result.length && i < deps.length;\n                i++\n              )\n                if (!objectIs(deps[i], JSCompiler_inline_result[i])) {\n                  JSCompiler_inline_result = !1;\n                  break a;\n                }\n              JSCompiler_inline_result = !0;\n            }\n          }\n          if (JSCompiler_inline_result) return prevState[0];\n        }\n      }\n      isInHookUserCodeInDev = !0;\n      nextCreate = nextCreate();\n      isInHookUserCodeInDev = !1;\n      workInProgressHook.memoizedState = [nextCreate, deps];\n      return nextCreate;\n    }\n    function dispatchAction(componentIdentity, queue, action) {\n      if (25 <= numberOfReRenders)\n        throw Error(\n          \"Too many re-renders. React limits the number of renders to prevent an infinite loop.\"\n        );\n      if (componentIdentity === currentlyRenderingComponent)\n        if (\n          ((didScheduleRenderPhaseUpdate = !0),\n          (componentIdentity = { action: action, next: null }),\n          null === renderPhaseUpdates && (renderPhaseUpdates = new Map()),\n          (action = renderPhaseUpdates.get(queue)),\n          void 0 === action)\n        )\n          renderPhaseUpdates.set(queue, componentIdentity);\n        else {\n          for (queue = action; null !== queue.next; ) queue = queue.next;\n          queue.next = componentIdentity;\n        }\n    }\n    function throwOnUseEffectEventCall() {\n      throw Error(\n        \"A function wrapped in useEffectEvent can't be called during rendering.\"\n      );\n    }\n    function unsupportedStartTransition() {\n      throw Error(\"startTransition cannot be called during server rendering.\");\n    }\n    function unsupportedSetOptimisticState() {\n      throw Error(\"Cannot update optimistic state while rendering.\");\n    }\n    function useActionState(action, initialState, permalink) {\n      resolveCurrentlyRenderingComponent();\n      var actionStateHookIndex = actionStateCounter++,\n        request = currentlyRenderingRequest;\n      if (\"function\" === typeof action.$$FORM_ACTION) {\n        var nextPostbackStateKey = null,\n          componentKeyPath = currentlyRenderingKeyPath;\n        request = request.formState;\n        var isSignatureEqual = action.$$IS_SIGNATURE_EQUAL;\n        if (null !== request && \"function\" === typeof isSignatureEqual) {\n          var postbackKey = request[1];\n          isSignatureEqual.call(action, request[2], request[3]) &&\n            ((nextPostbackStateKey =\n              void 0 !== permalink\n                ? \"p\" + permalink\n                : \"k\" +\n                  murmurhash3_32_gc(\n                    JSON.stringify([\n                      componentKeyPath,\n                      null,\n                      actionStateHookIndex\n                    ]),\n                    0\n                  )),\n            postbackKey === nextPostbackStateKey &&\n              ((actionStateMatchingIndex = actionStateHookIndex),\n              (initialState = request[0])));\n        }\n        var boundAction = action.bind(null, initialState);\n        action = function (payload) {\n          boundAction(payload);\n        };\n        \"function\" === typeof boundAction.$$FORM_ACTION &&\n          (action.$$FORM_ACTION = function (prefix) {\n            prefix = boundAction.$$FORM_ACTION(prefix);\n            void 0 !== permalink &&\n              (checkAttributeStringCoercion(permalink, \"target\"),\n              (permalink += \"\"),\n              (prefix.action = permalink));\n            var formData = prefix.data;\n            formData &&\n              (null === nextPostbackStateKey &&\n                (nextPostbackStateKey =\n                  void 0 !== permalink\n                    ? \"p\" + permalink\n                    : \"k\" +\n                      murmurhash3_32_gc(\n                        JSON.stringify([\n                          componentKeyPath,\n                          null,\n                          actionStateHookIndex\n                        ]),\n                        0\n                      )),\n              formData.append(\"$ACTION_KEY\", nextPostbackStateKey));\n            return prefix;\n          });\n        return [initialState, action, !1];\n      }\n      var _boundAction = action.bind(null, initialState);\n      return [\n        initialState,\n        function (payload) {\n          _boundAction(payload);\n        },\n        !1\n      ];\n    }\n    function unwrapThenable(thenable) {\n      var index = thenableIndexCounter;\n      thenableIndexCounter += 1;\n      null === thenableState && (thenableState = []);\n      return trackUsedThenable(thenableState, thenable, index);\n    }\n    function unsupportedRefresh() {\n      throw Error(\"Cache cannot be refreshed during server rendering.\");\n    }\n    function disabledLog() {}\n    function disableLogs() {\n      if (0 === disabledDepth) {\n        prevLog = console.log;\n        prevInfo = console.info;\n        prevWarn = console.warn;\n        prevError = console.error;\n        prevGroup = console.group;\n        prevGroupCollapsed = console.groupCollapsed;\n        prevGroupEnd = console.groupEnd;\n        var props = {\n          configurable: !0,\n          enumerable: !0,\n          value: disabledLog,\n          writable: !0\n        };\n        Object.defineProperties(console, {\n          info: props,\n          log: props,\n          warn: props,\n          error: props,\n          group: props,\n          groupCollapsed: props,\n          groupEnd: props\n        });\n      }\n      disabledDepth++;\n    }\n    function reenableLogs() {\n      disabledDepth--;\n      if (0 === disabledDepth) {\n        var props = { configurable: !0, enumerable: !0, writable: !0 };\n        Object.defineProperties(console, {\n          log: assign({}, props, { value: prevLog }),\n          info: assign({}, props, { value: prevInfo }),\n          warn: assign({}, props, { value: prevWarn }),\n          error: assign({}, props, { value: prevError }),\n          group: assign({}, props, { value: prevGroup }),\n          groupCollapsed: assign({}, props, { value: prevGroupCollapsed }),\n          groupEnd: assign({}, props, { value: prevGroupEnd })\n        });\n      }\n      0 > disabledDepth &&\n        console.error(\n          \"disabledDepth fell below zero. This is a bug in React. Please file an issue.\"\n        );\n    }\n    function formatOwnerStack(error) {\n      var prevPrepareStackTrace = Error.prepareStackTrace;\n      Error.prepareStackTrace = void 0;\n      error = error.stack;\n      Error.prepareStackTrace = prevPrepareStackTrace;\n      error.startsWith(\"Error: react-stack-top-frame\\n\") &&\n        (error = error.slice(29));\n      prevPrepareStackTrace = error.indexOf(\"\\n\");\n      -1 !== prevPrepareStackTrace &&\n        (error = error.slice(prevPrepareStackTrace + 1));\n      prevPrepareStackTrace = error.indexOf(\"react_stack_bottom_frame\");\n      -1 !== prevPrepareStackTrace &&\n        (prevPrepareStackTrace = error.lastIndexOf(\n          \"\\n\",\n          prevPrepareStackTrace\n        ));\n      if (-1 !== prevPrepareStackTrace)\n        error = error.slice(0, prevPrepareStackTrace);\n      else return \"\";\n      return error;\n    }\n    function describeBuiltInComponentFrame(name) {\n      if (void 0 === prefix)\n        try {\n          throw Error();\n        } catch (x) {\n          var match = x.stack.trim().match(/\\n( *(at )?)/);\n          prefix = (match && match[1]) || \"\";\n          suffix =\n            -1 < x.stack.indexOf(\"\\n    at\")\n              ? \" (<anonymous>)\"\n              : -1 < x.stack.indexOf(\"@\")\n                ? \"@unknown:0:0\"\n                : \"\";\n        }\n      return \"\\n\" + prefix + name + suffix;\n    }\n    function describeNativeComponentFrame(fn, construct) {\n      if (!fn || reentry) return \"\";\n      var frame = componentFrameCache.get(fn);\n      if (void 0 !== frame) return frame;\n      reentry = !0;\n      frame = Error.prepareStackTrace;\n      Error.prepareStackTrace = void 0;\n      var previousDispatcher = null;\n      previousDispatcher = ReactSharedInternals.H;\n      ReactSharedInternals.H = null;\n      disableLogs();\n      try {\n        var RunInRootFrame = {\n          DetermineComponentFrameRoot: function () {\n            try {\n              if (construct) {\n                var Fake = function () {\n                  throw Error();\n                };\n                Object.defineProperty(Fake.prototype, \"props\", {\n                  set: function () {\n                    throw Error();\n                  }\n                });\n                if (\"object\" === typeof Reflect && Reflect.construct) {\n                  try {\n                    Reflect.construct(Fake, []);\n                  } catch (x) {\n                    var control = x;\n                  }\n                  Reflect.construct(fn, [], Fake);\n                } else {\n                  try {\n                    Fake.call();\n                  } catch (x$0) {\n                    control = x$0;\n                  }\n                  fn.call(Fake.prototype);\n                }\n              } else {\n                try {\n                  throw Error();\n                } catch (x$1) {\n                  control = x$1;\n                }\n                (Fake = fn()) &&\n                  \"function\" === typeof Fake.catch &&\n                  Fake.catch(function () {});\n              }\n            } catch (sample) {\n              if (sample && control && \"string\" === typeof sample.stack)\n                return [sample.stack, control.stack];\n            }\n            return [null, null];\n          }\n        };\n        RunInRootFrame.DetermineComponentFrameRoot.displayName =\n          \"DetermineComponentFrameRoot\";\n        var namePropDescriptor = Object.getOwnPropertyDescriptor(\n          RunInRootFrame.DetermineComponentFrameRoot,\n          \"name\"\n        );\n        namePropDescriptor &&\n          namePropDescriptor.configurable &&\n          Object.defineProperty(\n            RunInRootFrame.DetermineComponentFrameRoot,\n            \"name\",\n            { value: \"DetermineComponentFrameRoot\" }\n          );\n        var _RunInRootFrame$Deter =\n            RunInRootFrame.DetermineComponentFrameRoot(),\n          sampleStack = _RunInRootFrame$Deter[0],\n          controlStack = _RunInRootFrame$Deter[1];\n        if (sampleStack && controlStack) {\n          var sampleLines = sampleStack.split(\"\\n\"),\n            controlLines = controlStack.split(\"\\n\");\n          for (\n            _RunInRootFrame$Deter = namePropDescriptor = 0;\n            namePropDescriptor < sampleLines.length &&\n            !sampleLines[namePropDescriptor].includes(\n              \"DetermineComponentFrameRoot\"\n            );\n\n          )\n            namePropDescriptor++;\n          for (\n            ;\n            _RunInRootFrame$Deter < controlLines.length &&\n            !controlLines[_RunInRootFrame$Deter].includes(\n              \"DetermineComponentFrameRoot\"\n            );\n\n          )\n            _RunInRootFrame$Deter++;\n          if (\n            namePropDescriptor === sampleLines.length ||\n            _RunInRootFrame$Deter === controlLines.length\n          )\n            for (\n              namePropDescriptor = sampleLines.length - 1,\n                _RunInRootFrame$Deter = controlLines.length - 1;\n              1 <= namePropDescriptor &&\n              0 <= _RunInRootFrame$Deter &&\n              sampleLines[namePropDescriptor] !==\n                controlLines[_RunInRootFrame$Deter];\n\n            )\n              _RunInRootFrame$Deter--;\n          for (\n            ;\n            1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter;\n            namePropDescriptor--, _RunInRootFrame$Deter--\n          )\n            if (\n              sampleLines[namePropDescriptor] !==\n              controlLines[_RunInRootFrame$Deter]\n            ) {\n              if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {\n                do\n                  if (\n                    (namePropDescriptor--,\n                    _RunInRootFrame$Deter--,\n                    0 > _RunInRootFrame$Deter ||\n                      sampleLines[namePropDescriptor] !==\n                        controlLines[_RunInRootFrame$Deter])\n                  ) {\n                    var _frame =\n                      \"\\n\" +\n                      sampleLines[namePropDescriptor].replace(\n                        \" at new \",\n                        \" at \"\n                      );\n                    fn.displayName &&\n                      _frame.includes(\"<anonymous>\") &&\n                      (_frame = _frame.replace(\"<anonymous>\", fn.displayName));\n                    \"function\" === typeof fn &&\n                      componentFrameCache.set(fn, _frame);\n                    return _frame;\n                  }\n                while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);\n              }\n              break;\n            }\n        }\n      } finally {\n        (reentry = !1),\n          (ReactSharedInternals.H = previousDispatcher),\n          reenableLogs(),\n          (Error.prepareStackTrace = frame);\n      }\n      sampleLines = (sampleLines = fn ? fn.displayName || fn.name : \"\")\n        ? describeBuiltInComponentFrame(sampleLines)\n        : \"\";\n      \"function\" === typeof fn && componentFrameCache.set(fn, sampleLines);\n      return sampleLines;\n    }\n    function describeComponentStackByType(type) {\n      if (\"string\" === typeof type) return describeBuiltInComponentFrame(type);\n      if (\"function\" === typeof type)\n        return type.prototype && type.prototype.isReactComponent\n          ? describeNativeComponentFrame(type, !0)\n          : describeNativeComponentFrame(type, !1);\n      if (\"object\" === typeof type && null !== type) {\n        switch (type.$$typeof) {\n          case REACT_FORWARD_REF_TYPE:\n            return describeNativeComponentFrame(type.render, !1);\n          case REACT_MEMO_TYPE:\n            return describeNativeComponentFrame(type.type, !1);\n          case REACT_LAZY_TYPE:\n            var lazyComponent = type,\n              payload = lazyComponent._payload;\n            lazyComponent = lazyComponent._init;\n            try {\n              type = lazyComponent(payload);\n            } catch (x) {\n              return describeBuiltInComponentFrame(\"Lazy\");\n            }\n            return describeComponentStackByType(type);\n        }\n        if (\"string\" === typeof type.name) {\n          a: {\n            payload = type.name;\n            lazyComponent = type.env;\n            type = type.debugLocation;\n            if (null != type) {\n              type = formatOwnerStack(type);\n              var idx = type.lastIndexOf(\"\\n\");\n              type = -1 === idx ? type : type.slice(idx + 1);\n              if (-1 !== type.indexOf(payload)) {\n                payload = \"\\n\" + type;\n                break a;\n              }\n            }\n            payload = describeBuiltInComponentFrame(\n              payload + (lazyComponent ? \" [\" + lazyComponent + \"]\" : \"\")\n            );\n          }\n          return payload;\n        }\n      }\n      switch (type) {\n        case REACT_SUSPENSE_LIST_TYPE:\n          return describeBuiltInComponentFrame(\"SuspenseList\");\n        case REACT_SUSPENSE_TYPE:\n          return describeBuiltInComponentFrame(\"Suspense\");\n      }\n      return \"\";\n    }\n    function resetOwnerStackLimit() {\n      var now = getCurrentTime();\n      1e3 < now - lastResetTime &&\n        ((ReactSharedInternals.recentlyCreatedOwnerStacks = 0),\n        (lastResetTime = now));\n    }\n    function isEligibleForOutlining(request, boundary) {\n      return (\n        (500 < boundary.byteSize ||\n          hasSuspenseyContent(boundary.contentState)) &&\n        null === boundary.contentPreamble\n      );\n    }\n    function defaultErrorHandler(error) {\n      if (\n        \"object\" === typeof error &&\n        null !== error &&\n        \"string\" === typeof error.environmentName\n      ) {\n        var JSCompiler_inline_result = error.environmentName;\n        error = [error].slice(0);\n        \"string\" === typeof error[0]\n          ? error.splice(\n              0,\n              1,\n              \"%c%s%c \" + error[0],\n              \"background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px\",\n              \" \" + JSCompiler_inline_result + \" \",\n              \"\"\n            )\n          : error.splice(\n              0,\n              0,\n              \"%c%s%c\",\n              \"background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px\",\n              \" \" + JSCompiler_inline_result + \" \",\n              \"\"\n            );\n        error.unshift(console);\n        JSCompiler_inline_result = bind.apply(console.error, error);\n        JSCompiler_inline_result();\n      } else console.error(error);\n      return null;\n    }\n    function RequestInstance(\n      resumableState,\n      renderState,\n      rootFormatContext,\n      progressiveChunkSize,\n      onError,\n      onAllReady,\n      onShellReady,\n      onShellError,\n      onFatalError,\n      onPostpone,\n      formState\n    ) {\n      var abortSet = new Set();\n      this.destination = null;\n      this.flushScheduled = !1;\n      this.resumableState = resumableState;\n      this.renderState = renderState;\n      this.rootFormatContext = rootFormatContext;\n      this.progressiveChunkSize =\n        void 0 === progressiveChunkSize ? 12800 : progressiveChunkSize;\n      this.status = 10;\n      this.fatalError = null;\n      this.pendingRootTasks = this.allPendingTasks = this.nextSegmentId = 0;\n      this.completedPreambleSegments = this.completedRootSegment = null;\n      this.byteSize = 0;\n      this.abortableTasks = abortSet;\n      this.pingedTasks = [];\n      this.clientRenderedBoundaries = [];\n      this.completedBoundaries = [];\n      this.partialBoundaries = [];\n      this.trackedPostpones = null;\n      this.onError = void 0 === onError ? defaultErrorHandler : onError;\n      this.onPostpone = void 0 === onPostpone ? noop : onPostpone;\n      this.onAllReady = void 0 === onAllReady ? noop : onAllReady;\n      this.onShellReady = void 0 === onShellReady ? noop : onShellReady;\n      this.onShellError = void 0 === onShellError ? noop : onShellError;\n      this.onFatalError = void 0 === onFatalError ? noop : onFatalError;\n      this.formState = void 0 === formState ? null : formState;\n      this.didWarnForKey = null;\n    }\n    function createRequest(\n      children,\n      resumableState,\n      renderState,\n      rootFormatContext,\n      progressiveChunkSize,\n      onError,\n      onAllReady,\n      onShellReady,\n      onShellError,\n      onFatalError,\n      onPostpone,\n      formState\n    ) {\n      resetOwnerStackLimit();\n      resumableState = new RequestInstance(\n        resumableState,\n        renderState,\n        rootFormatContext,\n        progressiveChunkSize,\n        onError,\n        onAllReady,\n        onShellReady,\n        onShellError,\n        onFatalError,\n        onPostpone,\n        formState\n      );\n      renderState = createPendingSegment(\n        resumableState,\n        0,\n        null,\n        rootFormatContext,\n        !1,\n        !1\n      );\n      renderState.parentFlushed = !0;\n      children = createRenderTask(\n        resumableState,\n        null,\n        children,\n        -1,\n        null,\n        renderState,\n        null,\n        null,\n        resumableState.abortableTasks,\n        null,\n        rootFormatContext,\n        null,\n        emptyTreeContext,\n        null,\n        null,\n        emptyContextObject,\n        null\n      );\n      pushComponentStack(children);\n      resumableState.pingedTasks.push(children);\n      return resumableState;\n    }\n    function createPrerenderRequest(\n      children,\n      resumableState,\n      renderState,\n      rootFormatContext,\n      progressiveChunkSize,\n      onError,\n      onAllReady,\n      onShellReady,\n      onShellError,\n      onFatalError,\n      onPostpone\n    ) {\n      children = createRequest(\n        children,\n        resumableState,\n        renderState,\n        rootFormatContext,\n        progressiveChunkSize,\n        onError,\n        onAllReady,\n        onShellReady,\n        onShellError,\n        onFatalError,\n        onPostpone,\n        void 0\n      );\n      children.trackedPostpones = {\n        workingMap: new Map(),\n        rootNodes: [],\n        rootSlots: null\n      };\n      return children;\n    }\n    function resumeRequest(\n      children,\n      postponedState,\n      renderState,\n      onError,\n      onAllReady,\n      onShellReady,\n      onShellError,\n      onFatalError,\n      onPostpone\n    ) {\n      resetOwnerStackLimit();\n      renderState = new RequestInstance(\n        postponedState.resumableState,\n        renderState,\n        postponedState.rootFormatContext,\n        postponedState.progressiveChunkSize,\n        onError,\n        onAllReady,\n        onShellReady,\n        onShellError,\n        onFatalError,\n        onPostpone,\n        null\n      );\n      renderState.nextSegmentId = postponedState.nextSegmentId;\n      if (\"number\" === typeof postponedState.replaySlots)\n        return (\n          (onError = createPendingSegment(\n            renderState,\n            0,\n            null,\n            postponedState.rootFormatContext,\n            !1,\n            !1\n          )),\n          (onError.parentFlushed = !0),\n          (children = createRenderTask(\n            renderState,\n            null,\n            children,\n            -1,\n            null,\n            onError,\n            null,\n            null,\n            renderState.abortableTasks,\n            null,\n            postponedState.rootFormatContext,\n            null,\n            emptyTreeContext,\n            null,\n            null,\n            emptyContextObject,\n            null\n          )),\n          pushComponentStack(children),\n          renderState.pingedTasks.push(children),\n          renderState\n        );\n      children = createReplayTask(\n        renderState,\n        null,\n        {\n          nodes: postponedState.replayNodes,\n          slots: postponedState.replaySlots,\n          pendingTasks: 0\n        },\n        children,\n        -1,\n        null,\n        null,\n        renderState.abortableTasks,\n        null,\n        postponedState.rootFormatContext,\n        null,\n        emptyTreeContext,\n        null,\n        null,\n        emptyContextObject,\n        null\n      );\n      pushComponentStack(children);\n      renderState.pingedTasks.push(children);\n      return renderState;\n    }\n    function resumeAndPrerenderRequest(\n      children,\n      postponedState,\n      renderState,\n      onError,\n      onAllReady,\n      onShellReady,\n      onShellError,\n      onFatalError,\n      onPostpone\n    ) {\n      children = resumeRequest(\n        children,\n        postponedState,\n        renderState,\n        onError,\n        onAllReady,\n        onShellReady,\n        onShellError,\n        onFatalError,\n        onPostpone\n      );\n      children.trackedPostpones = {\n        workingMap: new Map(),\n        rootNodes: [],\n        rootSlots: null\n      };\n      return children;\n    }\n    function pingTask(request, task) {\n      request.pingedTasks.push(task);\n      1 === request.pingedTasks.length &&\n        ((request.flushScheduled = null !== request.destination),\n        null !== request.trackedPostpones || 10 === request.status\n          ? scheduleMicrotask(function () {\n              return performWork(request);\n            })\n          : scheduleWork(function () {\n              return performWork(request);\n            }));\n    }\n    function createSuspenseBoundary(\n      request,\n      row,\n      fallbackAbortableTasks,\n      contentPreamble,\n      fallbackPreamble\n    ) {\n      fallbackAbortableTasks = {\n        status: PENDING,\n        rootSegmentID: -1,\n        parentFlushed: !1,\n        pendingTasks: 0,\n        row: row,\n        completedSegments: [],\n        byteSize: 0,\n        fallbackAbortableTasks: fallbackAbortableTasks,\n        errorDigest: null,\n        contentState: createHoistableState(),\n        fallbackState: createHoistableState(),\n        contentPreamble: contentPreamble,\n        fallbackPreamble: fallbackPreamble,\n        trackedContentKeyPath: null,\n        trackedFallbackNode: null,\n        errorMessage: null,\n        errorStack: null,\n        errorComponentStack: null\n      };\n      null !== row &&\n        (row.pendingTasks++,\n        (contentPreamble = row.boundaries),\n        null !== contentPreamble &&\n          (request.allPendingTasks++,\n          fallbackAbortableTasks.pendingTasks++,\n          contentPreamble.push(fallbackAbortableTasks)),\n        (request = row.inheritedHoistables),\n        null !== request &&\n          hoistHoistables(fallbackAbortableTasks.contentState, request));\n      return fallbackAbortableTasks;\n    }\n    function createRenderTask(\n      request,\n      thenableState,\n      node,\n      childIndex,\n      blockedBoundary,\n      blockedSegment,\n      blockedPreamble,\n      hoistableState,\n      abortSet,\n      keyPath,\n      formatContext,\n      context,\n      treeContext,\n      row,\n      componentStack,\n      legacyContext,\n      debugTask\n    ) {\n      request.allPendingTasks++;\n      null === blockedBoundary\n        ? request.pendingRootTasks++\n        : blockedBoundary.pendingTasks++;\n      null !== row && row.pendingTasks++;\n      var task = {\n        replay: null,\n        node: node,\n        childIndex: childIndex,\n        ping: function () {\n          return pingTask(request, task);\n        },\n        blockedBoundary: blockedBoundary,\n        blockedSegment: blockedSegment,\n        blockedPreamble: blockedPreamble,\n        hoistableState: hoistableState,\n        abortSet: abortSet,\n        keyPath: keyPath,\n        formatContext: formatContext,\n        context: context,\n        treeContext: treeContext,\n        row: row,\n        componentStack: componentStack,\n        thenableState: thenableState\n      };\n      task.debugTask = debugTask;\n      abortSet.add(task);\n      return task;\n    }\n    function createReplayTask(\n      request,\n      thenableState,\n      replay,\n      node,\n      childIndex,\n      blockedBoundary,\n      hoistableState,\n      abortSet,\n      keyPath,\n      formatContext,\n      context,\n      treeContext,\n      row,\n      componentStack,\n      legacyContext,\n      debugTask\n    ) {\n      request.allPendingTasks++;\n      null === blockedBoundary\n        ? request.pendingRootTasks++\n        : blockedBoundary.pendingTasks++;\n      null !== row && row.pendingTasks++;\n      replay.pendingTasks++;\n      var task = {\n        replay: replay,\n        node: node,\n        childIndex: childIndex,\n        ping: function () {\n          return pingTask(request, task);\n        },\n        blockedBoundary: blockedBoundary,\n        blockedSegment: null,\n        blockedPreamble: null,\n        hoistableState: hoistableState,\n        abortSet: abortSet,\n        keyPath: keyPath,\n        formatContext: formatContext,\n        context: context,\n        treeContext: treeContext,\n        row: row,\n        componentStack: componentStack,\n        thenableState: thenableState\n      };\n      task.debugTask = debugTask;\n      abortSet.add(task);\n      return task;\n    }\n    function createPendingSegment(\n      request,\n      index,\n      boundary,\n      parentFormatContext,\n      lastPushedText,\n      textEmbedded\n    ) {\n      return {\n        status: PENDING,\n        parentFlushed: !1,\n        id: -1,\n        index: index,\n        chunks: [],\n        children: [],\n        preambleChildren: [],\n        parentFormatContext: parentFormatContext,\n        boundary: boundary,\n        lastPushedText: lastPushedText,\n        textEmbedded: textEmbedded\n      };\n    }\n    function getCurrentStackInDEV() {\n      if (null === currentTaskInDEV || null === currentTaskInDEV.componentStack)\n        return \"\";\n      var componentStack = currentTaskInDEV.componentStack;\n      try {\n        var info = \"\";\n        if (\"string\" === typeof componentStack.type)\n          info += describeBuiltInComponentFrame(componentStack.type);\n        else if (\"function\" === typeof componentStack.type) {\n          if (!componentStack.owner) {\n            var JSCompiler_temp_const = info,\n              fn = componentStack.type,\n              name = fn ? fn.displayName || fn.name : \"\";\n            var JSCompiler_inline_result = name\n              ? describeBuiltInComponentFrame(name)\n              : \"\";\n            info = JSCompiler_temp_const + JSCompiler_inline_result;\n          }\n        } else\n          componentStack.owner ||\n            (info += describeComponentStackByType(componentStack.type));\n        for (; componentStack; )\n          (JSCompiler_temp_const = null),\n            null != componentStack.debugStack\n              ? (JSCompiler_temp_const = formatOwnerStack(\n                  componentStack.debugStack\n                ))\n              : ((JSCompiler_inline_result = componentStack),\n                null != JSCompiler_inline_result.stack &&\n                  (JSCompiler_temp_const =\n                    \"string\" !== typeof JSCompiler_inline_result.stack\n                      ? (JSCompiler_inline_result.stack = formatOwnerStack(\n                          JSCompiler_inline_result.stack\n                        ))\n                      : JSCompiler_inline_result.stack)),\n            (componentStack = componentStack.owner) &&\n              JSCompiler_temp_const &&\n              (info += \"\\n\" + JSCompiler_temp_const);\n        var JSCompiler_inline_result$jscomp$0 = info;\n      } catch (x) {\n        JSCompiler_inline_result$jscomp$0 =\n          \"\\nError generating stack: \" + x.message + \"\\n\" + x.stack;\n      }\n      return JSCompiler_inline_result$jscomp$0;\n    }\n    function pushHaltedAwaitOnComponentStack(task, debugInfo) {\n      if (null != debugInfo)\n        for (var i = debugInfo.length - 1; 0 <= i; i--) {\n          var info = debugInfo[i];\n          if (\"string\" === typeof info.name) break;\n          if (\"number\" === typeof info.time) break;\n          if (null != info.awaited) {\n            var bestStack = null == info.debugStack ? info.awaited : info;\n            if (void 0 !== bestStack.debugStack) {\n              task.componentStack = {\n                parent: task.componentStack,\n                type: info,\n                owner: bestStack.owner,\n                stack: bestStack.debugStack\n              };\n              task.debugTask = bestStack.debugTask;\n              break;\n            }\n          }\n        }\n    }\n    function pushServerComponentStack(task, debugInfo) {\n      if (null != debugInfo)\n        for (var i = 0; i < debugInfo.length; i++) {\n          var componentInfo = debugInfo[i];\n          \"string\" === typeof componentInfo.name &&\n            void 0 !== componentInfo.debugStack &&\n            ((task.componentStack = {\n              parent: task.componentStack,\n              type: componentInfo,\n              owner: componentInfo.owner,\n              stack: componentInfo.debugStack\n            }),\n            (task.debugTask = componentInfo.debugTask));\n        }\n    }\n    function pushComponentStack(task) {\n      var node = task.node;\n      if (\"object\" === typeof node && null !== node)\n        switch (node.$$typeof) {\n          case REACT_ELEMENT_TYPE:\n            var type = node.type,\n              owner = node._owner,\n              stack = node._debugStack;\n            pushServerComponentStack(task, node._debugInfo);\n            task.debugTask = node._debugTask;\n            task.componentStack = {\n              parent: task.componentStack,\n              type: type,\n              owner: owner,\n              stack: stack\n            };\n            break;\n          case REACT_LAZY_TYPE:\n            pushServerComponentStack(task, node._debugInfo);\n            break;\n          default:\n            \"function\" === typeof node.then &&\n              pushServerComponentStack(task, node._debugInfo);\n        }\n    }\n    function replaceSuspenseComponentStackWithSuspenseFallbackStack(\n      componentStack\n    ) {\n      return null === componentStack\n        ? null\n        : {\n            parent: componentStack.parent,\n            type: \"Suspense Fallback\",\n            owner: componentStack.owner,\n            stack: componentStack.stack\n          };\n    }\n    function getThrownInfo(node$jscomp$0) {\n      var errorInfo = {};\n      node$jscomp$0 &&\n        Object.defineProperty(errorInfo, \"componentStack\", {\n          configurable: !0,\n          enumerable: !0,\n          get: function () {\n            try {\n              var info = \"\",\n                node = node$jscomp$0;\n              do\n                (info += describeComponentStackByType(node.type)),\n                  (node = node.parent);\n              while (node);\n              var stack = info;\n            } catch (x) {\n              stack = \"\\nError generating stack: \" + x.message + \"\\n\" + x.stack;\n            }\n            Object.defineProperty(errorInfo, \"componentStack\", {\n              value: stack\n            });\n            return stack;\n          }\n        });\n      return errorInfo;\n    }\n    function encodeErrorForBoundary(\n      boundary,\n      digest,\n      error,\n      thrownInfo,\n      wasAborted\n    ) {\n      boundary.errorDigest = digest;\n      error instanceof Error\n        ? ((digest = String(error.message)), (error = String(error.stack)))\n        : ((digest =\n            \"object\" === typeof error && null !== error\n              ? describeObjectForErrorMessage(error)\n              : String(error)),\n          (error = null));\n      wasAborted = wasAborted\n        ? \"Switched to client rendering because the server rendering aborted due to:\\n\\n\"\n        : \"Switched to client rendering because the server rendering errored:\\n\\n\";\n      boundary.errorMessage = wasAborted + digest;\n      boundary.errorStack = null !== error ? wasAborted + error : null;\n      boundary.errorComponentStack = thrownInfo.componentStack;\n    }\n    function logRecoverableError(request, error, errorInfo, debugTask) {\n      request = request.onError;\n      error = debugTask\n        ? debugTask.run(request.bind(null, error, errorInfo))\n        : request(error, errorInfo);\n      if (null != error && \"string\" !== typeof error)\n        console.error(\n          'onError returned something with a type other than \"string\". onError should return a string and may return null or undefined but must not return anything else. It received something of type \"%s\" instead',\n          typeof error\n        );\n      else return error;\n    }\n    function fatalError(request, error, errorInfo, debugTask) {\n      errorInfo = request.onShellError;\n      var onFatalError = request.onFatalError;\n      debugTask\n        ? (debugTask.run(errorInfo.bind(null, error)),\n          debugTask.run(onFatalError.bind(null, error)))\n        : (errorInfo(error), onFatalError(error));\n      null !== request.destination\n        ? ((request.status = CLOSED),\n          closeWithError(request.destination, error))\n        : ((request.status = 13), (request.fatalError = error));\n    }\n    function finishSuspenseListRow(request, row) {\n      unblockSuspenseListRow(request, row.next, row.hoistables);\n    }\n    function unblockSuspenseListRow(\n      request,\n      unblockedRow,\n      inheritedHoistables\n    ) {\n      for (; null !== unblockedRow; ) {\n        null !== inheritedHoistables &&\n          (hoistHoistables(unblockedRow.hoistables, inheritedHoistables),\n          (unblockedRow.inheritedHoistables = inheritedHoistables));\n        var unblockedBoundaries = unblockedRow.boundaries;\n        if (null !== unblockedBoundaries) {\n          unblockedRow.boundaries = null;\n          for (var i = 0; i < unblockedBoundaries.length; i++) {\n            var unblockedBoundary = unblockedBoundaries[i];\n            null !== inheritedHoistables &&\n              hoistHoistables(\n                unblockedBoundary.contentState,\n                inheritedHoistables\n              );\n            finishedTask(request, unblockedBoundary, null, null);\n          }\n        }\n        unblockedRow.pendingTasks--;\n        if (0 < unblockedRow.pendingTasks) break;\n        inheritedHoistables = unblockedRow.hoistables;\n        unblockedRow = unblockedRow.next;\n      }\n    }\n    function tryToResolveTogetherRow(request, togetherRow) {\n      var boundaries = togetherRow.boundaries;\n      if (\n        null !== boundaries &&\n        togetherRow.pendingTasks === boundaries.length\n      ) {\n        for (\n          var allCompleteAndInlinable = !0, i = 0;\n          i < boundaries.length;\n          i++\n        ) {\n          var rowBoundary = boundaries[i];\n          if (\n            1 !== rowBoundary.pendingTasks ||\n            rowBoundary.parentFlushed ||\n            isEligibleForOutlining(request, rowBoundary)\n          ) {\n            allCompleteAndInlinable = !1;\n            break;\n          }\n        }\n        allCompleteAndInlinable &&\n          unblockSuspenseListRow(request, togetherRow, togetherRow.hoistables);\n      }\n    }\n    function createSuspenseListRow(previousRow) {\n      var newRow = {\n        pendingTasks: 1,\n        boundaries: null,\n        hoistables: createHoistableState(),\n        inheritedHoistables: null,\n        together: !1,\n        next: null\n      };\n      null !== previousRow &&\n        0 < previousRow.pendingTasks &&\n        (newRow.pendingTasks++,\n        (newRow.boundaries = []),\n        (previousRow.next = newRow));\n      return newRow;\n    }\n    function renderSuspenseListRows(request, task, keyPath, rows, revealOrder) {\n      var prevKeyPath = task.keyPath,\n        prevTreeContext = task.treeContext,\n        prevRow = task.row,\n        previousComponentStack = task.componentStack;\n      var previousDebugTask = task.debugTask;\n      pushServerComponentStack(task, task.node.props.children._debugInfo);\n      task.keyPath = keyPath;\n      keyPath = rows.length;\n      var previousSuspenseListRow = null;\n      if (null !== task.replay) {\n        var resumeSlots = task.replay.slots;\n        if (null !== resumeSlots && \"object\" === typeof resumeSlots)\n          for (var n = 0; n < keyPath; n++) {\n            var i =\n                \"backwards\" !== revealOrder &&\n                \"unstable_legacy-backwards\" !== revealOrder\n                  ? n\n                  : keyPath - 1 - n,\n              node = rows[i];\n            task.row = previousSuspenseListRow = createSuspenseListRow(\n              previousSuspenseListRow\n            );\n            task.treeContext = pushTreeContext(prevTreeContext, keyPath, i);\n            var resumeSegmentID = resumeSlots[i];\n            \"number\" === typeof resumeSegmentID\n              ? (resumeNode(request, task, resumeSegmentID, node, i),\n                delete resumeSlots[i])\n              : renderNode(request, task, node, i);\n            0 === --previousSuspenseListRow.pendingTasks &&\n              finishSuspenseListRow(request, previousSuspenseListRow);\n          }\n        else\n          for (resumeSlots = 0; resumeSlots < keyPath; resumeSlots++)\n            (n =\n              \"backwards\" !== revealOrder &&\n              \"unstable_legacy-backwards\" !== revealOrder\n                ? resumeSlots\n                : keyPath - 1 - resumeSlots),\n              (i = rows[n]),\n              warnForMissingKey(request, task, i),\n              (task.row = previousSuspenseListRow =\n                createSuspenseListRow(previousSuspenseListRow)),\n              (task.treeContext = pushTreeContext(prevTreeContext, keyPath, n)),\n              renderNode(request, task, i, n),\n              0 === --previousSuspenseListRow.pendingTasks &&\n                finishSuspenseListRow(request, previousSuspenseListRow);\n      } else if (\n        \"backwards\" !== revealOrder &&\n        \"unstable_legacy-backwards\" !== revealOrder\n      )\n        for (revealOrder = 0; revealOrder < keyPath; revealOrder++)\n          (resumeSlots = rows[revealOrder]),\n            warnForMissingKey(request, task, resumeSlots),\n            (task.row = previousSuspenseListRow =\n              createSuspenseListRow(previousSuspenseListRow)),\n            (task.treeContext = pushTreeContext(\n              prevTreeContext,\n              keyPath,\n              revealOrder\n            )),\n            renderNode(request, task, resumeSlots, revealOrder),\n            0 === --previousSuspenseListRow.pendingTasks &&\n              finishSuspenseListRow(request, previousSuspenseListRow);\n      else {\n        revealOrder = task.blockedSegment;\n        resumeSlots = revealOrder.children.length;\n        n = revealOrder.chunks.length;\n        for (i = keyPath - 1; 0 <= i; i--) {\n          node = rows[i];\n          task.row = previousSuspenseListRow = createSuspenseListRow(\n            previousSuspenseListRow\n          );\n          task.treeContext = pushTreeContext(prevTreeContext, keyPath, i);\n          resumeSegmentID = createPendingSegment(\n            request,\n            n,\n            null,\n            task.formatContext,\n            0 === i ? revealOrder.lastPushedText : !0,\n            !0\n          );\n          revealOrder.children.splice(resumeSlots, 0, resumeSegmentID);\n          task.blockedSegment = resumeSegmentID;\n          warnForMissingKey(request, task, node);\n          try {\n            renderNode(request, task, node, i),\n              resumeSegmentID.lastPushedText &&\n                resumeSegmentID.textEmbedded &&\n                resumeSegmentID.chunks.push(textSeparator),\n              (resumeSegmentID.status = COMPLETED),\n              finishedSegment(request, task.blockedBoundary, resumeSegmentID),\n              0 === --previousSuspenseListRow.pendingTasks &&\n                finishSuspenseListRow(request, previousSuspenseListRow);\n          } catch (thrownValue) {\n            throw (\n              ((resumeSegmentID.status =\n                12 === request.status ? ABORTED : ERRORED),\n              thrownValue)\n            );\n          }\n        }\n        task.blockedSegment = revealOrder;\n        revealOrder.lastPushedText = !1;\n      }\n      null !== prevRow &&\n        null !== previousSuspenseListRow &&\n        0 < previousSuspenseListRow.pendingTasks &&\n        (prevRow.pendingTasks++, (previousSuspenseListRow.next = prevRow));\n      task.treeContext = prevTreeContext;\n      task.row = prevRow;\n      task.keyPath = prevKeyPath;\n      task.componentStack = previousComponentStack;\n      task.debugTask = previousDebugTask;\n    }\n    function renderWithHooks(\n      request,\n      task,\n      keyPath,\n      Component,\n      props,\n      secondArg\n    ) {\n      var prevThenableState = task.thenableState;\n      task.thenableState = null;\n      currentlyRenderingComponent = {};\n      currentlyRenderingTask = task;\n      currentlyRenderingRequest = request;\n      currentlyRenderingKeyPath = keyPath;\n      isInHookUserCodeInDev = !1;\n      actionStateCounter = localIdCounter = 0;\n      actionStateMatchingIndex = -1;\n      thenableIndexCounter = 0;\n      thenableState = prevThenableState;\n      for (\n        request = callComponentInDEV(Component, props, secondArg);\n        didScheduleRenderPhaseUpdate;\n\n      )\n        (didScheduleRenderPhaseUpdate = !1),\n          (actionStateCounter = localIdCounter = 0),\n          (actionStateMatchingIndex = -1),\n          (thenableIndexCounter = 0),\n          (numberOfReRenders += 1),\n          (workInProgressHook = null),\n          (request = Component(props, secondArg));\n      resetHooksState();\n      return request;\n    }\n    function finishFunctionComponent(\n      request,\n      task,\n      keyPath,\n      children,\n      hasId,\n      actionStateCount,\n      actionStateMatchingIndex\n    ) {\n      var didEmitActionStateMarkers = !1;\n      if (0 !== actionStateCount && null !== request.formState) {\n        var segment = task.blockedSegment;\n        if (null !== segment) {\n          didEmitActionStateMarkers = !0;\n          segment = segment.chunks;\n          for (var i = 0; i < actionStateCount; i++)\n            i === actionStateMatchingIndex\n              ? segment.push(formStateMarkerIsMatching)\n              : segment.push(formStateMarkerIsNotMatching);\n        }\n      }\n      actionStateCount = task.keyPath;\n      task.keyPath = keyPath;\n      hasId\n        ? ((keyPath = task.treeContext),\n          (task.treeContext = pushTreeContext(keyPath, 1, 0)),\n          renderNode(request, task, children, -1),\n          (task.treeContext = keyPath))\n        : didEmitActionStateMarkers\n          ? renderNode(request, task, children, -1)\n          : renderNodeDestructive(request, task, children, -1);\n      task.keyPath = actionStateCount;\n    }\n    function renderElement(request, task, keyPath, type, props, ref) {\n      if (\"function\" === typeof type)\n        if (type.prototype && type.prototype.isReactComponent) {\n          var newProps = props;\n          if (\"ref\" in props) {\n            newProps = {};\n            for (var propName in props)\n              \"ref\" !== propName && (newProps[propName] = props[propName]);\n          }\n          var defaultProps = type.defaultProps;\n          if (defaultProps) {\n            newProps === props && (newProps = assign({}, newProps, props));\n            for (var _propName in defaultProps)\n              void 0 === newProps[_propName] &&\n                (newProps[_propName] = defaultProps[_propName]);\n          }\n          var resolvedProps = newProps;\n          var context = emptyContextObject,\n            contextType = type.contextType;\n          if (\n            \"contextType\" in type &&\n            null !== contextType &&\n            (void 0 === contextType ||\n              contextType.$$typeof !== REACT_CONTEXT_TYPE) &&\n            !didWarnAboutInvalidateContextType.has(type)\n          ) {\n            didWarnAboutInvalidateContextType.add(type);\n            var addendum =\n              void 0 === contextType\n                ? \" However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.\"\n                : \"object\" !== typeof contextType\n                  ? \" However, it is set to a \" + typeof contextType + \".\"\n                  : contextType.$$typeof === REACT_CONSUMER_TYPE\n                    ? \" Did you accidentally pass the Context.Consumer instead?\"\n                    : \" However, it is set to an object with keys {\" +\n                      Object.keys(contextType).join(\", \") +\n                      \"}.\";\n            console.error(\n              \"%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s\",\n              getComponentNameFromType(type) || \"Component\",\n              addendum\n            );\n          }\n          \"object\" === typeof contextType &&\n            null !== contextType &&\n            (context = contextType._currentValue);\n          var instance = new type(resolvedProps, context);\n          if (\n            \"function\" === typeof type.getDerivedStateFromProps &&\n            (null === instance.state || void 0 === instance.state)\n          ) {\n            var componentName = getComponentNameFromType(type) || \"Component\";\n            didWarnAboutUninitializedState.has(componentName) ||\n              (didWarnAboutUninitializedState.add(componentName),\n              console.error(\n                \"`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.\",\n                componentName,\n                null === instance.state ? \"null\" : \"undefined\",\n                componentName\n              ));\n          }\n          if (\n            \"function\" === typeof type.getDerivedStateFromProps ||\n            \"function\" === typeof instance.getSnapshotBeforeUpdate\n          ) {\n            var foundWillMountName = null,\n              foundWillReceivePropsName = null,\n              foundWillUpdateName = null;\n            \"function\" === typeof instance.componentWillMount &&\n            !0 !== instance.componentWillMount.__suppressDeprecationWarning\n              ? (foundWillMountName = \"componentWillMount\")\n              : \"function\" === typeof instance.UNSAFE_componentWillMount &&\n                (foundWillMountName = \"UNSAFE_componentWillMount\");\n            \"function\" === typeof instance.componentWillReceiveProps &&\n            !0 !==\n              instance.componentWillReceiveProps.__suppressDeprecationWarning\n              ? (foundWillReceivePropsName = \"componentWillReceiveProps\")\n              : \"function\" ===\n                  typeof instance.UNSAFE_componentWillReceiveProps &&\n                (foundWillReceivePropsName =\n                  \"UNSAFE_componentWillReceiveProps\");\n            \"function\" === typeof instance.componentWillUpdate &&\n            !0 !== instance.componentWillUpdate.__suppressDeprecationWarning\n              ? (foundWillUpdateName = \"componentWillUpdate\")\n              : \"function\" === typeof instance.UNSAFE_componentWillUpdate &&\n                (foundWillUpdateName = \"UNSAFE_componentWillUpdate\");\n            if (\n              null !== foundWillMountName ||\n              null !== foundWillReceivePropsName ||\n              null !== foundWillUpdateName\n            ) {\n              var _componentName =\n                  getComponentNameFromType(type) || \"Component\",\n                newApiName =\n                  \"function\" === typeof type.getDerivedStateFromProps\n                    ? \"getDerivedStateFromProps()\"\n                    : \"getSnapshotBeforeUpdate()\";\n              didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName) ||\n                (didWarnAboutLegacyLifecyclesAndDerivedState.add(\n                  _componentName\n                ),\n                console.error(\n                  \"Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\nThe above lifecycles should be removed. Learn more about this warning here:\\nhttps://react.dev/link/unsafe-component-lifecycles\",\n                  _componentName,\n                  newApiName,\n                  null !== foundWillMountName\n                    ? \"\\n  \" + foundWillMountName\n                    : \"\",\n                  null !== foundWillReceivePropsName\n                    ? \"\\n  \" + foundWillReceivePropsName\n                    : \"\",\n                  null !== foundWillUpdateName\n                    ? \"\\n  \" + foundWillUpdateName\n                    : \"\"\n                ));\n            }\n          }\n          var name = getComponentNameFromType(type) || \"Component\";\n          instance.render ||\n            (type.prototype && \"function\" === typeof type.prototype.render\n              ? console.error(\n                  \"No `render` method found on the %s instance: did you accidentally return an object from the constructor?\",\n                  name\n                )\n              : console.error(\n                  \"No `render` method found on the %s instance: you may have forgotten to define `render`.\",\n                  name\n                ));\n          !instance.getInitialState ||\n            instance.getInitialState.isReactClassApproved ||\n            instance.state ||\n            console.error(\n              \"getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?\",\n              name\n            );\n          instance.getDefaultProps &&\n            !instance.getDefaultProps.isReactClassApproved &&\n            console.error(\n              \"getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.\",\n              name\n            );\n          instance.contextType &&\n            console.error(\n              \"contextType was defined as an instance property on %s. Use a static property to define contextType instead.\",\n              name\n            );\n          type.childContextTypes &&\n            !didWarnAboutChildContextTypes.has(type) &&\n            (didWarnAboutChildContextTypes.add(type),\n            console.error(\n              \"%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)\",\n              name\n            ));\n          type.contextTypes &&\n            !didWarnAboutContextTypes$1.has(type) &&\n            (didWarnAboutContextTypes$1.add(type),\n            console.error(\n              \"%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)\",\n              name\n            ));\n          \"function\" === typeof instance.componentShouldUpdate &&\n            console.error(\n              \"%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.\",\n              name\n            );\n          type.prototype &&\n            type.prototype.isPureReactComponent &&\n            \"undefined\" !== typeof instance.shouldComponentUpdate &&\n            console.error(\n              \"%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.\",\n              getComponentNameFromType(type) || \"A pure component\"\n            );\n          \"function\" === typeof instance.componentDidUnmount &&\n            console.error(\n              \"%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?\",\n              name\n            );\n          \"function\" === typeof instance.componentDidReceiveProps &&\n            console.error(\n              \"%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().\",\n              name\n            );\n          \"function\" === typeof instance.componentWillRecieveProps &&\n            console.error(\n              \"%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?\",\n              name\n            );\n          \"function\" === typeof instance.UNSAFE_componentWillRecieveProps &&\n            console.error(\n              \"%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?\",\n              name\n            );\n          var hasMutatedProps = instance.props !== resolvedProps;\n          void 0 !== instance.props &&\n            hasMutatedProps &&\n            console.error(\n              \"When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.\",\n              name\n            );\n          instance.defaultProps &&\n            console.error(\n              \"Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.\",\n              name,\n              name\n            );\n          \"function\" !== typeof instance.getSnapshotBeforeUpdate ||\n            \"function\" === typeof instance.componentDidUpdate ||\n            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(type) ||\n            (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(type),\n            console.error(\n              \"%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.\",\n              getComponentNameFromType(type)\n            ));\n          \"function\" === typeof instance.getDerivedStateFromProps &&\n            console.error(\n              \"%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.\",\n              name\n            );\n          \"function\" === typeof instance.getDerivedStateFromError &&\n            console.error(\n              \"%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.\",\n              name\n            );\n          \"function\" === typeof type.getSnapshotBeforeUpdate &&\n            console.error(\n              \"%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.\",\n              name\n            );\n          var state = instance.state;\n          state &&\n            (\"object\" !== typeof state || isArrayImpl(state)) &&\n            console.error(\"%s.state: must be set to an object or null\", name);\n          \"function\" === typeof instance.getChildContext &&\n            \"object\" !== typeof type.childContextTypes &&\n            console.error(\n              \"%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().\",\n              name\n            );\n          var initialState = void 0 !== instance.state ? instance.state : null;\n          instance.updater = classComponentUpdater;\n          instance.props = resolvedProps;\n          instance.state = initialState;\n          var internalInstance = { queue: [], replace: !1 };\n          instance._reactInternals = internalInstance;\n          var contextType$jscomp$0 = type.contextType;\n          instance.context =\n            \"object\" === typeof contextType$jscomp$0 &&\n            null !== contextType$jscomp$0\n              ? contextType$jscomp$0._currentValue\n              : emptyContextObject;\n          if (instance.state === resolvedProps) {\n            var componentName$jscomp$0 =\n              getComponentNameFromType(type) || \"Component\";\n            didWarnAboutDirectlyAssigningPropsToState.has(\n              componentName$jscomp$0\n            ) ||\n              (didWarnAboutDirectlyAssigningPropsToState.add(\n                componentName$jscomp$0\n              ),\n              console.error(\n                \"%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.\",\n                componentName$jscomp$0\n              ));\n          }\n          var getDerivedStateFromProps = type.getDerivedStateFromProps;\n          if (\"function\" === typeof getDerivedStateFromProps) {\n            var partialState = getDerivedStateFromProps(\n              resolvedProps,\n              initialState\n            );\n            if (void 0 === partialState) {\n              var componentName$jscomp$1 =\n                getComponentNameFromType(type) || \"Component\";\n              didWarnAboutUndefinedDerivedState.has(componentName$jscomp$1) ||\n                (didWarnAboutUndefinedDerivedState.add(componentName$jscomp$1),\n                console.error(\n                  \"%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.\",\n                  componentName$jscomp$1\n                ));\n            }\n            var JSCompiler_inline_result =\n              null === partialState || void 0 === partialState\n                ? initialState\n                : assign({}, initialState, partialState);\n            instance.state = JSCompiler_inline_result;\n          }\n          if (\n            \"function\" !== typeof type.getDerivedStateFromProps &&\n            \"function\" !== typeof instance.getSnapshotBeforeUpdate &&\n            (\"function\" === typeof instance.UNSAFE_componentWillMount ||\n              \"function\" === typeof instance.componentWillMount)\n          ) {\n            var oldState = instance.state;\n            if (\"function\" === typeof instance.componentWillMount) {\n              if (\n                !0 !== instance.componentWillMount.__suppressDeprecationWarning\n              ) {\n                var componentName$jscomp$2 =\n                  getComponentNameFromType(type) || \"Unknown\";\n                didWarnAboutDeprecatedWillMount[componentName$jscomp$2] ||\n                  (console.warn(\n                    \"componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.\\n\\nPlease update the following components: %s\",\n                    componentName$jscomp$2\n                  ),\n                  (didWarnAboutDeprecatedWillMount[componentName$jscomp$2] =\n                    !0));\n              }\n              instance.componentWillMount();\n            }\n            \"function\" === typeof instance.UNSAFE_componentWillMount &&\n              instance.UNSAFE_componentWillMount();\n            oldState !== instance.state &&\n              (console.error(\n                \"%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.\",\n                getComponentNameFromType(type) || \"Component\"\n              ),\n              classComponentUpdater.enqueueReplaceState(\n                instance,\n                instance.state,\n                null\n              ));\n            if (\n              null !== internalInstance.queue &&\n              0 < internalInstance.queue.length\n            ) {\n              var oldQueue = internalInstance.queue,\n                oldReplace = internalInstance.replace;\n              internalInstance.queue = null;\n              internalInstance.replace = !1;\n              if (oldReplace && 1 === oldQueue.length)\n                instance.state = oldQueue[0];\n              else {\n                for (\n                  var nextState = oldReplace ? oldQueue[0] : instance.state,\n                    dontMutate = !0,\n                    i = oldReplace ? 1 : 0;\n                  i < oldQueue.length;\n                  i++\n                ) {\n                  var partial = oldQueue[i],\n                    partialState$jscomp$0 =\n                      \"function\" === typeof partial\n                        ? partial.call(\n                            instance,\n                            nextState,\n                            resolvedProps,\n                            void 0\n                          )\n                        : partial;\n                  null != partialState$jscomp$0 &&\n                    (dontMutate\n                      ? ((dontMutate = !1),\n                        (nextState = assign(\n                          {},\n                          nextState,\n                          partialState$jscomp$0\n                        )))\n                      : assign(nextState, partialState$jscomp$0));\n                }\n                instance.state = nextState;\n              }\n            } else internalInstance.queue = null;\n          }\n          var nextChildren = callRenderInDEV(instance);\n          if (12 === request.status) throw null;\n          instance.props !== resolvedProps &&\n            (didWarnAboutReassigningProps ||\n              console.error(\n                \"It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.\",\n                getComponentNameFromType(type) || \"a component\"\n              ),\n            (didWarnAboutReassigningProps = !0));\n          var prevKeyPath = task.keyPath;\n          task.keyPath = keyPath;\n          renderNodeDestructive(request, task, nextChildren, -1);\n          task.keyPath = prevKeyPath;\n        } else {\n          if (type.prototype && \"function\" === typeof type.prototype.render) {\n            var componentName$jscomp$3 =\n              getComponentNameFromType(type) || \"Unknown\";\n            didWarnAboutBadClass[componentName$jscomp$3] ||\n              (console.error(\n                \"The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.\",\n                componentName$jscomp$3,\n                componentName$jscomp$3\n              ),\n              (didWarnAboutBadClass[componentName$jscomp$3] = !0));\n          }\n          var value = renderWithHooks(\n            request,\n            task,\n            keyPath,\n            type,\n            props,\n            void 0\n          );\n          if (12 === request.status) throw null;\n          var hasId = 0 !== localIdCounter,\n            actionStateCount = actionStateCounter,\n            actionStateMatchingIndex$jscomp$0 = actionStateMatchingIndex;\n          if (type.contextTypes) {\n            var _componentName$jscomp$0 =\n              getComponentNameFromType(type) || \"Unknown\";\n            didWarnAboutContextTypes[_componentName$jscomp$0] ||\n              ((didWarnAboutContextTypes[_componentName$jscomp$0] = !0),\n              console.error(\n                \"%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)\",\n                _componentName$jscomp$0\n              ));\n          }\n          type &&\n            type.childContextTypes &&\n            console.error(\n              \"childContextTypes cannot be defined on a function component.\\n  %s.childContextTypes = ...\",\n              type.displayName || type.name || \"Component\"\n            );\n          if (\"function\" === typeof type.getDerivedStateFromProps) {\n            var componentName$jscomp$4 =\n              getComponentNameFromType(type) || \"Unknown\";\n            didWarnAboutGetDerivedStateOnFunctionComponent[\n              componentName$jscomp$4\n            ] ||\n              (console.error(\n                \"%s: Function components do not support getDerivedStateFromProps.\",\n                componentName$jscomp$4\n              ),\n              (didWarnAboutGetDerivedStateOnFunctionComponent[\n                componentName$jscomp$4\n              ] = !0));\n          }\n          if (\n            \"object\" === typeof type.contextType &&\n            null !== type.contextType\n          ) {\n            var _componentName2 = getComponentNameFromType(type) || \"Unknown\";\n            didWarnAboutContextTypeOnFunctionComponent[_componentName2] ||\n              (console.error(\n                \"%s: Function components do not support contextType.\",\n                _componentName2\n              ),\n              (didWarnAboutContextTypeOnFunctionComponent[_componentName2] =\n                !0));\n          }\n          finishFunctionComponent(\n            request,\n            task,\n            keyPath,\n            value,\n            hasId,\n            actionStateCount,\n            actionStateMatchingIndex$jscomp$0\n          );\n        }\n      else if (\"string\" === typeof type) {\n        var segment = task.blockedSegment;\n        if (null === segment) {\n          var children = props.children,\n            prevContext = task.formatContext,\n            prevKeyPath$jscomp$0 = task.keyPath;\n          task.formatContext = getChildFormatContext(prevContext, type, props);\n          task.keyPath = keyPath;\n          renderNode(request, task, children, -1);\n          task.formatContext = prevContext;\n          task.keyPath = prevKeyPath$jscomp$0;\n        } else {\n          var _children = pushStartInstance(\n            segment.chunks,\n            type,\n            props,\n            request.resumableState,\n            request.renderState,\n            task.blockedPreamble,\n            task.hoistableState,\n            task.formatContext,\n            segment.lastPushedText\n          );\n          segment.lastPushedText = !1;\n          var _prevContext2 = task.formatContext,\n            _prevKeyPath3 = task.keyPath;\n          task.keyPath = keyPath;\n          if (\n            (task.formatContext = getChildFormatContext(\n              _prevContext2,\n              type,\n              props\n            )).insertionMode === HTML_HEAD_MODE\n          ) {\n            var preambleSegment = createPendingSegment(\n              request,\n              0,\n              null,\n              task.formatContext,\n              !1,\n              !1\n            );\n            segment.preambleChildren.push(preambleSegment);\n            task.blockedSegment = preambleSegment;\n            try {\n              (preambleSegment.status = 6),\n                renderNode(request, task, _children, -1),\n                preambleSegment.lastPushedText &&\n                  preambleSegment.textEmbedded &&\n                  preambleSegment.chunks.push(textSeparator),\n                (preambleSegment.status = COMPLETED),\n                finishedSegment(request, task.blockedBoundary, preambleSegment);\n            } finally {\n              task.blockedSegment = segment;\n            }\n          } else renderNode(request, task, _children, -1);\n          task.formatContext = _prevContext2;\n          task.keyPath = _prevKeyPath3;\n          a: {\n            var target = segment.chunks,\n              resumableState = request.resumableState;\n            switch (type) {\n              case \"title\":\n              case \"style\":\n              case \"script\":\n              case \"area\":\n              case \"base\":\n              case \"br\":\n              case \"col\":\n              case \"embed\":\n              case \"hr\":\n              case \"img\":\n              case \"input\":\n              case \"keygen\":\n              case \"link\":\n              case \"meta\":\n              case \"param\":\n              case \"source\":\n              case \"track\":\n              case \"wbr\":\n                break a;\n              case \"body\":\n                if (_prevContext2.insertionMode <= HTML_HTML_MODE) {\n                  resumableState.hasBody = !0;\n                  break a;\n                }\n                break;\n              case \"html\":\n                if (_prevContext2.insertionMode === ROOT_HTML_MODE) {\n                  resumableState.hasHtml = !0;\n                  break a;\n                }\n                break;\n              case \"head\":\n                if (_prevContext2.insertionMode <= HTML_HTML_MODE) break a;\n            }\n            target.push(endChunkForTag(type));\n          }\n          segment.lastPushedText = !1;\n        }\n      } else {\n        switch (type) {\n          case REACT_LEGACY_HIDDEN_TYPE:\n          case REACT_STRICT_MODE_TYPE:\n          case REACT_PROFILER_TYPE:\n          case REACT_FRAGMENT_TYPE:\n            var prevKeyPath$jscomp$1 = task.keyPath;\n            task.keyPath = keyPath;\n            renderNodeDestructive(request, task, props.children, -1);\n            task.keyPath = prevKeyPath$jscomp$1;\n            return;\n          case REACT_ACTIVITY_TYPE:\n            var segment$jscomp$0 = task.blockedSegment;\n            if (null === segment$jscomp$0) {\n              if (\"hidden\" !== props.mode) {\n                var prevKeyPath$jscomp$2 = task.keyPath;\n                task.keyPath = keyPath;\n                renderNode(request, task, props.children, -1);\n                task.keyPath = prevKeyPath$jscomp$2;\n              }\n            } else if (\"hidden\" !== props.mode) {\n              segment$jscomp$0.chunks.push(startActivityBoundary);\n              segment$jscomp$0.lastPushedText = !1;\n              var _prevKeyPath4 = task.keyPath;\n              task.keyPath = keyPath;\n              renderNode(request, task, props.children, -1);\n              task.keyPath = _prevKeyPath4;\n              segment$jscomp$0.chunks.push(endActivityBoundary);\n              segment$jscomp$0.lastPushedText = !1;\n            }\n            return;\n          case REACT_SUSPENSE_LIST_TYPE:\n            a: {\n              var children$jscomp$0 = props.children,\n                revealOrder = props.revealOrder;\n              if (\n                \"forwards\" === revealOrder ||\n                \"backwards\" === revealOrder ||\n                \"unstable_legacy-backwards\" === revealOrder\n              ) {\n                if (isArrayImpl(children$jscomp$0)) {\n                  renderSuspenseListRows(\n                    request,\n                    task,\n                    keyPath,\n                    children$jscomp$0,\n                    revealOrder\n                  );\n                  break a;\n                }\n                var iteratorFn = getIteratorFn(children$jscomp$0);\n                if (iteratorFn) {\n                  var iterator = iteratorFn.call(children$jscomp$0);\n                  if (iterator) {\n                    validateIterable(\n                      task,\n                      children$jscomp$0,\n                      -1,\n                      iterator,\n                      iteratorFn\n                    );\n                    var step = iterator.next();\n                    if (!step.done) {\n                      var rows = [];\n                      do rows.push(step.value), (step = iterator.next());\n                      while (!step.done);\n                      renderSuspenseListRows(\n                        request,\n                        task,\n                        keyPath,\n                        children$jscomp$0,\n                        revealOrder\n                      );\n                    }\n                    break a;\n                  }\n                }\n              }\n              if (\"together\" === revealOrder) {\n                var _prevKeyPath2 = task.keyPath,\n                  prevRow = task.row,\n                  newRow = (task.row = createSuspenseListRow(null));\n                newRow.boundaries = [];\n                newRow.together = !0;\n                task.keyPath = keyPath;\n                renderNodeDestructive(request, task, children$jscomp$0, -1);\n                0 === --newRow.pendingTasks &&\n                  finishSuspenseListRow(request, newRow);\n                task.keyPath = _prevKeyPath2;\n                task.row = prevRow;\n                null !== prevRow &&\n                  0 < newRow.pendingTasks &&\n                  (prevRow.pendingTasks++, (newRow.next = prevRow));\n              } else {\n                var prevKeyPath$jscomp$3 = task.keyPath;\n                task.keyPath = keyPath;\n                renderNodeDestructive(request, task, children$jscomp$0, -1);\n                task.keyPath = prevKeyPath$jscomp$3;\n              }\n            }\n            return;\n          case REACT_VIEW_TRANSITION_TYPE:\n          case REACT_SCOPE_TYPE:\n            throw Error(\n              \"ReactDOMServer does not yet support scope components.\"\n            );\n          case REACT_SUSPENSE_TYPE:\n            a: if (null !== task.replay) {\n              var _prevKeyPath = task.keyPath,\n                _prevContext = task.formatContext,\n                _prevRow = task.row;\n              task.keyPath = keyPath;\n              task.formatContext = getSuspenseContentFormatContext(\n                request.resumableState,\n                _prevContext\n              );\n              task.row = null;\n              var _content = props.children;\n              try {\n                renderNode(request, task, _content, -1);\n              } finally {\n                (task.keyPath = _prevKeyPath),\n                  (task.formatContext = _prevContext),\n                  (task.row = _prevRow);\n              }\n            } else {\n              var prevKeyPath$jscomp$4 = task.keyPath,\n                prevContext$jscomp$0 = task.formatContext,\n                prevRow$jscomp$0 = task.row,\n                parentBoundary = task.blockedBoundary,\n                parentPreamble = task.blockedPreamble,\n                parentHoistableState = task.hoistableState,\n                parentSegment = task.blockedSegment,\n                fallback = props.fallback,\n                content = props.children,\n                fallbackAbortSet = new Set();\n              var newBoundary =\n                task.formatContext.insertionMode < HTML_MODE\n                  ? createSuspenseBoundary(\n                      request,\n                      task.row,\n                      fallbackAbortSet,\n                      createPreambleState(),\n                      createPreambleState()\n                    )\n                  : createSuspenseBoundary(\n                      request,\n                      task.row,\n                      fallbackAbortSet,\n                      null,\n                      null\n                    );\n              null !== request.trackedPostpones &&\n                (newBoundary.trackedContentKeyPath = keyPath);\n              var boundarySegment = createPendingSegment(\n                request,\n                parentSegment.chunks.length,\n                newBoundary,\n                task.formatContext,\n                !1,\n                !1\n              );\n              parentSegment.children.push(boundarySegment);\n              parentSegment.lastPushedText = !1;\n              var contentRootSegment = createPendingSegment(\n                request,\n                0,\n                null,\n                task.formatContext,\n                !1,\n                !1\n              );\n              contentRootSegment.parentFlushed = !0;\n              if (null !== request.trackedPostpones) {\n                var suspenseComponentStack = task.componentStack,\n                  fallbackKeyPath = [\n                    keyPath[0],\n                    \"Suspense Fallback\",\n                    keyPath[2]\n                  ],\n                  fallbackReplayNode = [\n                    fallbackKeyPath[1],\n                    fallbackKeyPath[2],\n                    [],\n                    null\n                  ];\n                request.trackedPostpones.workingMap.set(\n                  fallbackKeyPath,\n                  fallbackReplayNode\n                );\n                newBoundary.trackedFallbackNode = fallbackReplayNode;\n                task.blockedSegment = boundarySegment;\n                task.blockedPreamble = newBoundary.fallbackPreamble;\n                task.keyPath = fallbackKeyPath;\n                task.formatContext = getSuspenseFallbackFormatContext(\n                  request.resumableState,\n                  prevContext$jscomp$0\n                );\n                task.componentStack =\n                  replaceSuspenseComponentStackWithSuspenseFallbackStack(\n                    suspenseComponentStack\n                  );\n                boundarySegment.status = 6;\n                try {\n                  renderNode(request, task, fallback, -1),\n                    boundarySegment.lastPushedText &&\n                      boundarySegment.textEmbedded &&\n                      boundarySegment.chunks.push(textSeparator),\n                    (boundarySegment.status = COMPLETED),\n                    finishedSegment(request, parentBoundary, boundarySegment);\n                } catch (thrownValue) {\n                  throw (\n                    ((boundarySegment.status =\n                      12 === request.status ? ABORTED : ERRORED),\n                    thrownValue)\n                  );\n                } finally {\n                  (task.blockedSegment = parentSegment),\n                    (task.blockedPreamble = parentPreamble),\n                    (task.keyPath = prevKeyPath$jscomp$4),\n                    (task.formatContext = prevContext$jscomp$0);\n                }\n                var suspendedPrimaryTask = createRenderTask(\n                  request,\n                  null,\n                  content,\n                  -1,\n                  newBoundary,\n                  contentRootSegment,\n                  newBoundary.contentPreamble,\n                  newBoundary.contentState,\n                  task.abortSet,\n                  keyPath,\n                  getSuspenseContentFormatContext(\n                    request.resumableState,\n                    task.formatContext\n                  ),\n                  task.context,\n                  task.treeContext,\n                  null,\n                  suspenseComponentStack,\n                  emptyContextObject,\n                  task.debugTask\n                );\n                pushComponentStack(suspendedPrimaryTask);\n                request.pingedTasks.push(suspendedPrimaryTask);\n              } else {\n                task.blockedBoundary = newBoundary;\n                task.blockedPreamble = newBoundary.contentPreamble;\n                task.hoistableState = newBoundary.contentState;\n                task.blockedSegment = contentRootSegment;\n                task.keyPath = keyPath;\n                task.formatContext = getSuspenseContentFormatContext(\n                  request.resumableState,\n                  prevContext$jscomp$0\n                );\n                task.row = null;\n                contentRootSegment.status = 6;\n                try {\n                  if (\n                    (renderNode(request, task, content, -1),\n                    contentRootSegment.lastPushedText &&\n                      contentRootSegment.textEmbedded &&\n                      contentRootSegment.chunks.push(textSeparator),\n                    (contentRootSegment.status = COMPLETED),\n                    finishedSegment(request, newBoundary, contentRootSegment),\n                    queueCompletedSegment(newBoundary, contentRootSegment),\n                    0 === newBoundary.pendingTasks &&\n                      newBoundary.status === PENDING)\n                  ) {\n                    if (\n                      ((newBoundary.status = COMPLETED),\n                      !isEligibleForOutlining(request, newBoundary))\n                    ) {\n                      null !== prevRow$jscomp$0 &&\n                        0 === --prevRow$jscomp$0.pendingTasks &&\n                        finishSuspenseListRow(request, prevRow$jscomp$0);\n                      0 === request.pendingRootTasks &&\n                        task.blockedPreamble &&\n                        preparePreamble(request);\n                      break a;\n                    }\n                  } else\n                    null !== prevRow$jscomp$0 &&\n                      prevRow$jscomp$0.together &&\n                      tryToResolveTogetherRow(request, prevRow$jscomp$0);\n                } catch (thrownValue$2) {\n                  newBoundary.status = CLIENT_RENDERED;\n                  if (12 === request.status) {\n                    contentRootSegment.status = ABORTED;\n                    var error = request.fatalError;\n                  } else\n                    (contentRootSegment.status = ERRORED),\n                      (error = thrownValue$2);\n                  var thrownInfo = getThrownInfo(task.componentStack);\n                  var errorDigest = logRecoverableError(\n                    request,\n                    error,\n                    thrownInfo,\n                    task.debugTask\n                  );\n                  encodeErrorForBoundary(\n                    newBoundary,\n                    errorDigest,\n                    error,\n                    thrownInfo,\n                    !1\n                  );\n                  untrackBoundary(request, newBoundary);\n                } finally {\n                  (task.blockedBoundary = parentBoundary),\n                    (task.blockedPreamble = parentPreamble),\n                    (task.hoistableState = parentHoistableState),\n                    (task.blockedSegment = parentSegment),\n                    (task.keyPath = prevKeyPath$jscomp$4),\n                    (task.formatContext = prevContext$jscomp$0),\n                    (task.row = prevRow$jscomp$0);\n                }\n                var suspendedFallbackTask = createRenderTask(\n                  request,\n                  null,\n                  fallback,\n                  -1,\n                  parentBoundary,\n                  boundarySegment,\n                  newBoundary.fallbackPreamble,\n                  newBoundary.fallbackState,\n                  fallbackAbortSet,\n                  [keyPath[0], \"Suspense Fallback\", keyPath[2]],\n                  getSuspenseFallbackFormatContext(\n                    request.resumableState,\n                    task.formatContext\n                  ),\n                  task.context,\n                  task.treeContext,\n                  task.row,\n                  replaceSuspenseComponentStackWithSuspenseFallbackStack(\n                    task.componentStack\n                  ),\n                  emptyContextObject,\n                  task.debugTask\n                );\n                pushComponentStack(suspendedFallbackTask);\n                request.pingedTasks.push(suspendedFallbackTask);\n              }\n            }\n            return;\n        }\n        if (\"object\" === typeof type && null !== type)\n          switch (type.$$typeof) {\n            case REACT_FORWARD_REF_TYPE:\n              if (\"ref\" in props) {\n                var propsWithoutRef = {};\n                for (var key in props)\n                  \"ref\" !== key && (propsWithoutRef[key] = props[key]);\n              } else propsWithoutRef = props;\n              var children$jscomp$1 = renderWithHooks(\n                request,\n                task,\n                keyPath,\n                type.render,\n                propsWithoutRef,\n                ref\n              );\n              finishFunctionComponent(\n                request,\n                task,\n                keyPath,\n                children$jscomp$1,\n                0 !== localIdCounter,\n                actionStateCounter,\n                actionStateMatchingIndex\n              );\n              return;\n            case REACT_MEMO_TYPE:\n              renderElement(request, task, keyPath, type.type, props, ref);\n              return;\n            case REACT_CONTEXT_TYPE:\n              var value$jscomp$0 = props.value,\n                children$jscomp$2 = props.children;\n              var prevSnapshot = task.context;\n              var prevKeyPath$jscomp$5 = task.keyPath;\n              var prevValue = type._currentValue;\n              type._currentValue = value$jscomp$0;\n              void 0 !== type._currentRenderer &&\n                null !== type._currentRenderer &&\n                type._currentRenderer !== rendererSigil &&\n                console.error(\n                  \"Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.\"\n                );\n              type._currentRenderer = rendererSigil;\n              var prevNode = currentActiveSnapshot,\n                newNode = {\n                  parent: prevNode,\n                  depth: null === prevNode ? 0 : prevNode.depth + 1,\n                  context: type,\n                  parentValue: prevValue,\n                  value: value$jscomp$0\n                };\n              currentActiveSnapshot = newNode;\n              task.context = newNode;\n              task.keyPath = keyPath;\n              renderNodeDestructive(request, task, children$jscomp$2, -1);\n              var prevSnapshot$jscomp$0 = currentActiveSnapshot;\n              if (null === prevSnapshot$jscomp$0)\n                throw Error(\n                  \"Tried to pop a Context at the root of the app. This is a bug in React.\"\n                );\n              prevSnapshot$jscomp$0.context !== type &&\n                console.error(\n                  \"The parent context is not the expected context. This is probably a bug in React.\"\n                );\n              prevSnapshot$jscomp$0.context._currentValue =\n                prevSnapshot$jscomp$0.parentValue;\n              void 0 !== type._currentRenderer &&\n                null !== type._currentRenderer &&\n                type._currentRenderer !== rendererSigil &&\n                console.error(\n                  \"Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.\"\n                );\n              type._currentRenderer = rendererSigil;\n              var JSCompiler_inline_result$jscomp$0 = (currentActiveSnapshot =\n                prevSnapshot$jscomp$0.parent);\n              task.context = JSCompiler_inline_result$jscomp$0;\n              task.keyPath = prevKeyPath$jscomp$5;\n              prevSnapshot !== task.context &&\n                console.error(\n                  \"Popping the context provider did not return back to the original snapshot. This is a bug in React.\"\n                );\n              return;\n            case REACT_CONSUMER_TYPE:\n              var context$jscomp$0 = type._context,\n                render = props.children;\n              \"function\" !== typeof render &&\n                console.error(\n                  \"A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.\"\n                );\n              var newChildren = render(context$jscomp$0._currentValue),\n                prevKeyPath$jscomp$6 = task.keyPath;\n              task.keyPath = keyPath;\n              renderNodeDestructive(request, task, newChildren, -1);\n              task.keyPath = prevKeyPath$jscomp$6;\n              return;\n            case REACT_LAZY_TYPE:\n              var Component = callLazyInitInDEV(type);\n              if (12 === request.status) throw null;\n              renderElement(request, task, keyPath, Component, props, ref);\n              return;\n          }\n        var info = \"\";\n        if (\n          void 0 === type ||\n          (\"object\" === typeof type &&\n            null !== type &&\n            0 === Object.keys(type).length)\n        )\n          info +=\n            \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\";\n        throw Error(\n          \"Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: \" +\n            ((null == type ? type : typeof type) + \".\" + info)\n        );\n      }\n    }\n    function resumeNode(request, task, segmentId, node, childIndex) {\n      var prevReplay = task.replay,\n        blockedBoundary = task.blockedBoundary,\n        resumedSegment = createPendingSegment(\n          request,\n          0,\n          null,\n          task.formatContext,\n          !1,\n          !1\n        );\n      resumedSegment.id = segmentId;\n      resumedSegment.parentFlushed = !0;\n      try {\n        (task.replay = null),\n          (task.blockedSegment = resumedSegment),\n          renderNode(request, task, node, childIndex),\n          (resumedSegment.status = COMPLETED),\n          finishedSegment(request, blockedBoundary, resumedSegment),\n          null === blockedBoundary\n            ? (request.completedRootSegment = resumedSegment)\n            : (queueCompletedSegment(blockedBoundary, resumedSegment),\n              blockedBoundary.parentFlushed &&\n                request.partialBoundaries.push(blockedBoundary));\n      } finally {\n        (task.replay = prevReplay), (task.blockedSegment = null);\n      }\n    }\n    function replayElement(\n      request,\n      task,\n      keyPath,\n      name,\n      keyOrIndex,\n      childIndex,\n      type,\n      props,\n      ref,\n      replay\n    ) {\n      childIndex = replay.nodes;\n      for (var i = 0; i < childIndex.length; i++) {\n        var node = childIndex[i];\n        if (keyOrIndex === node[1]) {\n          if (4 === node.length) {\n            if (null !== name && name !== node[0])\n              throw Error(\n                \"Expected the resume to render <\" +\n                  node[0] +\n                  \"> in this slot but instead it rendered <\" +\n                  name +\n                  \">. The tree doesn't match so React will fallback to client rendering.\"\n              );\n            var childNodes = node[2];\n            name = node[3];\n            keyOrIndex = task.node;\n            task.replay = { nodes: childNodes, slots: name, pendingTasks: 1 };\n            try {\n              renderElement(request, task, keyPath, type, props, ref);\n              if (\n                1 === task.replay.pendingTasks &&\n                0 < task.replay.nodes.length\n              )\n                throw Error(\n                  \"Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.\"\n                );\n              task.replay.pendingTasks--;\n            } catch (x) {\n              if (\n                \"object\" === typeof x &&\n                null !== x &&\n                (x === SuspenseException || \"function\" === typeof x.then)\n              )\n                throw (\n                  (task.node === keyOrIndex\n                    ? (task.replay = replay)\n                    : childIndex.splice(i, 1),\n                  x)\n                );\n              task.replay.pendingTasks--;\n              type = getThrownInfo(task.componentStack);\n              props = request;\n              request = task.blockedBoundary;\n              keyPath = x;\n              ref = name;\n              name = logRecoverableError(props, keyPath, type, task.debugTask);\n              abortRemainingReplayNodes(\n                props,\n                request,\n                childNodes,\n                ref,\n                keyPath,\n                name,\n                type,\n                !1\n              );\n            }\n            task.replay = replay;\n          } else {\n            if (type !== REACT_SUSPENSE_TYPE)\n              throw Error(\n                \"Expected the resume to render <Suspense> in this slot but instead it rendered <\" +\n                  (getComponentNameFromType(type) || \"Unknown\") +\n                  \">. The tree doesn't match so React will fallback to client rendering.\"\n              );\n            a: {\n              replay = void 0;\n              name = node[5];\n              type = node[2];\n              ref = node[3];\n              keyOrIndex = null === node[4] ? [] : node[4][2];\n              node = null === node[4] ? null : node[4][3];\n              var prevKeyPath = task.keyPath,\n                prevContext = task.formatContext,\n                prevRow = task.row,\n                previousReplaySet = task.replay,\n                parentBoundary = task.blockedBoundary,\n                parentHoistableState = task.hoistableState,\n                content = props.children,\n                fallback = props.fallback,\n                fallbackAbortSet = new Set();\n              props =\n                task.formatContext.insertionMode < HTML_MODE\n                  ? createSuspenseBoundary(\n                      request,\n                      task.row,\n                      fallbackAbortSet,\n                      createPreambleState(),\n                      createPreambleState()\n                    )\n                  : createSuspenseBoundary(\n                      request,\n                      task.row,\n                      fallbackAbortSet,\n                      null,\n                      null\n                    );\n              props.parentFlushed = !0;\n              props.rootSegmentID = name;\n              task.blockedBoundary = props;\n              task.hoistableState = props.contentState;\n              task.keyPath = keyPath;\n              task.formatContext = getSuspenseContentFormatContext(\n                request.resumableState,\n                prevContext\n              );\n              task.row = null;\n              task.replay = { nodes: type, slots: ref, pendingTasks: 1 };\n              try {\n                renderNode(request, task, content, -1);\n                if (\n                  1 === task.replay.pendingTasks &&\n                  0 < task.replay.nodes.length\n                )\n                  throw Error(\n                    \"Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.\"\n                  );\n                task.replay.pendingTasks--;\n                if (0 === props.pendingTasks && props.status === PENDING) {\n                  props.status = COMPLETED;\n                  request.completedBoundaries.push(props);\n                  break a;\n                }\n              } catch (error) {\n                (props.status = CLIENT_RENDERED),\n                  (childNodes = getThrownInfo(task.componentStack)),\n                  (replay = logRecoverableError(\n                    request,\n                    error,\n                    childNodes,\n                    task.debugTask\n                  )),\n                  encodeErrorForBoundary(props, replay, error, childNodes, !1),\n                  task.replay.pendingTasks--,\n                  request.clientRenderedBoundaries.push(props);\n              } finally {\n                (task.blockedBoundary = parentBoundary),\n                  (task.hoistableState = parentHoistableState),\n                  (task.replay = previousReplaySet),\n                  (task.keyPath = prevKeyPath),\n                  (task.formatContext = prevContext),\n                  (task.row = prevRow);\n              }\n              props = createReplayTask(\n                request,\n                null,\n                { nodes: keyOrIndex, slots: node, pendingTasks: 0 },\n                fallback,\n                -1,\n                parentBoundary,\n                props.fallbackState,\n                fallbackAbortSet,\n                [keyPath[0], \"Suspense Fallback\", keyPath[2]],\n                getSuspenseFallbackFormatContext(\n                  request.resumableState,\n                  task.formatContext\n                ),\n                task.context,\n                task.treeContext,\n                task.row,\n                replaceSuspenseComponentStackWithSuspenseFallbackStack(\n                  task.componentStack\n                ),\n                emptyContextObject,\n                task.debugTask\n              );\n              pushComponentStack(props);\n              request.pingedTasks.push(props);\n            }\n          }\n          childIndex.splice(i, 1);\n          break;\n        }\n      }\n    }\n    function validateIterable(\n      task,\n      iterable,\n      childIndex,\n      iterator,\n      iteratorFn\n    ) {\n      if (iterator === iterable) {\n        if (\n          -1 !== childIndex ||\n          null === task.componentStack ||\n          \"function\" !== typeof task.componentStack.type ||\n          \"[object GeneratorFunction]\" !==\n            Object.prototype.toString.call(task.componentStack.type) ||\n          \"[object Generator]\" !== Object.prototype.toString.call(iterator)\n        )\n          didWarnAboutGenerators ||\n            console.error(\n              \"Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items.\"\n            ),\n            (didWarnAboutGenerators = !0);\n      } else\n        iterable.entries !== iteratorFn ||\n          didWarnAboutMaps ||\n          (console.error(\n            \"Using Maps as children is not supported. Use an array of keyed ReactElements instead.\"\n          ),\n          (didWarnAboutMaps = !0));\n    }\n    function renderNodeDestructive(request, task, node, childIndex) {\n      null !== task.replay && \"number\" === typeof task.replay.slots\n        ? resumeNode(request, task, task.replay.slots, node, childIndex)\n        : ((task.node = node),\n          (task.childIndex = childIndex),\n          (node = task.componentStack),\n          (childIndex = task.debugTask),\n          pushComponentStack(task),\n          retryNode(request, task),\n          (task.componentStack = node),\n          (task.debugTask = childIndex));\n    }\n    function retryNode(request, task) {\n      var node = task.node,\n        childIndex = task.childIndex;\n      if (null !== node) {\n        if (\"object\" === typeof node) {\n          switch (node.$$typeof) {\n            case REACT_ELEMENT_TYPE:\n              var type = node.type,\n                key = node.key;\n              node = node.props;\n              var refProp = node.ref;\n              refProp = void 0 !== refProp ? refProp : null;\n              var debugTask = task.debugTask,\n                name = getComponentNameFromType(type);\n              key = null == key ? (-1 === childIndex ? 0 : childIndex) : key;\n              var keyPath = [task.keyPath, name, key];\n              null !== task.replay\n                ? debugTask\n                  ? debugTask.run(\n                      replayElement.bind(\n                        null,\n                        request,\n                        task,\n                        keyPath,\n                        name,\n                        key,\n                        childIndex,\n                        type,\n                        node,\n                        refProp,\n                        task.replay\n                      )\n                    )\n                  : replayElement(\n                      request,\n                      task,\n                      keyPath,\n                      name,\n                      key,\n                      childIndex,\n                      type,\n                      node,\n                      refProp,\n                      task.replay\n                    )\n                : debugTask\n                  ? debugTask.run(\n                      renderElement.bind(\n                        null,\n                        request,\n                        task,\n                        keyPath,\n                        type,\n                        node,\n                        refProp\n                      )\n                    )\n                  : renderElement(request, task, keyPath, type, node, refProp);\n              return;\n            case REACT_PORTAL_TYPE:\n              throw Error(\n                \"Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.\"\n              );\n            case REACT_LAZY_TYPE:\n              type = callLazyInitInDEV(node);\n              if (12 === request.status) throw null;\n              renderNodeDestructive(request, task, type, childIndex);\n              return;\n          }\n          if (isArrayImpl(node)) {\n            renderChildrenArray(request, task, node, childIndex);\n            return;\n          }\n          if ((key = getIteratorFn(node)))\n            if ((type = key.call(node))) {\n              validateIterable(task, node, childIndex, type, key);\n              node = type.next();\n              if (!node.done) {\n                key = [];\n                do key.push(node.value), (node = type.next());\n                while (!node.done);\n                renderChildrenArray(request, task, key, childIndex);\n              }\n              return;\n            }\n          if (\"function\" === typeof node.then)\n            return (\n              (task.thenableState = null),\n              renderNodeDestructive(\n                request,\n                task,\n                unwrapThenable(node),\n                childIndex\n              )\n            );\n          if (node.$$typeof === REACT_CONTEXT_TYPE)\n            return renderNodeDestructive(\n              request,\n              task,\n              node._currentValue,\n              childIndex\n            );\n          request = Object.prototype.toString.call(node);\n          throw Error(\n            \"Objects are not valid as a React child (found: \" +\n              (\"[object Object]\" === request\n                ? \"object with keys {\" + Object.keys(node).join(\", \") + \"}\"\n                : request) +\n              \"). If you meant to render a collection of children, use an array instead.\"\n          );\n        }\n        \"string\" === typeof node\n          ? ((task = task.blockedSegment),\n            null !== task &&\n              (task.lastPushedText = pushTextInstance(\n                task.chunks,\n                node,\n                request.renderState,\n                task.lastPushedText\n              )))\n          : \"number\" === typeof node || \"bigint\" === typeof node\n            ? ((task = task.blockedSegment),\n              null !== task &&\n                (task.lastPushedText = pushTextInstance(\n                  task.chunks,\n                  \"\" + node,\n                  request.renderState,\n                  task.lastPushedText\n                )))\n            : (\"function\" === typeof node &&\n                ((request = node.displayName || node.name || \"Component\"),\n                console.error(\n                  \"Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\",\n                  request,\n                  request\n                )),\n              \"symbol\" === typeof node &&\n                console.error(\n                  \"Symbols are not valid as a React child.\\n  %s\",\n                  String(node)\n                ));\n      }\n    }\n    function warnForMissingKey(request, task, child) {\n      if (\n        null !== child &&\n        \"object\" === typeof child &&\n        (child.$$typeof === REACT_ELEMENT_TYPE ||\n          child.$$typeof === REACT_PORTAL_TYPE) &&\n        child._store &&\n        ((!child._store.validated && null == child.key) ||\n          2 === child._store.validated)\n      ) {\n        if (\"object\" !== typeof child._store)\n          throw Error(\n            \"React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.\"\n          );\n        child._store.validated = 1;\n        var didWarnForKey = request.didWarnForKey;\n        null == didWarnForKey &&\n          (didWarnForKey = request.didWarnForKey = new WeakSet());\n        request = task.componentStack;\n        if (null !== request && !didWarnForKey.has(request)) {\n          didWarnForKey.add(request);\n          var componentName = getComponentNameFromType(child.type);\n          didWarnForKey = child._owner;\n          var parentOwner = request.owner;\n          request = \"\";\n          if (parentOwner && \"undefined\" !== typeof parentOwner.type) {\n            var name = getComponentNameFromType(parentOwner.type);\n            name &&\n              (request = \"\\n\\nCheck the render method of `\" + name + \"`.\");\n          }\n          request ||\n            (componentName &&\n              (request =\n                \"\\n\\nCheck the top-level render call using <\" +\n                componentName +\n                \">.\"));\n          componentName = \"\";\n          null != didWarnForKey &&\n            parentOwner !== didWarnForKey &&\n            ((parentOwner = null),\n            \"undefined\" !== typeof didWarnForKey.type\n              ? (parentOwner = getComponentNameFromType(didWarnForKey.type))\n              : \"string\" === typeof didWarnForKey.name &&\n                (parentOwner = didWarnForKey.name),\n            parentOwner &&\n              (componentName =\n                \" It was passed a child from \" + parentOwner + \".\"));\n          didWarnForKey = task.componentStack;\n          task.componentStack = {\n            parent: task.componentStack,\n            type: child.type,\n            owner: child._owner,\n            stack: child._debugStack\n          };\n          console.error(\n            'Each child in a list should have a unique \"key\" prop.%s%s See https://react.dev/link/warning-keys for more information.',\n            request,\n            componentName\n          );\n          task.componentStack = didWarnForKey;\n        }\n      }\n    }\n    function renderChildrenArray(request, task, children, childIndex) {\n      var prevKeyPath = task.keyPath,\n        previousComponentStack = task.componentStack;\n      var previousDebugTask = task.debugTask;\n      pushServerComponentStack(task, task.node._debugInfo);\n      if (\n        -1 !== childIndex &&\n        ((task.keyPath = [task.keyPath, \"Fragment\", childIndex]),\n        null !== task.replay)\n      ) {\n        for (\n          var replay = task.replay, replayNodes = replay.nodes, j = 0;\n          j < replayNodes.length;\n          j++\n        ) {\n          var node = replayNodes[j];\n          if (node[1] === childIndex) {\n            childIndex = node[2];\n            node = node[3];\n            task.replay = { nodes: childIndex, slots: node, pendingTasks: 1 };\n            try {\n              renderChildrenArray(request, task, children, -1);\n              if (\n                1 === task.replay.pendingTasks &&\n                0 < task.replay.nodes.length\n              )\n                throw Error(\n                  \"Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.\"\n                );\n              task.replay.pendingTasks--;\n            } catch (x) {\n              if (\n                \"object\" === typeof x &&\n                null !== x &&\n                (x === SuspenseException || \"function\" === typeof x.then)\n              )\n                throw x;\n              task.replay.pendingTasks--;\n              var thrownInfo = getThrownInfo(task.componentStack);\n              children = task.blockedBoundary;\n              var error = x,\n                resumeSlots = node;\n              node = logRecoverableError(\n                request,\n                error,\n                thrownInfo,\n                task.debugTask\n              );\n              abortRemainingReplayNodes(\n                request,\n                children,\n                childIndex,\n                resumeSlots,\n                error,\n                node,\n                thrownInfo,\n                !1\n              );\n            }\n            task.replay = replay;\n            replayNodes.splice(j, 1);\n            break;\n          }\n        }\n        task.keyPath = prevKeyPath;\n        task.componentStack = previousComponentStack;\n        task.debugTask = previousDebugTask;\n        return;\n      }\n      replay = task.treeContext;\n      replayNodes = children.length;\n      if (\n        null !== task.replay &&\n        ((j = task.replay.slots), null !== j && \"object\" === typeof j)\n      ) {\n        for (childIndex = 0; childIndex < replayNodes; childIndex++)\n          (node = children[childIndex]),\n            (task.treeContext = pushTreeContext(\n              replay,\n              replayNodes,\n              childIndex\n            )),\n            (error = j[childIndex]),\n            \"number\" === typeof error\n              ? (resumeNode(request, task, error, node, childIndex),\n                delete j[childIndex])\n              : renderNode(request, task, node, childIndex);\n        task.treeContext = replay;\n        task.keyPath = prevKeyPath;\n        task.componentStack = previousComponentStack;\n        task.debugTask = previousDebugTask;\n        return;\n      }\n      for (j = 0; j < replayNodes; j++)\n        (childIndex = children[j]),\n          warnForMissingKey(request, task, childIndex),\n          (task.treeContext = pushTreeContext(replay, replayNodes, j)),\n          renderNode(request, task, childIndex, j);\n      task.treeContext = replay;\n      task.keyPath = prevKeyPath;\n      task.componentStack = previousComponentStack;\n      task.debugTask = previousDebugTask;\n    }\n    function trackPostponedBoundary(request, trackedPostpones, boundary) {\n      boundary.status = POSTPONED;\n      boundary.rootSegmentID = request.nextSegmentId++;\n      request = boundary.trackedContentKeyPath;\n      if (null === request)\n        throw Error(\n          \"It should not be possible to postpone at the root. This is a bug in React.\"\n        );\n      var fallbackReplayNode = boundary.trackedFallbackNode,\n        children = [],\n        boundaryNode = trackedPostpones.workingMap.get(request);\n      if (void 0 === boundaryNode)\n        return (\n          (boundary = [\n            request[1],\n            request[2],\n            children,\n            null,\n            fallbackReplayNode,\n            boundary.rootSegmentID\n          ]),\n          trackedPostpones.workingMap.set(request, boundary),\n          addToReplayParent(boundary, request[0], trackedPostpones),\n          boundary\n        );\n      boundaryNode[4] = fallbackReplayNode;\n      boundaryNode[5] = boundary.rootSegmentID;\n      return boundaryNode;\n    }\n    function trackPostpone(request, trackedPostpones, task, segment) {\n      segment.status = POSTPONED;\n      var keyPath = task.keyPath,\n        boundary = task.blockedBoundary;\n      if (null === boundary)\n        (segment.id = request.nextSegmentId++),\n          (trackedPostpones.rootSlots = segment.id),\n          null !== request.completedRootSegment &&\n            (request.completedRootSegment.status = POSTPONED);\n      else {\n        if (null !== boundary && boundary.status === PENDING) {\n          var boundaryNode = trackPostponedBoundary(\n            request,\n            trackedPostpones,\n            boundary\n          );\n          if (\n            boundary.trackedContentKeyPath === keyPath &&\n            -1 === task.childIndex\n          ) {\n            -1 === segment.id &&\n              (segment.id = segment.parentFlushed\n                ? boundary.rootSegmentID\n                : request.nextSegmentId++);\n            boundaryNode[3] = segment.id;\n            return;\n          }\n        }\n        -1 === segment.id &&\n          (segment.id =\n            segment.parentFlushed && null !== boundary\n              ? boundary.rootSegmentID\n              : request.nextSegmentId++);\n        if (-1 === task.childIndex)\n          null === keyPath\n            ? (trackedPostpones.rootSlots = segment.id)\n            : ((task = trackedPostpones.workingMap.get(keyPath)),\n              void 0 === task\n                ? ((task = [keyPath[1], keyPath[2], [], segment.id]),\n                  addToReplayParent(task, keyPath[0], trackedPostpones))\n                : (task[3] = segment.id));\n        else {\n          if (null === keyPath)\n            if (((request = trackedPostpones.rootSlots), null === request))\n              request = trackedPostpones.rootSlots = {};\n            else {\n              if (\"number\" === typeof request)\n                throw Error(\n                  \"It should not be possible to postpone both at the root of an element as well as a slot below. This is a bug in React.\"\n                );\n            }\n          else if (\n            ((boundary = trackedPostpones.workingMap),\n            (boundaryNode = boundary.get(keyPath)),\n            void 0 === boundaryNode)\n          )\n            (request = {}),\n              (boundaryNode = [keyPath[1], keyPath[2], [], request]),\n              boundary.set(keyPath, boundaryNode),\n              addToReplayParent(boundaryNode, keyPath[0], trackedPostpones);\n          else if (((request = boundaryNode[3]), null === request))\n            request = boundaryNode[3] = {};\n          else if (\"number\" === typeof request)\n            throw Error(\n              \"It should not be possible to postpone both at the root of an element as well as a slot below. This is a bug in React.\"\n            );\n          request[task.childIndex] = segment.id;\n        }\n      }\n    }\n    function untrackBoundary(request, boundary) {\n      request = request.trackedPostpones;\n      null !== request &&\n        ((boundary = boundary.trackedContentKeyPath),\n        null !== boundary &&\n          ((boundary = request.workingMap.get(boundary)),\n          void 0 !== boundary &&\n            ((boundary.length = 4), (boundary[2] = []), (boundary[3] = null))));\n    }\n    function spawnNewSuspendedReplayTask(request, task, thenableState) {\n      return createReplayTask(\n        request,\n        thenableState,\n        task.replay,\n        task.node,\n        task.childIndex,\n        task.blockedBoundary,\n        task.hoistableState,\n        task.abortSet,\n        task.keyPath,\n        task.formatContext,\n        task.context,\n        task.treeContext,\n        task.row,\n        task.componentStack,\n        emptyContextObject,\n        task.debugTask\n      );\n    }\n    function spawnNewSuspendedRenderTask(request, task, thenableState) {\n      var segment = task.blockedSegment,\n        newSegment = createPendingSegment(\n          request,\n          segment.chunks.length,\n          null,\n          task.formatContext,\n          segment.lastPushedText,\n          !0\n        );\n      segment.children.push(newSegment);\n      segment.lastPushedText = !1;\n      return createRenderTask(\n        request,\n        thenableState,\n        task.node,\n        task.childIndex,\n        task.blockedBoundary,\n        newSegment,\n        task.blockedPreamble,\n        task.hoistableState,\n        task.abortSet,\n        task.keyPath,\n        task.formatContext,\n        task.context,\n        task.treeContext,\n        task.row,\n        task.componentStack,\n        emptyContextObject,\n        task.debugTask\n      );\n    }\n    function renderNode(request, task, node, childIndex) {\n      var previousFormatContext = task.formatContext,\n        previousContext = task.context,\n        previousKeyPath = task.keyPath,\n        previousTreeContext = task.treeContext,\n        previousComponentStack = task.componentStack,\n        previousDebugTask = task.debugTask,\n        segment = task.blockedSegment;\n      if (null === segment) {\n        segment = task.replay;\n        try {\n          return renderNodeDestructive(request, task, node, childIndex);\n        } catch (thrownValue) {\n          if (\n            (resetHooksState(),\n            (node =\n              thrownValue === SuspenseException\n                ? getSuspendedThenable()\n                : thrownValue),\n            12 !== request.status && \"object\" === typeof node && null !== node)\n          ) {\n            if (\"function\" === typeof node.then) {\n              childIndex =\n                thrownValue === SuspenseException\n                  ? getThenableStateAfterSuspending()\n                  : null;\n              request = spawnNewSuspendedReplayTask(\n                request,\n                task,\n                childIndex\n              ).ping;\n              node.then(request, request);\n              task.formatContext = previousFormatContext;\n              task.context = previousContext;\n              task.keyPath = previousKeyPath;\n              task.treeContext = previousTreeContext;\n              task.componentStack = previousComponentStack;\n              task.replay = segment;\n              task.debugTask = previousDebugTask;\n              switchContext(previousContext);\n              return;\n            }\n            if (\"Maximum call stack size exceeded\" === node.message) {\n              node =\n                thrownValue === SuspenseException\n                  ? getThenableStateAfterSuspending()\n                  : null;\n              node = spawnNewSuspendedReplayTask(request, task, node);\n              request.pingedTasks.push(node);\n              task.formatContext = previousFormatContext;\n              task.context = previousContext;\n              task.keyPath = previousKeyPath;\n              task.treeContext = previousTreeContext;\n              task.componentStack = previousComponentStack;\n              task.replay = segment;\n              task.debugTask = previousDebugTask;\n              switchContext(previousContext);\n              return;\n            }\n          }\n        }\n      } else {\n        var childrenLength = segment.children.length,\n          chunkLength = segment.chunks.length;\n        try {\n          return renderNodeDestructive(request, task, node, childIndex);\n        } catch (thrownValue$3) {\n          if (\n            (resetHooksState(),\n            (segment.children.length = childrenLength),\n            (segment.chunks.length = chunkLength),\n            (node =\n              thrownValue$3 === SuspenseException\n                ? getSuspendedThenable()\n                : thrownValue$3),\n            12 !== request.status && \"object\" === typeof node && null !== node)\n          ) {\n            if (\"function\" === typeof node.then) {\n              segment = node;\n              node =\n                thrownValue$3 === SuspenseException\n                  ? getThenableStateAfterSuspending()\n                  : null;\n              request = spawnNewSuspendedRenderTask(request, task, node).ping;\n              segment.then(request, request);\n              task.formatContext = previousFormatContext;\n              task.context = previousContext;\n              task.keyPath = previousKeyPath;\n              task.treeContext = previousTreeContext;\n              task.componentStack = previousComponentStack;\n              task.debugTask = previousDebugTask;\n              switchContext(previousContext);\n              return;\n            }\n            if (\"Maximum call stack size exceeded\" === node.message) {\n              segment =\n                thrownValue$3 === SuspenseException\n                  ? getThenableStateAfterSuspending()\n                  : null;\n              segment = spawnNewSuspendedRenderTask(request, task, segment);\n              request.pingedTasks.push(segment);\n              task.formatContext = previousFormatContext;\n              task.context = previousContext;\n              task.keyPath = previousKeyPath;\n              task.treeContext = previousTreeContext;\n              task.componentStack = previousComponentStack;\n              task.debugTask = previousDebugTask;\n              switchContext(previousContext);\n              return;\n            }\n          }\n        }\n      }\n      task.formatContext = previousFormatContext;\n      task.context = previousContext;\n      task.keyPath = previousKeyPath;\n      task.treeContext = previousTreeContext;\n      switchContext(previousContext);\n      throw node;\n    }\n    function abortTaskSoft(task) {\n      var boundary = task.blockedBoundary,\n        segment = task.blockedSegment;\n      null !== segment &&\n        ((segment.status = ABORTED),\n        finishedTask(this, boundary, task.row, segment));\n    }\n    function abortRemainingReplayNodes(\n      request$jscomp$0,\n      boundary,\n      nodes,\n      slots,\n      error$jscomp$0,\n      errorDigest$jscomp$0,\n      errorInfo$jscomp$0,\n      aborted\n    ) {\n      for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n        if (4 === node.length)\n          abortRemainingReplayNodes(\n            request$jscomp$0,\n            boundary,\n            node[2],\n            node[3],\n            error$jscomp$0,\n            errorDigest$jscomp$0,\n            errorInfo$jscomp$0,\n            aborted\n          );\n        else {\n          var request = request$jscomp$0;\n          node = node[5];\n          var error = error$jscomp$0,\n            errorDigest = errorDigest$jscomp$0,\n            errorInfo = errorInfo$jscomp$0,\n            wasAborted = aborted,\n            resumedBoundary = createSuspenseBoundary(\n              request,\n              null,\n              new Set(),\n              null,\n              null\n            );\n          resumedBoundary.parentFlushed = !0;\n          resumedBoundary.rootSegmentID = node;\n          resumedBoundary.status = CLIENT_RENDERED;\n          encodeErrorForBoundary(\n            resumedBoundary,\n            errorDigest,\n            error,\n            errorInfo,\n            wasAborted\n          );\n          resumedBoundary.parentFlushed &&\n            request.clientRenderedBoundaries.push(resumedBoundary);\n        }\n      }\n      nodes.length = 0;\n      if (null !== slots) {\n        if (null === boundary)\n          throw Error(\n            \"We should not have any resumable nodes in the shell. This is a bug in React.\"\n          );\n        boundary.status !== CLIENT_RENDERED &&\n          ((boundary.status = CLIENT_RENDERED),\n          encodeErrorForBoundary(\n            boundary,\n            errorDigest$jscomp$0,\n            error$jscomp$0,\n            errorInfo$jscomp$0,\n            aborted\n          ),\n          boundary.parentFlushed &&\n            request$jscomp$0.clientRenderedBoundaries.push(boundary));\n        if (\"object\" === typeof slots)\n          for (var index in slots) delete slots[index];\n      }\n    }\n    function abortTask(task, request, error) {\n      var boundary = task.blockedBoundary,\n        segment = task.blockedSegment;\n      if (null !== segment) {\n        if (6 === segment.status) return;\n        segment.status = ABORTED;\n      }\n      var errorInfo = getThrownInfo(task.componentStack),\n        node = task.node;\n      null !== node &&\n        \"object\" === typeof node &&\n        pushHaltedAwaitOnComponentStack(task, node._debugInfo);\n      if (null === boundary) {\n        if (13 !== request.status && request.status !== CLOSED) {\n          boundary = task.replay;\n          if (null === boundary) {\n            null !== request.trackedPostpones && null !== segment\n              ? ((boundary = request.trackedPostpones),\n                logRecoverableError(request, error, errorInfo, task.debugTask),\n                trackPostpone(request, boundary, task, segment),\n                finishedTask(request, null, task.row, segment))\n              : (logRecoverableError(request, error, errorInfo, task.debugTask),\n                fatalError(request, error, errorInfo, task.debugTask));\n            return;\n          }\n          boundary.pendingTasks--;\n          0 === boundary.pendingTasks &&\n            0 < boundary.nodes.length &&\n            ((segment = logRecoverableError(request, error, errorInfo, null)),\n            abortRemainingReplayNodes(\n              request,\n              null,\n              boundary.nodes,\n              boundary.slots,\n              error,\n              segment,\n              errorInfo,\n              !0\n            ));\n          request.pendingRootTasks--;\n          0 === request.pendingRootTasks && completeShell(request);\n        }\n      } else {\n        node = request.trackedPostpones;\n        if (boundary.status !== CLIENT_RENDERED) {\n          if (null !== node && null !== segment)\n            return (\n              logRecoverableError(request, error, errorInfo, task.debugTask),\n              trackPostpone(request, node, task, segment),\n              boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {\n                return abortTask(fallbackTask, request, error);\n              }),\n              boundary.fallbackAbortableTasks.clear(),\n              finishedTask(request, boundary, task.row, segment)\n            );\n          boundary.status = CLIENT_RENDERED;\n          segment = logRecoverableError(\n            request,\n            error,\n            errorInfo,\n            task.debugTask\n          );\n          boundary.status = CLIENT_RENDERED;\n          encodeErrorForBoundary(boundary, segment, error, errorInfo, !0);\n          untrackBoundary(request, boundary);\n          boundary.parentFlushed &&\n            request.clientRenderedBoundaries.push(boundary);\n        }\n        boundary.pendingTasks--;\n        errorInfo = boundary.row;\n        null !== errorInfo &&\n          0 === --errorInfo.pendingTasks &&\n          finishSuspenseListRow(request, errorInfo);\n        boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {\n          return abortTask(fallbackTask, request, error);\n        });\n        boundary.fallbackAbortableTasks.clear();\n      }\n      task = task.row;\n      null !== task &&\n        0 === --task.pendingTasks &&\n        finishSuspenseListRow(request, task);\n      request.allPendingTasks--;\n      0 === request.allPendingTasks && completeAll(request);\n    }\n    function safelyEmitEarlyPreloads(request, shellComplete) {\n      try {\n        var renderState = request.renderState,\n          onHeaders = renderState.onHeaders;\n        if (onHeaders) {\n          var headers = renderState.headers;\n          if (headers) {\n            renderState.headers = null;\n            var linkHeader = headers.preconnects;\n            headers.fontPreloads &&\n              (linkHeader && (linkHeader += \", \"),\n              (linkHeader += headers.fontPreloads));\n            headers.highImagePreloads &&\n              (linkHeader && (linkHeader += \", \"),\n              (linkHeader += headers.highImagePreloads));\n            if (!shellComplete) {\n              var queueIter = renderState.styles.values(),\n                queueStep = queueIter.next();\n              b: for (\n                ;\n                0 < headers.remainingCapacity && !queueStep.done;\n                queueStep = queueIter.next()\n              )\n                for (\n                  var sheetIter = queueStep.value.sheets.values(),\n                    sheetStep = sheetIter.next();\n                  0 < headers.remainingCapacity && !sheetStep.done;\n                  sheetStep = sheetIter.next()\n                ) {\n                  var sheet = sheetStep.value,\n                    props = sheet.props,\n                    key = props.href,\n                    props$jscomp$0 = sheet.props;\n                  var header = getPreloadAsHeader(\n                    props$jscomp$0.href,\n                    \"style\",\n                    {\n                      crossOrigin: props$jscomp$0.crossOrigin,\n                      integrity: props$jscomp$0.integrity,\n                      nonce: props$jscomp$0.nonce,\n                      type: props$jscomp$0.type,\n                      fetchPriority: props$jscomp$0.fetchPriority,\n                      referrerPolicy: props$jscomp$0.referrerPolicy,\n                      media: props$jscomp$0.media\n                    }\n                  );\n                  if (0 <= (headers.remainingCapacity -= header.length + 2))\n                    (renderState.resets.style[key] = PRELOAD_NO_CREDS),\n                      linkHeader && (linkHeader += \", \"),\n                      (linkHeader += header),\n                      (renderState.resets.style[key] =\n                        \"string\" === typeof props.crossOrigin ||\n                        \"string\" === typeof props.integrity\n                          ? [props.crossOrigin, props.integrity]\n                          : PRELOAD_NO_CREDS);\n                  else break b;\n                }\n            }\n            linkHeader ? onHeaders({ Link: linkHeader }) : onHeaders({});\n          }\n        }\n      } catch (error) {\n        logRecoverableError(request, error, {}, null);\n      }\n    }\n    function completeShell(request) {\n      null === request.trackedPostpones && safelyEmitEarlyPreloads(request, !0);\n      null === request.trackedPostpones && preparePreamble(request);\n      request.onShellError = noop;\n      request = request.onShellReady;\n      request();\n    }\n    function completeAll(request) {\n      safelyEmitEarlyPreloads(\n        request,\n        null === request.trackedPostpones\n          ? !0\n          : null === request.completedRootSegment ||\n              request.completedRootSegment.status !== POSTPONED\n      );\n      preparePreamble(request);\n      request = request.onAllReady;\n      request();\n    }\n    function queueCompletedSegment(boundary, segment) {\n      if (\n        0 === segment.chunks.length &&\n        1 === segment.children.length &&\n        null === segment.children[0].boundary &&\n        -1 === segment.children[0].id\n      ) {\n        var childSegment = segment.children[0];\n        childSegment.id = segment.id;\n        childSegment.parentFlushed = !0;\n        (childSegment.status !== COMPLETED &&\n          childSegment.status !== ABORTED &&\n          childSegment.status !== ERRORED) ||\n          queueCompletedSegment(boundary, childSegment);\n      } else boundary.completedSegments.push(segment);\n    }\n    function finishedSegment(request, boundary, segment) {\n      if (null !== byteLengthOfChunk) {\n        segment = segment.chunks;\n        for (var segmentByteSize = 0, i = 0; i < segment.length; i++)\n          segmentByteSize += segment[i].byteLength;\n        null === boundary\n          ? (request.byteSize += segmentByteSize)\n          : (boundary.byteSize += segmentByteSize);\n      }\n    }\n    function finishedTask(request, boundary, row, segment) {\n      null !== row &&\n        (0 === --row.pendingTasks\n          ? finishSuspenseListRow(request, row)\n          : row.together && tryToResolveTogetherRow(request, row));\n      request.allPendingTasks--;\n      if (null === boundary) {\n        if (null !== segment && segment.parentFlushed) {\n          if (null !== request.completedRootSegment)\n            throw Error(\n              \"There can only be one root segment. This is a bug in React.\"\n            );\n          request.completedRootSegment = segment;\n        }\n        request.pendingRootTasks--;\n        0 === request.pendingRootTasks && completeShell(request);\n      } else if ((boundary.pendingTasks--, boundary.status !== CLIENT_RENDERED))\n        if (0 === boundary.pendingTasks)\n          if (\n            (boundary.status === PENDING && (boundary.status = COMPLETED),\n            null !== segment &&\n              segment.parentFlushed &&\n              (segment.status === COMPLETED || segment.status === ABORTED) &&\n              queueCompletedSegment(boundary, segment),\n            boundary.parentFlushed &&\n              request.completedBoundaries.push(boundary),\n            boundary.status === COMPLETED)\n          )\n            (row = boundary.row),\n              null !== row &&\n                hoistHoistables(row.hoistables, boundary.contentState),\n              isEligibleForOutlining(request, boundary) ||\n                (boundary.fallbackAbortableTasks.forEach(\n                  abortTaskSoft,\n                  request\n                ),\n                boundary.fallbackAbortableTasks.clear(),\n                null !== row &&\n                  0 === --row.pendingTasks &&\n                  finishSuspenseListRow(request, row)),\n              0 === request.pendingRootTasks &&\n                null === request.trackedPostpones &&\n                null !== boundary.contentPreamble &&\n                preparePreamble(request);\n          else {\n            if (\n              boundary.status === POSTPONED &&\n              ((boundary = boundary.row), null !== boundary)\n            ) {\n              if (null !== request.trackedPostpones) {\n                row = request.trackedPostpones;\n                var postponedRow = boundary.next;\n                if (\n                  null !== postponedRow &&\n                  ((segment = postponedRow.boundaries), null !== segment)\n                )\n                  for (\n                    postponedRow.boundaries = null, postponedRow = 0;\n                    postponedRow < segment.length;\n                    postponedRow++\n                  ) {\n                    var postponedBoundary = segment[postponedRow];\n                    trackPostponedBoundary(request, row, postponedBoundary);\n                    finishedTask(request, postponedBoundary, null, null);\n                  }\n              }\n              0 === --boundary.pendingTasks &&\n                finishSuspenseListRow(request, boundary);\n            }\n          }\n        else\n          null === segment ||\n            !segment.parentFlushed ||\n            (segment.status !== COMPLETED && segment.status !== ABORTED) ||\n            (queueCompletedSegment(boundary, segment),\n            1 === boundary.completedSegments.length &&\n              boundary.parentFlushed &&\n              request.partialBoundaries.push(boundary)),\n            (boundary = boundary.row),\n            null !== boundary &&\n              boundary.together &&\n              tryToResolveTogetherRow(request, boundary);\n      0 === request.allPendingTasks && completeAll(request);\n    }\n    function performWork(request$jscomp$2) {\n      if (\n        request$jscomp$2.status !== CLOSED &&\n        13 !== request$jscomp$2.status\n      ) {\n        var prevContext = currentActiveSnapshot,\n          prevDispatcher = ReactSharedInternals.H;\n        ReactSharedInternals.H = HooksDispatcher;\n        var prevAsyncDispatcher = ReactSharedInternals.A;\n        ReactSharedInternals.A = DefaultAsyncDispatcher;\n        var prevRequest = currentRequest;\n        currentRequest = request$jscomp$2;\n        var prevGetCurrentStackImpl = ReactSharedInternals.getCurrentStack;\n        ReactSharedInternals.getCurrentStack = getCurrentStackInDEV;\n        var prevResumableState = currentResumableState;\n        currentResumableState = request$jscomp$2.resumableState;\n        try {\n          var pingedTasks = request$jscomp$2.pingedTasks,\n            i;\n          for (i = 0; i < pingedTasks.length; i++) {\n            var request = request$jscomp$2,\n              task = pingedTasks[i],\n              segment = task.blockedSegment;\n            if (null === segment) {\n              var prevTaskInDEV = void 0,\n                request$jscomp$0 = request;\n              request = task;\n              if (0 !== request.replay.pendingTasks) {\n                switchContext(request.context);\n                prevTaskInDEV = currentTaskInDEV;\n                currentTaskInDEV = request;\n                try {\n                  \"number\" === typeof request.replay.slots\n                    ? resumeNode(\n                        request$jscomp$0,\n                        request,\n                        request.replay.slots,\n                        request.node,\n                        request.childIndex\n                      )\n                    : retryNode(request$jscomp$0, request);\n                  if (\n                    1 === request.replay.pendingTasks &&\n                    0 < request.replay.nodes.length\n                  )\n                    throw Error(\n                      \"Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.\"\n                    );\n                  request.replay.pendingTasks--;\n                  request.abortSet.delete(request);\n                  finishedTask(\n                    request$jscomp$0,\n                    request.blockedBoundary,\n                    request.row,\n                    null\n                  );\n                } catch (thrownValue) {\n                  resetHooksState();\n                  var x =\n                    thrownValue === SuspenseException\n                      ? getSuspendedThenable()\n                      : thrownValue;\n                  if (\n                    \"object\" === typeof x &&\n                    null !== x &&\n                    \"function\" === typeof x.then\n                  ) {\n                    var ping = request.ping;\n                    x.then(ping, ping);\n                    request.thenableState =\n                      thrownValue === SuspenseException\n                        ? getThenableStateAfterSuspending()\n                        : null;\n                  } else {\n                    request.replay.pendingTasks--;\n                    request.abortSet.delete(request);\n                    var errorInfo = getThrownInfo(request.componentStack),\n                      errorDigest = void 0,\n                      request$jscomp$1 = request$jscomp$0,\n                      boundary = request.blockedBoundary,\n                      error$jscomp$0 =\n                        12 === request$jscomp$0.status\n                          ? request$jscomp$0.fatalError\n                          : x,\n                      errorInfo$jscomp$0 = errorInfo,\n                      replayNodes = request.replay.nodes,\n                      resumeSlots = request.replay.slots;\n                    errorDigest = logRecoverableError(\n                      request$jscomp$1,\n                      error$jscomp$0,\n                      errorInfo$jscomp$0,\n                      request.debugTask\n                    );\n                    abortRemainingReplayNodes(\n                      request$jscomp$1,\n                      boundary,\n                      replayNodes,\n                      resumeSlots,\n                      error$jscomp$0,\n                      errorDigest,\n                      errorInfo$jscomp$0,\n                      !1\n                    );\n                    request$jscomp$0.pendingRootTasks--;\n                    0 === request$jscomp$0.pendingRootTasks &&\n                      completeShell(request$jscomp$0);\n                    request$jscomp$0.allPendingTasks--;\n                    0 === request$jscomp$0.allPendingTasks &&\n                      completeAll(request$jscomp$0);\n                  }\n                } finally {\n                  currentTaskInDEV = prevTaskInDEV;\n                }\n              }\n            } else if (\n              ((request$jscomp$0 = prevTaskInDEV = void 0),\n              (errorDigest = task),\n              (request$jscomp$1 = segment),\n              request$jscomp$1.status === PENDING)\n            ) {\n              request$jscomp$1.status = 6;\n              switchContext(errorDigest.context);\n              request$jscomp$0 = currentTaskInDEV;\n              currentTaskInDEV = errorDigest;\n              var childrenLength = request$jscomp$1.children.length,\n                chunkLength = request$jscomp$1.chunks.length;\n              try {\n                retryNode(request, errorDigest),\n                  request$jscomp$1.lastPushedText &&\n                    request$jscomp$1.textEmbedded &&\n                    request$jscomp$1.chunks.push(textSeparator),\n                  errorDigest.abortSet.delete(errorDigest),\n                  (request$jscomp$1.status = COMPLETED),\n                  finishedSegment(\n                    request,\n                    errorDigest.blockedBoundary,\n                    request$jscomp$1\n                  ),\n                  finishedTask(\n                    request,\n                    errorDigest.blockedBoundary,\n                    errorDigest.row,\n                    request$jscomp$1\n                  );\n              } catch (thrownValue) {\n                resetHooksState();\n                request$jscomp$1.children.length = childrenLength;\n                request$jscomp$1.chunks.length = chunkLength;\n                var x$jscomp$0 =\n                  thrownValue === SuspenseException\n                    ? getSuspendedThenable()\n                    : 12 === request.status\n                      ? request.fatalError\n                      : thrownValue;\n                if (\n                  12 === request.status &&\n                  null !== request.trackedPostpones\n                ) {\n                  var trackedPostpones = request.trackedPostpones,\n                    thrownInfo = getThrownInfo(errorDigest.componentStack);\n                  errorDigest.abortSet.delete(errorDigest);\n                  logRecoverableError(\n                    request,\n                    x$jscomp$0,\n                    thrownInfo,\n                    errorDigest.debugTask\n                  );\n                  trackPostpone(\n                    request,\n                    trackedPostpones,\n                    errorDigest,\n                    request$jscomp$1\n                  );\n                  finishedTask(\n                    request,\n                    errorDigest.blockedBoundary,\n                    errorDigest.row,\n                    request$jscomp$1\n                  );\n                } else if (\n                  \"object\" === typeof x$jscomp$0 &&\n                  null !== x$jscomp$0 &&\n                  \"function\" === typeof x$jscomp$0.then\n                ) {\n                  request$jscomp$1.status = PENDING;\n                  errorDigest.thenableState =\n                    thrownValue === SuspenseException\n                      ? getThenableStateAfterSuspending()\n                      : null;\n                  var ping$jscomp$0 = errorDigest.ping;\n                  x$jscomp$0.then(ping$jscomp$0, ping$jscomp$0);\n                } else {\n                  var errorInfo$jscomp$1 = getThrownInfo(\n                    errorDigest.componentStack\n                  );\n                  errorDigest.abortSet.delete(errorDigest);\n                  request$jscomp$1.status = ERRORED;\n                  var boundary$jscomp$0 = errorDigest.blockedBoundary,\n                    row = errorDigest.row,\n                    debugTask = errorDigest.debugTask;\n                  null !== row &&\n                    0 === --row.pendingTasks &&\n                    finishSuspenseListRow(request, row);\n                  request.allPendingTasks--;\n                  prevTaskInDEV = logRecoverableError(\n                    request,\n                    x$jscomp$0,\n                    errorInfo$jscomp$1,\n                    debugTask\n                  );\n                  if (null === boundary$jscomp$0)\n                    fatalError(\n                      request,\n                      x$jscomp$0,\n                      errorInfo$jscomp$1,\n                      debugTask\n                    );\n                  else if (\n                    (boundary$jscomp$0.pendingTasks--,\n                    boundary$jscomp$0.status !== CLIENT_RENDERED)\n                  ) {\n                    boundary$jscomp$0.status = CLIENT_RENDERED;\n                    encodeErrorForBoundary(\n                      boundary$jscomp$0,\n                      prevTaskInDEV,\n                      x$jscomp$0,\n                      errorInfo$jscomp$1,\n                      !1\n                    );\n                    untrackBoundary(request, boundary$jscomp$0);\n                    var boundaryRow = boundary$jscomp$0.row;\n                    null !== boundaryRow &&\n                      0 === --boundaryRow.pendingTasks &&\n                      finishSuspenseListRow(request, boundaryRow);\n                    boundary$jscomp$0.parentFlushed &&\n                      request.clientRenderedBoundaries.push(boundary$jscomp$0);\n                    0 === request.pendingRootTasks &&\n                      null === request.trackedPostpones &&\n                      null !== boundary$jscomp$0.contentPreamble &&\n                      preparePreamble(request);\n                  }\n                  0 === request.allPendingTasks && completeAll(request);\n                }\n              } finally {\n                currentTaskInDEV = request$jscomp$0;\n              }\n            }\n          }\n          pingedTasks.splice(0, i);\n          null !== request$jscomp$2.destination &&\n            flushCompletedQueues(\n              request$jscomp$2,\n              request$jscomp$2.destination\n            );\n        } catch (error) {\n          (pingedTasks = {}),\n            logRecoverableError(request$jscomp$2, error, pingedTasks, null),\n            fatalError(request$jscomp$2, error, pingedTasks, null);\n        } finally {\n          (currentResumableState = prevResumableState),\n            (ReactSharedInternals.H = prevDispatcher),\n            (ReactSharedInternals.A = prevAsyncDispatcher),\n            (ReactSharedInternals.getCurrentStack = prevGetCurrentStackImpl),\n            prevDispatcher === HooksDispatcher && switchContext(prevContext),\n            (currentRequest = prevRequest);\n        }\n      }\n    }\n    function preparePreambleFromSubtree(\n      request,\n      segment,\n      collectedPreambleSegments\n    ) {\n      segment.preambleChildren.length &&\n        collectedPreambleSegments.push(segment.preambleChildren);\n      for (var pendingPreambles = !1, i = 0; i < segment.children.length; i++)\n        pendingPreambles =\n          preparePreambleFromSegment(\n            request,\n            segment.children[i],\n            collectedPreambleSegments\n          ) || pendingPreambles;\n      return pendingPreambles;\n    }\n    function preparePreambleFromSegment(\n      request,\n      segment,\n      collectedPreambleSegments\n    ) {\n      var boundary = segment.boundary;\n      if (null === boundary)\n        return preparePreambleFromSubtree(\n          request,\n          segment,\n          collectedPreambleSegments\n        );\n      var preamble = boundary.contentPreamble,\n        fallbackPreamble = boundary.fallbackPreamble;\n      if (null === preamble || null === fallbackPreamble) return !1;\n      switch (boundary.status) {\n        case COMPLETED:\n          hoistPreambleState(request.renderState, preamble);\n          request.byteSize += boundary.byteSize;\n          segment = boundary.completedSegments[0];\n          if (!segment)\n            throw Error(\n              \"A previously unvisited boundary must have exactly one root segment. This is a bug in React.\"\n            );\n          return preparePreambleFromSubtree(\n            request,\n            segment,\n            collectedPreambleSegments\n          );\n        case POSTPONED:\n          if (null !== request.trackedPostpones) return !0;\n        case CLIENT_RENDERED:\n          if (segment.status === COMPLETED)\n            return (\n              hoistPreambleState(request.renderState, fallbackPreamble),\n              preparePreambleFromSubtree(\n                request,\n                segment,\n                collectedPreambleSegments\n              )\n            );\n        default:\n          return !0;\n      }\n    }\n    function preparePreamble(request) {\n      if (\n        request.completedRootSegment &&\n        null === request.completedPreambleSegments\n      ) {\n        var collectedPreambleSegments = [],\n          originalRequestByteSize = request.byteSize,\n          hasPendingPreambles = preparePreambleFromSegment(\n            request,\n            request.completedRootSegment,\n            collectedPreambleSegments\n          ),\n          preamble = request.renderState.preamble;\n        !1 === hasPendingPreambles ||\n        (preamble.headChunks && preamble.bodyChunks)\n          ? (request.completedPreambleSegments = collectedPreambleSegments)\n          : (request.byteSize = originalRequestByteSize);\n      }\n    }\n    function flushSubtree(request, destination, segment, hoistableState) {\n      segment.parentFlushed = !0;\n      switch (segment.status) {\n        case PENDING:\n          segment.id = request.nextSegmentId++;\n        case POSTPONED:\n          return (\n            (hoistableState = segment.id),\n            (segment.lastPushedText = !1),\n            (segment.textEmbedded = !1),\n            (request = request.renderState),\n            writeChunk(destination, placeholder1),\n            writeChunk(destination, request.placeholderPrefix),\n            (request = stringToChunk(hoistableState.toString(16))),\n            writeChunk(destination, request),\n            writeChunkAndReturn(destination, placeholder2)\n          );\n        case COMPLETED:\n          segment.status = FLUSHED;\n          var r = !0,\n            chunks = segment.chunks,\n            chunkIdx = 0;\n          segment = segment.children;\n          for (var childIdx = 0; childIdx < segment.length; childIdx++) {\n            for (r = segment[childIdx]; chunkIdx < r.index; chunkIdx++)\n              writeChunk(destination, chunks[chunkIdx]);\n            r = flushSegment(request, destination, r, hoistableState);\n          }\n          for (; chunkIdx < chunks.length - 1; chunkIdx++)\n            writeChunk(destination, chunks[chunkIdx]);\n          chunkIdx < chunks.length &&\n            (r = writeChunkAndReturn(destination, chunks[chunkIdx]));\n          return r;\n        case ABORTED:\n          return !0;\n        default:\n          throw Error(\n            \"Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.\"\n          );\n      }\n    }\n    function flushSegment(request, destination, segment, hoistableState) {\n      var boundary = segment.boundary;\n      if (null === boundary)\n        return flushSubtree(request, destination, segment, hoistableState);\n      boundary.parentFlushed = !0;\n      if (boundary.status === CLIENT_RENDERED) {\n        var row = boundary.row;\n        null !== row &&\n          0 === --row.pendingTasks &&\n          finishSuspenseListRow(request, row);\n        row = boundary.errorDigest;\n        var errorMessage = boundary.errorMessage,\n          errorStack = boundary.errorStack;\n        boundary = boundary.errorComponentStack;\n        writeChunkAndReturn(destination, startClientRenderedSuspenseBoundary);\n        writeChunk(destination, clientRenderedSuspenseBoundaryError1);\n        row &&\n          (writeChunk(destination, clientRenderedSuspenseBoundaryError1A),\n          writeChunk(destination, stringToChunk(escapeTextForBrowser(row))),\n          writeChunk(\n            destination,\n            clientRenderedSuspenseBoundaryErrorAttrInterstitial\n          ));\n        errorMessage &&\n          (writeChunk(destination, clientRenderedSuspenseBoundaryError1B),\n          writeChunk(\n            destination,\n            stringToChunk(escapeTextForBrowser(errorMessage))\n          ),\n          writeChunk(\n            destination,\n            clientRenderedSuspenseBoundaryErrorAttrInterstitial\n          ));\n        errorStack &&\n          (writeChunk(destination, clientRenderedSuspenseBoundaryError1C),\n          writeChunk(\n            destination,\n            stringToChunk(escapeTextForBrowser(errorStack))\n          ),\n          writeChunk(\n            destination,\n            clientRenderedSuspenseBoundaryErrorAttrInterstitial\n          ));\n        boundary &&\n          (writeChunk(destination, clientRenderedSuspenseBoundaryError1D),\n          writeChunk(\n            destination,\n            stringToChunk(escapeTextForBrowser(boundary))\n          ),\n          writeChunk(\n            destination,\n            clientRenderedSuspenseBoundaryErrorAttrInterstitial\n          ));\n        writeChunkAndReturn(destination, clientRenderedSuspenseBoundaryError2);\n        flushSubtree(request, destination, segment, hoistableState);\n      } else if (boundary.status !== COMPLETED)\n        boundary.status === PENDING &&\n          (boundary.rootSegmentID = request.nextSegmentId++),\n          0 < boundary.completedSegments.length &&\n            request.partialBoundaries.push(boundary),\n          writeStartPendingSuspenseBoundary(\n            destination,\n            request.renderState,\n            boundary.rootSegmentID\n          ),\n          hoistableState &&\n            hoistHoistables(hoistableState, boundary.fallbackState),\n          flushSubtree(request, destination, segment, hoistableState);\n      else if (\n        !flushingPartialBoundaries &&\n        isEligibleForOutlining(request, boundary) &&\n        (flushedByteSize + boundary.byteSize > request.progressiveChunkSize ||\n          hasSuspenseyContent(boundary.contentState))\n      )\n        (boundary.rootSegmentID = request.nextSegmentId++),\n          request.completedBoundaries.push(boundary),\n          writeStartPendingSuspenseBoundary(\n            destination,\n            request.renderState,\n            boundary.rootSegmentID\n          ),\n          flushSubtree(request, destination, segment, hoistableState);\n      else {\n        flushedByteSize += boundary.byteSize;\n        hoistableState &&\n          hoistHoistables(hoistableState, boundary.contentState);\n        segment = boundary.row;\n        null !== segment &&\n          isEligibleForOutlining(request, boundary) &&\n          0 === --segment.pendingTasks &&\n          finishSuspenseListRow(request, segment);\n        writeChunkAndReturn(destination, startCompletedSuspenseBoundary);\n        segment = boundary.completedSegments;\n        if (1 !== segment.length)\n          throw Error(\n            \"A previously unvisited boundary must have exactly one root segment. This is a bug in React.\"\n          );\n        flushSegment(request, destination, segment[0], hoistableState);\n      }\n      return writeChunkAndReturn(destination, endSuspenseBoundary);\n    }\n    function flushSegmentContainer(\n      request,\n      destination,\n      segment,\n      hoistableState\n    ) {\n      writeStartSegment(\n        destination,\n        request.renderState,\n        segment.parentFormatContext,\n        segment.id\n      );\n      flushSegment(request, destination, segment, hoistableState);\n      return writeEndSegment(destination, segment.parentFormatContext);\n    }\n    function flushCompletedBoundary(request, destination, boundary) {\n      flushedByteSize = boundary.byteSize;\n      for (\n        var completedSegments = boundary.completedSegments, i = 0;\n        i < completedSegments.length;\n        i++\n      )\n        flushPartiallyCompletedSegment(\n          request,\n          destination,\n          boundary,\n          completedSegments[i]\n        );\n      completedSegments.length = 0;\n      completedSegments = boundary.row;\n      null !== completedSegments &&\n        isEligibleForOutlining(request, boundary) &&\n        0 === --completedSegments.pendingTasks &&\n        finishSuspenseListRow(request, completedSegments);\n      writeHoistablesForBoundary(\n        destination,\n        boundary.contentState,\n        request.renderState\n      );\n      completedSegments = request.resumableState;\n      request = request.renderState;\n      i = boundary.rootSegmentID;\n      boundary = boundary.contentState;\n      var requiresStyleInsertion = request.stylesToHoist;\n      request.stylesToHoist = !1;\n      writeChunk(destination, request.startInlineScript);\n      writeChunk(destination, endOfStartTag);\n      requiresStyleInsertion\n        ? ((completedSegments.instructions & SentClientRenderFunction) ===\n            NothingSent &&\n            ((completedSegments.instructions |= SentClientRenderFunction),\n            writeChunk(destination, clientRenderScriptFunctionOnly)),\n          (completedSegments.instructions & SentCompleteBoundaryFunction) ===\n            NothingSent &&\n            ((completedSegments.instructions |= SentCompleteBoundaryFunction),\n            writeChunk(destination, completeBoundaryScriptFunctionOnly)),\n          (completedSegments.instructions & SentStyleInsertionFunction) ===\n          NothingSent\n            ? ((completedSegments.instructions |= SentStyleInsertionFunction),\n              writeChunk(\n                destination,\n                completeBoundaryWithStylesScript1FullPartial\n              ))\n            : writeChunk(destination, completeBoundaryWithStylesScript1Partial))\n        : ((completedSegments.instructions & SentCompleteBoundaryFunction) ===\n            NothingSent &&\n            ((completedSegments.instructions |= SentCompleteBoundaryFunction),\n            writeChunk(destination, completeBoundaryScriptFunctionOnly)),\n          writeChunk(destination, completeBoundaryScript1Partial));\n      completedSegments = stringToChunk(i.toString(16));\n      writeChunk(destination, request.boundaryPrefix);\n      writeChunk(destination, completedSegments);\n      writeChunk(destination, completeBoundaryScript2);\n      writeChunk(destination, request.segmentPrefix);\n      writeChunk(destination, completedSegments);\n      requiresStyleInsertion\n        ? (writeChunk(destination, completeBoundaryScript3a),\n          writeStyleResourceDependenciesInJS(destination, boundary))\n        : writeChunk(destination, completeBoundaryScript3b);\n      boundary = writeChunkAndReturn(destination, completeBoundaryScriptEnd);\n      return writeBootstrap(destination, request) && boundary;\n    }\n    function flushPartiallyCompletedSegment(\n      request,\n      destination,\n      boundary,\n      segment\n    ) {\n      if (segment.status === FLUSHED) return !0;\n      var hoistableState = boundary.contentState,\n        segmentID = segment.id;\n      if (-1 === segmentID) {\n        if (-1 === (segment.id = boundary.rootSegmentID))\n          throw Error(\n            \"A root segment ID must have been assigned by now. This is a bug in React.\"\n          );\n        return flushSegmentContainer(\n          request,\n          destination,\n          segment,\n          hoistableState\n        );\n      }\n      if (segmentID === boundary.rootSegmentID)\n        return flushSegmentContainer(\n          request,\n          destination,\n          segment,\n          hoistableState\n        );\n      flushSegmentContainer(request, destination, segment, hoistableState);\n      boundary = request.resumableState;\n      request = request.renderState;\n      writeChunk(destination, request.startInlineScript);\n      writeChunk(destination, endOfStartTag);\n      (boundary.instructions & SentCompleteSegmentFunction) === NothingSent\n        ? ((boundary.instructions |= SentCompleteSegmentFunction),\n          writeChunk(destination, completeSegmentScript1Full))\n        : writeChunk(destination, completeSegmentScript1Partial);\n      writeChunk(destination, request.segmentPrefix);\n      segmentID = stringToChunk(segmentID.toString(16));\n      writeChunk(destination, segmentID);\n      writeChunk(destination, completeSegmentScript2);\n      writeChunk(destination, request.placeholderPrefix);\n      writeChunk(destination, segmentID);\n      destination = writeChunkAndReturn(destination, completeSegmentScriptEnd);\n      return destination;\n    }\n    function flushCompletedQueues(request, destination) {\n      currentView = new Uint8Array(2048);\n      writtenBytes = 0;\n      try {\n        if (!(0 < request.pendingRootTasks)) {\n          var i,\n            completedRootSegment = request.completedRootSegment;\n          if (null !== completedRootSegment) {\n            if (completedRootSegment.status === POSTPONED) return;\n            var completedPreambleSegments = request.completedPreambleSegments;\n            if (null === completedPreambleSegments) return;\n            flushedByteSize = request.byteSize;\n            var resumableState = request.resumableState,\n              renderState = request.renderState,\n              preamble = renderState.preamble,\n              htmlChunks = preamble.htmlChunks,\n              headChunks = preamble.headChunks,\n              i$jscomp$0;\n            if (htmlChunks) {\n              for (i$jscomp$0 = 0; i$jscomp$0 < htmlChunks.length; i$jscomp$0++)\n                writeChunk(destination, htmlChunks[i$jscomp$0]);\n              if (headChunks)\n                for (\n                  i$jscomp$0 = 0;\n                  i$jscomp$0 < headChunks.length;\n                  i$jscomp$0++\n                )\n                  writeChunk(destination, headChunks[i$jscomp$0]);\n              else\n                writeChunk(destination, startChunkForTag(\"head\")),\n                  writeChunk(destination, endOfStartTag);\n            } else if (headChunks)\n              for (i$jscomp$0 = 0; i$jscomp$0 < headChunks.length; i$jscomp$0++)\n                writeChunk(destination, headChunks[i$jscomp$0]);\n            var charsetChunks = renderState.charsetChunks;\n            for (\n              i$jscomp$0 = 0;\n              i$jscomp$0 < charsetChunks.length;\n              i$jscomp$0++\n            )\n              writeChunk(destination, charsetChunks[i$jscomp$0]);\n            charsetChunks.length = 0;\n            renderState.preconnects.forEach(flushResource, destination);\n            renderState.preconnects.clear();\n            var viewportChunks = renderState.viewportChunks;\n            for (\n              i$jscomp$0 = 0;\n              i$jscomp$0 < viewportChunks.length;\n              i$jscomp$0++\n            )\n              writeChunk(destination, viewportChunks[i$jscomp$0]);\n            viewportChunks.length = 0;\n            renderState.fontPreloads.forEach(flushResource, destination);\n            renderState.fontPreloads.clear();\n            renderState.highImagePreloads.forEach(flushResource, destination);\n            renderState.highImagePreloads.clear();\n            currentlyFlushingRenderState = renderState;\n            renderState.styles.forEach(flushStylesInPreamble, destination);\n            currentlyFlushingRenderState = null;\n            var importMapChunks = renderState.importMapChunks;\n            for (\n              i$jscomp$0 = 0;\n              i$jscomp$0 < importMapChunks.length;\n              i$jscomp$0++\n            )\n              writeChunk(destination, importMapChunks[i$jscomp$0]);\n            importMapChunks.length = 0;\n            renderState.bootstrapScripts.forEach(flushResource, destination);\n            renderState.scripts.forEach(flushResource, destination);\n            renderState.scripts.clear();\n            renderState.bulkPreloads.forEach(flushResource, destination);\n            renderState.bulkPreloads.clear();\n            htmlChunks ||\n              headChunks ||\n              (resumableState.instructions |= SentCompletedShellId);\n            var hoistableChunks = renderState.hoistableChunks;\n            for (\n              i$jscomp$0 = 0;\n              i$jscomp$0 < hoistableChunks.length;\n              i$jscomp$0++\n            )\n              writeChunk(destination, hoistableChunks[i$jscomp$0]);\n            for (\n              resumableState = hoistableChunks.length = 0;\n              resumableState < completedPreambleSegments.length;\n              resumableState++\n            ) {\n              var segments = completedPreambleSegments[resumableState];\n              for (\n                renderState = 0;\n                renderState < segments.length;\n                renderState++\n              )\n                flushSegment(request, destination, segments[renderState], null);\n            }\n            var preamble$jscomp$0 = request.renderState.preamble,\n              headChunks$jscomp$0 = preamble$jscomp$0.headChunks;\n            (preamble$jscomp$0.htmlChunks || headChunks$jscomp$0) &&\n              writeChunk(destination, endChunkForTag(\"head\"));\n            var bodyChunks = preamble$jscomp$0.bodyChunks;\n            if (bodyChunks)\n              for (\n                completedPreambleSegments = 0;\n                completedPreambleSegments < bodyChunks.length;\n                completedPreambleSegments++\n              )\n                writeChunk(destination, bodyChunks[completedPreambleSegments]);\n            flushSegment(request, destination, completedRootSegment, null);\n            request.completedRootSegment = null;\n            var renderState$jscomp$0 = request.renderState;\n            if (\n              0 !== request.allPendingTasks ||\n              0 !== request.clientRenderedBoundaries.length ||\n              0 !== request.completedBoundaries.length ||\n              (null !== request.trackedPostpones &&\n                (0 !== request.trackedPostpones.rootNodes.length ||\n                  null !== request.trackedPostpones.rootSlots))\n            ) {\n              var resumableState$jscomp$0 = request.resumableState;\n              if (\n                (resumableState$jscomp$0.instructions & SentMarkShellTime) ===\n                NothingSent\n              ) {\n                resumableState$jscomp$0.instructions |= SentMarkShellTime;\n                writeChunk(destination, renderState$jscomp$0.startInlineScript);\n                if (\n                  (resumableState$jscomp$0.instructions &\n                    SentCompletedShellId) ===\n                  NothingSent\n                ) {\n                  resumableState$jscomp$0.instructions |= SentCompletedShellId;\n                  var shellId = \"_\" + resumableState$jscomp$0.idPrefix + \"R_\";\n                  writeChunk(destination, completedShellIdAttributeStart);\n                  writeChunk(\n                    destination,\n                    stringToChunk(escapeTextForBrowser(shellId))\n                  );\n                  writeChunk(destination, attributeEnd);\n                }\n                writeChunk(destination, endOfStartTag);\n                writeChunk(destination, shellTimeRuntimeScript);\n                writeChunkAndReturn(destination, endInlineScript);\n              }\n            }\n            writeBootstrap(destination, renderState$jscomp$0);\n          }\n          var renderState$jscomp$1 = request.renderState;\n          completedRootSegment = 0;\n          var viewportChunks$jscomp$0 = renderState$jscomp$1.viewportChunks;\n          for (\n            completedRootSegment = 0;\n            completedRootSegment < viewportChunks$jscomp$0.length;\n            completedRootSegment++\n          )\n            writeChunk(\n              destination,\n              viewportChunks$jscomp$0[completedRootSegment]\n            );\n          viewportChunks$jscomp$0.length = 0;\n          renderState$jscomp$1.preconnects.forEach(flushResource, destination);\n          renderState$jscomp$1.preconnects.clear();\n          renderState$jscomp$1.fontPreloads.forEach(flushResource, destination);\n          renderState$jscomp$1.fontPreloads.clear();\n          renderState$jscomp$1.highImagePreloads.forEach(\n            flushResource,\n            destination\n          );\n          renderState$jscomp$1.highImagePreloads.clear();\n          renderState$jscomp$1.styles.forEach(preloadLateStyles, destination);\n          renderState$jscomp$1.scripts.forEach(flushResource, destination);\n          renderState$jscomp$1.scripts.clear();\n          renderState$jscomp$1.bulkPreloads.forEach(flushResource, destination);\n          renderState$jscomp$1.bulkPreloads.clear();\n          var hoistableChunks$jscomp$0 = renderState$jscomp$1.hoistableChunks;\n          for (\n            completedRootSegment = 0;\n            completedRootSegment < hoistableChunks$jscomp$0.length;\n            completedRootSegment++\n          )\n            writeChunk(\n              destination,\n              hoistableChunks$jscomp$0[completedRootSegment]\n            );\n          hoistableChunks$jscomp$0.length = 0;\n          var clientRenderedBoundaries = request.clientRenderedBoundaries;\n          for (i = 0; i < clientRenderedBoundaries.length; i++) {\n            var boundary = clientRenderedBoundaries[i];\n            renderState$jscomp$1 = destination;\n            var resumableState$jscomp$1 = request.resumableState,\n              renderState$jscomp$2 = request.renderState,\n              id = boundary.rootSegmentID,\n              errorDigest = boundary.errorDigest,\n              errorMessage = boundary.errorMessage,\n              errorStack = boundary.errorStack,\n              errorComponentStack = boundary.errorComponentStack;\n            writeChunk(\n              renderState$jscomp$1,\n              renderState$jscomp$2.startInlineScript\n            );\n            writeChunk(renderState$jscomp$1, endOfStartTag);\n            (resumableState$jscomp$1.instructions &\n              SentClientRenderFunction) ===\n            NothingSent\n              ? ((resumableState$jscomp$1.instructions |=\n                  SentClientRenderFunction),\n                writeChunk(renderState$jscomp$1, clientRenderScript1Full))\n              : writeChunk(renderState$jscomp$1, clientRenderScript1Partial);\n            writeChunk(\n              renderState$jscomp$1,\n              renderState$jscomp$2.boundaryPrefix\n            );\n            writeChunk(renderState$jscomp$1, stringToChunk(id.toString(16)));\n            writeChunk(renderState$jscomp$1, clientRenderScript1A);\n            if (\n              errorDigest ||\n              errorMessage ||\n              errorStack ||\n              errorComponentStack\n            )\n              writeChunk(\n                renderState$jscomp$1,\n                clientRenderErrorScriptArgInterstitial\n              ),\n                writeChunk(\n                  renderState$jscomp$1,\n                  stringToChunk(\n                    escapeJSStringsForInstructionScripts(errorDigest || \"\")\n                  )\n                );\n            if (errorMessage || errorStack || errorComponentStack)\n              writeChunk(\n                renderState$jscomp$1,\n                clientRenderErrorScriptArgInterstitial\n              ),\n                writeChunk(\n                  renderState$jscomp$1,\n                  stringToChunk(\n                    escapeJSStringsForInstructionScripts(errorMessage || \"\")\n                  )\n                );\n            if (errorStack || errorComponentStack)\n              writeChunk(\n                renderState$jscomp$1,\n                clientRenderErrorScriptArgInterstitial\n              ),\n                writeChunk(\n                  renderState$jscomp$1,\n                  stringToChunk(\n                    escapeJSStringsForInstructionScripts(errorStack || \"\")\n                  )\n                );\n            errorComponentStack &&\n              (writeChunk(\n                renderState$jscomp$1,\n                clientRenderErrorScriptArgInterstitial\n              ),\n              writeChunk(\n                renderState$jscomp$1,\n                stringToChunk(\n                  escapeJSStringsForInstructionScripts(errorComponentStack)\n                )\n              ));\n            var JSCompiler_inline_result = writeChunkAndReturn(\n              renderState$jscomp$1,\n              clientRenderScriptEnd\n            );\n            if (!JSCompiler_inline_result) {\n              request.destination = null;\n              i++;\n              clientRenderedBoundaries.splice(0, i);\n              return;\n            }\n          }\n          clientRenderedBoundaries.splice(0, i);\n          var completedBoundaries = request.completedBoundaries;\n          for (i = 0; i < completedBoundaries.length; i++)\n            if (\n              !flushCompletedBoundary(\n                request,\n                destination,\n                completedBoundaries[i]\n              )\n            ) {\n              request.destination = null;\n              i++;\n              completedBoundaries.splice(0, i);\n              return;\n            }\n          completedBoundaries.splice(0, i);\n          completeWriting(destination);\n          currentView = new Uint8Array(2048);\n          writtenBytes = 0;\n          flushingPartialBoundaries = !0;\n          var partialBoundaries = request.partialBoundaries;\n          for (i = 0; i < partialBoundaries.length; i++) {\n            a: {\n              clientRenderedBoundaries = request;\n              boundary = destination;\n              var boundary$jscomp$0 = partialBoundaries[i];\n              flushedByteSize = boundary$jscomp$0.byteSize;\n              var completedSegments = boundary$jscomp$0.completedSegments;\n              for (\n                JSCompiler_inline_result = 0;\n                JSCompiler_inline_result < completedSegments.length;\n                JSCompiler_inline_result++\n              )\n                if (\n                  !flushPartiallyCompletedSegment(\n                    clientRenderedBoundaries,\n                    boundary,\n                    boundary$jscomp$0,\n                    completedSegments[JSCompiler_inline_result]\n                  )\n                ) {\n                  JSCompiler_inline_result++;\n                  completedSegments.splice(0, JSCompiler_inline_result);\n                  var JSCompiler_inline_result$jscomp$0 = !1;\n                  break a;\n                }\n              completedSegments.splice(0, JSCompiler_inline_result);\n              var row = boundary$jscomp$0.row;\n              null !== row &&\n                row.together &&\n                1 === boundary$jscomp$0.pendingTasks &&\n                (1 === row.pendingTasks\n                  ? unblockSuspenseListRow(\n                      clientRenderedBoundaries,\n                      row,\n                      row.hoistables\n                    )\n                  : row.pendingTasks--);\n              JSCompiler_inline_result$jscomp$0 = writeHoistablesForBoundary(\n                boundary,\n                boundary$jscomp$0.contentState,\n                clientRenderedBoundaries.renderState\n              );\n            }\n            if (!JSCompiler_inline_result$jscomp$0) {\n              request.destination = null;\n              i++;\n              partialBoundaries.splice(0, i);\n              return;\n            }\n          }\n          partialBoundaries.splice(0, i);\n          flushingPartialBoundaries = !1;\n          var largeBoundaries = request.completedBoundaries;\n          for (i = 0; i < largeBoundaries.length; i++)\n            if (\n              !flushCompletedBoundary(request, destination, largeBoundaries[i])\n            ) {\n              request.destination = null;\n              i++;\n              largeBoundaries.splice(0, i);\n              return;\n            }\n          largeBoundaries.splice(0, i);\n        }\n      } finally {\n        (flushingPartialBoundaries = !1),\n          0 === request.allPendingTasks &&\n          0 === request.clientRenderedBoundaries.length &&\n          0 === request.completedBoundaries.length\n            ? ((request.flushScheduled = !1),\n              (i = request.resumableState),\n              i.hasBody && writeChunk(destination, endChunkForTag(\"body\")),\n              i.hasHtml && writeChunk(destination, endChunkForTag(\"html\")),\n              completeWriting(destination),\n              0 !== request.abortableTasks.size &&\n                console.error(\n                  \"There was still abortable task at the root when we closed. This is a bug in React.\"\n                ),\n              (request.status = CLOSED),\n              destination.close(),\n              (request.destination = null))\n            : completeWriting(destination);\n      }\n    }\n    function startWork(request) {\n      request.flushScheduled = null !== request.destination;\n      scheduleMicrotask(function () {\n        return performWork(request);\n      });\n      scheduleWork(function () {\n        10 === request.status && (request.status = 11);\n        null === request.trackedPostpones &&\n          safelyEmitEarlyPreloads(request, 0 === request.pendingRootTasks);\n      });\n    }\n    function enqueueFlush(request) {\n      !1 === request.flushScheduled &&\n        0 === request.pingedTasks.length &&\n        null !== request.destination &&\n        ((request.flushScheduled = !0),\n        scheduleWork(function () {\n          var destination = request.destination;\n          destination\n            ? flushCompletedQueues(request, destination)\n            : (request.flushScheduled = !1);\n        }));\n    }\n    function startFlowing(request, destination) {\n      if (13 === request.status)\n        (request.status = CLOSED),\n          closeWithError(destination, request.fatalError);\n      else if (request.status !== CLOSED && null === request.destination) {\n        request.destination = destination;\n        try {\n          flushCompletedQueues(request, destination);\n        } catch (error) {\n          (destination = {}),\n            logRecoverableError(request, error, destination, null),\n            fatalError(request, error, destination, null);\n        }\n      }\n    }\n    function abort(request, reason) {\n      if (11 === request.status || 10 === request.status) request.status = 12;\n      try {\n        var abortableTasks = request.abortableTasks;\n        if (0 < abortableTasks.size) {\n          var error =\n            void 0 === reason\n              ? Error(\"The render was aborted by the server without a reason.\")\n              : \"object\" === typeof reason &&\n                  null !== reason &&\n                  \"function\" === typeof reason.then\n                ? Error(\"The render was aborted by the server with a promise.\")\n                : reason;\n          request.fatalError = error;\n          abortableTasks.forEach(function (task) {\n            var prevTaskInDEV = currentTaskInDEV,\n              prevGetCurrentStackImpl = ReactSharedInternals.getCurrentStack;\n            currentTaskInDEV = task;\n            ReactSharedInternals.getCurrentStack = getCurrentStackInDEV;\n            try {\n              abortTask(task, request, error);\n            } finally {\n              (currentTaskInDEV = prevTaskInDEV),\n                (ReactSharedInternals.getCurrentStack =\n                  prevGetCurrentStackImpl);\n            }\n          });\n          abortableTasks.clear();\n        }\n        null !== request.destination &&\n          flushCompletedQueues(request, request.destination);\n      } catch (error$4) {\n        (reason = {}),\n          logRecoverableError(request, error$4, reason, null),\n          fatalError(request, error$4, reason, null);\n      }\n    }\n    function addToReplayParent(node, parentKeyPath, trackedPostpones) {\n      if (null === parentKeyPath) trackedPostpones.rootNodes.push(node);\n      else {\n        var workingMap = trackedPostpones.workingMap,\n          parentNode = workingMap.get(parentKeyPath);\n        void 0 === parentNode &&\n          ((parentNode = [parentKeyPath[1], parentKeyPath[2], [], null]),\n          workingMap.set(parentKeyPath, parentNode),\n          addToReplayParent(parentNode, parentKeyPath[0], trackedPostpones));\n        parentNode[2].push(node);\n      }\n    }\n    function getPostponedState(request) {\n      var trackedPostpones = request.trackedPostpones;\n      if (\n        null === trackedPostpones ||\n        (0 === trackedPostpones.rootNodes.length &&\n          null === trackedPostpones.rootSlots)\n      )\n        return (request.trackedPostpones = null);\n      if (\n        null === request.completedRootSegment ||\n        (request.completedRootSegment.status !== POSTPONED &&\n          null !== request.completedPreambleSegments)\n      ) {\n        var nextSegmentId = request.nextSegmentId;\n        var replaySlots = trackedPostpones.rootSlots;\n        var resumableState = request.resumableState;\n        resumableState.bootstrapScriptContent = void 0;\n        resumableState.bootstrapScripts = void 0;\n        resumableState.bootstrapModules = void 0;\n      } else {\n        nextSegmentId = 0;\n        replaySlots = -1;\n        resumableState = request.resumableState;\n        var renderState = request.renderState;\n        resumableState.nextFormID = 0;\n        resumableState.hasBody = !1;\n        resumableState.hasHtml = !1;\n        resumableState.unknownResources = { font: renderState.resets.font };\n        resumableState.dnsResources = renderState.resets.dns;\n        resumableState.connectResources = renderState.resets.connect;\n        resumableState.imageResources = renderState.resets.image;\n        resumableState.styleResources = renderState.resets.style;\n        resumableState.scriptResources = {};\n        resumableState.moduleUnknownResources = {};\n        resumableState.moduleScriptResources = {};\n        resumableState.instructions = NothingSent;\n      }\n      return {\n        nextSegmentId: nextSegmentId,\n        rootFormatContext: request.rootFormatContext,\n        progressiveChunkSize: request.progressiveChunkSize,\n        resumableState: request.resumableState,\n        replayNodes: trackedPostpones.rootNodes,\n        replaySlots: replaySlots\n      };\n    }\n    function ensureCorrectIsomorphicReactVersion() {\n      var isomorphicReactPackageVersion = React.version;\n      if (\"19.2.0\" !== isomorphicReactPackageVersion)\n        throw Error(\n          'Incompatible React versions: The \"react\" and \"react-dom\" packages must have the exact same version. Instead got:\\n  - react:      ' +\n            (isomorphicReactPackageVersion +\n              \"\\n  - react-dom:  19.2.0\\nLearn more: https://react.dev/warnings/version-mismatch\")\n        );\n    }\n    var React = __webpack_require__(/*! react */ \"./node_modules/react/index.js\"),\n      ReactDOM = __webpack_require__(/*! react-dom */ \"./node_modules/react-dom/index.js\"),\n      REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n      REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n      REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\n      REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\n      REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\"),\n      REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\n      REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\n      REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\n      REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\n      REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"),\n      REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\n      REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\n      REACT_SCOPE_TYPE = Symbol.for(\"react.scope\"),\n      REACT_ACTIVITY_TYPE = Symbol.for(\"react.activity\"),\n      REACT_LEGACY_HIDDEN_TYPE = Symbol.for(\"react.legacy_hidden\"),\n      REACT_MEMO_CACHE_SENTINEL = Symbol.for(\"react.memo_cache_sentinel\"),\n      REACT_VIEW_TRANSITION_TYPE = Symbol.for(\"react.view_transition\"),\n      MAYBE_ITERATOR_SYMBOL = Symbol.iterator,\n      isArrayImpl = Array.isArray,\n      jsxPropsParents = new WeakMap(),\n      jsxChildrenParents = new WeakMap(),\n      CLIENT_REFERENCE_TAG = Symbol.for(\"react.client.reference\"),\n      channel = new MessageChannel(),\n      taskQueue = [];\n    channel.port1.onmessage = function () {\n      var task = taskQueue.shift();\n      task && task();\n    };\n    var LocalPromise = Promise,\n      scheduleMicrotask =\n        \"function\" === typeof queueMicrotask\n          ? queueMicrotask\n          : function (callback) {\n              LocalPromise.resolve(null)\n                .then(callback)\n                .catch(handleErrorInNextTick);\n            },\n      currentView = null,\n      writtenBytes = 0,\n      textEncoder = new TextEncoder(),\n      assign = Object.assign,\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      VALID_ATTRIBUTE_NAME_REGEX = RegExp(\n        \"^[:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD][:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]*$\"\n      ),\n      illegalAttributeNameCache = {},\n      validatedAttributeNameCache = {},\n      unitlessNumbers = new Set(\n        \"animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp\".split(\n          \" \"\n        )\n      ),\n      aliases = new Map([\n        [\"acceptCharset\", \"accept-charset\"],\n        [\"htmlFor\", \"for\"],\n        [\"httpEquiv\", \"http-equiv\"],\n        [\"crossOrigin\", \"crossorigin\"],\n        [\"accentHeight\", \"accent-height\"],\n        [\"alignmentBaseline\", \"alignment-baseline\"],\n        [\"arabicForm\", \"arabic-form\"],\n        [\"baselineShift\", \"baseline-shift\"],\n        [\"capHeight\", \"cap-height\"],\n        [\"clipPath\", \"clip-path\"],\n        [\"clipRule\", \"clip-rule\"],\n        [\"colorInterpolation\", \"color-interpolation\"],\n        [\"colorInterpolationFilters\", \"color-interpolation-filters\"],\n        [\"colorProfile\", \"color-profile\"],\n        [\"colorRendering\", \"color-rendering\"],\n        [\"dominantBaseline\", \"dominant-baseline\"],\n        [\"enableBackground\", \"enable-background\"],\n        [\"fillOpacity\", \"fill-opacity\"],\n        [\"fillRule\", \"fill-rule\"],\n        [\"floodColor\", \"flood-color\"],\n        [\"floodOpacity\", \"flood-opacity\"],\n        [\"fontFamily\", \"font-family\"],\n        [\"fontSize\", \"font-size\"],\n        [\"fontSizeAdjust\", \"font-size-adjust\"],\n        [\"fontStretch\", \"font-stretch\"],\n        [\"fontStyle\", \"font-style\"],\n        [\"fontVariant\", \"font-variant\"],\n        [\"fontWeight\", \"font-weight\"],\n        [\"glyphName\", \"glyph-name\"],\n        [\"glyphOrientationHorizontal\", \"glyph-orientation-horizontal\"],\n        [\"glyphOrientationVertical\", \"glyph-orientation-vertical\"],\n        [\"horizAdvX\", \"horiz-adv-x\"],\n        [\"horizOriginX\", \"horiz-origin-x\"],\n        [\"imageRendering\", \"image-rendering\"],\n        [\"letterSpacing\", \"letter-spacing\"],\n        [\"lightingColor\", \"lighting-color\"],\n        [\"markerEnd\", \"marker-end\"],\n        [\"markerMid\", \"marker-mid\"],\n        [\"markerStart\", \"marker-start\"],\n        [\"overlinePosition\", \"overline-position\"],\n        [\"overlineThickness\", \"overline-thickness\"],\n        [\"paintOrder\", \"paint-order\"],\n        [\"panose-1\", \"panose-1\"],\n        [\"pointerEvents\", \"pointer-events\"],\n        [\"renderingIntent\", \"rendering-intent\"],\n        [\"shapeRendering\", \"shape-rendering\"],\n        [\"stopColor\", \"stop-color\"],\n        [\"stopOpacity\", \"stop-opacity\"],\n        [\"strikethroughPosition\", \"strikethrough-position\"],\n        [\"strikethroughThickness\", \"strikethrough-thickness\"],\n        [\"strokeDasharray\", \"stroke-dasharray\"],\n        [\"strokeDashoffset\", \"stroke-dashoffset\"],\n        [\"strokeLinecap\", \"stroke-linecap\"],\n        [\"strokeLinejoin\", \"stroke-linejoin\"],\n        [\"strokeMiterlimit\", \"stroke-miterlimit\"],\n        [\"strokeOpacity\", \"stroke-opacity\"],\n        [\"strokeWidth\", \"stroke-width\"],\n        [\"textAnchor\", \"text-anchor\"],\n        [\"textDecoration\", \"text-decoration\"],\n        [\"textRendering\", \"text-rendering\"],\n        [\"transformOrigin\", \"transform-origin\"],\n        [\"underlinePosition\", \"underline-position\"],\n        [\"underlineThickness\", \"underline-thickness\"],\n        [\"unicodeBidi\", \"unicode-bidi\"],\n        [\"unicodeRange\", \"unicode-range\"],\n        [\"unitsPerEm\", \"units-per-em\"],\n        [\"vAlphabetic\", \"v-alphabetic\"],\n        [\"vHanging\", \"v-hanging\"],\n        [\"vIdeographic\", \"v-ideographic\"],\n        [\"vMathematical\", \"v-mathematical\"],\n        [\"vectorEffect\", \"vector-effect\"],\n        [\"vertAdvY\", \"vert-adv-y\"],\n        [\"vertOriginX\", \"vert-origin-x\"],\n        [\"vertOriginY\", \"vert-origin-y\"],\n        [\"wordSpacing\", \"word-spacing\"],\n        [\"writingMode\", \"writing-mode\"],\n        [\"xmlnsXlink\", \"xmlns:xlink\"],\n        [\"xHeight\", \"x-height\"]\n      ]),\n      hasReadOnlyValue = {\n        button: !0,\n        checkbox: !0,\n        image: !0,\n        hidden: !0,\n        radio: !0,\n        reset: !0,\n        submit: !0\n      },\n      ariaProperties = {\n        \"aria-current\": 0,\n        \"aria-description\": 0,\n        \"aria-details\": 0,\n        \"aria-disabled\": 0,\n        \"aria-hidden\": 0,\n        \"aria-invalid\": 0,\n        \"aria-keyshortcuts\": 0,\n        \"aria-label\": 0,\n        \"aria-roledescription\": 0,\n        \"aria-autocomplete\": 0,\n        \"aria-checked\": 0,\n        \"aria-expanded\": 0,\n        \"aria-haspopup\": 0,\n        \"aria-level\": 0,\n        \"aria-modal\": 0,\n        \"aria-multiline\": 0,\n        \"aria-multiselectable\": 0,\n        \"aria-orientation\": 0,\n        \"aria-placeholder\": 0,\n        \"aria-pressed\": 0,\n        \"aria-readonly\": 0,\n        \"aria-required\": 0,\n        \"aria-selected\": 0,\n        \"aria-sort\": 0,\n        \"aria-valuemax\": 0,\n        \"aria-valuemin\": 0,\n        \"aria-valuenow\": 0,\n        \"aria-valuetext\": 0,\n        \"aria-atomic\": 0,\n        \"aria-busy\": 0,\n        \"aria-live\": 0,\n        \"aria-relevant\": 0,\n        \"aria-dropeffect\": 0,\n        \"aria-grabbed\": 0,\n        \"aria-activedescendant\": 0,\n        \"aria-colcount\": 0,\n        \"aria-colindex\": 0,\n        \"aria-colspan\": 0,\n        \"aria-controls\": 0,\n        \"aria-describedby\": 0,\n        \"aria-errormessage\": 0,\n        \"aria-flowto\": 0,\n        \"aria-labelledby\": 0,\n        \"aria-owns\": 0,\n        \"aria-posinset\": 0,\n        \"aria-rowcount\": 0,\n        \"aria-rowindex\": 0,\n        \"aria-rowspan\": 0,\n        \"aria-setsize\": 0,\n        \"aria-braillelabel\": 0,\n        \"aria-brailleroledescription\": 0,\n        \"aria-colindextext\": 0,\n        \"aria-rowindextext\": 0\n      },\n      warnedProperties$1 = {},\n      rARIA$1 = RegExp(\n        \"^(aria)-[:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]*$\"\n      ),\n      rARIACamel$1 = RegExp(\n        \"^(aria)[A-Z][:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]*$\"\n      ),\n      didWarnValueNull = !1,\n      possibleStandardNames = {\n        accept: \"accept\",\n        acceptcharset: \"acceptCharset\",\n        \"accept-charset\": \"acceptCharset\",\n        accesskey: \"accessKey\",\n        action: \"action\",\n        allowfullscreen: \"allowFullScreen\",\n        alt: \"alt\",\n        as: \"as\",\n        async: \"async\",\n        autocapitalize: \"autoCapitalize\",\n        autocomplete: \"autoComplete\",\n        autocorrect: \"autoCorrect\",\n        autofocus: \"autoFocus\",\n        autoplay: \"autoPlay\",\n        autosave: \"autoSave\",\n        capture: \"capture\",\n        cellpadding: \"cellPadding\",\n        cellspacing: \"cellSpacing\",\n        challenge: \"challenge\",\n        charset: \"charSet\",\n        checked: \"checked\",\n        children: \"children\",\n        cite: \"cite\",\n        class: \"className\",\n        classid: \"classID\",\n        classname: \"className\",\n        cols: \"cols\",\n        colspan: \"colSpan\",\n        content: \"content\",\n        contenteditable: \"contentEditable\",\n        contextmenu: \"contextMenu\",\n        controls: \"controls\",\n        controlslist: \"controlsList\",\n        coords: \"coords\",\n        crossorigin: \"crossOrigin\",\n        dangerouslysetinnerhtml: \"dangerouslySetInnerHTML\",\n        data: \"data\",\n        datetime: \"dateTime\",\n        default: \"default\",\n        defaultchecked: \"defaultChecked\",\n        defaultvalue: \"defaultValue\",\n        defer: \"defer\",\n        dir: \"dir\",\n        disabled: \"disabled\",\n        disablepictureinpicture: \"disablePictureInPicture\",\n        disableremoteplayback: \"disableRemotePlayback\",\n        download: \"download\",\n        draggable: \"draggable\",\n        enctype: \"encType\",\n        enterkeyhint: \"enterKeyHint\",\n        fetchpriority: \"fetchPriority\",\n        for: \"htmlFor\",\n        form: \"form\",\n        formmethod: \"formMethod\",\n        formaction: \"formAction\",\n        formenctype: \"formEncType\",\n        formnovalidate: \"formNoValidate\",\n        formtarget: \"formTarget\",\n        frameborder: \"frameBorder\",\n        headers: \"headers\",\n        height: \"height\",\n        hidden: \"hidden\",\n        high: \"high\",\n        href: \"href\",\n        hreflang: \"hrefLang\",\n        htmlfor: \"htmlFor\",\n        httpequiv: \"httpEquiv\",\n        \"http-equiv\": \"httpEquiv\",\n        icon: \"icon\",\n        id: \"id\",\n        imagesizes: \"imageSizes\",\n        imagesrcset: \"imageSrcSet\",\n        inert: \"inert\",\n        innerhtml: \"innerHTML\",\n        inputmode: \"inputMode\",\n        integrity: \"integrity\",\n        is: \"is\",\n        itemid: \"itemID\",\n        itemprop: \"itemProp\",\n        itemref: \"itemRef\",\n        itemscope: \"itemScope\",\n        itemtype: \"itemType\",\n        keyparams: \"keyParams\",\n        keytype: \"keyType\",\n        kind: \"kind\",\n        label: \"label\",\n        lang: \"lang\",\n        list: \"list\",\n        loop: \"loop\",\n        low: \"low\",\n        manifest: \"manifest\",\n        marginwidth: \"marginWidth\",\n        marginheight: \"marginHeight\",\n        max: \"max\",\n        maxlength: \"maxLength\",\n        media: \"media\",\n        mediagroup: \"mediaGroup\",\n        method: \"method\",\n        min: \"min\",\n        minlength: \"minLength\",\n        multiple: \"multiple\",\n        muted: \"muted\",\n        name: \"name\",\n        nomodule: \"noModule\",\n        nonce: \"nonce\",\n        novalidate: \"noValidate\",\n        open: \"open\",\n        optimum: \"optimum\",\n        pattern: \"pattern\",\n        placeholder: \"placeholder\",\n        playsinline: \"playsInline\",\n        poster: \"poster\",\n        preload: \"preload\",\n        profile: \"profile\",\n        radiogroup: \"radioGroup\",\n        readonly: \"readOnly\",\n        referrerpolicy: \"referrerPolicy\",\n        rel: \"rel\",\n        required: \"required\",\n        reversed: \"reversed\",\n        role: \"role\",\n        rows: \"rows\",\n        rowspan: \"rowSpan\",\n        sandbox: \"sandbox\",\n        scope: \"scope\",\n        scoped: \"scoped\",\n        scrolling: \"scrolling\",\n        seamless: \"seamless\",\n        selected: \"selected\",\n        shape: \"shape\",\n        size: \"size\",\n        sizes: \"sizes\",\n        span: \"span\",\n        spellcheck: \"spellCheck\",\n        src: \"src\",\n        srcdoc: \"srcDoc\",\n        srclang: \"srcLang\",\n        srcset: \"srcSet\",\n        start: \"start\",\n        step: \"step\",\n        style: \"style\",\n        summary: \"summary\",\n        tabindex: \"tabIndex\",\n        target: \"target\",\n        title: \"title\",\n        type: \"type\",\n        usemap: \"useMap\",\n        value: \"value\",\n        width: \"width\",\n        wmode: \"wmode\",\n        wrap: \"wrap\",\n        about: \"about\",\n        accentheight: \"accentHeight\",\n        \"accent-height\": \"accentHeight\",\n        accumulate: \"accumulate\",\n        additive: \"additive\",\n        alignmentbaseline: \"alignmentBaseline\",\n        \"alignment-baseline\": \"alignmentBaseline\",\n        allowreorder: \"allowReorder\",\n        alphabetic: \"alphabetic\",\n        amplitude: \"amplitude\",\n        arabicform: \"arabicForm\",\n        \"arabic-form\": \"arabicForm\",\n        ascent: \"ascent\",\n        attributename: \"attributeName\",\n        attributetype: \"attributeType\",\n        autoreverse: \"autoReverse\",\n        azimuth: \"azimuth\",\n        basefrequency: \"baseFrequency\",\n        baselineshift: \"baselineShift\",\n        \"baseline-shift\": \"baselineShift\",\n        baseprofile: \"baseProfile\",\n        bbox: \"bbox\",\n        begin: \"begin\",\n        bias: \"bias\",\n        by: \"by\",\n        calcmode: \"calcMode\",\n        capheight: \"capHeight\",\n        \"cap-height\": \"capHeight\",\n        clip: \"clip\",\n        clippath: \"clipPath\",\n        \"clip-path\": \"clipPath\",\n        clippathunits: \"clipPathUnits\",\n        cliprule: \"clipRule\",\n        \"clip-rule\": \"clipRule\",\n        color: \"color\",\n        colorinterpolation: \"colorInterpolation\",\n        \"color-interpolation\": \"colorInterpolation\",\n        colorinterpolationfilters: \"colorInterpolationFilters\",\n        \"color-interpolation-filters\": \"colorInterpolationFilters\",\n        colorprofile: \"colorProfile\",\n        \"color-profile\": \"colorProfile\",\n        colorrendering: \"colorRendering\",\n        \"color-rendering\": \"colorRendering\",\n        contentscripttype: \"contentScriptType\",\n        contentstyletype: \"contentStyleType\",\n        cursor: \"cursor\",\n        cx: \"cx\",\n        cy: \"cy\",\n        d: \"d\",\n        datatype: \"datatype\",\n        decelerate: \"decelerate\",\n        descent: \"descent\",\n        diffuseconstant: \"diffuseConstant\",\n        direction: \"direction\",\n        display: \"display\",\n        divisor: \"divisor\",\n        dominantbaseline: \"dominantBaseline\",\n        \"dominant-baseline\": \"dominantBaseline\",\n        dur: \"dur\",\n        dx: \"dx\",\n        dy: \"dy\",\n        edgemode: \"edgeMode\",\n        elevation: \"elevation\",\n        enablebackground: \"enableBackground\",\n        \"enable-background\": \"enableBackground\",\n        end: \"end\",\n        exponent: \"exponent\",\n        externalresourcesrequired: \"externalResourcesRequired\",\n        fill: \"fill\",\n        fillopacity: \"fillOpacity\",\n        \"fill-opacity\": \"fillOpacity\",\n        fillrule: \"fillRule\",\n        \"fill-rule\": \"fillRule\",\n        filter: \"filter\",\n        filterres: \"filterRes\",\n        filterunits: \"filterUnits\",\n        floodopacity: \"floodOpacity\",\n        \"flood-opacity\": \"floodOpacity\",\n        floodcolor: \"floodColor\",\n        \"flood-color\": \"floodColor\",\n        focusable: \"focusable\",\n        fontfamily: \"fontFamily\",\n        \"font-family\": \"fontFamily\",\n        fontsize: \"fontSize\",\n        \"font-size\": \"fontSize\",\n        fontsizeadjust: \"fontSizeAdjust\",\n        \"font-size-adjust\": \"fontSizeAdjust\",\n        fontstretch: \"fontStretch\",\n        \"font-stretch\": \"fontStretch\",\n        fontstyle: \"fontStyle\",\n        \"font-style\": \"fontStyle\",\n        fontvariant: \"fontVariant\",\n        \"font-variant\": \"fontVariant\",\n        fontweight: \"fontWeight\",\n        \"font-weight\": \"fontWeight\",\n        format: \"format\",\n        from: \"from\",\n        fx: \"fx\",\n        fy: \"fy\",\n        g1: \"g1\",\n        g2: \"g2\",\n        glyphname: \"glyphName\",\n        \"glyph-name\": \"glyphName\",\n        glyphorientationhorizontal: \"glyphOrientationHorizontal\",\n        \"glyph-orientation-horizontal\": \"glyphOrientationHorizontal\",\n        glyphorientationvertical: \"glyphOrientationVertical\",\n        \"glyph-orientation-vertical\": \"glyphOrientationVertical\",\n        glyphref: \"glyphRef\",\n        gradienttransform: \"gradientTransform\",\n        gradientunits: \"gradientUnits\",\n        hanging: \"hanging\",\n        horizadvx: \"horizAdvX\",\n        \"horiz-adv-x\": \"horizAdvX\",\n        horizoriginx: \"horizOriginX\",\n        \"horiz-origin-x\": \"horizOriginX\",\n        ideographic: \"ideographic\",\n        imagerendering: \"imageRendering\",\n        \"image-rendering\": \"imageRendering\",\n        in2: \"in2\",\n        in: \"in\",\n        inlist: \"inlist\",\n        intercept: \"intercept\",\n        k1: \"k1\",\n        k2: \"k2\",\n        k3: \"k3\",\n        k4: \"k4\",\n        k: \"k\",\n        kernelmatrix: \"kernelMatrix\",\n        kernelunitlength: \"kernelUnitLength\",\n        kerning: \"kerning\",\n        keypoints: \"keyPoints\",\n        keysplines: \"keySplines\",\n        keytimes: \"keyTimes\",\n        lengthadjust: \"lengthAdjust\",\n        letterspacing: \"letterSpacing\",\n        \"letter-spacing\": \"letterSpacing\",\n        lightingcolor: \"lightingColor\",\n        \"lighting-color\": \"lightingColor\",\n        limitingconeangle: \"limitingConeAngle\",\n        local: \"local\",\n        markerend: \"markerEnd\",\n        \"marker-end\": \"markerEnd\",\n        markerheight: \"markerHeight\",\n        markermid: \"markerMid\",\n        \"marker-mid\": \"markerMid\",\n        markerstart: \"markerStart\",\n        \"marker-start\": \"markerStart\",\n        markerunits: \"markerUnits\",\n        markerwidth: \"markerWidth\",\n        mask: \"mask\",\n        maskcontentunits: \"maskContentUnits\",\n        maskunits: \"maskUnits\",\n        mathematical: \"mathematical\",\n        mode: \"mode\",\n        numoctaves: \"numOctaves\",\n        offset: \"offset\",\n        opacity: \"opacity\",\n        operator: \"operator\",\n        order: \"order\",\n        orient: \"orient\",\n        orientation: \"orientation\",\n        origin: \"origin\",\n        overflow: \"overflow\",\n        overlineposition: \"overlinePosition\",\n        \"overline-position\": \"overlinePosition\",\n        overlinethickness: \"overlineThickness\",\n        \"overline-thickness\": \"overlineThickness\",\n        paintorder: \"paintOrder\",\n        \"paint-order\": \"paintOrder\",\n        panose1: \"panose1\",\n        \"panose-1\": \"panose1\",\n        pathlength: \"pathLength\",\n        patterncontentunits: \"patternContentUnits\",\n        patterntransform: \"patternTransform\",\n        patternunits: \"patternUnits\",\n        pointerevents: \"pointerEvents\",\n        \"pointer-events\": \"pointerEvents\",\n        points: \"points\",\n        pointsatx: \"pointsAtX\",\n        pointsaty: \"pointsAtY\",\n        pointsatz: \"pointsAtZ\",\n        popover: \"popover\",\n        popovertarget: \"popoverTarget\",\n        popovertargetaction: \"popoverTargetAction\",\n        prefix: \"prefix\",\n        preservealpha: \"preserveAlpha\",\n        preserveaspectratio: \"preserveAspectRatio\",\n        primitiveunits: \"primitiveUnits\",\n        property: \"property\",\n        r: \"r\",\n        radius: \"radius\",\n        refx: \"refX\",\n        refy: \"refY\",\n        renderingintent: \"renderingIntent\",\n        \"rendering-intent\": \"renderingIntent\",\n        repeatcount: \"repeatCount\",\n        repeatdur: \"repeatDur\",\n        requiredextensions: \"requiredExtensions\",\n        requiredfeatures: \"requiredFeatures\",\n        resource: \"resource\",\n        restart: \"restart\",\n        result: \"result\",\n        results: \"results\",\n        rotate: \"rotate\",\n        rx: \"rx\",\n        ry: \"ry\",\n        scale: \"scale\",\n        security: \"security\",\n        seed: \"seed\",\n        shaperendering: \"shapeRendering\",\n        \"shape-rendering\": \"shapeRendering\",\n        slope: \"slope\",\n        spacing: \"spacing\",\n        specularconstant: \"specularConstant\",\n        specularexponent: \"specularExponent\",\n        speed: \"speed\",\n        spreadmethod: \"spreadMethod\",\n        startoffset: \"startOffset\",\n        stddeviation: \"stdDeviation\",\n        stemh: \"stemh\",\n        stemv: \"stemv\",\n        stitchtiles: \"stitchTiles\",\n        stopcolor: \"stopColor\",\n        \"stop-color\": \"stopColor\",\n        stopopacity: \"stopOpacity\",\n        \"stop-opacity\": \"stopOpacity\",\n        strikethroughposition: \"strikethroughPosition\",\n        \"strikethrough-position\": \"strikethroughPosition\",\n        strikethroughthickness: \"strikethroughThickness\",\n        \"strikethrough-thickness\": \"strikethroughThickness\",\n        string: \"string\",\n        stroke: \"stroke\",\n        strokedasharray: \"strokeDasharray\",\n        \"stroke-dasharray\": \"strokeDasharray\",\n        strokedashoffset: \"strokeDashoffset\",\n        \"stroke-dashoffset\": \"strokeDashoffset\",\n        strokelinecap: \"strokeLinecap\",\n        \"stroke-linecap\": \"strokeLinecap\",\n        strokelinejoin: \"strokeLinejoin\",\n        \"stroke-linejoin\": \"strokeLinejoin\",\n        strokemiterlimit: \"strokeMiterlimit\",\n        \"stroke-miterlimit\": \"strokeMiterlimit\",\n        strokewidth: \"strokeWidth\",\n        \"stroke-width\": \"strokeWidth\",\n        strokeopacity: \"strokeOpacity\",\n        \"stroke-opacity\": \"strokeOpacity\",\n        suppresscontenteditablewarning: \"suppressContentEditableWarning\",\n        suppresshydrationwarning: \"suppressHydrationWarning\",\n        surfacescale: \"surfaceScale\",\n        systemlanguage: \"systemLanguage\",\n        tablevalues: \"tableValues\",\n        targetx: \"targetX\",\n        targety: \"targetY\",\n        textanchor: \"textAnchor\",\n        \"text-anchor\": \"textAnchor\",\n        textdecoration: \"textDecoration\",\n        \"text-decoration\": \"textDecoration\",\n        textlength: \"textLength\",\n        textrendering: \"textRendering\",\n        \"text-rendering\": \"textRendering\",\n        to: \"to\",\n        transform: \"transform\",\n        transformorigin: \"transformOrigin\",\n        \"transform-origin\": \"transformOrigin\",\n        typeof: \"typeof\",\n        u1: \"u1\",\n        u2: \"u2\",\n        underlineposition: \"underlinePosition\",\n        \"underline-position\": \"underlinePosition\",\n        underlinethickness: \"underlineThickness\",\n        \"underline-thickness\": \"underlineThickness\",\n        unicode: \"unicode\",\n        unicodebidi: \"unicodeBidi\",\n        \"unicode-bidi\": \"unicodeBidi\",\n        unicoderange: \"unicodeRange\",\n        \"unicode-range\": \"unicodeRange\",\n        unitsperem: \"unitsPerEm\",\n        \"units-per-em\": \"unitsPerEm\",\n        unselectable: \"unselectable\",\n        valphabetic: \"vAlphabetic\",\n        \"v-alphabetic\": \"vAlphabetic\",\n        values: \"values\",\n        vectoreffect: \"vectorEffect\",\n        \"vector-effect\": \"vectorEffect\",\n        version: \"version\",\n        vertadvy: \"vertAdvY\",\n        \"vert-adv-y\": \"vertAdvY\",\n        vertoriginx: \"vertOriginX\",\n        \"vert-origin-x\": \"vertOriginX\",\n        vertoriginy: \"vertOriginY\",\n        \"vert-origin-y\": \"vertOriginY\",\n        vhanging: \"vHanging\",\n        \"v-hanging\": \"vHanging\",\n        videographic: \"vIdeographic\",\n        \"v-ideographic\": \"vIdeographic\",\n        viewbox: \"viewBox\",\n        viewtarget: \"viewTarget\",\n        visibility: \"visibility\",\n        vmathematical: \"vMathematical\",\n        \"v-mathematical\": \"vMathematical\",\n        vocab: \"vocab\",\n        widths: \"widths\",\n        wordspacing: \"wordSpacing\",\n        \"word-spacing\": \"wordSpacing\",\n        writingmode: \"writingMode\",\n        \"writing-mode\": \"writingMode\",\n        x1: \"x1\",\n        x2: \"x2\",\n        x: \"x\",\n        xchannelselector: \"xChannelSelector\",\n        xheight: \"xHeight\",\n        \"x-height\": \"xHeight\",\n        xlinkactuate: \"xlinkActuate\",\n        \"xlink:actuate\": \"xlinkActuate\",\n        xlinkarcrole: \"xlinkArcrole\",\n        \"xlink:arcrole\": \"xlinkArcrole\",\n        xlinkhref: \"xlinkHref\",\n        \"xlink:href\": \"xlinkHref\",\n        xlinkrole: \"xlinkRole\",\n        \"xlink:role\": \"xlinkRole\",\n        xlinkshow: \"xlinkShow\",\n        \"xlink:show\": \"xlinkShow\",\n        xlinktitle: \"xlinkTitle\",\n        \"xlink:title\": \"xlinkTitle\",\n        xlinktype: \"xlinkType\",\n        \"xlink:type\": \"xlinkType\",\n        xmlbase: \"xmlBase\",\n        \"xml:base\": \"xmlBase\",\n        xmllang: \"xmlLang\",\n        \"xml:lang\": \"xmlLang\",\n        xmlns: \"xmlns\",\n        \"xml:space\": \"xmlSpace\",\n        xmlnsxlink: \"xmlnsXlink\",\n        \"xmlns:xlink\": \"xmlnsXlink\",\n        xmlspace: \"xmlSpace\",\n        y1: \"y1\",\n        y2: \"y2\",\n        y: \"y\",\n        ychannelselector: \"yChannelSelector\",\n        z: \"z\",\n        zoomandpan: \"zoomAndPan\"\n      },\n      warnedProperties = {},\n      EVENT_NAME_REGEX = /^on./,\n      INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/,\n      rARIA = RegExp(\n        \"^(aria)-[:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]*$\"\n      ),\n      rARIACamel = RegExp(\n        \"^(aria)[A-Z][:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]*$\"\n      ),\n      badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/,\n      msPattern$1 = /^-ms-/,\n      hyphenPattern = /-(.)/g,\n      badStyleValueWithSemicolonPattern = /;\\s*$/,\n      warnedStyleNames = {},\n      warnedStyleValues = {},\n      warnedForNaNValue = !1,\n      warnedForInfinityValue = !1,\n      matchHtmlRegExp = /[\"'&<>]/,\n      uppercasePattern = /([A-Z])/g,\n      msPattern = /^ms-/,\n      isJavaScriptProtocol =\n        /^[\\u0000-\\u001F ]*j[\\r\\n\\t]*a[\\r\\n\\t]*v[\\r\\n\\t]*a[\\r\\n\\t]*s[\\r\\n\\t]*c[\\r\\n\\t]*r[\\r\\n\\t]*i[\\r\\n\\t]*p[\\r\\n\\t]*t[\\r\\n\\t]*:/i,\n      ReactSharedInternals =\n        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n      ReactDOMSharedInternals =\n        ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n      NotPending = Object.freeze({\n        pending: !1,\n        data: null,\n        method: null,\n        action: null\n      }),\n      previousDispatcher = ReactDOMSharedInternals.d;\n    ReactDOMSharedInternals.d = {\n      f: previousDispatcher.f,\n      r: previousDispatcher.r,\n      D: function (href) {\n        var request = currentRequest ? currentRequest : null;\n        if (request) {\n          var resumableState = request.resumableState,\n            renderState = request.renderState;\n          if (\"string\" === typeof href && href) {\n            if (!resumableState.dnsResources.hasOwnProperty(href)) {\n              resumableState.dnsResources[href] = EXISTS;\n              resumableState = renderState.headers;\n              var header, JSCompiler_temp;\n              if (\n                (JSCompiler_temp =\n                  resumableState && 0 < resumableState.remainingCapacity)\n              )\n                JSCompiler_temp =\n                  ((header =\n                    \"<\" +\n                    escapeHrefForLinkHeaderURLContext(href) +\n                    \">; rel=dns-prefetch\"),\n                  0 <= (resumableState.remainingCapacity -= header.length + 2));\n              JSCompiler_temp\n                ? ((renderState.resets.dns[href] = EXISTS),\n                  resumableState.preconnects &&\n                    (resumableState.preconnects += \", \"),\n                  (resumableState.preconnects += header))\n                : ((header = []),\n                  pushLinkImpl(header, { href: href, rel: \"dns-prefetch\" }),\n                  renderState.preconnects.add(header));\n            }\n            enqueueFlush(request);\n          }\n        } else previousDispatcher.D(href);\n      },\n      C: function (href, crossOrigin) {\n        var request = currentRequest ? currentRequest : null;\n        if (request) {\n          var resumableState = request.resumableState,\n            renderState = request.renderState;\n          if (\"string\" === typeof href && href) {\n            var bucket =\n              \"use-credentials\" === crossOrigin\n                ? \"credentials\"\n                : \"string\" === typeof crossOrigin\n                  ? \"anonymous\"\n                  : \"default\";\n            if (!resumableState.connectResources[bucket].hasOwnProperty(href)) {\n              resumableState.connectResources[bucket][href] = EXISTS;\n              resumableState = renderState.headers;\n              var header, JSCompiler_temp;\n              if (\n                (JSCompiler_temp =\n                  resumableState && 0 < resumableState.remainingCapacity)\n              ) {\n                JSCompiler_temp =\n                  \"<\" +\n                  escapeHrefForLinkHeaderURLContext(href) +\n                  \">; rel=preconnect\";\n                if (\"string\" === typeof crossOrigin) {\n                  var escapedCrossOrigin =\n                    escapeStringForLinkHeaderQuotedParamValueContext(\n                      crossOrigin,\n                      \"crossOrigin\"\n                    );\n                  JSCompiler_temp +=\n                    '; crossorigin=\"' + escapedCrossOrigin + '\"';\n                }\n                JSCompiler_temp =\n                  ((header = JSCompiler_temp),\n                  0 <= (resumableState.remainingCapacity -= header.length + 2));\n              }\n              JSCompiler_temp\n                ? ((renderState.resets.connect[bucket][href] = EXISTS),\n                  resumableState.preconnects &&\n                    (resumableState.preconnects += \", \"),\n                  (resumableState.preconnects += header))\n                : ((bucket = []),\n                  pushLinkImpl(bucket, {\n                    rel: \"preconnect\",\n                    href: href,\n                    crossOrigin: crossOrigin\n                  }),\n                  renderState.preconnects.add(bucket));\n            }\n            enqueueFlush(request);\n          }\n        } else previousDispatcher.C(href, crossOrigin);\n      },\n      L: function (href, as, options) {\n        var request = currentRequest ? currentRequest : null;\n        if (request) {\n          var resumableState = request.resumableState,\n            renderState = request.renderState;\n          if (as && href) {\n            switch (as) {\n              case \"image\":\n                if (options) {\n                  var imageSrcSet = options.imageSrcSet;\n                  var imageSizes = options.imageSizes;\n                  var fetchPriority = options.fetchPriority;\n                }\n                var key = imageSrcSet\n                  ? imageSrcSet + \"\\n\" + (imageSizes || \"\")\n                  : href;\n                if (resumableState.imageResources.hasOwnProperty(key)) return;\n                resumableState.imageResources[key] = PRELOAD_NO_CREDS;\n                resumableState = renderState.headers;\n                var header;\n                resumableState &&\n                0 < resumableState.remainingCapacity &&\n                \"string\" !== typeof imageSrcSet &&\n                \"high\" === fetchPriority &&\n                ((header = getPreloadAsHeader(href, as, options)),\n                0 <= (resumableState.remainingCapacity -= header.length + 2))\n                  ? ((renderState.resets.image[key] = PRELOAD_NO_CREDS),\n                    resumableState.highImagePreloads &&\n                      (resumableState.highImagePreloads += \", \"),\n                    (resumableState.highImagePreloads += header))\n                  : ((resumableState = []),\n                    pushLinkImpl(\n                      resumableState,\n                      assign(\n                        {\n                          rel: \"preload\",\n                          href: imageSrcSet ? void 0 : href,\n                          as: as\n                        },\n                        options\n                      )\n                    ),\n                    \"high\" === fetchPriority\n                      ? renderState.highImagePreloads.add(resumableState)\n                      : (renderState.bulkPreloads.add(resumableState),\n                        renderState.preloads.images.set(key, resumableState)));\n                break;\n              case \"style\":\n                if (resumableState.styleResources.hasOwnProperty(href)) return;\n                imageSrcSet = [];\n                pushLinkImpl(\n                  imageSrcSet,\n                  assign({ rel: \"preload\", href: href, as: as }, options)\n                );\n                resumableState.styleResources[href] =\n                  !options ||\n                  (\"string\" !== typeof options.crossOrigin &&\n                    \"string\" !== typeof options.integrity)\n                    ? PRELOAD_NO_CREDS\n                    : [options.crossOrigin, options.integrity];\n                renderState.preloads.stylesheets.set(href, imageSrcSet);\n                renderState.bulkPreloads.add(imageSrcSet);\n                break;\n              case \"script\":\n                if (resumableState.scriptResources.hasOwnProperty(href)) return;\n                imageSrcSet = [];\n                renderState.preloads.scripts.set(href, imageSrcSet);\n                renderState.bulkPreloads.add(imageSrcSet);\n                pushLinkImpl(\n                  imageSrcSet,\n                  assign({ rel: \"preload\", href: href, as: as }, options)\n                );\n                resumableState.scriptResources[href] =\n                  !options ||\n                  (\"string\" !== typeof options.crossOrigin &&\n                    \"string\" !== typeof options.integrity)\n                    ? PRELOAD_NO_CREDS\n                    : [options.crossOrigin, options.integrity];\n                break;\n              default:\n                if (resumableState.unknownResources.hasOwnProperty(as)) {\n                  if (\n                    ((imageSrcSet = resumableState.unknownResources[as]),\n                    imageSrcSet.hasOwnProperty(href))\n                  )\n                    return;\n                } else\n                  (imageSrcSet = {}),\n                    (resumableState.unknownResources[as] = imageSrcSet);\n                imageSrcSet[href] = PRELOAD_NO_CREDS;\n                if (\n                  (resumableState = renderState.headers) &&\n                  0 < resumableState.remainingCapacity &&\n                  \"font\" === as &&\n                  ((key = getPreloadAsHeader(href, as, options)),\n                  0 <= (resumableState.remainingCapacity -= key.length + 2))\n                )\n                  (renderState.resets.font[href] = PRELOAD_NO_CREDS),\n                    resumableState.fontPreloads &&\n                      (resumableState.fontPreloads += \", \"),\n                    (resumableState.fontPreloads += key);\n                else\n                  switch (\n                    ((resumableState = []),\n                    (href = assign(\n                      { rel: \"preload\", href: href, as: as },\n                      options\n                    )),\n                    pushLinkImpl(resumableState, href),\n                    as)\n                  ) {\n                    case \"font\":\n                      renderState.fontPreloads.add(resumableState);\n                      break;\n                    default:\n                      renderState.bulkPreloads.add(resumableState);\n                  }\n            }\n            enqueueFlush(request);\n          }\n        } else previousDispatcher.L(href, as, options);\n      },\n      m: function (href, options) {\n        var request = currentRequest ? currentRequest : null;\n        if (request) {\n          var resumableState = request.resumableState,\n            renderState = request.renderState;\n          if (href) {\n            var as =\n              options && \"string\" === typeof options.as ? options.as : \"script\";\n            switch (as) {\n              case \"script\":\n                if (resumableState.moduleScriptResources.hasOwnProperty(href))\n                  return;\n                as = [];\n                resumableState.moduleScriptResources[href] =\n                  !options ||\n                  (\"string\" !== typeof options.crossOrigin &&\n                    \"string\" !== typeof options.integrity)\n                    ? PRELOAD_NO_CREDS\n                    : [options.crossOrigin, options.integrity];\n                renderState.preloads.moduleScripts.set(href, as);\n                break;\n              default:\n                if (resumableState.moduleUnknownResources.hasOwnProperty(as)) {\n                  var resources = resumableState.unknownResources[as];\n                  if (resources.hasOwnProperty(href)) return;\n                } else\n                  (resources = {}),\n                    (resumableState.moduleUnknownResources[as] = resources);\n                as = [];\n                resources[href] = PRELOAD_NO_CREDS;\n            }\n            pushLinkImpl(\n              as,\n              assign({ rel: \"modulepreload\", href: href }, options)\n            );\n            renderState.bulkPreloads.add(as);\n            enqueueFlush(request);\n          }\n        } else previousDispatcher.m(href, options);\n      },\n      X: function (src, options) {\n        var request = currentRequest ? currentRequest : null;\n        if (request) {\n          var resumableState = request.resumableState,\n            renderState = request.renderState;\n          if (src) {\n            var resourceState = resumableState.scriptResources.hasOwnProperty(\n              src\n            )\n              ? resumableState.scriptResources[src]\n              : void 0;\n            resourceState !== EXISTS &&\n              ((resumableState.scriptResources[src] = EXISTS),\n              (options = assign({ src: src, async: !0 }, options)),\n              resourceState &&\n                (2 === resourceState.length &&\n                  adoptPreloadCredentials(options, resourceState),\n                (src = renderState.preloads.scripts.get(src))) &&\n                (src.length = 0),\n              (src = []),\n              renderState.scripts.add(src),\n              pushScriptImpl(src, options),\n              enqueueFlush(request));\n          }\n        } else previousDispatcher.X(src, options);\n      },\n      S: function (href, precedence, options) {\n        var request = currentRequest ? currentRequest : null;\n        if (request) {\n          var resumableState = request.resumableState,\n            renderState = request.renderState;\n          if (href) {\n            precedence = precedence || \"default\";\n            var styleQueue = renderState.styles.get(precedence),\n              resourceState = resumableState.styleResources.hasOwnProperty(href)\n                ? resumableState.styleResources[href]\n                : void 0;\n            resourceState !== EXISTS &&\n              ((resumableState.styleResources[href] = EXISTS),\n              styleQueue ||\n                ((styleQueue = {\n                  precedence: stringToChunk(escapeTextForBrowser(precedence)),\n                  rules: [],\n                  hrefs: [],\n                  sheets: new Map()\n                }),\n                renderState.styles.set(precedence, styleQueue)),\n              (precedence = {\n                state: PENDING$1,\n                props: assign(\n                  {\n                    rel: \"stylesheet\",\n                    href: href,\n                    \"data-precedence\": precedence\n                  },\n                  options\n                )\n              }),\n              resourceState &&\n                (2 === resourceState.length &&\n                  adoptPreloadCredentials(precedence.props, resourceState),\n                (renderState = renderState.preloads.stylesheets.get(href)) &&\n                0 < renderState.length\n                  ? (renderState.length = 0)\n                  : (precedence.state = PRELOADED)),\n              styleQueue.sheets.set(href, precedence),\n              enqueueFlush(request));\n          }\n        } else previousDispatcher.S(href, precedence, options);\n      },\n      M: function (src, options) {\n        var request = currentRequest ? currentRequest : null;\n        if (request) {\n          var resumableState = request.resumableState,\n            renderState = request.renderState;\n          if (src) {\n            var resourceState =\n              resumableState.moduleScriptResources.hasOwnProperty(src)\n                ? resumableState.moduleScriptResources[src]\n                : void 0;\n            resourceState !== EXISTS &&\n              ((resumableState.moduleScriptResources[src] = EXISTS),\n              (options = assign(\n                { src: src, type: \"module\", async: !0 },\n                options\n              )),\n              resourceState &&\n                (2 === resourceState.length &&\n                  adoptPreloadCredentials(options, resourceState),\n                (src = renderState.preloads.moduleScripts.get(src))) &&\n                (src.length = 0),\n              (src = []),\n              renderState.scripts.add(src),\n              pushScriptImpl(src, options),\n              enqueueFlush(request));\n          }\n        } else previousDispatcher.M(src, options);\n      }\n    };\n    var NothingSent = 0,\n      SentCompleteSegmentFunction = 1,\n      SentCompleteBoundaryFunction = 2,\n      SentClientRenderFunction = 4,\n      SentStyleInsertionFunction = 8,\n      SentCompletedShellId = 32,\n      SentMarkShellTime = 64,\n      EXISTS = null,\n      PRELOAD_NO_CREDS = [];\n    Object.freeze(PRELOAD_NO_CREDS);\n    var currentlyFlushingRenderState = null;\n    stringToPrecomputedChunk('\"></template>');\n    var startInlineScript = stringToPrecomputedChunk(\"<script\"),\n      endInlineScript = stringToPrecomputedChunk(\"\\x3c/script>\"),\n      startScriptSrc = stringToPrecomputedChunk('<script src=\"'),\n      startModuleSrc = stringToPrecomputedChunk('<script type=\"module\" src=\"'),\n      scriptNonce = stringToPrecomputedChunk(' nonce=\"'),\n      scriptIntegirty = stringToPrecomputedChunk(' integrity=\"'),\n      scriptCrossOrigin = stringToPrecomputedChunk(' crossorigin=\"'),\n      endAsyncScript = stringToPrecomputedChunk(' async=\"\">\\x3c/script>'),\n      startInlineStyle = stringToPrecomputedChunk(\"<style\"),\n      scriptRegex = /(<\\/|<)(s)(cript)/gi,\n      importMapScriptStart = stringToPrecomputedChunk(\n        '<script type=\"importmap\">'\n      ),\n      importMapScriptEnd = stringToPrecomputedChunk(\"\\x3c/script>\");\n    var didWarnForNewBooleanPropsWithEmptyValue = {};\n    var ROOT_HTML_MODE = 0,\n      HTML_HTML_MODE = 1,\n      HTML_MODE = 2,\n      HTML_HEAD_MODE = 3,\n      SVG_MODE = 4,\n      MATHML_MODE = 5,\n      HTML_TABLE_MODE = 6,\n      HTML_TABLE_BODY_MODE = 7,\n      HTML_TABLE_ROW_MODE = 8,\n      HTML_COLGROUP_MODE = 9,\n      textSeparator = stringToPrecomputedChunk(\"\\x3c!-- --\\x3e\"),\n      styleNameCache = new Map(),\n      styleAttributeStart = stringToPrecomputedChunk(' style=\"'),\n      styleAssign = stringToPrecomputedChunk(\":\"),\n      styleSeparator = stringToPrecomputedChunk(\";\"),\n      attributeSeparator = stringToPrecomputedChunk(\" \"),\n      attributeAssign = stringToPrecomputedChunk('=\"'),\n      attributeEnd = stringToPrecomputedChunk('\"'),\n      attributeEmptyString = stringToPrecomputedChunk('=\"\"'),\n      actionJavaScriptURL = stringToPrecomputedChunk(\n        escapeTextForBrowser(\n          \"javascript:throw new Error('React form unexpectedly submitted.')\"\n        )\n      ),\n      startHiddenInputChunk = stringToPrecomputedChunk('<input type=\"hidden\"'),\n      endOfStartTag = stringToPrecomputedChunk(\">\"),\n      endOfStartTagSelfClosing = stringToPrecomputedChunk(\"/>\"),\n      didWarnDefaultInputValue = !1,\n      didWarnDefaultChecked = !1,\n      didWarnDefaultSelectValue = !1,\n      didWarnDefaultTextareaValue = !1,\n      didWarnInvalidOptionChildren = !1,\n      didWarnInvalidOptionInnerHTML = !1,\n      didWarnSelectedSetOnOption = !1,\n      didWarnFormActionType = !1,\n      didWarnFormActionName = !1,\n      didWarnFormActionTarget = !1,\n      didWarnFormActionMethod = !1,\n      selectedMarkerAttribute = stringToPrecomputedChunk(' selected=\"\"'),\n      formReplayingRuntimeScript = stringToPrecomputedChunk(\n        'addEventListener(\"submit\",function(a){if(!a.defaultPrevented){var c=a.target,d=a.submitter,e=c.action,b=d;if(d){var f=d.getAttribute(\"formAction\");null!=f&&(e=f,b=null)}\"javascript:throw new Error(\\'React form unexpectedly submitted.\\')\"===e&&(a.preventDefault(),b?(a=document.createElement(\"input\"),a.name=b.name,a.value=b.value,b.parentNode.insertBefore(a,b),b=new FormData(c),a.parentNode.removeChild(a)):b=new FormData(c),a=c.ownerDocument||c,(a.$$reactFormReplay=a.$$reactFormReplay||[]).push(c,d,b))}});'\n      ),\n      formStateMarkerIsMatching = stringToPrecomputedChunk(\"\\x3c!--F!--\\x3e\"),\n      formStateMarkerIsNotMatching = stringToPrecomputedChunk(\"\\x3c!--F--\\x3e\"),\n      styleRegex = /(<\\/|<)(s)(tyle)/gi,\n      headPreambleContributionChunk =\n        stringToPrecomputedChunk(\"\\x3c!--head--\\x3e\"),\n      bodyPreambleContributionChunk =\n        stringToPrecomputedChunk(\"\\x3c!--body--\\x3e\"),\n      htmlPreambleContributionChunk =\n        stringToPrecomputedChunk(\"\\x3c!--html--\\x3e\"),\n      leadingNewline = stringToPrecomputedChunk(\"\\n\"),\n      VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\\.\\-\\d]*$/,\n      validatedTagCache = new Map(),\n      doctypeChunk = stringToPrecomputedChunk(\"<!DOCTYPE html>\"),\n      endTagCache = new Map(),\n      shellTimeRuntimeScript = stringToPrecomputedChunk(\n        \"requestAnimationFrame(function(){$RT=performance.now()});\"\n      ),\n      placeholder1 = stringToPrecomputedChunk('<template id=\"'),\n      placeholder2 = stringToPrecomputedChunk('\"></template>'),\n      startActivityBoundary = stringToPrecomputedChunk(\"\\x3c!--&--\\x3e\"),\n      endActivityBoundary = stringToPrecomputedChunk(\"\\x3c!--/&--\\x3e\"),\n      startCompletedSuspenseBoundary =\n        stringToPrecomputedChunk(\"\\x3c!--$--\\x3e\"),\n      startPendingSuspenseBoundary1 = stringToPrecomputedChunk(\n        '\\x3c!--$?--\\x3e<template id=\"'\n      ),\n      startPendingSuspenseBoundary2 = stringToPrecomputedChunk('\"></template>'),\n      startClientRenderedSuspenseBoundary =\n        stringToPrecomputedChunk(\"\\x3c!--$!--\\x3e\"),\n      endSuspenseBoundary = stringToPrecomputedChunk(\"\\x3c!--/$--\\x3e\"),\n      clientRenderedSuspenseBoundaryError1 =\n        stringToPrecomputedChunk(\"<template\"),\n      clientRenderedSuspenseBoundaryErrorAttrInterstitial =\n        stringToPrecomputedChunk('\"'),\n      clientRenderedSuspenseBoundaryError1A =\n        stringToPrecomputedChunk(' data-dgst=\"'),\n      clientRenderedSuspenseBoundaryError1B =\n        stringToPrecomputedChunk(' data-msg=\"'),\n      clientRenderedSuspenseBoundaryError1C =\n        stringToPrecomputedChunk(' data-stck=\"'),\n      clientRenderedSuspenseBoundaryError1D =\n        stringToPrecomputedChunk(' data-cstck=\"'),\n      clientRenderedSuspenseBoundaryError2 =\n        stringToPrecomputedChunk(\"></template>\"),\n      startSegmentHTML = stringToPrecomputedChunk('<div hidden id=\"'),\n      startSegmentHTML2 = stringToPrecomputedChunk('\">'),\n      endSegmentHTML = stringToPrecomputedChunk(\"</div>\"),\n      startSegmentSVG = stringToPrecomputedChunk(\n        '<svg aria-hidden=\"true\" style=\"display:none\" id=\"'\n      ),\n      startSegmentSVG2 = stringToPrecomputedChunk('\">'),\n      endSegmentSVG = stringToPrecomputedChunk(\"</svg>\"),\n      startSegmentMathML = stringToPrecomputedChunk(\n        '<math aria-hidden=\"true\" style=\"display:none\" id=\"'\n      ),\n      startSegmentMathML2 = stringToPrecomputedChunk('\">'),\n      endSegmentMathML = stringToPrecomputedChunk(\"</math>\"),\n      startSegmentTable = stringToPrecomputedChunk('<table hidden id=\"'),\n      startSegmentTable2 = stringToPrecomputedChunk('\">'),\n      endSegmentTable = stringToPrecomputedChunk(\"</table>\"),\n      startSegmentTableBody = stringToPrecomputedChunk(\n        '<table hidden><tbody id=\"'\n      ),\n      startSegmentTableBody2 = stringToPrecomputedChunk('\">'),\n      endSegmentTableBody = stringToPrecomputedChunk(\"</tbody></table>\"),\n      startSegmentTableRow = stringToPrecomputedChunk('<table hidden><tr id=\"'),\n      startSegmentTableRow2 = stringToPrecomputedChunk('\">'),\n      endSegmentTableRow = stringToPrecomputedChunk(\"</tr></table>\"),\n      startSegmentColGroup = stringToPrecomputedChunk(\n        '<table hidden><colgroup id=\"'\n      ),\n      startSegmentColGroup2 = stringToPrecomputedChunk('\">'),\n      endSegmentColGroup = stringToPrecomputedChunk(\"</colgroup></table>\"),\n      completeSegmentScript1Full = stringToPrecomputedChunk(\n        '$RS=function(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS(\"'\n      ),\n      completeSegmentScript1Partial = stringToPrecomputedChunk('$RS(\"'),\n      completeSegmentScript2 = stringToPrecomputedChunk('\",\"'),\n      completeSegmentScriptEnd = stringToPrecomputedChunk('\")\\x3c/script>');\n    stringToPrecomputedChunk('<template data-rsi=\"\" data-sid=\"');\n    stringToPrecomputedChunk('\" data-pid=\"');\n    var completeBoundaryScriptFunctionOnly = stringToPrecomputedChunk(\n      '$RB=[];$RV=function(a){$RT=performance.now();for(var b=0;b<a.length;b+=2){var c=a[b],e=a[b+1];null!==e.parentNode&&e.parentNode.removeChild(e);var f=c.parentNode;if(f){var g=c.previousSibling,h=0;do{if(c&&8===c.nodeType){var d=c.data;if(\"/$\"===d||\"/&\"===d)if(0===h)break;else h--;else\"$\"!==d&&\"$?\"!==d&&\"$~\"!==d&&\"$!\"!==d&&\"&\"!==d||h++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;e.firstChild;)f.insertBefore(e.firstChild,c);g.data=\"$\";g._reactRetry&&requestAnimationFrame(g._reactRetry)}}a.length=0};\\n$RC=function(a,b){if(b=document.getElementById(b))(a=document.getElementById(a))?(a.previousSibling.data=\"$~\",$RB.push(a,b),2===$RB.length&&(\"number\"!==typeof $RT?requestAnimationFrame($RV.bind(null,$RB)):(a=performance.now(),setTimeout($RV.bind(null,$RB),2300>a&&2E3<a?2300-a:$RT+300-a)))):b.parentNode.removeChild(b)};'\n    );\n    stringToChunk(\n      '$RV=function(A,g){function k(a,b){var e=a.getAttribute(b);e&&(b=a.style,l.push(a,b.viewTransitionName,b.viewTransitionClass),\"auto\"!==e&&(b.viewTransitionClass=e),(a=a.getAttribute(\"vt-name\"))||(a=\"_T_\"+K++ +\"_\"),b.viewTransitionName=a,B=!0)}var B=!1,K=0,l=[];try{var f=document.__reactViewTransition;if(f){f.finished.finally($RV.bind(null,g));return}var m=new Map;for(f=1;f<g.length;f+=2)for(var h=g[f].querySelectorAll(\"[vt-share]\"),d=0;d<h.length;d++){var c=h[d];m.set(c.getAttribute(\"vt-name\"),c)}var u=[];for(h=0;h<g.length;h+=2){var C=g[h],x=C.parentNode;if(x){var v=x.getBoundingClientRect();if(v.left||v.top||v.width||v.height){c=C;for(f=0;c;){if(8===c.nodeType){var r=c.data;if(\"/$\"===r)if(0===f)break;else f--;else\"$\"!==r&&\"$?\"!==r&&\"$~\"!==r&&\"$!\"!==r||f++}else if(1===c.nodeType){d=c;var D=d.getAttribute(\"vt-name\"),y=m.get(D);k(d,y?\"vt-share\":\"vt-exit\");y&&(k(y,\"vt-share\"),m.set(D,null));var E=d.querySelectorAll(\"[vt-share]\");for(d=0;d<E.length;d++){var F=E[d],G=F.getAttribute(\"vt-name\"),\\nH=m.get(G);H&&(k(F,\"vt-share\"),k(H,\"vt-share\"),m.set(G,null))}}c=c.nextSibling}for(var I=g[h+1],t=I.firstElementChild;t;)null!==m.get(t.getAttribute(\"vt-name\"))&&k(t,\"vt-enter\"),t=t.nextElementSibling;c=x;do for(var n=c.firstElementChild;n;){var J=n.getAttribute(\"vt-update\");J&&\"none\"!==J&&!l.includes(n)&&k(n,\"vt-update\");n=n.nextElementSibling}while((c=c.parentNode)&&1===c.nodeType&&\"none\"!==c.getAttribute(\"vt-update\"));u.push.apply(u,I.querySelectorAll(\\'img[src]:not([loading=\"lazy\"])\\'))}}}if(B){var z=\\ndocument.__reactViewTransition=document.startViewTransition({update:function(){A(g);for(var a=[document.documentElement.clientHeight,document.fonts.ready],b={},e=0;e<u.length;b={g:b.g},e++)if(b.g=u[e],!b.g.complete){var p=b.g.getBoundingClientRect();0<p.bottom&&0<p.right&&p.top<window.innerHeight&&p.left<window.innerWidth&&(p=new Promise(function(w){return function(q){w.g.addEventListener(\"load\",q);w.g.addEventListener(\"error\",q)}}(b)),a.push(p))}return Promise.race([Promise.all(a),new Promise(function(w){var q=\\nperformance.now();setTimeout(w,2300>q&&2E3<q?2300-q:500)})])},types:[]});z.ready.finally(function(){for(var a=l.length-3;0<=a;a-=3){var b=l[a],e=b.style;e.viewTransitionName=l[a+1];e.viewTransitionClass=l[a+1];\"\"===b.getAttribute(\"style\")&&b.removeAttribute(\"style\")}});z.finished.finally(function(){document.__reactViewTransition===z&&(document.__reactViewTransition=null)});$RB=[];return}}catch(a){}A(g)}.bind(null,$RV);'\n    );\n    var completeBoundaryScript1Partial = stringToPrecomputedChunk('$RC(\"'),\n      completeBoundaryWithStylesScript1FullPartial = stringToPrecomputedChunk(\n        '$RM=new Map;$RR=function(n,w,p){function u(q){this._p=null;q()}for(var r=new Map,t=document,h,b,e=t.querySelectorAll(\"link[data-precedence],style[data-precedence]\"),v=[],k=0;b=e[k++];)\"not all\"===b.getAttribute(\"media\")?v.push(b):(\"LINK\"===b.tagName&&$RM.set(b.getAttribute(\"href\"),b),r.set(b.dataset.precedence,h=b));e=0;b=[];var l,a;for(k=!0;;){if(k){var f=p[e++];if(!f){k=!1;e=0;continue}var c=!1,m=0;var d=f[m++];if(a=$RM.get(d)){var g=a._p;c=!0}else{a=t.createElement(\"link\");a.href=d;a.rel=\\n\"stylesheet\";for(a.dataset.precedence=l=f[m++];g=f[m++];)a.setAttribute(g,f[m++]);g=a._p=new Promise(function(q,x){a.onload=u.bind(a,q);a.onerror=u.bind(a,x)});$RM.set(d,a)}d=a.getAttribute(\"media\");!g||d&&!matchMedia(d).matches||b.push(g);if(c)continue}else{a=v[e++];if(!a)break;l=a.getAttribute(\"data-precedence\");a.removeAttribute(\"media\")}c=r.get(l)||h;c===h&&(h=a);r.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=t.head,c.insertBefore(a,c.firstChild))}if(p=document.getElementById(n))p.previousSibling.data=\\n\"$~\";Promise.all(b).then($RC.bind(null,n,w),$RX.bind(null,n,\"CSS failed to load\"))};$RR(\"'\n      ),\n      completeBoundaryWithStylesScript1Partial =\n        stringToPrecomputedChunk('$RR(\"'),\n      completeBoundaryScript2 = stringToPrecomputedChunk('\",\"'),\n      completeBoundaryScript3a = stringToPrecomputedChunk('\",'),\n      completeBoundaryScript3b = stringToPrecomputedChunk('\"'),\n      completeBoundaryScriptEnd = stringToPrecomputedChunk(\")\\x3c/script>\");\n    stringToPrecomputedChunk('<template data-rci=\"\" data-bid=\"');\n    stringToPrecomputedChunk('<template data-rri=\"\" data-bid=\"');\n    stringToPrecomputedChunk('\" data-sid=\"');\n    stringToPrecomputedChunk('\" data-sty=\"');\n    var clientRenderScriptFunctionOnly = stringToPrecomputedChunk(\n        '$RX=function(b,c,d,e,f){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data=\"$!\",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),f&&(a.cstck=f),b._reactRetry&&b._reactRetry())};'\n      ),\n      clientRenderScript1Full = stringToPrecomputedChunk(\n        '$RX=function(b,c,d,e,f){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data=\"$!\",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),f&&(a.cstck=f),b._reactRetry&&b._reactRetry())};;$RX(\"'\n      ),\n      clientRenderScript1Partial = stringToPrecomputedChunk('$RX(\"'),\n      clientRenderScript1A = stringToPrecomputedChunk('\"'),\n      clientRenderErrorScriptArgInterstitial = stringToPrecomputedChunk(\",\"),\n      clientRenderScriptEnd = stringToPrecomputedChunk(\")\\x3c/script>\");\n    stringToPrecomputedChunk('<template data-rxi=\"\" data-bid=\"');\n    stringToPrecomputedChunk('\" data-dgst=\"');\n    stringToPrecomputedChunk('\" data-msg=\"');\n    stringToPrecomputedChunk('\" data-stck=\"');\n    stringToPrecomputedChunk('\" data-cstck=\"');\n    var regexForJSStringsInInstructionScripts = /[<\\u2028\\u2029]/g,\n      regexForJSStringsInScripts = /[&><\\u2028\\u2029]/g,\n      lateStyleTagResourceOpen1 = stringToPrecomputedChunk(\n        ' media=\"not all\" data-precedence=\"'\n      ),\n      lateStyleTagResourceOpen2 = stringToPrecomputedChunk('\" data-href=\"'),\n      lateStyleTagResourceOpen3 = stringToPrecomputedChunk('\">'),\n      lateStyleTagTemplateClose = stringToPrecomputedChunk(\"</style>\"),\n      currentlyRenderingBoundaryHasStylesToHoist = !1,\n      destinationHasCapacity = !0,\n      stylesheetFlushingQueue = [],\n      styleTagResourceOpen1 = stringToPrecomputedChunk(' data-precedence=\"'),\n      styleTagResourceOpen2 = stringToPrecomputedChunk('\" data-href=\"'),\n      spaceSeparator = stringToPrecomputedChunk(\" \"),\n      styleTagResourceOpen3 = stringToPrecomputedChunk('\">'),\n      styleTagResourceClose = stringToPrecomputedChunk(\"</style>\");\n    stringToPrecomputedChunk('<link rel=\"expect\" href=\"#');\n    stringToPrecomputedChunk('\" blocking=\"render\"/>');\n    var completedShellIdAttributeStart = stringToPrecomputedChunk(' id=\"'),\n      arrayFirstOpenBracket = stringToPrecomputedChunk(\"[\"),\n      arraySubsequentOpenBracket = stringToPrecomputedChunk(\",[\"),\n      arrayInterstitial = stringToPrecomputedChunk(\",\"),\n      arrayCloseBracket = stringToPrecomputedChunk(\"]\"),\n      PENDING$1 = 0,\n      PRELOADED = 1,\n      PREAMBLE = 2,\n      LATE = 3,\n      regexForHrefInLinkHeaderURLContext = /[<>\\r\\n]/g,\n      regexForLinkHeaderQuotedParamValueContext = /[\"';,\\r\\n]/g,\n      bind = Function.prototype.bind,\n      REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n      emptyContextObject = {};\n    Object.freeze(emptyContextObject);\n    var rendererSigil = {};\n    var currentActiveSnapshot = null,\n      didWarnAboutNoopUpdateForComponent = {},\n      didWarnAboutDeprecatedWillMount = {};\n    var didWarnAboutUninitializedState = new Set();\n    var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();\n    var didWarnAboutLegacyLifecyclesAndDerivedState = new Set();\n    var didWarnAboutDirectlyAssigningPropsToState = new Set();\n    var didWarnAboutUndefinedDerivedState = new Set();\n    var didWarnAboutContextTypes$1 = new Set();\n    var didWarnAboutChildContextTypes = new Set();\n    var didWarnAboutInvalidateContextType = new Set();\n    var didWarnOnInvalidCallback = new Set();\n    var classComponentUpdater = {\n        enqueueSetState: function (inst, payload, callback) {\n          var internals = inst._reactInternals;\n          null === internals.queue\n            ? warnNoop(inst, \"setState\")\n            : (internals.queue.push(payload),\n              void 0 !== callback &&\n                null !== callback &&\n                warnOnInvalidCallback(callback));\n        },\n        enqueueReplaceState: function (inst, payload, callback) {\n          inst = inst._reactInternals;\n          inst.replace = !0;\n          inst.queue = [payload];\n          void 0 !== callback &&\n            null !== callback &&\n            warnOnInvalidCallback(callback);\n        },\n        enqueueForceUpdate: function (inst, callback) {\n          null === inst._reactInternals.queue\n            ? warnNoop(inst, \"forceUpdate\")\n            : void 0 !== callback &&\n              null !== callback &&\n              warnOnInvalidCallback(callback);\n        }\n      },\n      emptyTreeContext = { id: 1, overflow: \"\" },\n      clz32 = Math.clz32 ? Math.clz32 : clz32Fallback,\n      log = Math.log,\n      LN2 = Math.LN2,\n      SuspenseException = Error(\n        \"Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\\n\\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`.\"\n      ),\n      suspendedThenable = null,\n      objectIs = \"function\" === typeof Object.is ? Object.is : is,\n      currentlyRenderingComponent = null,\n      currentlyRenderingTask = null,\n      currentlyRenderingRequest = null,\n      currentlyRenderingKeyPath = null,\n      firstWorkInProgressHook = null,\n      workInProgressHook = null,\n      isReRender = !1,\n      didScheduleRenderPhaseUpdate = !1,\n      localIdCounter = 0,\n      actionStateCounter = 0,\n      actionStateMatchingIndex = -1,\n      thenableIndexCounter = 0,\n      thenableState = null,\n      renderPhaseUpdates = null,\n      numberOfReRenders = 0,\n      isInHookUserCodeInDev = !1,\n      currentHookNameInDev,\n      HooksDispatcher = {\n        readContext: readContext,\n        use: function (usable) {\n          if (null !== usable && \"object\" === typeof usable) {\n            if (\"function\" === typeof usable.then)\n              return unwrapThenable(usable);\n            if (usable.$$typeof === REACT_CONTEXT_TYPE)\n              return readContext(usable);\n          }\n          throw Error(\n            \"An unsupported type was passed to use(): \" + String(usable)\n          );\n        },\n        useContext: function (context) {\n          currentHookNameInDev = \"useContext\";\n          resolveCurrentlyRenderingComponent();\n          return context._currentValue;\n        },\n        useMemo: useMemo,\n        useReducer: useReducer,\n        useRef: function (initialValue) {\n          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();\n          workInProgressHook = createWorkInProgressHook();\n          var previousRef = workInProgressHook.memoizedState;\n          return null === previousRef\n            ? ((initialValue = { current: initialValue }),\n              Object.seal(initialValue),\n              (workInProgressHook.memoizedState = initialValue))\n            : previousRef;\n        },\n        useState: function (initialState) {\n          currentHookNameInDev = \"useState\";\n          return useReducer(basicStateReducer, initialState);\n        },\n        useInsertionEffect: noop,\n        useLayoutEffect: noop,\n        useCallback: function (callback, deps) {\n          return useMemo(function () {\n            return callback;\n          }, deps);\n        },\n        useImperativeHandle: noop,\n        useEffect: noop,\n        useDebugValue: noop,\n        useDeferredValue: function (value, initialValue) {\n          resolveCurrentlyRenderingComponent();\n          return void 0 !== initialValue ? initialValue : value;\n        },\n        useTransition: function () {\n          resolveCurrentlyRenderingComponent();\n          return [!1, unsupportedStartTransition];\n        },\n        useId: function () {\n          var treeId = currentlyRenderingTask.treeContext;\n          var overflow = treeId.overflow;\n          treeId = treeId.id;\n          treeId =\n            (treeId & ~(1 << (32 - clz32(treeId) - 1))).toString(32) + overflow;\n          var resumableState = currentResumableState;\n          if (null === resumableState)\n            throw Error(\n              \"Invalid hook call. Hooks can only be called inside of the body of a function component.\"\n            );\n          overflow = localIdCounter++;\n          treeId = \"_\" + resumableState.idPrefix + \"R_\" + treeId;\n          0 < overflow && (treeId += \"H\" + overflow.toString(32));\n          return treeId + \"_\";\n        },\n        useSyncExternalStore: function (\n          subscribe,\n          getSnapshot,\n          getServerSnapshot\n        ) {\n          if (void 0 === getServerSnapshot)\n            throw Error(\n              \"Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.\"\n            );\n          return getServerSnapshot();\n        },\n        useOptimistic: function (passthrough) {\n          resolveCurrentlyRenderingComponent();\n          return [passthrough, unsupportedSetOptimisticState];\n        },\n        useActionState: useActionState,\n        useFormState: useActionState,\n        useHostTransitionStatus: function () {\n          resolveCurrentlyRenderingComponent();\n          return NotPending;\n        },\n        useMemoCache: function (size) {\n          for (var data = Array(size), i = 0; i < size; i++)\n            data[i] = REACT_MEMO_CACHE_SENTINEL;\n          return data;\n        },\n        useCacheRefresh: function () {\n          return unsupportedRefresh;\n        },\n        useEffectEvent: function () {\n          return throwOnUseEffectEventCall;\n        }\n      },\n      currentResumableState = null,\n      currentTaskInDEV = null,\n      DefaultAsyncDispatcher = {\n        getCacheForType: function () {\n          throw Error(\"Not implemented.\");\n        },\n        cacheSignal: function () {\n          throw Error(\"Not implemented.\");\n        },\n        getOwner: function () {\n          return null === currentTaskInDEV\n            ? null\n            : currentTaskInDEV.componentStack;\n        }\n      },\n      disabledDepth = 0,\n      prevLog,\n      prevInfo,\n      prevWarn,\n      prevError,\n      prevGroup,\n      prevGroupCollapsed,\n      prevGroupEnd;\n    disabledLog.__reactDisabledLog = !0;\n    var prefix,\n      suffix,\n      reentry = !1;\n    var componentFrameCache = new (\n      \"function\" === typeof WeakMap ? WeakMap : Map\n    )();\n    var callComponent = {\n        react_stack_bottom_frame: function (Component, props, secondArg) {\n          return Component(props, secondArg);\n        }\n      },\n      callComponentInDEV =\n        callComponent.react_stack_bottom_frame.bind(callComponent),\n      callRender = {\n        react_stack_bottom_frame: function (instance) {\n          return instance.render();\n        }\n      },\n      callRenderInDEV = callRender.react_stack_bottom_frame.bind(callRender),\n      callLazyInit = {\n        react_stack_bottom_frame: function (lazy) {\n          var init = lazy._init;\n          return init(lazy._payload);\n        }\n      },\n      callLazyInitInDEV =\n        callLazyInit.react_stack_bottom_frame.bind(callLazyInit),\n      lastResetTime = 0;\n    if (\n      \"object\" === typeof performance &&\n      \"function\" === typeof performance.now\n    ) {\n      var localPerformance = performance;\n      var getCurrentTime = function () {\n        return localPerformance.now();\n      };\n    } else {\n      var localDate = Date;\n      getCurrentTime = function () {\n        return localDate.now();\n      };\n    }\n    var CLIENT_RENDERED = 4,\n      PENDING = 0,\n      COMPLETED = 1,\n      FLUSHED = 2,\n      ABORTED = 3,\n      ERRORED = 4,\n      POSTPONED = 5,\n      CLOSED = 14,\n      currentRequest = null,\n      didWarnAboutBadClass = {},\n      didWarnAboutContextTypes = {},\n      didWarnAboutContextTypeOnFunctionComponent = {},\n      didWarnAboutGetDerivedStateOnFunctionComponent = {},\n      didWarnAboutReassigningProps = !1,\n      didWarnAboutGenerators = !1,\n      didWarnAboutMaps = !1,\n      flushedByteSize = 0,\n      flushingPartialBoundaries = !1;\n    ensureCorrectIsomorphicReactVersion();\n    ensureCorrectIsomorphicReactVersion();\n    exports.prerender = function (children, options) {\n      return new Promise(function (resolve, reject) {\n        var onHeaders = options ? options.onHeaders : void 0,\n          onHeadersImpl;\n        onHeaders &&\n          (onHeadersImpl = function (headersDescriptor) {\n            onHeaders(new Headers(headersDescriptor));\n          });\n        var resources = createResumableState(\n            options ? options.identifierPrefix : void 0,\n            options ? options.unstable_externalRuntimeSrc : void 0,\n            options ? options.bootstrapScriptContent : void 0,\n            options ? options.bootstrapScripts : void 0,\n            options ? options.bootstrapModules : void 0\n          ),\n          request = createPrerenderRequest(\n            children,\n            resources,\n            createRenderState(\n              resources,\n              void 0,\n              options ? options.unstable_externalRuntimeSrc : void 0,\n              options ? options.importMap : void 0,\n              onHeadersImpl,\n              options ? options.maxHeadersLength : void 0\n            ),\n            createRootFormatContext(options ? options.namespaceURI : void 0),\n            options ? options.progressiveChunkSize : void 0,\n            options ? options.onError : void 0,\n            function () {\n              var stream = new ReadableStream(\n                {\n                  type: \"bytes\",\n                  pull: function (controller) {\n                    startFlowing(request, controller);\n                  },\n                  cancel: function (reason) {\n                    request.destination = null;\n                    abort(request, reason);\n                  }\n                },\n                { highWaterMark: 0 }\n              );\n              stream = {\n                postponed: getPostponedState(request),\n                prelude: stream\n              };\n              resolve(stream);\n            },\n            void 0,\n            void 0,\n            reject,\n            options ? options.onPostpone : void 0\n          );\n        if (options && options.signal) {\n          var signal = options.signal;\n          if (signal.aborted) abort(request, signal.reason);\n          else {\n            var listener = function () {\n              abort(request, signal.reason);\n              signal.removeEventListener(\"abort\", listener);\n            };\n            signal.addEventListener(\"abort\", listener);\n          }\n        }\n        startWork(request);\n      });\n    };\n    exports.renderToReadableStream = function (children, options) {\n      return new Promise(function (resolve, reject) {\n        var onFatalError,\n          onAllReady,\n          allReady = new Promise(function (res, rej) {\n            onAllReady = res;\n            onFatalError = rej;\n          }),\n          onHeaders = options ? options.onHeaders : void 0,\n          onHeadersImpl;\n        onHeaders &&\n          (onHeadersImpl = function (headersDescriptor) {\n            onHeaders(new Headers(headersDescriptor));\n          });\n        var resumableState = createResumableState(\n            options ? options.identifierPrefix : void 0,\n            options ? options.unstable_externalRuntimeSrc : void 0,\n            options ? options.bootstrapScriptContent : void 0,\n            options ? options.bootstrapScripts : void 0,\n            options ? options.bootstrapModules : void 0\n          ),\n          request = createRequest(\n            children,\n            resumableState,\n            createRenderState(\n              resumableState,\n              options ? options.nonce : void 0,\n              options ? options.unstable_externalRuntimeSrc : void 0,\n              options ? options.importMap : void 0,\n              onHeadersImpl,\n              options ? options.maxHeadersLength : void 0\n            ),\n            createRootFormatContext(options ? options.namespaceURI : void 0),\n            options ? options.progressiveChunkSize : void 0,\n            options ? options.onError : void 0,\n            onAllReady,\n            function () {\n              var stream = new ReadableStream(\n                {\n                  type: \"bytes\",\n                  pull: function (controller) {\n                    startFlowing(request, controller);\n                  },\n                  cancel: function (reason) {\n                    request.destination = null;\n                    abort(request, reason);\n                  }\n                },\n                { highWaterMark: 0 }\n              );\n              stream.allReady = allReady;\n              resolve(stream);\n            },\n            function (error) {\n              allReady.catch(function () {});\n              reject(error);\n            },\n            onFatalError,\n            options ? options.onPostpone : void 0,\n            options ? options.formState : void 0\n          );\n        if (options && options.signal) {\n          var signal = options.signal;\n          if (signal.aborted) abort(request, signal.reason);\n          else {\n            var listener = function () {\n              abort(request, signal.reason);\n              signal.removeEventListener(\"abort\", listener);\n            };\n            signal.addEventListener(\"abort\", listener);\n          }\n        }\n        startWork(request);\n      });\n    };\n    exports.resume = function (children, postponedState, options) {\n      return new Promise(function (resolve, reject) {\n        var onFatalError,\n          onAllReady,\n          allReady = new Promise(function (res, rej) {\n            onAllReady = res;\n            onFatalError = rej;\n          }),\n          request = resumeRequest(\n            children,\n            postponedState,\n            createRenderState(\n              postponedState.resumableState,\n              options ? options.nonce : void 0,\n              void 0,\n              void 0,\n              void 0,\n              void 0\n            ),\n            options ? options.onError : void 0,\n            onAllReady,\n            function () {\n              var stream = new ReadableStream(\n                {\n                  type: \"bytes\",\n                  pull: function (controller) {\n                    startFlowing(request, controller);\n                  },\n                  cancel: function (reason) {\n                    request.destination = null;\n                    abort(request, reason);\n                  }\n                },\n                { highWaterMark: 0 }\n              );\n              stream.allReady = allReady;\n              resolve(stream);\n            },\n            function (error) {\n              allReady.catch(function () {});\n              reject(error);\n            },\n            onFatalError,\n            options ? options.onPostpone : void 0\n          );\n        if (options && options.signal) {\n          var signal = options.signal;\n          if (signal.aborted) abort(request, signal.reason);\n          else {\n            var listener = function () {\n              abort(request, signal.reason);\n              signal.removeEventListener(\"abort\", listener);\n            };\n            signal.addEventListener(\"abort\", listener);\n          }\n        }\n        startWork(request);\n      });\n    };\n    exports.resumeAndPrerender = function (children, postponedState, options) {\n      return new Promise(function (resolve, reject) {\n        var request = resumeAndPrerenderRequest(\n          children,\n          postponedState,\n          createRenderState(\n            postponedState.resumableState,\n            void 0,\n            void 0,\n            void 0,\n            void 0,\n            void 0\n          ),\n          options ? options.onError : void 0,\n          function () {\n            var stream = new ReadableStream(\n              {\n                type: \"bytes\",\n                pull: function (controller) {\n                  startFlowing(request, controller);\n                },\n                cancel: function (reason) {\n                  request.destination = null;\n                  abort(request, reason);\n                }\n              },\n              { highWaterMark: 0 }\n            );\n            stream = { postponed: getPostponedState(request), prelude: stream };\n            resolve(stream);\n          },\n          void 0,\n          void 0,\n          reject,\n          options ? options.onPostpone : void 0\n        );\n        if (options && options.signal) {\n          var signal = options.signal;\n          if (signal.aborted) abort(request, signal.reason);\n          else {\n            var listener = function () {\n              abort(request, signal.reason);\n              signal.removeEventListener(\"abort\", listener);\n            };\n            signal.addEventListener(\"abort\", listener);\n          }\n        }\n        startWork(request);\n      });\n    };\n    exports.version = \"19.2.0\";\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2Nqcy9yZWFjdC1kb20tc2VydmVyLmJyb3dzZXIuZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTtBQUNiLEtBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLElBQUk7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMEJBQTBCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNkNBQTZDO0FBQ25FLHNCQUFzQiw0Q0FBNEM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsSUFBSTtBQUN0QztBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EseUJBQXlCLDZCQUE2QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELGlCQUFpQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixzQkFBc0I7QUFDdEI7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGNBQWM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrSkFBa0osaUJBQWlCO0FBQ25LO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0pBQWtKLGlCQUFpQixtREFBbUQsbUJBQW1CLFdBQVcsK0JBQStCO0FBQ25SO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RixHQUFHO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHFCQUFxQjtBQUN2RDtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsaUJBQWlCO0FBQ2pCLHFCQUFxQixXQUFXLGVBQWUsbUJBQW1CO0FBQ2xFLG1CQUFtQjtBQUNuQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsaUJBQWlCLGtEQUFrRDtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxQ0FBcUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUNBQWlDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1Qix3QkFBd0I7QUFDeEIsNEJBQTRCLFdBQVcsZUFBZSxtQkFBbUI7QUFDekUsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQiwyQkFBMkI7QUFDM0Isa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0hBQWtILDhCQUE4QjtBQUNoSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxZQUFZO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDBCQUEwQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc2ZBQXNmLFdBQVcsMExBQTBMLFNBQVMsV0FBVyxFQUFFO0FBQ2p0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsWUFBWTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw0QkFBNEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFCQUFxQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixvQ0FBb0M7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwyQkFBMkI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixhQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDRCQUE0QjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IscUJBQXFCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSx3QkFBd0IsV0FBVyxnQkFBZ0I7QUFDbkQseUJBQXlCLFdBQVcsaUJBQWlCO0FBQ3JELHlCQUF5QixXQUFXLGlCQUFpQjtBQUNyRCwwQkFBMEIsV0FBVyxrQkFBa0I7QUFDdkQsMEJBQTBCLFdBQVcsa0JBQWtCO0FBQ3ZELG1DQUFtQyxXQUFXLDJCQUEyQjtBQUN6RSw2QkFBNkIsV0FBVyxxQkFBcUI7QUFDN0QsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdFQUFnRSxlQUFlLG9DQUFvQztBQUN0SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxnRUFBZ0UsZUFBZSxvQ0FBb0M7QUFDdEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxRQUFRO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx1QkFBdUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdDQUFnQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsYUFBYTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx1QkFBdUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHVCQUF1QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixRQUFRO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHNCQUFzQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHVCQUF1QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaURBQWlEO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMscUNBQXFDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMEJBQTBCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsa0JBQWtCLGdCQUFnQjtBQUN2RTtBQUNBO0FBQ0EsUUFBUTtBQUNSLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLG9CQUFvQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHdCQUF3QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLDZCQUE2QjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDJCQUEyQjtBQUM1RCx3Q0FBd0Msb0JBQW9CO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw4QkFBOEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdDQUFnQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLG1DQUFtQyxnQ0FBZ0M7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxQ0FBcUM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQ0FBZ0M7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDhCQUE4QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw0QkFBNEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyw0Q0FBTztBQUMvQixpQkFBaUIsbUJBQU8sQ0FBQyxvREFBVztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QywyQkFBMkI7QUFDM0IsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGlDQUFpQztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsb0NBQW9DO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsb0NBQW9DO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQ0FBb0M7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrQ0FBa0M7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHFCQUFxQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxQ0FBcUM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLHdCQUF3Qiw0Q0FBNEMsTUFBTSxtQ0FBbUMsc0JBQXNCLGtWQUFrVixFQUFFO0FBQ3RnQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxzQkFBc0IsRUFBRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw2QkFBNkIsNkJBQTZCLGdDQUFnQyxhQUFhLDJDQUEyQyw2QkFBNkI7QUFDMU07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdCQUFnQixzQkFBc0IsWUFBWSxXQUFXLE1BQU0sb0JBQW9CLGlEQUFpRCxtQkFBbUIsTUFBTSw0QkFBNEIsR0FBRyxzQkFBc0IsYUFBYSxxQ0FBcUMsU0FBUyx3REFBd0QsZ0JBQWdCLGlCQUFpQixJQUFJLFNBQVMsS0FBSyxhQUFhLGdDQUFnQyxXQUFXLHFEQUFxRCxZQUFZLG9CQUFvQiw4U0FBOFM7QUFDcjBCO0FBQ0E7QUFDQSx5QkFBeUIsZ0JBQWdCLHdCQUF3Qix3TEFBd0wsa0JBQWtCLElBQUkscUNBQXFDLE1BQU0scUNBQXFDLE9BQU8sY0FBYyxRQUFRLFdBQVcsdURBQXVELFdBQVcsS0FBSyxXQUFXLG1DQUFtQyxTQUFTLFFBQVEsV0FBVyxNQUFNLDBCQUEwQixNQUFNLGdDQUFnQyxxQ0FBcUMsSUFBSSxRQUFRLEVBQUUsRUFBRSxtQkFBbUIsYUFBYSwyQkFBMkIsU0FBUywrQ0FBK0Msd0JBQXdCLElBQUksMkNBQTJDLDRCQUE0QixtQ0FBbUMsdUNBQXVDLFFBQVEsV0FBVyxLQUFLLG9EQUFvRCxvREFBb0QsZ0JBQWdCLHVDQUF1QyxFQUFFLGlGQUFpRixJQUFJLGlDQUFpQyxFQUFFLEVBQUUsa0NBQWtDLGdEQUFnRCx1QkFBdUIsOEVBQThFLHlFQUF5RSxNQUFNLHFFQUFxRSxrQkFBa0IsS0FBSywyRUFBMkUsS0FBSyxXQUFXLEdBQUcsTUFBTSxnQ0FBZ0Msa0NBQWtDLHNHQUFzRyxtQkFBbUIsK0JBQStCLGlDQUFpQyxnQkFBZ0IsNERBQTRELDBCQUEwQix1Q0FBdUMsSUFBSSxVQUFVLEVBQUUsMkJBQTJCLHFCQUFxQixLQUFLLE1BQU0scUJBQXFCLDRCQUE0Qiw2QkFBNkIsMERBQTBELEVBQUUsOEJBQThCLDBFQUEwRSxFQUFFLE9BQU8sUUFBUSxVQUFVLEtBQUssZ0JBQWdCO0FBQ2o2RTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsb0JBQW9CLGNBQWMsYUFBYSxJQUFJLCtHQUErRyxTQUFTLHVJQUF1SSxJQUFJLEtBQUssUUFBUSxVQUFVLEVBQUUsTUFBTSxhQUFhLE9BQU8sS0FBSyxJQUFJLFNBQVMsYUFBYSxhQUFhLGlCQUFpQixXQUFXLEtBQUssS0FBSywwQkFBMEIsU0FBUyxxQkFBcUIsa0NBQWtDLFNBQVMsMEJBQTBCLGlDQUFpQyxxQkFBcUIsc0JBQXNCLEVBQUUsYUFBYSwwQkFBMEIseUNBQXlDLGNBQWMsS0FBSyxTQUFTLFlBQVksb0NBQW9DLDJCQUEyQixjQUFjLGFBQWEsV0FBVyx1RkFBdUYsOERBQThELCtFQUErRTtBQUM1bEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGlDQUFpQyx5SUFBeUk7QUFDM007QUFDQTtBQUNBLGlDQUFpQyxpQ0FBaUMsMElBQTBJO0FBQzVNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDJCQUEyQixxQkFBcUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsdUJBQXVCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSw4Q0FBOEMsVUFBVTtBQUN4RDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLG1DQUFtQztBQUNuQyxxREFBcUQ7QUFDckQseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxpQkFBaUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxJQUFJLDhCQUE4QjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsSUFBSSxjQUFjO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLElBQUksMEJBQTBCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGdCQUFnQjtBQUNoQjtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsSUFBSSxlQUFlO0FBQ25CLEdBQUciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TU1IvLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2Nqcy9yZWFjdC1kb20tc2VydmVyLmJyb3dzZXIuZGV2ZWxvcG1lbnQuanM/ZTMxYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1kb20tc2VydmVyLmJyb3dzZXIuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbi8qXG5cblxuIEpTIEltcGxlbWVudGF0aW9uIG9mIE11cm11ckhhc2gzIChyMTM2KSAoYXMgb2YgTWF5IDIwLCAyMDExKVxuXG4gQ29weXJpZ2h0IChjKSAyMDExIEdhcnkgQ291cnRcbiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiBTT0ZUV0FSRS5cbiovXG5cInVzZSBzdHJpY3RcIjtcblwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViAmJlxuICAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIHN0eWxlUmVwbGFjZXIobWF0Y2gsIHByZWZpeCwgcywgc3VmZml4KSB7XG4gICAgICByZXR1cm4gXCJcIiArIHByZWZpeCArIChcInNcIiA9PT0gcyA/IFwiXFxcXDczIFwiIDogXCJcXFxcNTMgXCIpICsgc3VmZml4O1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY3JpcHRSZXBsYWNlcihtYXRjaCwgcHJlZml4LCBzLCBzdWZmaXgpIHtcbiAgICAgIHJldHVybiBcIlwiICsgcHJlZml4ICsgKFwic1wiID09PSBzID8gXCJcXFxcdTAwNzNcIiA6IFwiXFxcXHUwMDUzXCIpICsgc3VmZml4O1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgICAgIGlmIChudWxsID09PSBtYXliZUl0ZXJhYmxlIHx8IFwib2JqZWN0XCIgIT09IHR5cGVvZiBtYXliZUl0ZXJhYmxlKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIG1heWJlSXRlcmFibGUgPVxuICAgICAgICAoTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSkgfHxcbiAgICAgICAgbWF5YmVJdGVyYWJsZVtcIkBAaXRlcmF0b3JcIl07XG4gICAgICByZXR1cm4gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbWF5YmVJdGVyYWJsZSA/IG1heWJlSXRlcmFibGUgOiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvYmplY3ROYW1lKG9iamVjdCkge1xuICAgICAgb2JqZWN0ID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCk7XG4gICAgICByZXR1cm4gb2JqZWN0LnNsaWNlKDgsIG9iamVjdC5sZW5ndGggLSAxKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVLZXlGb3JFcnJvck1lc3NhZ2Uoa2V5KSB7XG4gICAgICB2YXIgZW5jb2RlZEtleSA9IEpTT04uc3RyaW5naWZ5KGtleSk7XG4gICAgICByZXR1cm4gJ1wiJyArIGtleSArICdcIicgPT09IGVuY29kZWRLZXkgPyBrZXkgOiBlbmNvZGVkS2V5O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZVZhbHVlRm9yRXJyb3JNZXNzYWdlKHZhbHVlKSB7XG4gICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgMTAgPj0gdmFsdWUubGVuZ3RoID8gdmFsdWUgOiB2YWx1ZS5zbGljZSgwLCAxMCkgKyBcIi4uLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgIGlmIChpc0FycmF5SW1wbCh2YWx1ZSkpIHJldHVybiBcIlsuLi5dXCI7XG4gICAgICAgICAgaWYgKG51bGwgIT09IHZhbHVlICYmIHZhbHVlLiQkdHlwZW9mID09PSBDTElFTlRfUkVGRVJFTkNFX1RBRylcbiAgICAgICAgICAgIHJldHVybiBcImNsaWVudFwiO1xuICAgICAgICAgIHZhbHVlID0gb2JqZWN0TmFtZSh2YWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIFwiT2JqZWN0XCIgPT09IHZhbHVlID8gXCJ7Li4ufVwiIDogdmFsdWU7XG4gICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgIHJldHVybiB2YWx1ZS4kJHR5cGVvZiA9PT0gQ0xJRU5UX1JFRkVSRU5DRV9UQUdcbiAgICAgICAgICAgID8gXCJjbGllbnRcIlxuICAgICAgICAgICAgOiAodmFsdWUgPSB2YWx1ZS5kaXNwbGF5TmFtZSB8fCB2YWx1ZS5uYW1lKVxuICAgICAgICAgICAgICA/IFwiZnVuY3Rpb24gXCIgKyB2YWx1ZVxuICAgICAgICAgICAgICA6IFwiZnVuY3Rpb25cIjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVFbGVtZW50VHlwZSh0eXBlKSB7XG4gICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHR5cGUpIHJldHVybiB0eXBlO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZVwiO1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZUxpc3RcIjtcbiAgICAgIH1cbiAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlRWxlbWVudFR5cGUodHlwZS5yZW5kZXIpO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlRWxlbWVudFR5cGUodHlwZS50eXBlKTtcbiAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgIHZhciBwYXlsb2FkID0gdHlwZS5fcGF5bG9hZDtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLl9pbml0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlRWxlbWVudFR5cGUodHlwZShwYXlsb2FkKSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVPYmplY3RGb3JFcnJvck1lc3NhZ2Uob2JqZWN0T3JBcnJheSwgZXhwYW5kZWROYW1lKSB7XG4gICAgICB2YXIgb2JqS2luZCA9IG9iamVjdE5hbWUob2JqZWN0T3JBcnJheSk7XG4gICAgICBpZiAoXCJPYmplY3RcIiAhPT0gb2JqS2luZCAmJiBcIkFycmF5XCIgIT09IG9iaktpbmQpIHJldHVybiBvYmpLaW5kO1xuICAgICAgdmFyIHN0YXJ0ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IDA7XG4gICAgICBpZiAoaXNBcnJheUltcGwob2JqZWN0T3JBcnJheSkpXG4gICAgICAgIGlmIChqc3hDaGlsZHJlblBhcmVudHMuaGFzKG9iamVjdE9yQXJyYXkpKSB7XG4gICAgICAgICAgdmFyIHR5cGUgPSBqc3hDaGlsZHJlblBhcmVudHMuZ2V0KG9iamVjdE9yQXJyYXkpO1xuICAgICAgICAgIG9iaktpbmQgPSBcIjxcIiArIGRlc2NyaWJlRWxlbWVudFR5cGUodHlwZSkgKyBcIj5cIjtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdE9yQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IG9iamVjdE9yQXJyYXlbaV07XG4gICAgICAgICAgICB2YWx1ZSA9XG4gICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiB2YWx1ZVxuICAgICAgICAgICAgICAgID8gdmFsdWVcbiAgICAgICAgICAgICAgICA6IFwib2JqZWN0XCIgPT09IHR5cGVvZiB2YWx1ZSAmJiBudWxsICE9PSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgPyBcIntcIiArIGRlc2NyaWJlT2JqZWN0Rm9yRXJyb3JNZXNzYWdlKHZhbHVlKSArIFwifVwiXG4gICAgICAgICAgICAgICAgICA6IFwie1wiICsgZGVzY3JpYmVWYWx1ZUZvckVycm9yTWVzc2FnZSh2YWx1ZSkgKyBcIn1cIjtcbiAgICAgICAgICAgIFwiXCIgKyBpID09PSBleHBhbmRlZE5hbWVcbiAgICAgICAgICAgICAgPyAoKHN0YXJ0ID0gb2JqS2luZC5sZW5ndGgpLFxuICAgICAgICAgICAgICAgIChsZW5ndGggPSB2YWx1ZS5sZW5ndGgpLFxuICAgICAgICAgICAgICAgIChvYmpLaW5kICs9IHZhbHVlKSlcbiAgICAgICAgICAgICAgOiAob2JqS2luZCA9XG4gICAgICAgICAgICAgICAgICAxNSA+IHZhbHVlLmxlbmd0aCAmJiA0MCA+IG9iaktpbmQubGVuZ3RoICsgdmFsdWUubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgID8gb2JqS2luZCArIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIDogb2JqS2luZCArIFwiey4uLn1cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9iaktpbmQgKz0gXCI8L1wiICsgZGVzY3JpYmVFbGVtZW50VHlwZSh0eXBlKSArIFwiPlwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9iaktpbmQgPSBcIltcIjtcbiAgICAgICAgICBmb3IgKHR5cGUgPSAwOyB0eXBlIDwgb2JqZWN0T3JBcnJheS5sZW5ndGg7IHR5cGUrKylcbiAgICAgICAgICAgIDAgPCB0eXBlICYmIChvYmpLaW5kICs9IFwiLCBcIiksXG4gICAgICAgICAgICAgIChpID0gb2JqZWN0T3JBcnJheVt0eXBlXSksXG4gICAgICAgICAgICAgIChpID1cbiAgICAgICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgaSAmJiBudWxsICE9PSBpXG4gICAgICAgICAgICAgICAgICA/IGRlc2NyaWJlT2JqZWN0Rm9yRXJyb3JNZXNzYWdlKGkpXG4gICAgICAgICAgICAgICAgICA6IGRlc2NyaWJlVmFsdWVGb3JFcnJvck1lc3NhZ2UoaSkpLFxuICAgICAgICAgICAgICBcIlwiICsgdHlwZSA9PT0gZXhwYW5kZWROYW1lXG4gICAgICAgICAgICAgICAgPyAoKHN0YXJ0ID0gb2JqS2luZC5sZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgKGxlbmd0aCA9IGkubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgIChvYmpLaW5kICs9IGkpKVxuICAgICAgICAgICAgICAgIDogKG9iaktpbmQgPVxuICAgICAgICAgICAgICAgICAgICAxMCA+IGkubGVuZ3RoICYmIDQwID4gb2JqS2luZC5sZW5ndGggKyBpLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgID8gb2JqS2luZCArIGlcbiAgICAgICAgICAgICAgICAgICAgICA6IG9iaktpbmQgKyBcIi4uLlwiKTtcbiAgICAgICAgICBvYmpLaW5kICs9IFwiXVwiO1xuICAgICAgICB9XG4gICAgICBlbHNlIGlmIChvYmplY3RPckFycmF5LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpXG4gICAgICAgIG9iaktpbmQgPSBcIjxcIiArIGRlc2NyaWJlRWxlbWVudFR5cGUob2JqZWN0T3JBcnJheS50eXBlKSArIFwiLz5cIjtcbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAob2JqZWN0T3JBcnJheS4kJHR5cGVvZiA9PT0gQ0xJRU5UX1JFRkVSRU5DRV9UQUcpIHJldHVybiBcImNsaWVudFwiO1xuICAgICAgICBpZiAoanN4UHJvcHNQYXJlbnRzLmhhcyhvYmplY3RPckFycmF5KSkge1xuICAgICAgICAgIG9iaktpbmQgPSBqc3hQcm9wc1BhcmVudHMuZ2V0KG9iamVjdE9yQXJyYXkpO1xuICAgICAgICAgIG9iaktpbmQgPSBcIjxcIiArIChkZXNjcmliZUVsZW1lbnRUeXBlKG9iaktpbmQpIHx8IFwiLi4uXCIpO1xuICAgICAgICAgIHR5cGUgPSBPYmplY3Qua2V5cyhvYmplY3RPckFycmF5KTtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdHlwZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgb2JqS2luZCArPSBcIiBcIjtcbiAgICAgICAgICAgIHZhbHVlID0gdHlwZVtpXTtcbiAgICAgICAgICAgIG9iaktpbmQgKz0gZGVzY3JpYmVLZXlGb3JFcnJvck1lc3NhZ2UodmFsdWUpICsgXCI9XCI7XG4gICAgICAgICAgICB2YXIgX3ZhbHVlMiA9IG9iamVjdE9yQXJyYXlbdmFsdWVdO1xuICAgICAgICAgICAgdmFyIF9zdWJzdHIyID1cbiAgICAgICAgICAgICAgdmFsdWUgPT09IGV4cGFuZGVkTmFtZSAmJlxuICAgICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgX3ZhbHVlMiAmJlxuICAgICAgICAgICAgICBudWxsICE9PSBfdmFsdWUyXG4gICAgICAgICAgICAgICAgPyBkZXNjcmliZU9iamVjdEZvckVycm9yTWVzc2FnZShfdmFsdWUyKVxuICAgICAgICAgICAgICAgIDogZGVzY3JpYmVWYWx1ZUZvckVycm9yTWVzc2FnZShfdmFsdWUyKTtcbiAgICAgICAgICAgIFwic3RyaW5nXCIgIT09IHR5cGVvZiBfdmFsdWUyICYmIChfc3Vic3RyMiA9IFwie1wiICsgX3N1YnN0cjIgKyBcIn1cIik7XG4gICAgICAgICAgICB2YWx1ZSA9PT0gZXhwYW5kZWROYW1lXG4gICAgICAgICAgICAgID8gKChzdGFydCA9IG9iaktpbmQubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAobGVuZ3RoID0gX3N1YnN0cjIubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAob2JqS2luZCArPSBfc3Vic3RyMikpXG4gICAgICAgICAgICAgIDogKG9iaktpbmQgPVxuICAgICAgICAgICAgICAgICAgMTAgPiBfc3Vic3RyMi5sZW5ndGggJiYgNDAgPiBvYmpLaW5kLmxlbmd0aCArIF9zdWJzdHIyLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICA/IG9iaktpbmQgKyBfc3Vic3RyMlxuICAgICAgICAgICAgICAgICAgICA6IG9iaktpbmQgKyBcIi4uLlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb2JqS2luZCArPSBcIj5cIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvYmpLaW5kID0gXCJ7XCI7XG4gICAgICAgICAgdHlwZSA9IE9iamVjdC5rZXlzKG9iamVjdE9yQXJyYXkpO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0eXBlLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgMCA8IGkgJiYgKG9iaktpbmQgKz0gXCIsIFwiKSxcbiAgICAgICAgICAgICAgKHZhbHVlID0gdHlwZVtpXSksXG4gICAgICAgICAgICAgIChvYmpLaW5kICs9IGRlc2NyaWJlS2V5Rm9yRXJyb3JNZXNzYWdlKHZhbHVlKSArIFwiOiBcIiksXG4gICAgICAgICAgICAgIChfdmFsdWUyID0gb2JqZWN0T3JBcnJheVt2YWx1ZV0pLFxuICAgICAgICAgICAgICAoX3ZhbHVlMiA9XG4gICAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIF92YWx1ZTIgJiYgbnVsbCAhPT0gX3ZhbHVlMlxuICAgICAgICAgICAgICAgICAgPyBkZXNjcmliZU9iamVjdEZvckVycm9yTWVzc2FnZShfdmFsdWUyKVxuICAgICAgICAgICAgICAgICAgOiBkZXNjcmliZVZhbHVlRm9yRXJyb3JNZXNzYWdlKF92YWx1ZTIpKSxcbiAgICAgICAgICAgICAgdmFsdWUgPT09IGV4cGFuZGVkTmFtZVxuICAgICAgICAgICAgICAgID8gKChzdGFydCA9IG9iaktpbmQubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgIChsZW5ndGggPSBfdmFsdWUyLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgICAob2JqS2luZCArPSBfdmFsdWUyKSlcbiAgICAgICAgICAgICAgICA6IChvYmpLaW5kID1cbiAgICAgICAgICAgICAgICAgICAgMTAgPiBfdmFsdWUyLmxlbmd0aCAmJiA0MCA+IG9iaktpbmQubGVuZ3RoICsgX3ZhbHVlMi5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICA/IG9iaktpbmQgKyBfdmFsdWUyXG4gICAgICAgICAgICAgICAgICAgICAgOiBvYmpLaW5kICsgXCIuLi5cIik7XG4gICAgICAgICAgb2JqS2luZCArPSBcIn1cIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gZXhwYW5kZWROYW1lXG4gICAgICAgID8gb2JqS2luZFxuICAgICAgICA6IC0xIDwgc3RhcnQgJiYgMCA8IGxlbmd0aFxuICAgICAgICAgID8gKChvYmplY3RPckFycmF5ID0gXCIgXCIucmVwZWF0KHN0YXJ0KSArIFwiXlwiLnJlcGVhdChsZW5ndGgpKSxcbiAgICAgICAgICAgIFwiXFxuICBcIiArIG9iaktpbmQgKyBcIlxcbiAgXCIgKyBvYmplY3RPckFycmF5KVxuICAgICAgICAgIDogXCJcXG4gIFwiICsgb2JqS2luZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbXVybXVyaGFzaDNfMzJfZ2Moa2V5LCBzZWVkKSB7XG4gICAgICB2YXIgcmVtYWluZGVyID0ga2V5Lmxlbmd0aCAmIDM7XG4gICAgICB2YXIgYnl0ZXMgPSBrZXkubGVuZ3RoIC0gcmVtYWluZGVyO1xuICAgICAgdmFyIGgxID0gc2VlZDtcbiAgICAgIGZvciAoc2VlZCA9IDA7IHNlZWQgPCBieXRlczsgKSB7XG4gICAgICAgIHZhciBrMSA9XG4gICAgICAgICAgKGtleS5jaGFyQ29kZUF0KHNlZWQpICYgMjU1KSB8XG4gICAgICAgICAgKChrZXkuY2hhckNvZGVBdCgrK3NlZWQpICYgMjU1KSA8PCA4KSB8XG4gICAgICAgICAgKChrZXkuY2hhckNvZGVBdCgrK3NlZWQpICYgMjU1KSA8PCAxNikgfFxuICAgICAgICAgICgoa2V5LmNoYXJDb2RlQXQoKytzZWVkKSAmIDI1NSkgPDwgMjQpO1xuICAgICAgICArK3NlZWQ7XG4gICAgICAgIGsxID1cbiAgICAgICAgICAoMzQzMjkxODM1MyAqIChrMSAmIDY1NTM1KSArXG4gICAgICAgICAgICAoKCgzNDMyOTE4MzUzICogKGsxID4+PiAxNikpICYgNjU1MzUpIDw8IDE2KSkgJlxuICAgICAgICAgIDQyOTQ5NjcyOTU7XG4gICAgICAgIGsxID0gKGsxIDw8IDE1KSB8IChrMSA+Pj4gMTcpO1xuICAgICAgICBrMSA9XG4gICAgICAgICAgKDQ2MTg0NTkwNyAqIChrMSAmIDY1NTM1KSArXG4gICAgICAgICAgICAoKCg0NjE4NDU5MDcgKiAoazEgPj4+IDE2KSkgJiA2NTUzNSkgPDwgMTYpKSAmXG4gICAgICAgICAgNDI5NDk2NzI5NTtcbiAgICAgICAgaDEgXj0gazE7XG4gICAgICAgIGgxID0gKGgxIDw8IDEzKSB8IChoMSA+Pj4gMTkpO1xuICAgICAgICBoMSA9XG4gICAgICAgICAgKDUgKiAoaDEgJiA2NTUzNSkgKyAoKCg1ICogKGgxID4+PiAxNikpICYgNjU1MzUpIDw8IDE2KSkgJiA0Mjk0OTY3Mjk1O1xuICAgICAgICBoMSA9IChoMSAmIDY1NTM1KSArIDI3NDkyICsgKCgoKGgxID4+PiAxNikgKyA1ODk2NCkgJiA2NTUzNSkgPDwgMTYpO1xuICAgICAgfVxuICAgICAgazEgPSAwO1xuICAgICAgc3dpdGNoIChyZW1haW5kZXIpIHtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGsxIF49IChrZXkuY2hhckNvZGVBdChzZWVkICsgMikgJiAyNTUpIDw8IDE2O1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgazEgXj0gKGtleS5jaGFyQ29kZUF0KHNlZWQgKyAxKSAmIDI1NSkgPDwgODtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIChrMSBePSBrZXkuY2hhckNvZGVBdChzZWVkKSAmIDI1NSksXG4gICAgICAgICAgICAoazEgPVxuICAgICAgICAgICAgICAoMzQzMjkxODM1MyAqIChrMSAmIDY1NTM1KSArXG4gICAgICAgICAgICAgICAgKCgoMzQzMjkxODM1MyAqIChrMSA+Pj4gMTYpKSAmIDY1NTM1KSA8PCAxNikpICZcbiAgICAgICAgICAgICAgNDI5NDk2NzI5NSksXG4gICAgICAgICAgICAoazEgPSAoazEgPDwgMTUpIHwgKGsxID4+PiAxNykpLFxuICAgICAgICAgICAgKGgxIF49XG4gICAgICAgICAgICAgICg0NjE4NDU5MDcgKiAoazEgJiA2NTUzNSkgK1xuICAgICAgICAgICAgICAgICgoKDQ2MTg0NTkwNyAqIChrMSA+Pj4gMTYpKSAmIDY1NTM1KSA8PCAxNikpICZcbiAgICAgICAgICAgICAgNDI5NDk2NzI5NSk7XG4gICAgICB9XG4gICAgICBoMSBePSBrZXkubGVuZ3RoO1xuICAgICAgaDEgXj0gaDEgPj4+IDE2O1xuICAgICAgaDEgPVxuICAgICAgICAoMjI0NjgyMjUwNyAqIChoMSAmIDY1NTM1KSArXG4gICAgICAgICAgKCgoMjI0NjgyMjUwNyAqIChoMSA+Pj4gMTYpKSAmIDY1NTM1KSA8PCAxNikpICZcbiAgICAgICAgNDI5NDk2NzI5NTtcbiAgICAgIGgxIF49IGgxID4+PiAxMztcbiAgICAgIGgxID1cbiAgICAgICAgKDMyNjY0ODk5MDkgKiAoaDEgJiA2NTUzNSkgK1xuICAgICAgICAgICgoKDMyNjY0ODk5MDkgKiAoaDEgPj4+IDE2KSkgJiA2NTUzNSkgPDwgMTYpKSAmXG4gICAgICAgIDQyOTQ5NjcyOTU7XG4gICAgICByZXR1cm4gKGgxIF4gKGgxID4+PiAxNikpID4+PiAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY2hlZHVsZVdvcmsoY2FsbGJhY2spIHtcbiAgICAgIHRhc2tRdWV1ZS5wdXNoKGNhbGxiYWNrKTtcbiAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UobnVsbCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZUVycm9ySW5OZXh0VGljayhlcnJvcikge1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNodW5rKSB7XG4gICAgICBpZiAoMCAhPT0gY2h1bmsuYnl0ZUxlbmd0aClcbiAgICAgICAgaWYgKDIwNDggPCBjaHVuay5ieXRlTGVuZ3RoKVxuICAgICAgICAgIDAgPCB3cml0dGVuQnl0ZXMgJiZcbiAgICAgICAgICAgIChkZXN0aW5hdGlvbi5lbnF1ZXVlKFxuICAgICAgICAgICAgICBuZXcgVWludDhBcnJheShjdXJyZW50Vmlldy5idWZmZXIsIDAsIHdyaXR0ZW5CeXRlcylcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICAoY3VycmVudFZpZXcgPSBuZXcgVWludDhBcnJheSgyMDQ4KSksXG4gICAgICAgICAgICAod3JpdHRlbkJ5dGVzID0gMCkpLFxuICAgICAgICAgICAgZGVzdGluYXRpb24uZW5xdWV1ZShjaHVuayk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBhbGxvd2FibGVCeXRlcyA9IGN1cnJlbnRWaWV3Lmxlbmd0aCAtIHdyaXR0ZW5CeXRlcztcbiAgICAgICAgICBhbGxvd2FibGVCeXRlcyA8IGNodW5rLmJ5dGVMZW5ndGggJiZcbiAgICAgICAgICAgICgwID09PSBhbGxvd2FibGVCeXRlc1xuICAgICAgICAgICAgICA/IGRlc3RpbmF0aW9uLmVucXVldWUoY3VycmVudFZpZXcpXG4gICAgICAgICAgICAgIDogKGN1cnJlbnRWaWV3LnNldChcbiAgICAgICAgICAgICAgICAgIGNodW5rLnN1YmFycmF5KDAsIGFsbG93YWJsZUJ5dGVzKSxcbiAgICAgICAgICAgICAgICAgIHdyaXR0ZW5CeXRlc1xuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb24uZW5xdWV1ZShjdXJyZW50VmlldyksXG4gICAgICAgICAgICAgICAgKGNodW5rID0gY2h1bmsuc3ViYXJyYXkoYWxsb3dhYmxlQnl0ZXMpKSksXG4gICAgICAgICAgICAoY3VycmVudFZpZXcgPSBuZXcgVWludDhBcnJheSgyMDQ4KSksXG4gICAgICAgICAgICAod3JpdHRlbkJ5dGVzID0gMCkpO1xuICAgICAgICAgIGN1cnJlbnRWaWV3LnNldChjaHVuaywgd3JpdHRlbkJ5dGVzKTtcbiAgICAgICAgICB3cml0dGVuQnl0ZXMgKz0gY2h1bmsuYnl0ZUxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBjaHVuaykge1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2h1bmspO1xuICAgICAgcmV0dXJuICEwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21wbGV0ZVdyaXRpbmcoZGVzdGluYXRpb24pIHtcbiAgICAgIGN1cnJlbnRWaWV3ICYmXG4gICAgICAgIDAgPCB3cml0dGVuQnl0ZXMgJiZcbiAgICAgICAgKGRlc3RpbmF0aW9uLmVucXVldWUoXG4gICAgICAgICAgbmV3IFVpbnQ4QXJyYXkoY3VycmVudFZpZXcuYnVmZmVyLCAwLCB3cml0dGVuQnl0ZXMpXG4gICAgICAgICksXG4gICAgICAgIChjdXJyZW50VmlldyA9IG51bGwpLFxuICAgICAgICAod3JpdHRlbkJ5dGVzID0gMCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdHJpbmdUb0NodW5rKGNvbnRlbnQpIHtcbiAgICAgIHJldHVybiB0ZXh0RW5jb2Rlci5lbmNvZGUoY29udGVudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhjb250ZW50KSB7XG4gICAgICBjb250ZW50ID0gdGV4dEVuY29kZXIuZW5jb2RlKGNvbnRlbnQpO1xuICAgICAgMjA0OCA8IGNvbnRlbnQuYnl0ZUxlbmd0aCAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwicHJlY29tcHV0ZWQgY2h1bmtzIG11c3QgYmUgc21hbGxlciB0aGFuIHRoZSB2aWV3IHNpemUgY29uZmlndXJlZCBmb3IgdGhpcyBob3N0LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICk7XG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9XG4gICAgZnVuY3Rpb24gYnl0ZUxlbmd0aE9mQ2h1bmsoY2h1bmspIHtcbiAgICAgIHJldHVybiBjaHVuay5ieXRlTGVuZ3RoO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbG9zZVdpdGhFcnJvcihkZXN0aW5hdGlvbiwgZXJyb3IpIHtcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGRlc3RpbmF0aW9uLmVycm9yXG4gICAgICAgID8gZGVzdGluYXRpb24uZXJyb3IoZXJyb3IpXG4gICAgICAgIDogZGVzdGluYXRpb24uY2xvc2UoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdHlwZU5hbWUodmFsdWUpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBTeW1ib2wgJiZcbiAgICAgICAgICBTeW1ib2wudG9TdHJpbmdUYWcgJiZcbiAgICAgICAgICB2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddKSB8fFxuICAgICAgICB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8XG4gICAgICAgIFwiT2JqZWN0XCJcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSwgITE7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gXCJcIiArIHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlLCBhdHRyaWJ1dGVOYW1lKSB7XG4gICAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIlRoZSBwcm92aWRlZCBgJXNgIGF0dHJpYnV0ZSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLiBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgdXNpbmcgaXQgaGVyZS5cIixcbiAgICAgICAgICAgIGF0dHJpYnV0ZU5hbWUsXG4gICAgICAgICAgICB0eXBlTmFtZSh2YWx1ZSlcbiAgICAgICAgICApLFxuICAgICAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSlcbiAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tDU1NQcm9wZXJ0eVN0cmluZ0NvZXJjaW9uKHZhbHVlLCBwcm9wTmFtZSkge1xuICAgICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJUaGUgcHJvdmlkZWQgYCVzYCBDU1MgcHJvcGVydHkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4gVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIHVzaW5nIGl0IGhlcmUuXCIsXG4gICAgICAgICAgICBwcm9wTmFtZSxcbiAgICAgICAgICAgIHR5cGVOYW1lKHZhbHVlKVxuICAgICAgICAgICksXG4gICAgICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKVxuICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0h0bWxTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAgICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJUaGUgcHJvdmlkZWQgSFRNTCBtYXJrdXAgdXNlcyBhIHZhbHVlIG9mIHVuc3VwcG9ydGVkIHR5cGUgJXMuIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSB1c2luZyBpdCBoZXJlLlwiLFxuICAgICAgICAgICAgdHlwZU5hbWUodmFsdWUpXG4gICAgICAgICAgKSxcbiAgICAgICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpXG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzQXR0cmlidXRlTmFtZVNhZmUoYXR0cmlidXRlTmFtZSkge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlLCBhdHRyaWJ1dGVOYW1lKSlcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZSwgYXR0cmlidXRlTmFtZSkpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGlmIChWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWC50ZXN0KGF0dHJpYnV0ZU5hbWUpKVxuICAgICAgICByZXR1cm4gKHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZVthdHRyaWJ1dGVOYW1lXSA9ICEwKTtcbiAgICAgIGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGVbYXR0cmlidXRlTmFtZV0gPSAhMDtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJJbnZhbGlkIGF0dHJpYnV0ZSBuYW1lOiBgJXNgXCIsIGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgcmV0dXJuICExO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0NvbnRyb2xsZWRWYWx1ZVByb3BzKHRhZ05hbWUsIHByb3BzKSB7XG4gICAgICBoYXNSZWFkT25seVZhbHVlW3Byb3BzLnR5cGVdIHx8XG4gICAgICAgIHByb3BzLm9uQ2hhbmdlIHx8XG4gICAgICAgIHByb3BzLm9uSW5wdXQgfHxcbiAgICAgICAgcHJvcHMucmVhZE9ubHkgfHxcbiAgICAgICAgcHJvcHMuZGlzYWJsZWQgfHxcbiAgICAgICAgbnVsbCA9PSBwcm9wcy52YWx1ZSB8fFxuICAgICAgICAoXCJzZWxlY3RcIiA9PT0gdGFnTmFtZVxuICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJZb3UgcHJvdmlkZWQgYSBgdmFsdWVgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gYG9uQ2hhbmdlYCBoYW5kbGVyLiBUaGlzIHdpbGwgcmVuZGVyIGEgcmVhZC1vbmx5IGZpZWxkLiBJZiB0aGUgZmllbGQgc2hvdWxkIGJlIG11dGFibGUgdXNlIGBkZWZhdWx0VmFsdWVgLiBPdGhlcndpc2UsIHNldCBgb25DaGFuZ2VgLlwiXG4gICAgICAgICAgICApXG4gICAgICAgICAgOiBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIllvdSBwcm92aWRlZCBhIGB2YWx1ZWAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiBgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmIHRoZSBmaWVsZCBzaG91bGQgYmUgbXV0YWJsZSB1c2UgYGRlZmF1bHRWYWx1ZWAuIE90aGVyd2lzZSwgc2V0IGVpdGhlciBgb25DaGFuZ2VgIG9yIGByZWFkT25seWAuXCJcbiAgICAgICAgICAgICkpO1xuICAgICAgcHJvcHMub25DaGFuZ2UgfHxcbiAgICAgICAgcHJvcHMucmVhZE9ubHkgfHxcbiAgICAgICAgcHJvcHMuZGlzYWJsZWQgfHxcbiAgICAgICAgbnVsbCA9PSBwcm9wcy5jaGVja2VkIHx8XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJZb3UgcHJvdmlkZWQgYSBgY2hlY2tlZGAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiBgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmIHRoZSBmaWVsZCBzaG91bGQgYmUgbXV0YWJsZSB1c2UgYGRlZmF1bHRDaGVja2VkYC4gT3RoZXJ3aXNlLCBzZXQgZWl0aGVyIGBvbkNoYW5nZWAgb3IgYHJlYWRPbmx5YC5cIlxuICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnR5JDEodGFnTmFtZSwgbmFtZSkge1xuICAgICAgaWYgKFxuICAgICAgICBoYXNPd25Qcm9wZXJ0eS5jYWxsKHdhcm5lZFByb3BlcnRpZXMkMSwgbmFtZSkgJiZcbiAgICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdXG4gICAgICApXG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIGlmIChyQVJJQUNhbWVsJDEudGVzdChuYW1lKSkge1xuICAgICAgICB0YWdOYW1lID0gXCJhcmlhLVwiICsgbmFtZS5zbGljZSg0KS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB0YWdOYW1lID0gYXJpYVByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkodGFnTmFtZSkgPyB0YWdOYW1lIDogbnVsbDtcbiAgICAgICAgaWYgKG51bGwgPT0gdGFnTmFtZSlcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJJbnZhbGlkIEFSSUEgYXR0cmlidXRlIGAlc2AuIEFSSUEgYXR0cmlidXRlcyBmb2xsb3cgdGhlIHBhdHRlcm4gYXJpYS0qIGFuZCBtdXN0IGJlIGxvd2VyY2FzZS5cIixcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICh3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSAhMClcbiAgICAgICAgICApO1xuICAgICAgICBpZiAobmFtZSAhPT0gdGFnTmFtZSlcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJJbnZhbGlkIEFSSUEgYXR0cmlidXRlIGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgP1wiLFxuICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICB0YWdOYW1lXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgKHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9ICEwKVxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAockFSSUEkMS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHRhZ05hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHRhZ05hbWUgPSBhcmlhUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eSh0YWdOYW1lKSA/IHRhZ05hbWUgOiBudWxsO1xuICAgICAgICBpZiAobnVsbCA9PSB0YWdOYW1lKSByZXR1cm4gKHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9ICEwKSwgITE7XG4gICAgICAgIG5hbWUgIT09IHRhZ05hbWUgJiZcbiAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiVW5rbm93biBBUklBIGF0dHJpYnV0ZSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD9cIixcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICB0YWdOYW1lXG4gICAgICAgICAgKSxcbiAgICAgICAgICAod2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gITApKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0aWVzJDIodHlwZSwgcHJvcHMpIHtcbiAgICAgIHZhciBpbnZhbGlkUHJvcHMgPSBbXSxcbiAgICAgICAga2V5O1xuICAgICAgZm9yIChrZXkgaW4gcHJvcHMpXG4gICAgICAgIHZhbGlkYXRlUHJvcGVydHkkMSh0eXBlLCBrZXkpIHx8IGludmFsaWRQcm9wcy5wdXNoKGtleSk7XG4gICAgICBwcm9wcyA9IGludmFsaWRQcm9wc1xuICAgICAgICAubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgcmV0dXJuIFwiYFwiICsgcHJvcCArIFwiYFwiO1xuICAgICAgICB9KVxuICAgICAgICAuam9pbihcIiwgXCIpO1xuICAgICAgMSA9PT0gaW52YWxpZFByb3BzLmxlbmd0aFxuICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkludmFsaWQgYXJpYSBwcm9wICVzIG9uIDwlcz4gdGFnLiBGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvaW52YWxpZC1hcmlhLXByb3BzXCIsXG4gICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgIHR5cGVcbiAgICAgICAgICApXG4gICAgICAgIDogMSA8IGludmFsaWRQcm9wcy5sZW5ndGggJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJJbnZhbGlkIGFyaWEgcHJvcHMgJXMgb24gPCVzPiB0YWcuIEZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9pbnZhbGlkLWFyaWEtcHJvcHNcIixcbiAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgdHlwZVxuICAgICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydHkodGFnTmFtZSwgbmFtZSwgdmFsdWUsIGV2ZW50UmVnaXN0cnkpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHdhcm5lZFByb3BlcnRpZXMsIG5hbWUpICYmIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0pXG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmIChcIm9uZm9jdXNpblwiID09PSBsb3dlckNhc2VkTmFtZSB8fCBcIm9uZm9jdXNvdXRcIiA9PT0gbG93ZXJDYXNlZE5hbWUpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiUmVhY3QgdXNlcyBvbkZvY3VzIGFuZCBvbkJsdXIgaW5zdGVhZCBvZiBvbkZvY3VzSW4gYW5kIG9uRm9jdXNPdXQuIEFsbCBSZWFjdCBldmVudHMgYXJlIG5vcm1hbGl6ZWQgdG8gYnViYmxlLCBzbyBvbkZvY3VzSW4gYW5kIG9uRm9jdXNPdXQgYXJlIG5vdCBuZWVkZWQvc3VwcG9ydGVkIGJ5IFJlYWN0LlwiXG4gICAgICAgICAgKSxcbiAgICAgICAgICAod2FybmVkUHJvcGVydGllc1tuYW1lXSA9ICEwKVxuICAgICAgICApO1xuICAgICAgaWYgKFxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICAoKFwiZm9ybVwiID09PSB0YWdOYW1lICYmIFwiYWN0aW9uXCIgPT09IG5hbWUpIHx8XG4gICAgICAgICAgKFwiaW5wdXRcIiA9PT0gdGFnTmFtZSAmJiBcImZvcm1BY3Rpb25cIiA9PT0gbmFtZSkgfHxcbiAgICAgICAgICAoXCJidXR0b25cIiA9PT0gdGFnTmFtZSAmJiBcImZvcm1BY3Rpb25cIiA9PT0gbmFtZSkpXG4gICAgICApXG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIGlmIChudWxsICE9IGV2ZW50UmVnaXN0cnkpIHtcbiAgICAgICAgdGFnTmFtZSA9IGV2ZW50UmVnaXN0cnkucG9zc2libGVSZWdpc3RyYXRpb25OYW1lcztcbiAgICAgICAgaWYgKGV2ZW50UmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSlcbiAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgIGV2ZW50UmVnaXN0cnkgPSB0YWdOYW1lLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKVxuICAgICAgICAgID8gdGFnTmFtZVtsb3dlckNhc2VkTmFtZV1cbiAgICAgICAgICA6IG51bGw7XG4gICAgICAgIGlmIChudWxsICE9IGV2ZW50UmVnaXN0cnkpXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiSW52YWxpZCBldmVudCBoYW5kbGVyIHByb3BlcnR5IGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgP1wiLFxuICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICBldmVudFJlZ2lzdHJ5XG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgKHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSAhMClcbiAgICAgICAgICApO1xuICAgICAgICBpZiAoRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlVua25vd24gZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSBgJXNgLiBJdCB3aWxsIGJlIGlnbm9yZWQuXCIsXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICAod2FybmVkUHJvcGVydGllc1tuYW1lXSA9ICEwKVxuICAgICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKEVWRU5UX05BTUVfUkVHRVgudGVzdChuYW1lKSlcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBJTlZBTElEX0VWRU5UX05BTUVfUkVHRVgudGVzdChuYW1lKSAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJJbnZhbGlkIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgYCVzYC4gUmVhY3QgZXZlbnRzIHVzZSB0aGUgY2FtZWxDYXNlIG5hbWluZyBjb252ZW50aW9uLCBmb3IgZXhhbXBsZSBgb25DbGlja2AuXCIsXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICksXG4gICAgICAgICAgKHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSAhMClcbiAgICAgICAgKTtcbiAgICAgIGlmIChyQVJJQS50ZXN0KG5hbWUpIHx8IHJBUklBQ2FtZWwudGVzdChuYW1lKSkgcmV0dXJuICEwO1xuICAgICAgaWYgKFwiaW5uZXJodG1sXCIgPT09IGxvd2VyQ2FzZWROYW1lKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkRpcmVjdGx5IHNldHRpbmcgcHJvcGVydHkgYGlubmVySFRNTGAgaXMgbm90IHBlcm1pdHRlZC4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIGxvb2t1cCBkb2N1bWVudGF0aW9uIG9uIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuXCJcbiAgICAgICAgICApLFxuICAgICAgICAgICh3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gITApXG4gICAgICAgICk7XG4gICAgICBpZiAoXCJhcmlhXCIgPT09IGxvd2VyQ2FzZWROYW1lKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIlRoZSBgYXJpYWAgYXR0cmlidXRlIGlzIHJlc2VydmVkIGZvciBmdXR1cmUgdXNlIGluIFJlYWN0LiBQYXNzIGluZGl2aWR1YWwgYGFyaWEtYCBhdHRyaWJ1dGVzIGluc3RlYWQuXCJcbiAgICAgICAgICApLFxuICAgICAgICAgICh3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gITApXG4gICAgICAgICk7XG4gICAgICBpZiAoXG4gICAgICAgIFwiaXNcIiA9PT0gbG93ZXJDYXNlZE5hbWUgJiZcbiAgICAgICAgbnVsbCAhPT0gdmFsdWUgJiZcbiAgICAgICAgdm9pZCAwICE9PSB2YWx1ZSAmJlxuICAgICAgICBcInN0cmluZ1wiICE9PSB0eXBlb2YgdmFsdWVcbiAgICAgIClcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJSZWNlaXZlZCBhIGAlc2AgZm9yIGEgc3RyaW5nIGF0dHJpYnV0ZSBgaXNgLiBJZiB0aGlzIGlzIGV4cGVjdGVkLCBjYXN0IHRoZSB2YWx1ZSB0byBhIHN0cmluZy5cIixcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZVxuICAgICAgICAgICksXG4gICAgICAgICAgKHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSAhMClcbiAgICAgICAgKTtcbiAgICAgIGlmIChcIm51bWJlclwiID09PSB0eXBlb2YgdmFsdWUgJiYgaXNOYU4odmFsdWUpKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIlJlY2VpdmVkIE5hTiBmb3IgdGhlIGAlc2AgYXR0cmlidXRlLiBJZiB0aGlzIGlzIGV4cGVjdGVkLCBjYXN0IHRoZSB2YWx1ZSB0byBhIHN0cmluZy5cIixcbiAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICApLFxuICAgICAgICAgICh3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gITApXG4gICAgICAgICk7XG4gICAgICBpZiAocG9zc2libGVTdGFuZGFyZE5hbWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgKChsb3dlckNhc2VkTmFtZSA9IHBvc3NpYmxlU3RhbmRhcmROYW1lc1tsb3dlckNhc2VkTmFtZV0pLFxuICAgICAgICAgIGxvd2VyQ2FzZWROYW1lICE9PSBuYW1lKVxuICAgICAgICApXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiSW52YWxpZCBET00gcHJvcGVydHkgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/XCIsXG4gICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgIGxvd2VyQ2FzZWROYW1lXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgKHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSAhMClcbiAgICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmIChuYW1lICE9PSBsb3dlckNhc2VkTmFtZSlcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJSZWFjdCBkb2VzIG5vdCByZWNvZ25pemUgdGhlIGAlc2AgcHJvcCBvbiBhIERPTSBlbGVtZW50LiBJZiB5b3UgaW50ZW50aW9uYWxseSB3YW50IGl0IHRvIGFwcGVhciBpbiB0aGUgRE9NIGFzIGEgY3VzdG9tIGF0dHJpYnV0ZSwgc3BlbGwgaXQgYXMgbG93ZXJjYXNlIGAlc2AgaW5zdGVhZC4gSWYgeW91IGFjY2lkZW50YWxseSBwYXNzZWQgaXQgZnJvbSBhIHBhcmVudCBjb21wb25lbnQsIHJlbW92ZSBpdCBmcm9tIHRoZSBET00gZWxlbWVudC5cIixcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBsb3dlckNhc2VkTmFtZVxuICAgICAgICAgICksXG4gICAgICAgICAgKHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSAhMClcbiAgICAgICAgKTtcbiAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICAgIGNhc2UgXCJzdHlsZVwiOlxuICAgICAgICBjYXNlIFwic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nXCI6XG4gICAgICAgIGNhc2UgXCJzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmdcIjpcbiAgICAgICAgY2FzZSBcImRlZmF1bHRWYWx1ZVwiOlxuICAgICAgICBjYXNlIFwiZGVmYXVsdENoZWNrZWRcIjpcbiAgICAgICAgY2FzZSBcImlubmVySFRNTFwiOlxuICAgICAgICBjYXNlIFwicmVmXCI6XG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICBjYXNlIFwiaW5uZXJUZXh0XCI6XG4gICAgICAgIGNhc2UgXCJ0ZXh0Q29udGVudFwiOlxuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgICAgICBjYXNlIFwiYXV0b0ZvY3VzXCI6XG4gICAgICAgICAgICBjYXNlIFwiY2hlY2tlZFwiOlxuICAgICAgICAgICAgY2FzZSBcIm11bHRpcGxlXCI6XG4gICAgICAgICAgICBjYXNlIFwibXV0ZWRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJzZWxlY3RlZFwiOlxuICAgICAgICAgICAgY2FzZSBcImNvbnRlbnRFZGl0YWJsZVwiOlxuICAgICAgICAgICAgY2FzZSBcInNwZWxsQ2hlY2tcIjpcbiAgICAgICAgICAgIGNhc2UgXCJkcmFnZ2FibGVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJ2YWx1ZVwiOlxuICAgICAgICAgICAgY2FzZSBcImF1dG9SZXZlcnNlXCI6XG4gICAgICAgICAgICBjYXNlIFwiZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZFwiOlxuICAgICAgICAgICAgY2FzZSBcImZvY3VzYWJsZVwiOlxuICAgICAgICAgICAgY2FzZSBcInByZXNlcnZlQWxwaGFcIjpcbiAgICAgICAgICAgIGNhc2UgXCJhbGxvd0Z1bGxTY3JlZW5cIjpcbiAgICAgICAgICAgIGNhc2UgXCJhc3luY1wiOlxuICAgICAgICAgICAgY2FzZSBcImF1dG9QbGF5XCI6XG4gICAgICAgICAgICBjYXNlIFwiY29udHJvbHNcIjpcbiAgICAgICAgICAgIGNhc2UgXCJkZWZhdWx0XCI6XG4gICAgICAgICAgICBjYXNlIFwiZGVmZXJcIjpcbiAgICAgICAgICAgIGNhc2UgXCJkaXNhYmxlZFwiOlxuICAgICAgICAgICAgY2FzZSBcImRpc2FibGVQaWN0dXJlSW5QaWN0dXJlXCI6XG4gICAgICAgICAgICBjYXNlIFwiZGlzYWJsZVJlbW90ZVBsYXliYWNrXCI6XG4gICAgICAgICAgICBjYXNlIFwiZm9ybU5vVmFsaWRhdGVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJoaWRkZW5cIjpcbiAgICAgICAgICAgIGNhc2UgXCJsb29wXCI6XG4gICAgICAgICAgICBjYXNlIFwibm9Nb2R1bGVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJub1ZhbGlkYXRlXCI6XG4gICAgICAgICAgICBjYXNlIFwib3BlblwiOlxuICAgICAgICAgICAgY2FzZSBcInBsYXlzSW5saW5lXCI6XG4gICAgICAgICAgICBjYXNlIFwicmVhZE9ubHlcIjpcbiAgICAgICAgICAgIGNhc2UgXCJyZXF1aXJlZFwiOlxuICAgICAgICAgICAgY2FzZSBcInJldmVyc2VkXCI6XG4gICAgICAgICAgICBjYXNlIFwic2NvcGVkXCI6XG4gICAgICAgICAgICBjYXNlIFwic2VhbWxlc3NcIjpcbiAgICAgICAgICAgIGNhc2UgXCJpdGVtU2NvcGVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJjYXB0dXJlXCI6XG4gICAgICAgICAgICBjYXNlIFwiZG93bmxvYWRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJpbmVydFwiOlxuICAgICAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBsb3dlckNhc2VkTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKS5zbGljZSgwLCA1KTtcbiAgICAgICAgICAgICAgaWYgKFwiZGF0YS1cIiA9PT0gbG93ZXJDYXNlZE5hbWUgfHwgXCJhcmlhLVwiID09PSBsb3dlckNhc2VkTmFtZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAnUmVjZWl2ZWQgYCVzYCBmb3IgYSBub24tYm9vbGVhbiBhdHRyaWJ1dGUgYCVzYC5cXG5cXG5JZiB5b3Ugd2FudCB0byB3cml0ZSBpdCB0byB0aGUgRE9NLCBwYXNzIGEgc3RyaW5nIGluc3RlYWQ6ICVzPVwiJXNcIiBvciAlcz17dmFsdWUudG9TdHJpbmcoKX0uJyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgOiBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAnUmVjZWl2ZWQgYCVzYCBmb3IgYSBub24tYm9vbGVhbiBhdHRyaWJ1dGUgYCVzYC5cXG5cXG5JZiB5b3Ugd2FudCB0byB3cml0ZSBpdCB0byB0aGUgRE9NLCBwYXNzIGEgc3RyaW5nIGluc3RlYWQ6ICVzPVwiJXNcIiBvciAlcz17dmFsdWUudG9TdHJpbmcoKX0uXFxuXFxuSWYgeW91IHVzZWQgdG8gY29uZGl0aW9uYWxseSBvbWl0IGl0IHdpdGggJXM9e2NvbmRpdGlvbiAmJiB2YWx1ZX0sIHBhc3MgJXM9e2NvbmRpdGlvbiA/IHZhbHVlIDogdW5kZWZpbmVkfSBpbnN0ZWFkLicsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcmV0dXJuICh3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gITApO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICAgICAgICByZXR1cm4gKHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSAhMCksICExO1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgaWYgKFwiZmFsc2VcIiA9PT0gdmFsdWUgfHwgXCJ0cnVlXCIgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgICAgICAgY2FzZSBcImNoZWNrZWRcIjpcbiAgICAgICAgICAgICAgY2FzZSBcInNlbGVjdGVkXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJtdWx0aXBsZVwiOlxuICAgICAgICAgICAgICBjYXNlIFwibXV0ZWRcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImFsbG93RnVsbFNjcmVlblwiOlxuICAgICAgICAgICAgICBjYXNlIFwiYXN5bmNcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImF1dG9QbGF5XCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJjb250cm9sc1wiOlxuICAgICAgICAgICAgICBjYXNlIFwiZGVmYXVsdFwiOlxuICAgICAgICAgICAgICBjYXNlIFwiZGVmZXJcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImRpc2FibGVkXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJkaXNhYmxlUGljdHVyZUluUGljdHVyZVwiOlxuICAgICAgICAgICAgICBjYXNlIFwiZGlzYWJsZVJlbW90ZVBsYXliYWNrXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJmb3JtTm9WYWxpZGF0ZVwiOlxuICAgICAgICAgICAgICBjYXNlIFwiaGlkZGVuXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJsb29wXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJub01vZHVsZVwiOlxuICAgICAgICAgICAgICBjYXNlIFwibm9WYWxpZGF0ZVwiOlxuICAgICAgICAgICAgICBjYXNlIFwib3BlblwiOlxuICAgICAgICAgICAgICBjYXNlIFwicGxheXNJbmxpbmVcIjpcbiAgICAgICAgICAgICAgY2FzZSBcInJlYWRPbmx5XCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJyZXF1aXJlZFwiOlxuICAgICAgICAgICAgICBjYXNlIFwicmV2ZXJzZWRcIjpcbiAgICAgICAgICAgICAgY2FzZSBcInNjb3BlZFwiOlxuICAgICAgICAgICAgICBjYXNlIFwic2VhbWxlc3NcIjpcbiAgICAgICAgICAgICAgY2FzZSBcIml0ZW1TY29wZVwiOlxuICAgICAgICAgICAgICBjYXNlIFwiaW5lcnRcIjpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlJlY2VpdmVkIHRoZSBzdHJpbmcgYCVzYCBmb3IgdGhlIGJvb2xlYW4gYXR0cmlidXRlIGAlc2AuICVzIERpZCB5b3UgbWVhbiAlcz17JXN9P1wiLFxuICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgXCJmYWxzZVwiID09PSB2YWx1ZVxuICAgICAgICAgICAgICAgID8gXCJUaGUgYnJvd3NlciB3aWxsIGludGVycHJldCBpdCBhcyBhIHRydXRoeSB2YWx1ZS5cIlxuICAgICAgICAgICAgICAgIDogJ0FsdGhvdWdoIHRoaXMgd29ya3MsIGl0IHdpbGwgbm90IHdvcmsgYXMgZXhwZWN0ZWQgaWYgeW91IHBhc3MgdGhlIHN0cmluZyBcImZhbHNlXCIuJyxcbiAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gITA7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuICEwO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3YXJuVW5rbm93blByb3BlcnRpZXModHlwZSwgcHJvcHMsIGV2ZW50UmVnaXN0cnkpIHtcbiAgICAgIHZhciB1bmtub3duUHJvcHMgPSBbXSxcbiAgICAgICAga2V5O1xuICAgICAgZm9yIChrZXkgaW4gcHJvcHMpXG4gICAgICAgIHZhbGlkYXRlUHJvcGVydHkodHlwZSwga2V5LCBwcm9wc1trZXldLCBldmVudFJlZ2lzdHJ5KSB8fFxuICAgICAgICAgIHVua25vd25Qcm9wcy5wdXNoKGtleSk7XG4gICAgICBwcm9wcyA9IHVua25vd25Qcm9wc1xuICAgICAgICAubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgcmV0dXJuIFwiYFwiICsgcHJvcCArIFwiYFwiO1xuICAgICAgICB9KVxuICAgICAgICAuam9pbihcIiwgXCIpO1xuICAgICAgMSA9PT0gdW5rbm93blByb3BzLmxlbmd0aFxuICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkludmFsaWQgdmFsdWUgZm9yIHByb3AgJXMgb24gPCVzPiB0YWcuIEVpdGhlciByZW1vdmUgaXQgZnJvbSB0aGUgZWxlbWVudCwgb3IgcGFzcyBhIHN0cmluZyBvciBudW1iZXIgdmFsdWUgdG8ga2VlcCBpdCBpbiB0aGUgRE9NLiBGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvYXR0cmlidXRlLWJlaGF2aW9yIFwiLFxuICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICB0eXBlXG4gICAgICAgICAgKVxuICAgICAgICA6IDEgPCB1bmtub3duUHJvcHMubGVuZ3RoICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiSW52YWxpZCB2YWx1ZXMgZm9yIHByb3BzICVzIG9uIDwlcz4gdGFnLiBFaXRoZXIgcmVtb3ZlIHRoZW0gZnJvbSB0aGUgZWxlbWVudCwgb3IgcGFzcyBhIHN0cmluZyBvciBudW1iZXIgdmFsdWUgdG8ga2VlcCB0aGVtIGluIHRoZSBET00uIEZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9hdHRyaWJ1dGUtYmVoYXZpb3IgXCIsXG4gICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgIHR5cGVcbiAgICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjYW1lbGl6ZShzdHJpbmcpIHtcbiAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZShoeXBoZW5QYXR0ZXJuLCBmdW5jdGlvbiAoXywgY2hhcmFjdGVyKSB7XG4gICAgICAgIHJldHVybiBjaGFyYWN0ZXIudG9VcHBlckNhc2UoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlc2NhcGVUZXh0Rm9yQnJvd3Nlcih0ZXh0KSB7XG4gICAgICBpZiAoXG4gICAgICAgIFwiYm9vbGVhblwiID09PSB0eXBlb2YgdGV4dCB8fFxuICAgICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgdGV4dCB8fFxuICAgICAgICBcImJpZ2ludFwiID09PSB0eXBlb2YgdGV4dFxuICAgICAgKVxuICAgICAgICByZXR1cm4gXCJcIiArIHRleHQ7XG4gICAgICBjaGVja0h0bWxTdHJpbmdDb2VyY2lvbih0ZXh0KTtcbiAgICAgIHRleHQgPSBcIlwiICsgdGV4dDtcbiAgICAgIHZhciBtYXRjaCA9IG1hdGNoSHRtbFJlZ0V4cC5leGVjKHRleHQpO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIHZhciBodG1sID0gXCJcIixcbiAgICAgICAgICBpbmRleCxcbiAgICAgICAgICBsYXN0SW5kZXggPSAwO1xuICAgICAgICBmb3IgKGluZGV4ID0gbWF0Y2guaW5kZXg7IGluZGV4IDwgdGV4dC5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICBzd2l0Y2ggKHRleHQuY2hhckNvZGVBdChpbmRleCkpIHtcbiAgICAgICAgICAgIGNhc2UgMzQ6XG4gICAgICAgICAgICAgIG1hdGNoID0gXCImcXVvdDtcIjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM4OlxuICAgICAgICAgICAgICBtYXRjaCA9IFwiJmFtcDtcIjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM5OlxuICAgICAgICAgICAgICBtYXRjaCA9IFwiJiN4Mjc7XCI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA2MDpcbiAgICAgICAgICAgICAgbWF0Y2ggPSBcIiZsdDtcIjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDYyOlxuICAgICAgICAgICAgICBtYXRjaCA9IFwiJmd0O1wiO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsYXN0SW5kZXggIT09IGluZGV4ICYmIChodG1sICs9IHRleHQuc2xpY2UobGFzdEluZGV4LCBpbmRleCkpO1xuICAgICAgICAgIGxhc3RJbmRleCA9IGluZGV4ICsgMTtcbiAgICAgICAgICBodG1sICs9IG1hdGNoO1xuICAgICAgICB9XG4gICAgICAgIHRleHQgPSBsYXN0SW5kZXggIT09IGluZGV4ID8gaHRtbCArIHRleHQuc2xpY2UobGFzdEluZGV4LCBpbmRleCkgOiBodG1sO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNhbml0aXplVVJMKHVybCkge1xuICAgICAgcmV0dXJuIGlzSmF2YVNjcmlwdFByb3RvY29sLnRlc3QoXCJcIiArIHVybClcbiAgICAgICAgPyBcImphdmFzY3JpcHQ6dGhyb3cgbmV3IEVycm9yKCdSZWFjdCBoYXMgYmxvY2tlZCBhIGphdmFzY3JpcHQ6IFVSTCBhcyBhIHNlY3VyaXR5IHByZWNhdXRpb24uJylcIlxuICAgICAgICA6IHVybDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZXNjYXBlRW50aXJlSW5saW5lU2NyaXB0Q29udGVudChzY3JpcHRUZXh0KSB7XG4gICAgICBjaGVja0h0bWxTdHJpbmdDb2VyY2lvbihzY3JpcHRUZXh0KTtcbiAgICAgIHJldHVybiAoXCJcIiArIHNjcmlwdFRleHQpLnJlcGxhY2Uoc2NyaXB0UmVnZXgsIHNjcmlwdFJlcGxhY2VyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlUmVuZGVyU3RhdGUoXG4gICAgICByZXN1bWFibGVTdGF0ZSxcbiAgICAgIG5vbmNlLFxuICAgICAgZXh0ZXJuYWxSdW50aW1lQ29uZmlnLFxuICAgICAgaW1wb3J0TWFwLFxuICAgICAgb25IZWFkZXJzLFxuICAgICAgbWF4SGVhZGVyc0xlbmd0aFxuICAgICkge1xuICAgICAgZXh0ZXJuYWxSdW50aW1lQ29uZmlnID1cbiAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG5vbmNlID8gbm9uY2UgOiBub25jZSAmJiBub25jZS5zY3JpcHQ7XG4gICAgICB2YXIgaW5saW5lU2NyaXB0V2l0aE5vbmNlID1cbiAgICAgICAgICB2b2lkIDAgPT09IGV4dGVybmFsUnVudGltZUNvbmZpZ1xuICAgICAgICAgICAgPyBzdGFydElubGluZVNjcmlwdFxuICAgICAgICAgICAgOiBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXG4gICAgICAgICAgICAgICAgJzxzY3JpcHQgbm9uY2U9XCInICtcbiAgICAgICAgICAgICAgICAgIGVzY2FwZVRleHRGb3JCcm93c2VyKGV4dGVybmFsUnVudGltZUNvbmZpZykgK1xuICAgICAgICAgICAgICAgICAgJ1wiJ1xuICAgICAgICAgICAgICApLFxuICAgICAgICBub25jZVN0eWxlID0gXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG5vbmNlID8gdm9pZCAwIDogbm9uY2UgJiYgbm9uY2Uuc3R5bGUsXG4gICAgICAgIGlubGluZVN0eWxlV2l0aE5vbmNlID1cbiAgICAgICAgICB2b2lkIDAgPT09IG5vbmNlU3R5bGVcbiAgICAgICAgICAgID8gc3RhcnRJbmxpbmVTdHlsZVxuICAgICAgICAgICAgOiBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXG4gICAgICAgICAgICAgICAgJzxzdHlsZSBub25jZT1cIicgKyBlc2NhcGVUZXh0Rm9yQnJvd3Nlcihub25jZVN0eWxlKSArICdcIidcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgaWRQcmVmaXggPSByZXN1bWFibGVTdGF0ZS5pZFByZWZpeCxcbiAgICAgICAgYm9vdHN0cmFwQ2h1bmtzID0gW10sXG4gICAgICAgIGJvb3RzdHJhcFNjcmlwdENvbnRlbnQgPSByZXN1bWFibGVTdGF0ZS5ib290c3RyYXBTY3JpcHRDb250ZW50LFxuICAgICAgICBib290c3RyYXBTY3JpcHRzID0gcmVzdW1hYmxlU3RhdGUuYm9vdHN0cmFwU2NyaXB0cyxcbiAgICAgICAgYm9vdHN0cmFwTW9kdWxlcyA9IHJlc3VtYWJsZVN0YXRlLmJvb3RzdHJhcE1vZHVsZXM7XG4gICAgICB2b2lkIDAgIT09IGJvb3RzdHJhcFNjcmlwdENvbnRlbnQgJiZcbiAgICAgICAgKGJvb3RzdHJhcENodW5rcy5wdXNoKGlubGluZVNjcmlwdFdpdGhOb25jZSksXG4gICAgICAgIHB1c2hDb21wbGV0ZWRTaGVsbElkQXR0cmlidXRlKGJvb3RzdHJhcENodW5rcywgcmVzdW1hYmxlU3RhdGUpLFxuICAgICAgICBib290c3RyYXBDaHVua3MucHVzaChcbiAgICAgICAgICBlbmRPZlN0YXJ0VGFnLFxuICAgICAgICAgIHN0cmluZ1RvQ2h1bmsoXG4gICAgICAgICAgICBlc2NhcGVFbnRpcmVJbmxpbmVTY3JpcHRDb250ZW50KGJvb3RzdHJhcFNjcmlwdENvbnRlbnQpXG4gICAgICAgICAgKSxcbiAgICAgICAgICBlbmRJbmxpbmVTY3JpcHRcbiAgICAgICAgKSk7XG4gICAgICBib290c3RyYXBTY3JpcHRDb250ZW50ID0gW107XG4gICAgICB2b2lkIDAgIT09IGltcG9ydE1hcCAmJlxuICAgICAgICAoYm9vdHN0cmFwU2NyaXB0Q29udGVudC5wdXNoKGltcG9ydE1hcFNjcmlwdFN0YXJ0KSxcbiAgICAgICAgYm9vdHN0cmFwU2NyaXB0Q29udGVudC5wdXNoKFxuICAgICAgICAgIHN0cmluZ1RvQ2h1bmsoXG4gICAgICAgICAgICBlc2NhcGVFbnRpcmVJbmxpbmVTY3JpcHRDb250ZW50KEpTT04uc3RyaW5naWZ5KGltcG9ydE1hcCkpXG4gICAgICAgICAgKVxuICAgICAgICApLFxuICAgICAgICBib290c3RyYXBTY3JpcHRDb250ZW50LnB1c2goaW1wb3J0TWFwU2NyaXB0RW5kKSk7XG4gICAgICBvbkhlYWRlcnMgJiZcbiAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIG1heEhlYWRlcnNMZW5ndGggJiZcbiAgICAgICAgMCA+PSBtYXhIZWFkZXJzTGVuZ3RoICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJSZWFjdCBleHBlY3RlZCBhIHBvc2l0aXZlIG5vbi16ZXJvIGBtYXhIZWFkZXJzTGVuZ3RoYCBvcHRpb24gYnV0IGZvdW5kICVzIGluc3RlYWQuIFdoZW4gdXNpbmcgdGhlIGBvbkhlYWRlcnNgIG9wdGlvbiB5b3UgbWF5IHN1cHBseSBhbiBvcHRpb25hbCBgbWF4SGVhZGVyc0xlbmd0aGAgb3B0aW9uIGFzIHdlbGwgaG93ZXZlciwgd2hlbiBzZXR0aW5nIHRoaXMgdmFsdWUgdG8gemVybyBvciBsZXNzIG5vIGhlYWRlcnMgd2lsbCBiZSBjYXB0dXJlZC5cIixcbiAgICAgICAgICAwID09PSBtYXhIZWFkZXJzTGVuZ3RoID8gXCJ6ZXJvXCIgOiBtYXhIZWFkZXJzTGVuZ3RoXG4gICAgICAgICk7XG4gICAgICBpbXBvcnRNYXAgPSBvbkhlYWRlcnNcbiAgICAgICAgPyB7XG4gICAgICAgICAgICBwcmVjb25uZWN0czogXCJcIixcbiAgICAgICAgICAgIGZvbnRQcmVsb2FkczogXCJcIixcbiAgICAgICAgICAgIGhpZ2hJbWFnZVByZWxvYWRzOiBcIlwiLFxuICAgICAgICAgICAgcmVtYWluaW5nQ2FwYWNpdHk6XG4gICAgICAgICAgICAgIDIgK1xuICAgICAgICAgICAgICAoXCJudW1iZXJcIiA9PT0gdHlwZW9mIG1heEhlYWRlcnNMZW5ndGggPyBtYXhIZWFkZXJzTGVuZ3RoIDogMmUzKVxuICAgICAgICAgIH1cbiAgICAgICAgOiBudWxsO1xuICAgICAgb25IZWFkZXJzID0ge1xuICAgICAgICBwbGFjZWhvbGRlclByZWZpeDogc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKGlkUHJlZml4ICsgXCJQOlwiKSxcbiAgICAgICAgc2VnbWVudFByZWZpeDogc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKGlkUHJlZml4ICsgXCJTOlwiKSxcbiAgICAgICAgYm91bmRhcnlQcmVmaXg6IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhpZFByZWZpeCArIFwiQjpcIiksXG4gICAgICAgIHN0YXJ0SW5saW5lU2NyaXB0OiBpbmxpbmVTY3JpcHRXaXRoTm9uY2UsXG4gICAgICAgIHN0YXJ0SW5saW5lU3R5bGU6IGlubGluZVN0eWxlV2l0aE5vbmNlLFxuICAgICAgICBwcmVhbWJsZTogY3JlYXRlUHJlYW1ibGVTdGF0ZSgpLFxuICAgICAgICBleHRlcm5hbFJ1bnRpbWVTY3JpcHQ6IG51bGwsXG4gICAgICAgIGJvb3RzdHJhcENodW5rczogYm9vdHN0cmFwQ2h1bmtzLFxuICAgICAgICBpbXBvcnRNYXBDaHVua3M6IGJvb3RzdHJhcFNjcmlwdENvbnRlbnQsXG4gICAgICAgIG9uSGVhZGVyczogb25IZWFkZXJzLFxuICAgICAgICBoZWFkZXJzOiBpbXBvcnRNYXAsXG4gICAgICAgIHJlc2V0czoge1xuICAgICAgICAgIGZvbnQ6IHt9LFxuICAgICAgICAgIGRuczoge30sXG4gICAgICAgICAgY29ubmVjdDogeyBkZWZhdWx0OiB7fSwgYW5vbnltb3VzOiB7fSwgY3JlZGVudGlhbHM6IHt9IH0sXG4gICAgICAgICAgaW1hZ2U6IHt9LFxuICAgICAgICAgIHN0eWxlOiB7fVxuICAgICAgICB9LFxuICAgICAgICBjaGFyc2V0Q2h1bmtzOiBbXSxcbiAgICAgICAgdmlld3BvcnRDaHVua3M6IFtdLFxuICAgICAgICBob2lzdGFibGVDaHVua3M6IFtdLFxuICAgICAgICBwcmVjb25uZWN0czogbmV3IFNldCgpLFxuICAgICAgICBmb250UHJlbG9hZHM6IG5ldyBTZXQoKSxcbiAgICAgICAgaGlnaEltYWdlUHJlbG9hZHM6IG5ldyBTZXQoKSxcbiAgICAgICAgc3R5bGVzOiBuZXcgTWFwKCksXG4gICAgICAgIGJvb3RzdHJhcFNjcmlwdHM6IG5ldyBTZXQoKSxcbiAgICAgICAgc2NyaXB0czogbmV3IFNldCgpLFxuICAgICAgICBidWxrUHJlbG9hZHM6IG5ldyBTZXQoKSxcbiAgICAgICAgcHJlbG9hZHM6IHtcbiAgICAgICAgICBpbWFnZXM6IG5ldyBNYXAoKSxcbiAgICAgICAgICBzdHlsZXNoZWV0czogbmV3IE1hcCgpLFxuICAgICAgICAgIHNjcmlwdHM6IG5ldyBNYXAoKSxcbiAgICAgICAgICBtb2R1bGVTY3JpcHRzOiBuZXcgTWFwKClcbiAgICAgICAgfSxcbiAgICAgICAgbm9uY2U6IHsgc2NyaXB0OiBleHRlcm5hbFJ1bnRpbWVDb25maWcsIHN0eWxlOiBub25jZVN0eWxlIH0sXG4gICAgICAgIGhvaXN0YWJsZVN0YXRlOiBudWxsLFxuICAgICAgICBzdHlsZXNUb0hvaXN0OiAhMVxuICAgICAgfTtcbiAgICAgIGlmICh2b2lkIDAgIT09IGJvb3RzdHJhcFNjcmlwdHMpXG4gICAgICAgIGZvciAoaW1wb3J0TWFwID0gMDsgaW1wb3J0TWFwIDwgYm9vdHN0cmFwU2NyaXB0cy5sZW5ndGg7IGltcG9ydE1hcCsrKVxuICAgICAgICAgIChtYXhIZWFkZXJzTGVuZ3RoID0gYm9vdHN0cmFwU2NyaXB0c1tpbXBvcnRNYXBdKSxcbiAgICAgICAgICAgIChpbmxpbmVTdHlsZVdpdGhOb25jZSA9IG5vbmNlU3R5bGUgPSB2b2lkIDApLFxuICAgICAgICAgICAgKGlkUHJlZml4ID0ge1xuICAgICAgICAgICAgICByZWw6IFwicHJlbG9hZFwiLFxuICAgICAgICAgICAgICBhczogXCJzY3JpcHRcIixcbiAgICAgICAgICAgICAgZmV0Y2hQcmlvcml0eTogXCJsb3dcIixcbiAgICAgICAgICAgICAgbm9uY2U6IG5vbmNlXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBtYXhIZWFkZXJzTGVuZ3RoXG4gICAgICAgICAgICAgID8gKGlkUHJlZml4LmhyZWYgPSBpbmxpbmVTY3JpcHRXaXRoTm9uY2UgPSBtYXhIZWFkZXJzTGVuZ3RoKVxuICAgICAgICAgICAgICA6ICgoaWRQcmVmaXguaHJlZiA9IGlubGluZVNjcmlwdFdpdGhOb25jZSA9IG1heEhlYWRlcnNMZW5ndGguc3JjKSxcbiAgICAgICAgICAgICAgICAoaWRQcmVmaXguaW50ZWdyaXR5ID0gaW5saW5lU3R5bGVXaXRoTm9uY2UgPVxuICAgICAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG1heEhlYWRlcnNMZW5ndGguaW50ZWdyaXR5XG4gICAgICAgICAgICAgICAgICAgID8gbWF4SGVhZGVyc0xlbmd0aC5pbnRlZ3JpdHlcbiAgICAgICAgICAgICAgICAgICAgOiB2b2lkIDApLFxuICAgICAgICAgICAgICAgIChpZFByZWZpeC5jcm9zc09yaWdpbiA9IG5vbmNlU3R5bGUgPVxuICAgICAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG1heEhlYWRlcnNMZW5ndGggfHxcbiAgICAgICAgICAgICAgICAgIG51bGwgPT0gbWF4SGVhZGVyc0xlbmd0aC5jcm9zc09yaWdpblxuICAgICAgICAgICAgICAgICAgICA/IHZvaWQgMFxuICAgICAgICAgICAgICAgICAgICA6IFwidXNlLWNyZWRlbnRpYWxzXCIgPT09IG1heEhlYWRlcnNMZW5ndGguY3Jvc3NPcmlnaW5cbiAgICAgICAgICAgICAgICAgICAgICA/IFwidXNlLWNyZWRlbnRpYWxzXCJcbiAgICAgICAgICAgICAgICAgICAgICA6IFwiXCIpKSxcbiAgICAgICAgICAgIHByZWxvYWRCb290c3RyYXBTY3JpcHRPck1vZHVsZShcbiAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUsXG4gICAgICAgICAgICAgIG9uSGVhZGVycyxcbiAgICAgICAgICAgICAgaW5saW5lU2NyaXB0V2l0aE5vbmNlLFxuICAgICAgICAgICAgICBpZFByZWZpeFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGJvb3RzdHJhcENodW5rcy5wdXNoKFxuICAgICAgICAgICAgICBzdGFydFNjcmlwdFNyYyxcbiAgICAgICAgICAgICAgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihpbmxpbmVTY3JpcHRXaXRoTm9uY2UpKSxcbiAgICAgICAgICAgICAgYXR0cmlidXRlRW5kXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgZXh0ZXJuYWxSdW50aW1lQ29uZmlnICYmXG4gICAgICAgICAgICAgIGJvb3RzdHJhcENodW5rcy5wdXNoKFxuICAgICAgICAgICAgICAgIHNjcmlwdE5vbmNlLFxuICAgICAgICAgICAgICAgIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoZXh0ZXJuYWxSdW50aW1lQ29uZmlnKSksXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlRW5kXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgaW5saW5lU3R5bGVXaXRoTm9uY2UgJiZcbiAgICAgICAgICAgICAgYm9vdHN0cmFwQ2h1bmtzLnB1c2goXG4gICAgICAgICAgICAgICAgc2NyaXB0SW50ZWdpcnR5LFxuICAgICAgICAgICAgICAgIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoaW5saW5lU3R5bGVXaXRoTm9uY2UpKSxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVFbmRcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBub25jZVN0eWxlICYmXG4gICAgICAgICAgICAgIGJvb3RzdHJhcENodW5rcy5wdXNoKFxuICAgICAgICAgICAgICAgIHNjcmlwdENyb3NzT3JpZ2luLFxuICAgICAgICAgICAgICAgIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIobm9uY2VTdHlsZSkpLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUVuZFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgcHVzaENvbXBsZXRlZFNoZWxsSWRBdHRyaWJ1dGUoYm9vdHN0cmFwQ2h1bmtzLCByZXN1bWFibGVTdGF0ZSksXG4gICAgICAgICAgICBib290c3RyYXBDaHVua3MucHVzaChlbmRBc3luY1NjcmlwdCk7XG4gICAgICBpZiAodm9pZCAwICE9PSBib290c3RyYXBNb2R1bGVzKVxuICAgICAgICBmb3IgKG5vbmNlID0gMDsgbm9uY2UgPCBib290c3RyYXBNb2R1bGVzLmxlbmd0aDsgbm9uY2UrKylcbiAgICAgICAgICAoYm9vdHN0cmFwU2NyaXB0cyA9IGJvb3RzdHJhcE1vZHVsZXNbbm9uY2VdKSxcbiAgICAgICAgICAgIChpbmxpbmVTY3JpcHRXaXRoTm9uY2UgPSBtYXhIZWFkZXJzTGVuZ3RoID0gdm9pZCAwKSxcbiAgICAgICAgICAgIChub25jZVN0eWxlID0ge1xuICAgICAgICAgICAgICByZWw6IFwibW9kdWxlcHJlbG9hZFwiLFxuICAgICAgICAgICAgICBmZXRjaFByaW9yaXR5OiBcImxvd1wiLFxuICAgICAgICAgICAgICBub25jZTogZXh0ZXJuYWxSdW50aW1lQ29uZmlnXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBib290c3RyYXBTY3JpcHRzXG4gICAgICAgICAgICAgID8gKG5vbmNlU3R5bGUuaHJlZiA9IGltcG9ydE1hcCA9IGJvb3RzdHJhcFNjcmlwdHMpXG4gICAgICAgICAgICAgIDogKChub25jZVN0eWxlLmhyZWYgPSBpbXBvcnRNYXAgPSBib290c3RyYXBTY3JpcHRzLnNyYyksXG4gICAgICAgICAgICAgICAgKG5vbmNlU3R5bGUuaW50ZWdyaXR5ID0gaW5saW5lU2NyaXB0V2l0aE5vbmNlID1cbiAgICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBib290c3RyYXBTY3JpcHRzLmludGVncml0eVxuICAgICAgICAgICAgICAgICAgICA/IGJvb3RzdHJhcFNjcmlwdHMuaW50ZWdyaXR5XG4gICAgICAgICAgICAgICAgICAgIDogdm9pZCAwKSxcbiAgICAgICAgICAgICAgICAobm9uY2VTdHlsZS5jcm9zc09yaWdpbiA9IG1heEhlYWRlcnNMZW5ndGggPVxuICAgICAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGJvb3RzdHJhcFNjcmlwdHMgfHxcbiAgICAgICAgICAgICAgICAgIG51bGwgPT0gYm9vdHN0cmFwU2NyaXB0cy5jcm9zc09yaWdpblxuICAgICAgICAgICAgICAgICAgICA/IHZvaWQgMFxuICAgICAgICAgICAgICAgICAgICA6IFwidXNlLWNyZWRlbnRpYWxzXCIgPT09IGJvb3RzdHJhcFNjcmlwdHMuY3Jvc3NPcmlnaW5cbiAgICAgICAgICAgICAgICAgICAgICA/IFwidXNlLWNyZWRlbnRpYWxzXCJcbiAgICAgICAgICAgICAgICAgICAgICA6IFwiXCIpKSxcbiAgICAgICAgICAgIHByZWxvYWRCb290c3RyYXBTY3JpcHRPck1vZHVsZShcbiAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUsXG4gICAgICAgICAgICAgIG9uSGVhZGVycyxcbiAgICAgICAgICAgICAgaW1wb3J0TWFwLFxuICAgICAgICAgICAgICBub25jZVN0eWxlXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgYm9vdHN0cmFwQ2h1bmtzLnB1c2goXG4gICAgICAgICAgICAgIHN0YXJ0TW9kdWxlU3JjLFxuICAgICAgICAgICAgICBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKGltcG9ydE1hcCkpLFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVFbmRcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBleHRlcm5hbFJ1bnRpbWVDb25maWcgJiZcbiAgICAgICAgICAgICAgYm9vdHN0cmFwQ2h1bmtzLnB1c2goXG4gICAgICAgICAgICAgICAgc2NyaXB0Tm9uY2UsXG4gICAgICAgICAgICAgICAgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihleHRlcm5hbFJ1bnRpbWVDb25maWcpKSxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVFbmRcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBpbmxpbmVTY3JpcHRXaXRoTm9uY2UgJiZcbiAgICAgICAgICAgICAgYm9vdHN0cmFwQ2h1bmtzLnB1c2goXG4gICAgICAgICAgICAgICAgc2NyaXB0SW50ZWdpcnR5LFxuICAgICAgICAgICAgICAgIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoaW5saW5lU2NyaXB0V2l0aE5vbmNlKSksXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlRW5kXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgbWF4SGVhZGVyc0xlbmd0aCAmJlxuICAgICAgICAgICAgICBib290c3RyYXBDaHVua3MucHVzaChcbiAgICAgICAgICAgICAgICBzY3JpcHRDcm9zc09yaWdpbixcbiAgICAgICAgICAgICAgICBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKG1heEhlYWRlcnNMZW5ndGgpKSxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVFbmRcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHB1c2hDb21wbGV0ZWRTaGVsbElkQXR0cmlidXRlKGJvb3RzdHJhcENodW5rcywgcmVzdW1hYmxlU3RhdGUpLFxuICAgICAgICAgICAgYm9vdHN0cmFwQ2h1bmtzLnB1c2goZW5kQXN5bmNTY3JpcHQpO1xuICAgICAgcmV0dXJuIG9uSGVhZGVycztcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlUmVzdW1hYmxlU3RhdGUoXG4gICAgICBpZGVudGlmaWVyUHJlZml4LFxuICAgICAgZXh0ZXJuYWxSdW50aW1lQ29uZmlnLFxuICAgICAgYm9vdHN0cmFwU2NyaXB0Q29udGVudCxcbiAgICAgIGJvb3RzdHJhcFNjcmlwdHMsXG4gICAgICBib290c3RyYXBNb2R1bGVzXG4gICAgKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpZFByZWZpeDogdm9pZCAwID09PSBpZGVudGlmaWVyUHJlZml4ID8gXCJcIiA6IGlkZW50aWZpZXJQcmVmaXgsXG4gICAgICAgIG5leHRGb3JtSUQ6IDAsXG4gICAgICAgIHN0cmVhbWluZ0Zvcm1hdDogMCxcbiAgICAgICAgYm9vdHN0cmFwU2NyaXB0Q29udGVudDogYm9vdHN0cmFwU2NyaXB0Q29udGVudCxcbiAgICAgICAgYm9vdHN0cmFwU2NyaXB0czogYm9vdHN0cmFwU2NyaXB0cyxcbiAgICAgICAgYm9vdHN0cmFwTW9kdWxlczogYm9vdHN0cmFwTW9kdWxlcyxcbiAgICAgICAgaW5zdHJ1Y3Rpb25zOiBOb3RoaW5nU2VudCxcbiAgICAgICAgaGFzQm9keTogITEsXG4gICAgICAgIGhhc0h0bWw6ICExLFxuICAgICAgICB1bmtub3duUmVzb3VyY2VzOiB7fSxcbiAgICAgICAgZG5zUmVzb3VyY2VzOiB7fSxcbiAgICAgICAgY29ubmVjdFJlc291cmNlczogeyBkZWZhdWx0OiB7fSwgYW5vbnltb3VzOiB7fSwgY3JlZGVudGlhbHM6IHt9IH0sXG4gICAgICAgIGltYWdlUmVzb3VyY2VzOiB7fSxcbiAgICAgICAgc3R5bGVSZXNvdXJjZXM6IHt9LFxuICAgICAgICBzY3JpcHRSZXNvdXJjZXM6IHt9LFxuICAgICAgICBtb2R1bGVVbmtub3duUmVzb3VyY2VzOiB7fSxcbiAgICAgICAgbW9kdWxlU2NyaXB0UmVzb3VyY2VzOiB7fVxuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlUHJlYW1ibGVTdGF0ZSgpIHtcbiAgICAgIHJldHVybiB7IGh0bWxDaHVua3M6IG51bGwsIGhlYWRDaHVua3M6IG51bGwsIGJvZHlDaHVua3M6IG51bGwgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlRm9ybWF0Q29udGV4dChcbiAgICAgIGluc2VydGlvbk1vZGUsXG4gICAgICBzZWxlY3RlZFZhbHVlLFxuICAgICAgdGFnU2NvcGUsXG4gICAgICB2aWV3VHJhbnNpdGlvblxuICAgICkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5zZXJ0aW9uTW9kZTogaW5zZXJ0aW9uTW9kZSxcbiAgICAgICAgc2VsZWN0ZWRWYWx1ZTogc2VsZWN0ZWRWYWx1ZSxcbiAgICAgICAgdGFnU2NvcGU6IHRhZ1Njb3BlLFxuICAgICAgICB2aWV3VHJhbnNpdGlvbjogdmlld1RyYW5zaXRpb25cbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVJvb3RGb3JtYXRDb250ZXh0KG5hbWVzcGFjZVVSSSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoXG4gICAgICAgIFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiA9PT0gbmFtZXNwYWNlVVJJXG4gICAgICAgICAgPyBTVkdfTU9ERVxuICAgICAgICAgIDogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MXCIgPT09IG5hbWVzcGFjZVVSSVxuICAgICAgICAgICAgPyBNQVRITUxfTU9ERVxuICAgICAgICAgICAgOiBST09UX0hUTUxfTU9ERSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgMCxcbiAgICAgICAgbnVsbFxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Q2hpbGRGb3JtYXRDb250ZXh0KHBhcmVudENvbnRleHQsIHR5cGUsIHByb3BzKSB7XG4gICAgICB2YXIgc3VidHJlZVNjb3BlID0gcGFyZW50Q29udGV4dC50YWdTY29wZSAmIC0yNTtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwibm9zY3JpcHRcIjpcbiAgICAgICAgICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChIVE1MX01PREUsIG51bGwsIHN1YnRyZWVTY29wZSB8IDEsIG51bGwpO1xuICAgICAgICBjYXNlIFwic2VsZWN0XCI6XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoXG4gICAgICAgICAgICBIVE1MX01PREUsXG4gICAgICAgICAgICBudWxsICE9IHByb3BzLnZhbHVlID8gcHJvcHMudmFsdWUgOiBwcm9wcy5kZWZhdWx0VmFsdWUsXG4gICAgICAgICAgICBzdWJ0cmVlU2NvcGUsXG4gICAgICAgICAgICBudWxsXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBcInN2Z1wiOlxuICAgICAgICAgIHJldHVybiBjcmVhdGVGb3JtYXRDb250ZXh0KFNWR19NT0RFLCBudWxsLCBzdWJ0cmVlU2NvcGUsIG51bGwpO1xuICAgICAgICBjYXNlIFwicGljdHVyZVwiOlxuICAgICAgICAgIHJldHVybiBjcmVhdGVGb3JtYXRDb250ZXh0KEhUTUxfTU9ERSwgbnVsbCwgc3VidHJlZVNjb3BlIHwgMiwgbnVsbCk7XG4gICAgICAgIGNhc2UgXCJtYXRoXCI6XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoTUFUSE1MX01PREUsIG51bGwsIHN1YnRyZWVTY29wZSwgbnVsbCk7XG4gICAgICAgIGNhc2UgXCJmb3JlaWduT2JqZWN0XCI6XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoSFRNTF9NT0RFLCBudWxsLCBzdWJ0cmVlU2NvcGUsIG51bGwpO1xuICAgICAgICBjYXNlIFwidGFibGVcIjpcbiAgICAgICAgICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChIVE1MX1RBQkxFX01PREUsIG51bGwsIHN1YnRyZWVTY29wZSwgbnVsbCk7XG4gICAgICAgIGNhc2UgXCJ0aGVhZFwiOlxuICAgICAgICBjYXNlIFwidGJvZHlcIjpcbiAgICAgICAgY2FzZSBcInRmb290XCI6XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoXG4gICAgICAgICAgICBIVE1MX1RBQkxFX0JPRFlfTU9ERSxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBzdWJ0cmVlU2NvcGUsXG4gICAgICAgICAgICBudWxsXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBcImNvbGdyb3VwXCI6XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoXG4gICAgICAgICAgICBIVE1MX0NPTEdST1VQX01PREUsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgc3VidHJlZVNjb3BlLFxuICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgXCJ0clwiOlxuICAgICAgICAgIHJldHVybiBjcmVhdGVGb3JtYXRDb250ZXh0KFxuICAgICAgICAgICAgSFRNTF9UQUJMRV9ST1dfTU9ERSxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBzdWJ0cmVlU2NvcGUsXG4gICAgICAgICAgICBudWxsXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBcImhlYWRcIjpcbiAgICAgICAgICBpZiAocGFyZW50Q29udGV4dC5pbnNlcnRpb25Nb2RlIDwgSFRNTF9NT0RFKVxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoXG4gICAgICAgICAgICAgIEhUTUxfSEVBRF9NT0RFLFxuICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICBzdWJ0cmVlU2NvcGUsXG4gICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJodG1sXCI6XG4gICAgICAgICAgaWYgKHBhcmVudENvbnRleHQuaW5zZXJ0aW9uTW9kZSA9PT0gUk9PVF9IVE1MX01PREUpXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChcbiAgICAgICAgICAgICAgSFRNTF9IVE1MX01PREUsXG4gICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgIHN1YnRyZWVTY29wZSxcbiAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJlbnRDb250ZXh0Lmluc2VydGlvbk1vZGUgPj0gSFRNTF9UQUJMRV9NT0RFIHx8XG4gICAgICAgIHBhcmVudENvbnRleHQuaW5zZXJ0aW9uTW9kZSA8IEhUTUxfTU9ERVxuICAgICAgICA/IGNyZWF0ZUZvcm1hdENvbnRleHQoSFRNTF9NT0RFLCBudWxsLCBzdWJ0cmVlU2NvcGUsIG51bGwpXG4gICAgICAgIDogcGFyZW50Q29udGV4dC50YWdTY29wZSAhPT0gc3VidHJlZVNjb3BlXG4gICAgICAgICAgPyBjcmVhdGVGb3JtYXRDb250ZXh0KFxuICAgICAgICAgICAgICBwYXJlbnRDb250ZXh0Lmluc2VydGlvbk1vZGUsXG4gICAgICAgICAgICAgIHBhcmVudENvbnRleHQuc2VsZWN0ZWRWYWx1ZSxcbiAgICAgICAgICAgICAgc3VidHJlZVNjb3BlLFxuICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICApXG4gICAgICAgICAgOiBwYXJlbnRDb250ZXh0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRTdXNwZW5zZVZpZXdUcmFuc2l0aW9uKHBhcmVudFZpZXdUcmFuc2l0aW9uKSB7XG4gICAgICByZXR1cm4gbnVsbCA9PT0gcGFyZW50Vmlld1RyYW5zaXRpb25cbiAgICAgICAgPyBudWxsXG4gICAgICAgIDoge1xuICAgICAgICAgICAgdXBkYXRlOiBwYXJlbnRWaWV3VHJhbnNpdGlvbi51cGRhdGUsXG4gICAgICAgICAgICBlbnRlcjogXCJub25lXCIsXG4gICAgICAgICAgICBleGl0OiBcIm5vbmVcIixcbiAgICAgICAgICAgIHNoYXJlOiBwYXJlbnRWaWV3VHJhbnNpdGlvbi51cGRhdGUsXG4gICAgICAgICAgICBuYW1lOiBwYXJlbnRWaWV3VHJhbnNpdGlvbi5hdXRvTmFtZSxcbiAgICAgICAgICAgIGF1dG9OYW1lOiBwYXJlbnRWaWV3VHJhbnNpdGlvbi5hdXRvTmFtZSxcbiAgICAgICAgICAgIG5hbWVJZHg6IDBcbiAgICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRTdXNwZW5zZUZhbGxiYWNrRm9ybWF0Q29udGV4dChyZXN1bWFibGVTdGF0ZSwgcGFyZW50Q29udGV4dCkge1xuICAgICAgcGFyZW50Q29udGV4dC50YWdTY29wZSAmIDMyICYmIChyZXN1bWFibGVTdGF0ZS5pbnN0cnVjdGlvbnMgfD0gMTI4KTtcbiAgICAgIHJldHVybiBjcmVhdGVGb3JtYXRDb250ZXh0KFxuICAgICAgICBwYXJlbnRDb250ZXh0Lmluc2VydGlvbk1vZGUsXG4gICAgICAgIHBhcmVudENvbnRleHQuc2VsZWN0ZWRWYWx1ZSxcbiAgICAgICAgcGFyZW50Q29udGV4dC50YWdTY29wZSB8IDEyLFxuICAgICAgICBnZXRTdXNwZW5zZVZpZXdUcmFuc2l0aW9uKHBhcmVudENvbnRleHQudmlld1RyYW5zaXRpb24pXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRTdXNwZW5zZUNvbnRlbnRGb3JtYXRDb250ZXh0KHJlc3VtYWJsZVN0YXRlLCBwYXJlbnRDb250ZXh0KSB7XG4gICAgICByZXN1bWFibGVTdGF0ZSA9IGdldFN1c3BlbnNlVmlld1RyYW5zaXRpb24ocGFyZW50Q29udGV4dC52aWV3VHJhbnNpdGlvbik7XG4gICAgICB2YXIgc3VidHJlZVNjb3BlID0gcGFyZW50Q29udGV4dC50YWdTY29wZSB8IDE2O1xuICAgICAgbnVsbCAhPT0gcmVzdW1hYmxlU3RhdGUgJiZcbiAgICAgICAgXCJub25lXCIgIT09IHJlc3VtYWJsZVN0YXRlLnNoYXJlICYmXG4gICAgICAgIChzdWJ0cmVlU2NvcGUgfD0gNjQpO1xuICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoXG4gICAgICAgIHBhcmVudENvbnRleHQuaW5zZXJ0aW9uTW9kZSxcbiAgICAgICAgcGFyZW50Q29udGV4dC5zZWxlY3RlZFZhbHVlLFxuICAgICAgICBzdWJ0cmVlU2NvcGUsXG4gICAgICAgIHJlc3VtYWJsZVN0YXRlXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoVGV4dEluc3RhbmNlKHRhcmdldCwgdGV4dCwgcmVuZGVyU3RhdGUsIHRleHRFbWJlZGRlZCkge1xuICAgICAgaWYgKFwiXCIgPT09IHRleHQpIHJldHVybiB0ZXh0RW1iZWRkZWQ7XG4gICAgICB0ZXh0RW1iZWRkZWQgJiYgdGFyZ2V0LnB1c2godGV4dFNlcGFyYXRvcik7XG4gICAgICB0YXJnZXQucHVzaChzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKHRleHQpKSk7XG4gICAgICByZXR1cm4gITA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hTdHlsZUF0dHJpYnV0ZSh0YXJnZXQsIHN0eWxlKSB7XG4gICAgICBpZiAoXCJvYmplY3RcIiAhPT0gdHlwZW9mIHN0eWxlKVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIlRoZSBgc3R5bGVgIHByb3AgZXhwZWN0cyBhIG1hcHBpbmcgZnJvbSBzdHlsZSBwcm9wZXJ0aWVzIHRvIHZhbHVlcywgbm90IGEgc3RyaW5nLiBGb3IgZXhhbXBsZSwgc3R5bGU9e3ttYXJnaW5SaWdodDogc3BhY2luZyArICdlbSd9fSB3aGVuIHVzaW5nIEpTWC5cIlxuICAgICAgICApO1xuICAgICAgdmFyIGlzRmlyc3QgPSAhMCxcbiAgICAgICAgc3R5bGVOYW1lO1xuICAgICAgZm9yIChzdHlsZU5hbWUgaW4gc3R5bGUpXG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHN0eWxlLCBzdHlsZU5hbWUpKSB7XG4gICAgICAgICAgdmFyIHN0eWxlVmFsdWUgPSBzdHlsZVtzdHlsZU5hbWVdO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIG51bGwgIT0gc3R5bGVWYWx1ZSAmJlxuICAgICAgICAgICAgXCJib29sZWFuXCIgIT09IHR5cGVvZiBzdHlsZVZhbHVlICYmXG4gICAgICAgICAgICBcIlwiICE9PSBzdHlsZVZhbHVlXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAoMCA9PT0gc3R5bGVOYW1lLmluZGV4T2YoXCItLVwiKSkge1xuICAgICAgICAgICAgICB2YXIgbmFtZUNodW5rID0gc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihzdHlsZU5hbWUpKTtcbiAgICAgICAgICAgICAgY2hlY2tDU1NQcm9wZXJ0eVN0cmluZ0NvZXJjaW9uKHN0eWxlVmFsdWUsIHN0eWxlTmFtZSk7XG4gICAgICAgICAgICAgIHN0eWxlVmFsdWUgPSBzdHJpbmdUb0NodW5rKFxuICAgICAgICAgICAgICAgIGVzY2FwZVRleHRGb3JCcm93c2VyKChcIlwiICsgc3R5bGVWYWx1ZSkudHJpbSgpKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmFtZUNodW5rID0gc3R5bGVOYW1lO1xuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBzdHlsZVZhbHVlO1xuICAgICAgICAgICAgICBpZiAoLTEgPCBuYW1lQ2h1bmsuaW5kZXhPZihcIi1cIikpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IG5hbWVDaHVuaztcbiAgICAgICAgICAgICAgICAod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJlxuICAgICAgICAgICAgICAgICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSkgfHxcbiAgICAgICAgICAgICAgICAgICgod2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9ICEwKSxcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiVW5zdXBwb3J0ZWQgc3R5bGUgcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiAlcz9cIixcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgY2FtZWxpemUobmFtZS5yZXBsYWNlKG1zUGF0dGVybiQxLCBcIm1zLVwiKSlcbiAgICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybi50ZXN0KG5hbWVDaHVuaykpXG4gICAgICAgICAgICAgICAgKG5hbWUgPSBuYW1lQ2h1bmspLFxuICAgICAgICAgICAgICAgICAgKHdhcm5lZFN0eWxlTmFtZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSkgfHxcbiAgICAgICAgICAgICAgICAgICAgKCh3YXJuZWRTdHlsZU5hbWVzW25hbWVdID0gITApLFxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgIFwiVW5zdXBwb3J0ZWQgdmVuZG9yLXByZWZpeGVkIHN0eWxlIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/XCIsXG4gICAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKVxuICAgICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgICAgZWxzZSBpZiAoYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IG5hbWVDaHVuaztcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUkanNjb21wJDAgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAod2FybmVkU3R5bGVWYWx1ZXMuaGFzT3duUHJvcGVydHkodmFsdWUkanNjb21wJDApICYmXG4gICAgICAgICAgICAgICAgICB3YXJuZWRTdHlsZVZhbHVlc1t2YWx1ZSRqc2NvbXAkMF0pIHx8XG4gICAgICAgICAgICAgICAgICAoKHdhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlJGpzY29tcCQwXSA9ICEwKSxcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICdTdHlsZSBwcm9wZXJ0eSB2YWx1ZXMgc2hvdWxkblxcJ3QgY29udGFpbiBhIHNlbWljb2xvbi4gVHJ5IFwiJXM6ICVzXCIgaW5zdGVhZC4nLFxuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSRqc2NvbXAkMC5yZXBsYWNlKFxuICAgICAgICAgICAgICAgICAgICAgIGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybixcbiAgICAgICAgICAgICAgICAgICAgICBcIlwiXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICAgICAgICAgIChpc05hTih2YWx1ZSlcbiAgICAgICAgICAgICAgICAgID8gd2FybmVkRm9yTmFOVmFsdWUgfHxcbiAgICAgICAgICAgICAgICAgICAgKCh3YXJuZWRGb3JOYU5WYWx1ZSA9ICEwKSxcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICBcImBOYU5gIGlzIGFuIGludmFsaWQgdmFsdWUgZm9yIHRoZSBgJXNgIGNzcyBzdHlsZSBwcm9wZXJ0eS5cIixcbiAgICAgICAgICAgICAgICAgICAgICBuYW1lQ2h1bmtcbiAgICAgICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgICAgIDogaXNGaW5pdGUodmFsdWUpIHx8XG4gICAgICAgICAgICAgICAgICAgIHdhcm5lZEZvckluZmluaXR5VmFsdWUgfHxcbiAgICAgICAgICAgICAgICAgICAgKCh3YXJuZWRGb3JJbmZpbml0eVZhbHVlID0gITApLFxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgIFwiYEluZmluaXR5YCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvciB0aGUgYCVzYCBjc3Mgc3R5bGUgcHJvcGVydHkuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgbmFtZUNodW5rXG4gICAgICAgICAgICAgICAgICAgICkpKTtcbiAgICAgICAgICAgICAgbmFtZUNodW5rID0gc3R5bGVOYW1lO1xuICAgICAgICAgICAgICB2YWx1ZSA9IHN0eWxlTmFtZUNhY2hlLmdldChuYW1lQ2h1bmspO1xuICAgICAgICAgICAgICB2b2lkIDAgIT09IHZhbHVlXG4gICAgICAgICAgICAgICAgPyAobmFtZUNodW5rID0gdmFsdWUpXG4gICAgICAgICAgICAgICAgOiAoKHZhbHVlID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFxuICAgICAgICAgICAgICAgICAgICBlc2NhcGVUZXh0Rm9yQnJvd3NlcihcbiAgICAgICAgICAgICAgICAgICAgICBuYW1lQ2h1bmtcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKHVwcGVyY2FzZVBhdHRlcm4sIFwiLSQxXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UobXNQYXR0ZXJuLCBcIi1tcy1cIilcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgICBzdHlsZU5hbWVDYWNoZS5zZXQobmFtZUNodW5rLCB2YWx1ZSksXG4gICAgICAgICAgICAgICAgICAobmFtZUNodW5rID0gdmFsdWUpKTtcbiAgICAgICAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIHN0eWxlVmFsdWVcbiAgICAgICAgICAgICAgICA/IChzdHlsZVZhbHVlID1cbiAgICAgICAgICAgICAgICAgICAgMCA9PT0gc3R5bGVWYWx1ZSB8fCB1bml0bGVzc051bWJlcnMuaGFzKHN0eWxlTmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICA/IHN0cmluZ1RvQ2h1bmsoXCJcIiArIHN0eWxlVmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgOiBzdHJpbmdUb0NodW5rKHN0eWxlVmFsdWUgKyBcInB4XCIpKVxuICAgICAgICAgICAgICAgIDogKGNoZWNrQ1NTUHJvcGVydHlTdHJpbmdDb2VyY2lvbihzdHlsZVZhbHVlLCBzdHlsZU5hbWUpLFxuICAgICAgICAgICAgICAgICAgKHN0eWxlVmFsdWUgPSBzdHJpbmdUb0NodW5rKFxuICAgICAgICAgICAgICAgICAgICBlc2NhcGVUZXh0Rm9yQnJvd3NlcigoXCJcIiArIHN0eWxlVmFsdWUpLnRyaW0oKSlcbiAgICAgICAgICAgICAgICAgICkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlzRmlyc3RcbiAgICAgICAgICAgICAgPyAoKGlzRmlyc3QgPSAhMSksXG4gICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2goXG4gICAgICAgICAgICAgICAgICBzdHlsZUF0dHJpYnV0ZVN0YXJ0LFxuICAgICAgICAgICAgICAgICAgbmFtZUNodW5rLFxuICAgICAgICAgICAgICAgICAgc3R5bGVBc3NpZ24sXG4gICAgICAgICAgICAgICAgICBzdHlsZVZhbHVlXG4gICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgOiB0YXJnZXQucHVzaChzdHlsZVNlcGFyYXRvciwgbmFtZUNodW5rLCBzdHlsZUFzc2lnbiwgc3R5bGVWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBpc0ZpcnN0IHx8IHRhcmdldC5wdXNoKGF0dHJpYnV0ZUVuZCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hCb29sZWFuQXR0cmlidXRlKHRhcmdldCwgbmFtZSwgdmFsdWUpIHtcbiAgICAgIHZhbHVlICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHZhbHVlICYmXG4gICAgICAgIFwic3ltYm9sXCIgIT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICB0YXJnZXQucHVzaChcbiAgICAgICAgICBhdHRyaWJ1dGVTZXBhcmF0b3IsXG4gICAgICAgICAgc3RyaW5nVG9DaHVuayhuYW1lKSxcbiAgICAgICAgICBhdHRyaWJ1dGVFbXB0eVN0cmluZ1xuICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoU3RyaW5nQXR0cmlidXRlKHRhcmdldCwgbmFtZSwgdmFsdWUpIHtcbiAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHZhbHVlICYmXG4gICAgICAgIFwic3ltYm9sXCIgIT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICBcImJvb2xlYW5cIiAhPT0gdHlwZW9mIHZhbHVlICYmXG4gICAgICAgIHRhcmdldC5wdXNoKFxuICAgICAgICAgIGF0dHJpYnV0ZVNlcGFyYXRvcixcbiAgICAgICAgICBzdHJpbmdUb0NodW5rKG5hbWUpLFxuICAgICAgICAgIGF0dHJpYnV0ZUFzc2lnbixcbiAgICAgICAgICBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKHZhbHVlKSksXG4gICAgICAgICAgYXR0cmlidXRlRW5kXG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hBZGRpdGlvbmFsRm9ybUZpZWxkKHZhbHVlLCBrZXkpIHtcbiAgICAgIHRoaXMucHVzaChzdGFydEhpZGRlbklucHV0Q2h1bmspO1xuICAgICAgdmFsaWRhdGVBZGRpdGlvbmFsRm9ybUZpZWxkKHZhbHVlKTtcbiAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGhpcywgXCJuYW1lXCIsIGtleSk7XG4gICAgICBwdXNoU3RyaW5nQXR0cmlidXRlKHRoaXMsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgdGhpcy5wdXNoKGVuZE9mU3RhcnRUYWdTZWxmQ2xvc2luZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlQWRkaXRpb25hbEZvcm1GaWVsZCh2YWx1ZSkge1xuICAgICAgaWYgKFwic3RyaW5nXCIgIT09IHR5cGVvZiB2YWx1ZSlcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJGaWxlL0Jsb2IgZmllbGRzIGFyZSBub3QgeWV0IHN1cHBvcnRlZCBpbiBwcm9ncmVzc2l2ZSBmb3Jtcy4gV2lsbCBmYWxsYmFjayB0byBjbGllbnQgaHlkcmF0aW9uLlwiXG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEN1c3RvbUZvcm1GaWVsZHMocmVzdW1hYmxlU3RhdGUsIGZvcm1BY3Rpb24pIHtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBmb3JtQWN0aW9uLiQkRk9STV9BQ1RJT04pIHtcbiAgICAgICAgdmFyIGlkID0gcmVzdW1hYmxlU3RhdGUubmV4dEZvcm1JRCsrO1xuICAgICAgICByZXN1bWFibGVTdGF0ZSA9IHJlc3VtYWJsZVN0YXRlLmlkUHJlZml4ICsgaWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIGN1c3RvbUZpZWxkcyA9IGZvcm1BY3Rpb24uJCRGT1JNX0FDVElPTihyZXN1bWFibGVTdGF0ZSk7XG4gICAgICAgICAgaWYgKGN1c3RvbUZpZWxkcykge1xuICAgICAgICAgICAgdmFyIGZvcm1EYXRhID0gY3VzdG9tRmllbGRzLmRhdGE7XG4gICAgICAgICAgICBudWxsICE9IGZvcm1EYXRhICYmIGZvcm1EYXRhLmZvckVhY2godmFsaWRhdGVBZGRpdGlvbmFsRm9ybUZpZWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGN1c3RvbUZpZWxkcztcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiB4ICYmXG4gICAgICAgICAgICBudWxsICE9PSB4ICYmXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB4LnRoZW5cbiAgICAgICAgICApXG4gICAgICAgICAgICB0aHJvdyB4O1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkZhaWxlZCB0byBzZXJpYWxpemUgYW4gYWN0aW9uIGZvciBwcm9ncmVzc2l2ZSBlbmhhbmNlbWVudDpcXG4lc1wiLFxuICAgICAgICAgICAgeFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoRm9ybUFjdGlvbkF0dHJpYnV0ZShcbiAgICAgIHRhcmdldCxcbiAgICAgIHJlc3VtYWJsZVN0YXRlLFxuICAgICAgcmVuZGVyU3RhdGUsXG4gICAgICBmb3JtQWN0aW9uLFxuICAgICAgZm9ybUVuY1R5cGUsXG4gICAgICBmb3JtTWV0aG9kLFxuICAgICAgZm9ybVRhcmdldCxcbiAgICAgIG5hbWVcbiAgICApIHtcbiAgICAgIHZhciBmb3JtRGF0YSA9IG51bGw7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZm9ybUFjdGlvbikge1xuICAgICAgICBudWxsID09PSBuYW1lIHx8XG4gICAgICAgICAgZGlkV2FybkZvcm1BY3Rpb25OYW1lIHx8XG4gICAgICAgICAgKChkaWRXYXJuRm9ybUFjdGlvbk5hbWUgPSAhMCksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICdDYW5ub3Qgc3BlY2lmeSBhIFwibmFtZVwiIHByb3AgZm9yIGEgYnV0dG9uIHRoYXQgc3BlY2lmaWVzIGEgZnVuY3Rpb24gYXMgYSBmb3JtQWN0aW9uLiBSZWFjdCBuZWVkcyBpdCB0byBlbmNvZGUgd2hpY2ggYWN0aW9uIHNob3VsZCBiZSBpbnZva2VkLiBJdCB3aWxsIGdldCBvdmVycmlkZGVuLidcbiAgICAgICAgICApKTtcbiAgICAgICAgKG51bGwgPT09IGZvcm1FbmNUeXBlICYmIG51bGwgPT09IGZvcm1NZXRob2QpIHx8XG4gICAgICAgICAgZGlkV2FybkZvcm1BY3Rpb25NZXRob2QgfHxcbiAgICAgICAgICAoKGRpZFdhcm5Gb3JtQWN0aW9uTWV0aG9kID0gITApLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkNhbm5vdCBzcGVjaWZ5IGEgZm9ybUVuY1R5cGUgb3IgZm9ybU1ldGhvZCBmb3IgYSBidXR0b24gdGhhdCBzcGVjaWZpZXMgYSBmdW5jdGlvbiBhcyBhIGZvcm1BY3Rpb24uIFJlYWN0IHByb3ZpZGVzIHRob3NlIGF1dG9tYXRpY2FsbHkuIFRoZXkgd2lsbCBnZXQgb3ZlcnJpZGRlbi5cIlxuICAgICAgICAgICkpO1xuICAgICAgICBudWxsID09PSBmb3JtVGFyZ2V0IHx8XG4gICAgICAgICAgZGlkV2FybkZvcm1BY3Rpb25UYXJnZXQgfHxcbiAgICAgICAgICAoKGRpZFdhcm5Gb3JtQWN0aW9uVGFyZ2V0ID0gITApLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkNhbm5vdCBzcGVjaWZ5IGEgZm9ybVRhcmdldCBmb3IgYSBidXR0b24gdGhhdCBzcGVjaWZpZXMgYSBmdW5jdGlvbiBhcyBhIGZvcm1BY3Rpb24uIFRoZSBmdW5jdGlvbiB3aWxsIGFsd2F5cyBiZSBleGVjdXRlZCBpbiB0aGUgc2FtZSB3aW5kb3cuXCJcbiAgICAgICAgICApKTtcbiAgICAgICAgdmFyIGN1c3RvbUZpZWxkcyA9IGdldEN1c3RvbUZvcm1GaWVsZHMocmVzdW1hYmxlU3RhdGUsIGZvcm1BY3Rpb24pO1xuICAgICAgICBudWxsICE9PSBjdXN0b21GaWVsZHNcbiAgICAgICAgICA/ICgobmFtZSA9IGN1c3RvbUZpZWxkcy5uYW1lKSxcbiAgICAgICAgICAgIChmb3JtQWN0aW9uID0gY3VzdG9tRmllbGRzLmFjdGlvbiB8fCBcIlwiKSxcbiAgICAgICAgICAgIChmb3JtRW5jVHlwZSA9IGN1c3RvbUZpZWxkcy5lbmNUeXBlKSxcbiAgICAgICAgICAgIChmb3JtTWV0aG9kID0gY3VzdG9tRmllbGRzLm1ldGhvZCksXG4gICAgICAgICAgICAoZm9ybVRhcmdldCA9IGN1c3RvbUZpZWxkcy50YXJnZXQpLFxuICAgICAgICAgICAgKGZvcm1EYXRhID0gY3VzdG9tRmllbGRzLmRhdGEpKVxuICAgICAgICAgIDogKHRhcmdldC5wdXNoKFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVTZXBhcmF0b3IsXG4gICAgICAgICAgICAgIHN0cmluZ1RvQ2h1bmsoXCJmb3JtQWN0aW9uXCIpLFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVBc3NpZ24sXG4gICAgICAgICAgICAgIGFjdGlvbkphdmFTY3JpcHRVUkwsXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZUVuZFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIChmb3JtVGFyZ2V0ID0gZm9ybU1ldGhvZCA9IGZvcm1FbmNUeXBlID0gZm9ybUFjdGlvbiA9IG5hbWUgPSBudWxsKSxcbiAgICAgICAgICAgIGluamVjdEZvcm1SZXBsYXlpbmdSdW50aW1lKHJlc3VtYWJsZVN0YXRlLCByZW5kZXJTdGF0ZSkpO1xuICAgICAgfVxuICAgICAgbnVsbCAhPSBuYW1lICYmIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgICBudWxsICE9IGZvcm1BY3Rpb24gJiYgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIFwiZm9ybUFjdGlvblwiLCBmb3JtQWN0aW9uKTtcbiAgICAgIG51bGwgIT0gZm9ybUVuY1R5cGUgJiYgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIFwiZm9ybUVuY1R5cGVcIiwgZm9ybUVuY1R5cGUpO1xuICAgICAgbnVsbCAhPSBmb3JtTWV0aG9kICYmIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBcImZvcm1NZXRob2RcIiwgZm9ybU1ldGhvZCk7XG4gICAgICBudWxsICE9IGZvcm1UYXJnZXQgJiYgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIFwiZm9ybVRhcmdldFwiLCBmb3JtVGFyZ2V0KTtcbiAgICAgIHJldHVybiBmb3JtRGF0YTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIG5hbWUsIHZhbHVlKSB7XG4gICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgY2FzZSBcImNsYXNzTmFtZVwiOlxuICAgICAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCBcImNsYXNzXCIsIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInRhYkluZGV4XCI6XG4gICAgICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsIFwidGFiaW5kZXhcIiwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZGlyXCI6XG4gICAgICAgIGNhc2UgXCJyb2xlXCI6XG4gICAgICAgIGNhc2UgXCJ2aWV3Qm94XCI6XG4gICAgICAgIGNhc2UgXCJ3aWR0aFwiOlxuICAgICAgICBjYXNlIFwiaGVpZ2h0XCI6XG4gICAgICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInN0eWxlXCI6XG4gICAgICAgICAgcHVzaFN0eWxlQXR0cmlidXRlKHRhcmdldCwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic3JjXCI6XG4gICAgICAgIGNhc2UgXCJocmVmXCI6XG4gICAgICAgICAgaWYgKFwiXCIgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICBcInNyY1wiID09PSBuYW1lXG4gICAgICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICdBbiBlbXB0eSBzdHJpbmcgKFwiXCIpIHdhcyBwYXNzZWQgdG8gdGhlICVzIGF0dHJpYnV0ZS4gVGhpcyBtYXkgY2F1c2UgdGhlIGJyb3dzZXIgdG8gZG93bmxvYWQgdGhlIHdob2xlIHBhZ2UgYWdhaW4gb3ZlciB0aGUgbmV0d29yay4gVG8gZml4IHRoaXMsIGVpdGhlciBkbyBub3QgcmVuZGVyIHRoZSBlbGVtZW50IGF0IGFsbCBvciBwYXNzIG51bGwgdG8gJXMgaW5zdGVhZCBvZiBhbiBlbXB0eSBzdHJpbmcuJyxcbiAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICA6IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAnQW4gZW1wdHkgc3RyaW5nIChcIlwiKSB3YXMgcGFzc2VkIHRvIHRoZSAlcyBhdHRyaWJ1dGUuIFRvIGZpeCB0aGlzLCBlaXRoZXIgZG8gbm90IHJlbmRlciB0aGUgZWxlbWVudCBhdCBhbGwgb3IgcGFzcyBudWxsIHRvICVzIGluc3RlYWQgb2YgYW4gZW1wdHkgc3RyaW5nLicsXG4gICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJhY3Rpb25cIjpcbiAgICAgICAgY2FzZSBcImZvcm1BY3Rpb25cIjpcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBudWxsID09IHZhbHVlIHx8XG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB2YWx1ZSB8fFxuICAgICAgICAgICAgXCJzeW1ib2xcIiA9PT0gdHlwZW9mIHZhbHVlIHx8XG4gICAgICAgICAgICBcImJvb2xlYW5cIiA9PT0gdHlwZW9mIHZhbHVlXG4gICAgICAgICAgKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbih2YWx1ZSwgbmFtZSk7XG4gICAgICAgICAgdmFsdWUgPSBzYW5pdGl6ZVVSTChcIlwiICsgdmFsdWUpO1xuICAgICAgICAgIHRhcmdldC5wdXNoKFxuICAgICAgICAgICAgYXR0cmlidXRlU2VwYXJhdG9yLFxuICAgICAgICAgICAgc3RyaW5nVG9DaHVuayhuYW1lKSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZUFzc2lnbixcbiAgICAgICAgICAgIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIodmFsdWUpKSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZUVuZFxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJkZWZhdWx0VmFsdWVcIjpcbiAgICAgICAgY2FzZSBcImRlZmF1bHRDaGVja2VkXCI6XG4gICAgICAgIGNhc2UgXCJpbm5lckhUTUxcIjpcbiAgICAgICAgY2FzZSBcInN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZ1wiOlxuICAgICAgICBjYXNlIFwic3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nXCI6XG4gICAgICAgIGNhc2UgXCJyZWZcIjpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImF1dG9Gb2N1c1wiOlxuICAgICAgICBjYXNlIFwibXVsdGlwbGVcIjpcbiAgICAgICAgY2FzZSBcIm11dGVkXCI6XG4gICAgICAgICAgcHVzaEJvb2xlYW5BdHRyaWJ1dGUodGFyZ2V0LCBuYW1lLnRvTG93ZXJDYXNlKCksIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInhsaW5rSHJlZlwiOlxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHZhbHVlIHx8XG4gICAgICAgICAgICBcInN5bWJvbFwiID09PSB0eXBlb2YgdmFsdWUgfHxcbiAgICAgICAgICAgIFwiYm9vbGVhblwiID09PSB0eXBlb2YgdmFsdWVcbiAgICAgICAgICApXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlLCBuYW1lKTtcbiAgICAgICAgICB2YWx1ZSA9IHNhbml0aXplVVJMKFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgdGFyZ2V0LnB1c2goXG4gICAgICAgICAgICBhdHRyaWJ1dGVTZXBhcmF0b3IsXG4gICAgICAgICAgICBzdHJpbmdUb0NodW5rKFwieGxpbms6aHJlZlwiKSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZUFzc2lnbixcbiAgICAgICAgICAgIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIodmFsdWUpKSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZUVuZFxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJjb250ZW50RWRpdGFibGVcIjpcbiAgICAgICAgY2FzZSBcInNwZWxsQ2hlY2tcIjpcbiAgICAgICAgY2FzZSBcImRyYWdnYWJsZVwiOlxuICAgICAgICBjYXNlIFwidmFsdWVcIjpcbiAgICAgICAgY2FzZSBcImF1dG9SZXZlcnNlXCI6XG4gICAgICAgIGNhc2UgXCJleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkXCI6XG4gICAgICAgIGNhc2UgXCJmb2N1c2FibGVcIjpcbiAgICAgICAgY2FzZSBcInByZXNlcnZlQWxwaGFcIjpcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICAgICAgXCJzeW1ib2xcIiAhPT0gdHlwZW9mIHZhbHVlICYmXG4gICAgICAgICAgICB0YXJnZXQucHVzaChcbiAgICAgICAgICAgICAgYXR0cmlidXRlU2VwYXJhdG9yLFxuICAgICAgICAgICAgICBzdHJpbmdUb0NodW5rKG5hbWUpLFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVBc3NpZ24sXG4gICAgICAgICAgICAgIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIodmFsdWUpKSxcbiAgICAgICAgICAgICAgYXR0cmlidXRlRW5kXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiaW5lcnRcIjpcbiAgICAgICAgICBcIlwiICE9PSB2YWx1ZSB8fFxuICAgICAgICAgICAgZGlkV2FybkZvck5ld0Jvb2xlYW5Qcm9wc1dpdGhFbXB0eVZhbHVlW25hbWVdIHx8XG4gICAgICAgICAgICAoKGRpZFdhcm5Gb3JOZXdCb29sZWFuUHJvcHNXaXRoRW1wdHlWYWx1ZVtuYW1lXSA9ICEwKSxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVjZWl2ZWQgYW4gZW1wdHkgc3RyaW5nIGZvciBhIGJvb2xlYW4gYXR0cmlidXRlIGAlc2AuIFRoaXMgd2lsbCB0cmVhdCB0aGUgYXR0cmlidXRlIGFzIGlmIGl0IHdlcmUgZmFsc2UuIEVpdGhlciBwYXNzIGBmYWxzZWAgdG8gc2lsZW5jZSB0aGlzIHdhcm5pbmcsIG9yIHBhc3MgYHRydWVgIGlmIHlvdSB1c2VkIGFuIGVtcHR5IHN0cmluZyBpbiBlYXJsaWVyIHZlcnNpb25zIG9mIFJlYWN0IHRvIGluZGljYXRlIHRoaXMgYXR0cmlidXRlIGlzIHRydWUuXCIsXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICkpO1xuICAgICAgICBjYXNlIFwiYWxsb3dGdWxsU2NyZWVuXCI6XG4gICAgICAgIGNhc2UgXCJhc3luY1wiOlxuICAgICAgICBjYXNlIFwiYXV0b1BsYXlcIjpcbiAgICAgICAgY2FzZSBcImNvbnRyb2xzXCI6XG4gICAgICAgIGNhc2UgXCJkZWZhdWx0XCI6XG4gICAgICAgIGNhc2UgXCJkZWZlclwiOlxuICAgICAgICBjYXNlIFwiZGlzYWJsZWRcIjpcbiAgICAgICAgY2FzZSBcImRpc2FibGVQaWN0dXJlSW5QaWN0dXJlXCI6XG4gICAgICAgIGNhc2UgXCJkaXNhYmxlUmVtb3RlUGxheWJhY2tcIjpcbiAgICAgICAgY2FzZSBcImZvcm1Ob1ZhbGlkYXRlXCI6XG4gICAgICAgIGNhc2UgXCJoaWRkZW5cIjpcbiAgICAgICAgY2FzZSBcImxvb3BcIjpcbiAgICAgICAgY2FzZSBcIm5vTW9kdWxlXCI6XG4gICAgICAgIGNhc2UgXCJub1ZhbGlkYXRlXCI6XG4gICAgICAgIGNhc2UgXCJvcGVuXCI6XG4gICAgICAgIGNhc2UgXCJwbGF5c0lubGluZVwiOlxuICAgICAgICBjYXNlIFwicmVhZE9ubHlcIjpcbiAgICAgICAgY2FzZSBcInJlcXVpcmVkXCI6XG4gICAgICAgIGNhc2UgXCJyZXZlcnNlZFwiOlxuICAgICAgICBjYXNlIFwic2NvcGVkXCI6XG4gICAgICAgIGNhc2UgXCJzZWFtbGVzc1wiOlxuICAgICAgICBjYXNlIFwiaXRlbVNjb3BlXCI6XG4gICAgICAgICAgdmFsdWUgJiZcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHZhbHVlICYmXG4gICAgICAgICAgICBcInN5bWJvbFwiICE9PSB0eXBlb2YgdmFsdWUgJiZcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVTZXBhcmF0b3IsXG4gICAgICAgICAgICAgIHN0cmluZ1RvQ2h1bmsobmFtZSksXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZUVtcHR5U3RyaW5nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiY2FwdHVyZVwiOlxuICAgICAgICBjYXNlIFwiZG93bmxvYWRcIjpcbiAgICAgICAgICAhMCA9PT0gdmFsdWVcbiAgICAgICAgICAgID8gdGFyZ2V0LnB1c2goXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlU2VwYXJhdG9yLFxuICAgICAgICAgICAgICAgIHN0cmluZ1RvQ2h1bmsobmFtZSksXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlRW1wdHlTdHJpbmdcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgOiAhMSAhPT0gdmFsdWUgJiZcbiAgICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgdmFsdWUgJiZcbiAgICAgICAgICAgICAgXCJzeW1ib2xcIiAhPT0gdHlwZW9mIHZhbHVlICYmXG4gICAgICAgICAgICAgIHRhcmdldC5wdXNoKFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZVNlcGFyYXRvcixcbiAgICAgICAgICAgICAgICBzdHJpbmdUb0NodW5rKG5hbWUpLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUFzc2lnbixcbiAgICAgICAgICAgICAgICBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKHZhbHVlKSksXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlRW5kXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJjb2xzXCI6XG4gICAgICAgIGNhc2UgXCJyb3dzXCI6XG4gICAgICAgIGNhc2UgXCJzaXplXCI6XG4gICAgICAgIGNhc2UgXCJzcGFuXCI6XG4gICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgdmFsdWUgJiZcbiAgICAgICAgICAgIFwic3ltYm9sXCIgIT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICAgICAgIWlzTmFOKHZhbHVlKSAmJlxuICAgICAgICAgICAgMSA8PSB2YWx1ZSAmJlxuICAgICAgICAgICAgdGFyZ2V0LnB1c2goXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZVNlcGFyYXRvcixcbiAgICAgICAgICAgICAgc3RyaW5nVG9DaHVuayhuYW1lKSxcbiAgICAgICAgICAgICAgYXR0cmlidXRlQXNzaWduLFxuICAgICAgICAgICAgICBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKHZhbHVlKSksXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZUVuZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInJvd1NwYW5cIjpcbiAgICAgICAgY2FzZSBcInN0YXJ0XCI6XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdmFsdWUgfHxcbiAgICAgICAgICAgIFwic3ltYm9sXCIgPT09IHR5cGVvZiB2YWx1ZSB8fFxuICAgICAgICAgICAgaXNOYU4odmFsdWUpIHx8XG4gICAgICAgICAgICB0YXJnZXQucHVzaChcbiAgICAgICAgICAgICAgYXR0cmlidXRlU2VwYXJhdG9yLFxuICAgICAgICAgICAgICBzdHJpbmdUb0NodW5rKG5hbWUpLFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVBc3NpZ24sXG4gICAgICAgICAgICAgIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIodmFsdWUpKSxcbiAgICAgICAgICAgICAgYXR0cmlidXRlRW5kXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwieGxpbmtBY3R1YXRlXCI6XG4gICAgICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsIFwieGxpbms6YWN0dWF0ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ4bGlua0FyY3JvbGVcIjpcbiAgICAgICAgICBwdXNoU3RyaW5nQXR0cmlidXRlKHRhcmdldCwgXCJ4bGluazphcmNyb2xlXCIsIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInhsaW5rUm9sZVwiOlxuICAgICAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCBcInhsaW5rOnJvbGVcIiwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwieGxpbmtTaG93XCI6XG4gICAgICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsIFwieGxpbms6c2hvd1wiLCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ4bGlua1RpdGxlXCI6XG4gICAgICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsIFwieGxpbms6dGl0bGVcIiwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwieGxpbmtUeXBlXCI6XG4gICAgICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsIFwieGxpbms6dHlwZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ4bWxCYXNlXCI6XG4gICAgICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsIFwieG1sOmJhc2VcIiwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwieG1sTGFuZ1wiOlxuICAgICAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCBcInhtbDpsYW5nXCIsIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInhtbFNwYWNlXCI6XG4gICAgICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsIFwieG1sOnNwYWNlXCIsIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhKDIgPCBuYW1lLmxlbmd0aCkgfHxcbiAgICAgICAgICAgIChcIm9cIiAhPT0gbmFtZVswXSAmJiBcIk9cIiAhPT0gbmFtZVswXSkgfHxcbiAgICAgICAgICAgIChcIm5cIiAhPT0gbmFtZVsxXSAmJiBcIk5cIiAhPT0gbmFtZVsxXSlcbiAgICAgICAgICApXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICgobmFtZSA9IGFsaWFzZXMuZ2V0KG5hbWUpIHx8IG5hbWUpLCBpc0F0dHJpYnV0ZU5hbWVTYWZlKG5hbWUpKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICAgICAgICB2YXIgcHJlZml4ID0gbmFtZS50b0xvd2VyQ2FzZSgpLnNsaWNlKDAsIDUpO1xuICAgICAgICAgICAgICAgICAgaWYgKFwiZGF0YS1cIiAhPT0gcHJlZml4ICYmIFwiYXJpYS1cIiAhPT0gcHJlZml4KSByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGFyZ2V0LnB1c2goXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlU2VwYXJhdG9yLFxuICAgICAgICAgICAgICAgIHN0cmluZ1RvQ2h1bmsobmFtZSksXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlQXNzaWduLFxuICAgICAgICAgICAgICAgIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIodmFsdWUpKSxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVFbmRcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaElubmVySFRNTCh0YXJnZXQsIGlubmVySFRNTCwgY2hpbGRyZW4pIHtcbiAgICAgIGlmIChudWxsICE9IGlubmVySFRNTCkge1xuICAgICAgICBpZiAobnVsbCAhPSBjaGlsZHJlbilcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiQ2FuIG9ubHkgc2V0IG9uZSBvZiBgY2hpbGRyZW5gIG9yIGBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAuXCJcbiAgICAgICAgICApO1xuICAgICAgICBpZiAoXCJvYmplY3RcIiAhPT0gdHlwZW9mIGlubmVySFRNTCB8fCAhKFwiX19odG1sXCIgaW4gaW5uZXJIVE1MKSlcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBtdXN0IGJlIGluIHRoZSBmb3JtIGB7X19odG1sOiAuLi59YC4gUGxlYXNlIHZpc2l0IGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvZGFuZ2Vyb3VzbHktc2V0LWlubmVyLWh0bWwgZm9yIG1vcmUgaW5mb3JtYXRpb24uXCJcbiAgICAgICAgICApO1xuICAgICAgICBpbm5lckhUTUwgPSBpbm5lckhUTUwuX19odG1sO1xuICAgICAgICBudWxsICE9PSBpbm5lckhUTUwgJiZcbiAgICAgICAgICB2b2lkIDAgIT09IGlubmVySFRNTCAmJlxuICAgICAgICAgIChjaGVja0h0bWxTdHJpbmdDb2VyY2lvbihpbm5lckhUTUwpLFxuICAgICAgICAgIHRhcmdldC5wdXNoKHN0cmluZ1RvQ2h1bmsoXCJcIiArIGlubmVySFRNTCkpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tTZWxlY3RQcm9wKHByb3BzLCBwcm9wTmFtZSkge1xuICAgICAgdmFyIHZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgbnVsbCAhPSB2YWx1ZSAmJlxuICAgICAgICAoKHZhbHVlID0gaXNBcnJheUltcGwodmFsdWUpKSxcbiAgICAgICAgcHJvcHMubXVsdGlwbGUgJiYgIXZhbHVlXG4gICAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlRoZSBgJXNgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhbiBhcnJheSBpZiBgbXVsdGlwbGVgIGlzIHRydWUuXCIsXG4gICAgICAgICAgICAgIHByb3BOYW1lXG4gICAgICAgICAgICApXG4gICAgICAgICAgOiAhcHJvcHMubXVsdGlwbGUgJiZcbiAgICAgICAgICAgIHZhbHVlICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlRoZSBgJXNgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhIHNjYWxhciB2YWx1ZSBpZiBgbXVsdGlwbGVgIGlzIGZhbHNlLlwiLFxuICAgICAgICAgICAgICBwcm9wTmFtZVxuICAgICAgICAgICAgKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZsYXR0ZW5PcHRpb25DaGlsZHJlbihjaGlsZHJlbikge1xuICAgICAgdmFyIGNvbnRlbnQgPSBcIlwiO1xuICAgICAgUmVhY3QuQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIG51bGwgIT0gY2hpbGQgJiZcbiAgICAgICAgICAoKGNvbnRlbnQgKz0gY2hpbGQpLFxuICAgICAgICAgIGRpZFdhcm5JbnZhbGlkT3B0aW9uQ2hpbGRyZW4gfHxcbiAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBjaGlsZCB8fFxuICAgICAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIGNoaWxkIHx8XG4gICAgICAgICAgICBcImJpZ2ludFwiID09PSB0eXBlb2YgY2hpbGQgfHxcbiAgICAgICAgICAgICgoZGlkV2FybkludmFsaWRPcHRpb25DaGlsZHJlbiA9ICEwKSxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiQ2Fubm90IGluZmVyIHRoZSBvcHRpb24gdmFsdWUgb2YgY29tcGxleCBjaGlsZHJlbi4gUGFzcyBhIGB2YWx1ZWAgcHJvcCBvciB1c2UgYSBwbGFpbiBzdHJpbmcgYXMgY2hpbGRyZW4gdG8gPG9wdGlvbj4uXCJcbiAgICAgICAgICAgICkpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGluamVjdEZvcm1SZXBsYXlpbmdSdW50aW1lKHJlc3VtYWJsZVN0YXRlLCByZW5kZXJTdGF0ZSkge1xuICAgICAgaWYgKChyZXN1bWFibGVTdGF0ZS5pbnN0cnVjdGlvbnMgJiAxNikgPT09IE5vdGhpbmdTZW50KSB7XG4gICAgICAgIHJlc3VtYWJsZVN0YXRlLmluc3RydWN0aW9ucyB8PSAxNjtcbiAgICAgICAgdmFyIHByZWFtYmxlID0gcmVuZGVyU3RhdGUucHJlYW1ibGUsXG4gICAgICAgICAgYm9vdHN0cmFwQ2h1bmtzID0gcmVuZGVyU3RhdGUuYm9vdHN0cmFwQ2h1bmtzO1xuICAgICAgICAocHJlYW1ibGUuaHRtbENodW5rcyB8fCBwcmVhbWJsZS5oZWFkQ2h1bmtzKSAmJlxuICAgICAgICAwID09PSBib290c3RyYXBDaHVua3MubGVuZ3RoXG4gICAgICAgICAgPyAoYm9vdHN0cmFwQ2h1bmtzLnB1c2gocmVuZGVyU3RhdGUuc3RhcnRJbmxpbmVTY3JpcHQpLFxuICAgICAgICAgICAgcHVzaENvbXBsZXRlZFNoZWxsSWRBdHRyaWJ1dGUoYm9vdHN0cmFwQ2h1bmtzLCByZXN1bWFibGVTdGF0ZSksXG4gICAgICAgICAgICBib290c3RyYXBDaHVua3MucHVzaChcbiAgICAgICAgICAgICAgZW5kT2ZTdGFydFRhZyxcbiAgICAgICAgICAgICAgZm9ybVJlcGxheWluZ1J1bnRpbWVTY3JpcHQsXG4gICAgICAgICAgICAgIGVuZElubGluZVNjcmlwdFxuICAgICAgICAgICAgKSlcbiAgICAgICAgICA6IGJvb3RzdHJhcENodW5rcy51bnNoaWZ0KFxuICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5zdGFydElubGluZVNjcmlwdCxcbiAgICAgICAgICAgICAgZW5kT2ZTdGFydFRhZyxcbiAgICAgICAgICAgICAgZm9ybVJlcGxheWluZ1J1bnRpbWVTY3JpcHQsXG4gICAgICAgICAgICAgIGVuZElubGluZVNjcmlwdFxuICAgICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaExpbmtJbXBsKHRhcmdldCwgcHJvcHMpIHtcbiAgICAgIHRhcmdldC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoXCJsaW5rXCIpKTtcbiAgICAgIGZvciAodmFyIHByb3BLZXkgaW4gcHJvcHMpXG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5KSkge1xuICAgICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcbiAgICAgICAgICBpZiAobnVsbCAhPSBwcm9wVmFsdWUpXG4gICAgICAgICAgICBzd2l0Y2ggKHByb3BLZXkpIHtcbiAgICAgICAgICAgICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJsaW5rIGlzIGEgc2VsZi1jbG9zaW5nIHRhZyBhbmQgbXVzdCBuZWl0aGVyIGhhdmUgYGNoaWxkcmVuYCBub3IgdXNlIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB0YXJnZXQucHVzaChlbmRPZlN0YXJ0VGFnU2VsZkNsb3NpbmcpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVzY2FwZVN0eWxlVGV4dENvbnRlbnQoc3R5bGVUZXh0KSB7XG4gICAgICBjaGVja0h0bWxTdHJpbmdDb2VyY2lvbihzdHlsZVRleHQpO1xuICAgICAgcmV0dXJuIChcIlwiICsgc3R5bGVUZXh0KS5yZXBsYWNlKHN0eWxlUmVnZXgsIHN0eWxlUmVwbGFjZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoU2VsZkNsb3NpbmcodGFyZ2V0LCBwcm9wcywgdGFnKSB7XG4gICAgICB0YXJnZXQucHVzaChzdGFydENodW5rRm9yVGFnKHRhZykpO1xuICAgICAgZm9yICh2YXIgcHJvcEtleSBpbiBwcm9wcylcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuICAgICAgICAgIGlmIChudWxsICE9IHByb3BWYWx1ZSlcbiAgICAgICAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICB0YWcgK1xuICAgICAgICAgICAgICAgICAgICBcIiBpcyBhIHNlbGYtY2xvc2luZyB0YWcgYW5kIG11c3QgbmVpdGhlciBoYXZlIGBjaGlsZHJlbmAgbm9yIHVzZSBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLlwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgdGFyZ2V0LnB1c2goZW5kT2ZTdGFydFRhZ1NlbGZDbG9zaW5nKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoVGl0bGVJbXBsKHRhcmdldCwgcHJvcHMpIHtcbiAgICAgIHRhcmdldC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoXCJ0aXRsZVwiKSk7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBudWxsLFxuICAgICAgICBpbm5lckhUTUwgPSBudWxsLFxuICAgICAgICBwcm9wS2V5O1xuICAgICAgZm9yIChwcm9wS2V5IGluIHByb3BzKVxuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkpIHtcbiAgICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG4gICAgICAgICAgaWYgKG51bGwgIT0gcHJvcFZhbHVlKVxuICAgICAgICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICAgIGNoaWxkcmVuID0gcHJvcFZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICBpbm5lckhUTUwgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIHRhcmdldC5wdXNoKGVuZE9mU3RhcnRUYWcpO1xuICAgICAgcHJvcHMgPSBBcnJheS5pc0FycmF5KGNoaWxkcmVuKVxuICAgICAgICA/IDIgPiBjaGlsZHJlbi5sZW5ndGhcbiAgICAgICAgICA/IGNoaWxkcmVuWzBdXG4gICAgICAgICAgOiBudWxsXG4gICAgICAgIDogY2hpbGRyZW47XG4gICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBwcm9wcyAmJlxuICAgICAgICBcInN5bWJvbFwiICE9PSB0eXBlb2YgcHJvcHMgJiZcbiAgICAgICAgbnVsbCAhPT0gcHJvcHMgJiZcbiAgICAgICAgdm9pZCAwICE9PSBwcm9wcyAmJlxuICAgICAgICB0YXJnZXQucHVzaChzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKFwiXCIgKyBwcm9wcykpKTtcbiAgICAgIHB1c2hJbm5lckhUTUwodGFyZ2V0LCBpbm5lckhUTUwsIGNoaWxkcmVuKTtcbiAgICAgIHRhcmdldC5wdXNoKGVuZENodW5rRm9yVGFnKFwidGl0bGVcIikpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hTY3JpcHRJbXBsKHRhcmdldCwgcHJvcHMpIHtcbiAgICAgIHRhcmdldC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoXCJzY3JpcHRcIikpO1xuICAgICAgdmFyIGNoaWxkcmVuID0gbnVsbCxcbiAgICAgICAgaW5uZXJIVE1MID0gbnVsbCxcbiAgICAgICAgcHJvcEtleTtcbiAgICAgIGZvciAocHJvcEtleSBpbiBwcm9wcylcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuICAgICAgICAgIGlmIChudWxsICE9IHByb3BWYWx1ZSlcbiAgICAgICAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgICBjaGlsZHJlbiA9IHByb3BWYWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgICAgICAgaW5uZXJIVE1MID0gcHJvcFZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB0YXJnZXQucHVzaChlbmRPZlN0YXJ0VGFnKTtcbiAgICAgIG51bGwgIT0gY2hpbGRyZW4gJiZcbiAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIGNoaWxkcmVuICYmXG4gICAgICAgICgocHJvcHMgPVxuICAgICAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiBjaGlsZHJlblxuICAgICAgICAgICAgPyBcImEgbnVtYmVyIGZvciBjaGlsZHJlblwiXG4gICAgICAgICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pXG4gICAgICAgICAgICAgID8gXCJhbiBhcnJheSBmb3IgY2hpbGRyZW5cIlxuICAgICAgICAgICAgICA6IFwic29tZXRoaW5nIHVuZXhwZWN0ZWQgZm9yIGNoaWxkcmVuXCIpLFxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiQSBzY3JpcHQgZWxlbWVudCB3YXMgcmVuZGVyZWQgd2l0aCAlcy4gSWYgc2NyaXB0IGVsZW1lbnQgaGFzIGNoaWxkcmVuIGl0IG11c3QgYmUgYSBzaW5nbGUgc3RyaW5nLiBDb25zaWRlciB1c2luZyBkYW5nZXJvdXNseVNldElubmVySFRNTCBvciBwYXNzaW5nIGEgcGxhaW4gc3RyaW5nIGFzIGNoaWxkcmVuLlwiLFxuICAgICAgICAgIHByb3BzXG4gICAgICAgICkpO1xuICAgICAgcHVzaElubmVySFRNTCh0YXJnZXQsIGlubmVySFRNTCwgY2hpbGRyZW4pO1xuICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGNoaWxkcmVuICYmXG4gICAgICAgIHRhcmdldC5wdXNoKHN0cmluZ1RvQ2h1bmsoZXNjYXBlRW50aXJlSW5saW5lU2NyaXB0Q29udGVudChjaGlsZHJlbikpKTtcbiAgICAgIHRhcmdldC5wdXNoKGVuZENodW5rRm9yVGFnKFwic2NyaXB0XCIpKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoU3RhcnRTaW5nbGV0b25FbGVtZW50KHRhcmdldCwgcHJvcHMsIHRhZykge1xuICAgICAgdGFyZ2V0LnB1c2goc3RhcnRDaHVua0ZvclRhZyh0YWcpKTtcbiAgICAgIHZhciBpbm5lckhUTUwgPSAodGFnID0gbnVsbCksXG4gICAgICAgIHByb3BLZXk7XG4gICAgICBmb3IgKHByb3BLZXkgaW4gcHJvcHMpXG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5KSkge1xuICAgICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcbiAgICAgICAgICBpZiAobnVsbCAhPSBwcm9wVmFsdWUpXG4gICAgICAgICAgICBzd2l0Y2ggKHByb3BLZXkpIHtcbiAgICAgICAgICAgICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICAgICAgICAgICAgdGFnID0gcHJvcFZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICBpbm5lckhUTUwgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIHRhcmdldC5wdXNoKGVuZE9mU3RhcnRUYWcpO1xuICAgICAgcHVzaElubmVySFRNTCh0YXJnZXQsIGlubmVySFRNTCwgdGFnKTtcbiAgICAgIHJldHVybiB0YWc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hTdGFydEdlbmVyaWNFbGVtZW50KHRhcmdldCwgcHJvcHMsIHRhZykge1xuICAgICAgdGFyZ2V0LnB1c2goc3RhcnRDaHVua0ZvclRhZyh0YWcpKTtcbiAgICAgIHZhciBpbm5lckhUTUwgPSAodGFnID0gbnVsbCksXG4gICAgICAgIHByb3BLZXk7XG4gICAgICBmb3IgKHByb3BLZXkgaW4gcHJvcHMpXG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5KSkge1xuICAgICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcbiAgICAgICAgICBpZiAobnVsbCAhPSBwcm9wVmFsdWUpXG4gICAgICAgICAgICBzd2l0Y2ggKHByb3BLZXkpIHtcbiAgICAgICAgICAgICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICAgICAgICAgICAgdGFnID0gcHJvcFZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICBpbm5lckhUTUwgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIHRhcmdldC5wdXNoKGVuZE9mU3RhcnRUYWcpO1xuICAgICAgcHVzaElubmVySFRNTCh0YXJnZXQsIGlubmVySFRNTCwgdGFnKTtcbiAgICAgIHJldHVybiBcInN0cmluZ1wiID09PSB0eXBlb2YgdGFnXG4gICAgICAgID8gKHRhcmdldC5wdXNoKHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIodGFnKSkpLCBudWxsKVxuICAgICAgICA6IHRhZztcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RhcnRDaHVua0ZvclRhZyh0YWcpIHtcbiAgICAgIHZhciB0YWdTdGFydENodW5rID0gdmFsaWRhdGVkVGFnQ2FjaGUuZ2V0KHRhZyk7XG4gICAgICBpZiAodm9pZCAwID09PSB0YWdTdGFydENodW5rKSB7XG4gICAgICAgIGlmICghVkFMSURfVEFHX1JFR0VYLnRlc3QodGFnKSkgdGhyb3cgRXJyb3IoXCJJbnZhbGlkIHRhZzogXCIgKyB0YWcpO1xuICAgICAgICB0YWdTdGFydENodW5rID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFwiPFwiICsgdGFnKTtcbiAgICAgICAgdmFsaWRhdGVkVGFnQ2FjaGUuc2V0KHRhZywgdGFnU3RhcnRDaHVuayk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFnU3RhcnRDaHVuaztcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaFN0YXJ0SW5zdGFuY2UoXG4gICAgICB0YXJnZXQkanNjb21wJDAsXG4gICAgICB0eXBlLFxuICAgICAgcHJvcHMsXG4gICAgICByZXN1bWFibGVTdGF0ZSxcbiAgICAgIHJlbmRlclN0YXRlLFxuICAgICAgcHJlYW1ibGVTdGF0ZSxcbiAgICAgIGhvaXN0YWJsZVN0YXRlLFxuICAgICAgZm9ybWF0Q29udGV4dCxcbiAgICAgIHRleHRFbWJlZGRlZFxuICAgICkge1xuICAgICAgdmFsaWRhdGVQcm9wZXJ0aWVzJDIodHlwZSwgcHJvcHMpO1xuICAgICAgKFwiaW5wdXRcIiAhPT0gdHlwZSAmJiBcInRleHRhcmVhXCIgIT09IHR5cGUgJiYgXCJzZWxlY3RcIiAhPT0gdHlwZSkgfHxcbiAgICAgICAgbnVsbCA9PSBwcm9wcyB8fFxuICAgICAgICBudWxsICE9PSBwcm9wcy52YWx1ZSB8fFxuICAgICAgICBkaWRXYXJuVmFsdWVOdWxsIHx8XG4gICAgICAgICgoZGlkV2FyblZhbHVlTnVsbCA9ICEwKSxcbiAgICAgICAgXCJzZWxlY3RcIiA9PT0gdHlwZSAmJiBwcm9wcy5tdWx0aXBsZVxuICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJgdmFsdWVgIHByb3Agb24gYCVzYCBzaG91bGQgbm90IGJlIG51bGwuIENvbnNpZGVyIHVzaW5nIGFuIGVtcHR5IGFycmF5IHdoZW4gYG11bHRpcGxlYCBpcyBzZXQgdG8gYHRydWVgIHRvIGNsZWFyIHRoZSBjb21wb25lbnQgb3IgYHVuZGVmaW5lZGAgZm9yIHVuY29udHJvbGxlZCBjb21wb25lbnRzLlwiLFxuICAgICAgICAgICAgICB0eXBlXG4gICAgICAgICAgICApXG4gICAgICAgICAgOiBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcImB2YWx1ZWAgcHJvcCBvbiBgJXNgIHNob3VsZCBub3QgYmUgbnVsbC4gQ29uc2lkZXIgdXNpbmcgYW4gZW1wdHkgc3RyaW5nIHRvIGNsZWFyIHRoZSBjb21wb25lbnQgb3IgYHVuZGVmaW5lZGAgZm9yIHVuY29udHJvbGxlZCBjb21wb25lbnRzLlwiLFxuICAgICAgICAgICAgICB0eXBlXG4gICAgICAgICAgICApKTtcbiAgICAgIGI6IGlmICgtMSA9PT0gdHlwZS5pbmRleE9mKFwiLVwiKSkgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICExO1xuICAgICAgZWxzZVxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwiYW5ub3RhdGlvbi14bWxcIjpcbiAgICAgICAgICBjYXNlIFwiY29sb3ItcHJvZmlsZVwiOlxuICAgICAgICAgIGNhc2UgXCJmb250LWZhY2VcIjpcbiAgICAgICAgICBjYXNlIFwiZm9udC1mYWNlLXNyY1wiOlxuICAgICAgICAgIGNhc2UgXCJmb250LWZhY2UtdXJpXCI6XG4gICAgICAgICAgY2FzZSBcImZvbnQtZmFjZS1mb3JtYXRcIjpcbiAgICAgICAgICBjYXNlIFwiZm9udC1mYWNlLW5hbWVcIjpcbiAgICAgICAgICBjYXNlIFwibWlzc2luZy1nbHlwaFwiOlxuICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITE7XG4gICAgICAgICAgICBicmVhayBiO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAhMDtcbiAgICAgICAgfVxuICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0IHx8XG4gICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBwcm9wcy5pcyB8fFxuICAgICAgICB3YXJuVW5rbm93blByb3BlcnRpZXModHlwZSwgcHJvcHMsIG51bGwpO1xuICAgICAgIXByb3BzLnN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZyAmJlxuICAgICAgICBwcm9wcy5jb250ZW50RWRpdGFibGUgJiZcbiAgICAgICAgbnVsbCAhPSBwcm9wcy5jaGlsZHJlbiAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiQSBjb21wb25lbnQgaXMgYGNvbnRlbnRFZGl0YWJsZWAgYW5kIGNvbnRhaW5zIGBjaGlsZHJlbmAgbWFuYWdlZCBieSBSZWFjdC4gSXQgaXMgbm93IHlvdXIgcmVzcG9uc2liaWxpdHkgdG8gZ3VhcmFudGVlIHRoYXQgbm9uZSBvZiB0aG9zZSBub2RlcyBhcmUgdW5leHBlY3RlZGx5IG1vZGlmaWVkIG9yIGR1cGxpY2F0ZWQuIFRoaXMgaXMgcHJvYmFibHkgbm90IGludGVudGlvbmFsLlwiXG4gICAgICAgICk7XG4gICAgICBmb3JtYXRDb250ZXh0Lmluc2VydGlvbk1vZGUgIT09IFNWR19NT0RFICYmXG4gICAgICAgIGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSAhPT0gTUFUSE1MX01PREUgJiZcbiAgICAgICAgLTEgPT09IHR5cGUuaW5kZXhPZihcIi1cIikgJiZcbiAgICAgICAgdHlwZS50b0xvd2VyQ2FzZSgpICE9PSB0eXBlICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCI8JXMgLz4gaXMgdXNpbmcgaW5jb3JyZWN0IGNhc2luZy4gVXNlIFBhc2NhbENhc2UgZm9yIFJlYWN0IGNvbXBvbmVudHMsIG9yIGxvd2VyY2FzZSBmb3IgSFRNTCBlbGVtZW50cy5cIixcbiAgICAgICAgICB0eXBlXG4gICAgICAgICk7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcImRpdlwiOlxuICAgICAgICBjYXNlIFwic3BhblwiOlxuICAgICAgICBjYXNlIFwic3ZnXCI6XG4gICAgICAgIGNhc2UgXCJwYXRoXCI6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJhXCI6XG4gICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goc3RhcnRDaHVua0ZvclRhZyhcImFcIikpO1xuICAgICAgICAgIHZhciBjaGlsZHJlbiA9IG51bGwsXG4gICAgICAgICAgICBpbm5lckhUTUwgPSBudWxsLFxuICAgICAgICAgICAgcHJvcEtleTtcbiAgICAgICAgICBmb3IgKHByb3BLZXkgaW4gcHJvcHMpXG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkpIHtcbiAgICAgICAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuICAgICAgICAgICAgICBpZiAobnVsbCAhPSBwcm9wVmFsdWUpXG4gICAgICAgICAgICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4gPSBwcm9wVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgICAgICAgICAgIGlubmVySFRNTCA9IHByb3BWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiaHJlZlwiOlxuICAgICAgICAgICAgICAgICAgICBcIlwiID09PSBwcm9wVmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICA/IHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0JGpzY29tcCQwLCBcImhyZWZcIiwgXCJcIilcbiAgICAgICAgICAgICAgICAgICAgICA6IHB1c2hBdHRyaWJ1dGUodGFyZ2V0JGpzY29tcCQwLCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0JGpzY29tcCQwLCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChlbmRPZlN0YXJ0VGFnKTtcbiAgICAgICAgICBwdXNoSW5uZXJIVE1MKHRhcmdldCRqc2NvbXAkMCwgaW5uZXJIVE1MLCBjaGlsZHJlbik7XG4gICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBjaGlsZHJlbikge1xuICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihjaGlsZHJlbikpKTtcbiAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDAgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDAgPSBjaGlsZHJlbjtcbiAgICAgICAgICByZXR1cm4gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwO1xuICAgICAgICBjYXNlIFwiZ1wiOlxuICAgICAgICBjYXNlIFwicFwiOlxuICAgICAgICBjYXNlIFwibGlcIjpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInNlbGVjdFwiOlxuICAgICAgICAgIGNoZWNrQ29udHJvbGxlZFZhbHVlUHJvcHMoXCJzZWxlY3RcIiwgcHJvcHMpO1xuICAgICAgICAgIGNoZWNrU2VsZWN0UHJvcChwcm9wcywgXCJ2YWx1ZVwiKTtcbiAgICAgICAgICBjaGVja1NlbGVjdFByb3AocHJvcHMsIFwiZGVmYXVsdFZhbHVlXCIpO1xuICAgICAgICAgIHZvaWQgMCA9PT0gcHJvcHMudmFsdWUgfHxcbiAgICAgICAgICAgIHZvaWQgMCA9PT0gcHJvcHMuZGVmYXVsdFZhbHVlIHx8XG4gICAgICAgICAgICBkaWRXYXJuRGVmYXVsdFNlbGVjdFZhbHVlIHx8XG4gICAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJTZWxlY3QgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgc2VsZWN0IGVsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9jb250cm9sbGVkLWNvbXBvbmVudHNcIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIChkaWRXYXJuRGVmYXVsdFNlbGVjdFZhbHVlID0gITApKTtcbiAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChzdGFydENodW5rRm9yVGFnKFwic2VsZWN0XCIpKTtcbiAgICAgICAgICB2YXIgY2hpbGRyZW4kanNjb21wJDAgPSBudWxsLFxuICAgICAgICAgICAgaW5uZXJIVE1MJGpzY29tcCQwID0gbnVsbCxcbiAgICAgICAgICAgIHByb3BLZXkkanNjb21wJDA7XG4gICAgICAgICAgZm9yIChwcm9wS2V5JGpzY29tcCQwIGluIHByb3BzKVxuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkkanNjb21wJDApKSB7XG4gICAgICAgICAgICAgIHZhciBwcm9wVmFsdWUkanNjb21wJDAgPSBwcm9wc1twcm9wS2V5JGpzY29tcCQwXTtcbiAgICAgICAgICAgICAgaWYgKG51bGwgIT0gcHJvcFZhbHVlJGpzY29tcCQwKVxuICAgICAgICAgICAgICAgIHN3aXRjaCAocHJvcEtleSRqc2NvbXAkMCkge1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuJGpzY29tcCQwID0gcHJvcFZhbHVlJGpzY29tcCQwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICAgICAgICAgICAgICBpbm5lckhUTUwkanNjb21wJDAgPSBwcm9wVmFsdWUkanNjb21wJDA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImRlZmF1bHRWYWx1ZVwiOlxuICAgICAgICAgICAgICAgICAgY2FzZSBcInZhbHVlXCI6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZShcbiAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcEtleSRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wVmFsdWUkanNjb21wJDBcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gICAgICAgICAgcHVzaElubmVySFRNTCh0YXJnZXQkanNjb21wJDAsIGlubmVySFRNTCRqc2NvbXAkMCwgY2hpbGRyZW4kanNjb21wJDApO1xuICAgICAgICAgIHJldHVybiBjaGlsZHJlbiRqc2NvbXAkMDtcbiAgICAgICAgY2FzZSBcIm9wdGlvblwiOlxuICAgICAgICAgIHZhciBzZWxlY3RlZFZhbHVlID0gZm9ybWF0Q29udGV4dC5zZWxlY3RlZFZhbHVlO1xuICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoXCJvcHRpb25cIikpO1xuICAgICAgICAgIHZhciBjaGlsZHJlbiRqc2NvbXAkMSA9IG51bGwsXG4gICAgICAgICAgICB2YWx1ZSA9IG51bGwsXG4gICAgICAgICAgICBzZWxlY3RlZCA9IG51bGwsXG4gICAgICAgICAgICBpbm5lckhUTUwkanNjb21wJDEgPSBudWxsLFxuICAgICAgICAgICAgcHJvcEtleSRqc2NvbXAkMTtcbiAgICAgICAgICBmb3IgKHByb3BLZXkkanNjb21wJDEgaW4gcHJvcHMpXG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSRqc2NvbXAkMSkpIHtcbiAgICAgICAgICAgICAgdmFyIHByb3BWYWx1ZSRqc2NvbXAkMSA9IHByb3BzW3Byb3BLZXkkanNjb21wJDFdO1xuICAgICAgICAgICAgICBpZiAobnVsbCAhPSBwcm9wVmFsdWUkanNjb21wJDEpXG4gICAgICAgICAgICAgICAgc3dpdGNoIChwcm9wS2V5JGpzY29tcCQxKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4kanNjb21wJDEgPSBwcm9wVmFsdWUkanNjb21wJDE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcInNlbGVjdGVkXCI6XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkID0gcHJvcFZhbHVlJGpzY29tcCQxO1xuICAgICAgICAgICAgICAgICAgICBkaWRXYXJuU2VsZWN0ZWRTZXRPbk9wdGlvbiB8fFxuICAgICAgICAgICAgICAgICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJVc2UgdGhlIGBkZWZhdWx0VmFsdWVgIG9yIGB2YWx1ZWAgcHJvcHMgb24gPHNlbGVjdD4gaW5zdGVhZCBvZiBzZXR0aW5nIGBzZWxlY3RlZGAgb24gPG9wdGlvbj4uXCJcbiAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgIChkaWRXYXJuU2VsZWN0ZWRTZXRPbk9wdGlvbiA9ICEwKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgICAgICAgICAgIGlubmVySFRNTCRqc2NvbXAkMSA9IHByb3BWYWx1ZSRqc2NvbXAkMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwidmFsdWVcIjpcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwcm9wVmFsdWUkanNjb21wJDE7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBwdXNoQXR0cmlidXRlKFxuICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQxLFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BWYWx1ZSRqc2NvbXAkMVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobnVsbCAhPSBzZWxlY3RlZFZhbHVlKSB7XG4gICAgICAgICAgICBpZiAobnVsbCAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbih2YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICAgICAgICAgICAgdmFyIHN0cmluZ1ZhbHVlID0gXCJcIiArIHZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgIG51bGwgPT09IGlubmVySFRNTCRqc2NvbXAkMSB8fFxuICAgICAgICAgICAgICAgIGRpZFdhcm5JbnZhbGlkT3B0aW9uSW5uZXJIVE1MIHx8XG4gICAgICAgICAgICAgICAgKChkaWRXYXJuSW52YWxpZE9wdGlvbklubmVySFRNTCA9ICEwKSxcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJQYXNzIGEgYHZhbHVlYCBwcm9wIGlmIHlvdSBzZXQgZGFuZ2Vyb3VzbHlJbm5lckhUTUwgc28gUmVhY3Qga25vd3Mgd2hpY2ggdmFsdWUgc2hvdWxkIGJlIHNlbGVjdGVkLlwiXG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgKHN0cmluZ1ZhbHVlID0gZmxhdHRlbk9wdGlvbkNoaWxkcmVuKGNoaWxkcmVuJGpzY29tcCQxKSk7XG4gICAgICAgICAgICBpZiAoaXNBcnJheUltcGwoc2VsZWN0ZWRWYWx1ZSkpXG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZWN0ZWRWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgIChjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHNlbGVjdGVkVmFsdWVbaV0sIFwidmFsdWVcIiksXG4gICAgICAgICAgICAgICAgICBcIlwiICsgc2VsZWN0ZWRWYWx1ZVtpXSA9PT0gc3RyaW5nVmFsdWUpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChzZWxlY3RlZE1hcmtlckF0dHJpYnV0ZSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbihzZWxlY3RlZFZhbHVlLCBcInNlbGVjdC52YWx1ZVwiKSxcbiAgICAgICAgICAgICAgICBcIlwiICsgc2VsZWN0ZWRWYWx1ZSA9PT0gc3RyaW5nVmFsdWUgJiZcbiAgICAgICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKHNlbGVjdGVkTWFya2VyQXR0cmlidXRlKTtcbiAgICAgICAgICB9IGVsc2Ugc2VsZWN0ZWQgJiYgdGFyZ2V0JGpzY29tcCQwLnB1c2goc2VsZWN0ZWRNYXJrZXJBdHRyaWJ1dGUpO1xuICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKGVuZE9mU3RhcnRUYWcpO1xuICAgICAgICAgIHB1c2hJbm5lckhUTUwodGFyZ2V0JGpzY29tcCQwLCBpbm5lckhUTUwkanNjb21wJDEsIGNoaWxkcmVuJGpzY29tcCQxKTtcbiAgICAgICAgICByZXR1cm4gY2hpbGRyZW4kanNjb21wJDE7XG4gICAgICAgIGNhc2UgXCJ0ZXh0YXJlYVwiOlxuICAgICAgICAgIGNoZWNrQ29udHJvbGxlZFZhbHVlUHJvcHMoXCJ0ZXh0YXJlYVwiLCBwcm9wcyk7XG4gICAgICAgICAgdm9pZCAwID09PSBwcm9wcy52YWx1ZSB8fFxuICAgICAgICAgICAgdm9pZCAwID09PSBwcm9wcy5kZWZhdWx0VmFsdWUgfHxcbiAgICAgICAgICAgIGRpZFdhcm5EZWZhdWx0VGV4dGFyZWFWYWx1ZSB8fFxuICAgICAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiVGV4dGFyZWEgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgdGV4dGFyZWEgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9jb250cm9sbGVkLWNvbXBvbmVudHNcIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIChkaWRXYXJuRGVmYXVsdFRleHRhcmVhVmFsdWUgPSAhMCkpO1xuICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoXCJ0ZXh0YXJlYVwiKSk7XG4gICAgICAgICAgdmFyIHZhbHVlJGpzY29tcCQwID0gbnVsbCxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZSA9IG51bGwsXG4gICAgICAgICAgICBjaGlsZHJlbiRqc2NvbXAkMiA9IG51bGwsXG4gICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQyO1xuICAgICAgICAgIGZvciAocHJvcEtleSRqc2NvbXAkMiBpbiBwcm9wcylcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5JGpzY29tcCQyKSkge1xuICAgICAgICAgICAgICB2YXIgcHJvcFZhbHVlJGpzY29tcCQyID0gcHJvcHNbcHJvcEtleSRqc2NvbXAkMl07XG4gICAgICAgICAgICAgIGlmIChudWxsICE9IHByb3BWYWx1ZSRqc2NvbXAkMilcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHByb3BLZXkkanNjb21wJDIpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbiRqc2NvbXAkMiA9IHByb3BWYWx1ZSRqc2NvbXAkMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwidmFsdWVcIjpcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUkanNjb21wJDAgPSBwcm9wVmFsdWUkanNjb21wJDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImRlZmF1bHRWYWx1ZVwiOlxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWUgPSBwcm9wVmFsdWUkanNjb21wJDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgIFwiYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBkb2VzIG5vdCBtYWtlIHNlbnNlIG9uIDx0ZXh0YXJlYT4uXCJcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHB1c2hBdHRyaWJ1dGUoXG4gICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BLZXkkanNjb21wJDIsXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcFZhbHVlJGpzY29tcCQyXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIG51bGwgPT09IHZhbHVlJGpzY29tcCQwICYmXG4gICAgICAgICAgICBudWxsICE9PSBkZWZhdWx0VmFsdWUgJiZcbiAgICAgICAgICAgICh2YWx1ZSRqc2NvbXAkMCA9IGRlZmF1bHRWYWx1ZSk7XG4gICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gICAgICAgICAgaWYgKG51bGwgIT0gY2hpbGRyZW4kanNjb21wJDIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiVXNlIHRoZSBgZGVmYXVsdFZhbHVlYCBvciBgdmFsdWVgIHByb3BzIGluc3RlYWQgb2Ygc2V0dGluZyBjaGlsZHJlbiBvbiA8dGV4dGFyZWE+LlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKG51bGwgIT0gdmFsdWUkanNjb21wJDApXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiSWYgeW91IHN1cHBseSBgZGVmYXVsdFZhbHVlYCBvbiBhIDx0ZXh0YXJlYT4sIGRvIG5vdCBwYXNzIGNoaWxkcmVuLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoaXNBcnJheUltcGwoY2hpbGRyZW4kanNjb21wJDIpKSB7XG4gICAgICAgICAgICAgIGlmICgxIDwgY2hpbGRyZW4kanNjb21wJDIubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiPHRleHRhcmVhPiBjYW4gb25seSBoYXZlIGF0IG1vc3Qgb25lIGNoaWxkLlwiKTtcbiAgICAgICAgICAgICAgY2hlY2tIdG1sU3RyaW5nQ29lcmNpb24oY2hpbGRyZW4kanNjb21wJDJbMF0pO1xuICAgICAgICAgICAgICB2YWx1ZSRqc2NvbXAkMCA9IFwiXCIgKyBjaGlsZHJlbiRqc2NvbXAkMlswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoZWNrSHRtbFN0cmluZ0NvZXJjaW9uKGNoaWxkcmVuJGpzY29tcCQyKTtcbiAgICAgICAgICAgIHZhbHVlJGpzY29tcCQwID0gXCJcIiArIGNoaWxkcmVuJGpzY29tcCQyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgdmFsdWUkanNjb21wJDAgJiZcbiAgICAgICAgICAgIFwiXFxuXCIgPT09IHZhbHVlJGpzY29tcCQwWzBdICYmXG4gICAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChsZWFkaW5nTmV3bGluZSk7XG4gICAgICAgICAgbnVsbCAhPT0gdmFsdWUkanNjb21wJDAgJiZcbiAgICAgICAgICAgIChjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlJGpzY29tcCQwLCBcInZhbHVlXCIpLFxuICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goXG4gICAgICAgICAgICAgIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoXCJcIiArIHZhbHVlJGpzY29tcCQwKSlcbiAgICAgICAgICAgICkpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjYXNlIFwiaW5wdXRcIjpcbiAgICAgICAgICBjaGVja0NvbnRyb2xsZWRWYWx1ZVByb3BzKFwiaW5wdXRcIiwgcHJvcHMpO1xuICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoXCJpbnB1dFwiKSk7XG4gICAgICAgICAgdmFyIG5hbWUgPSBudWxsLFxuICAgICAgICAgICAgZm9ybUFjdGlvbiA9IG51bGwsXG4gICAgICAgICAgICBmb3JtRW5jVHlwZSA9IG51bGwsXG4gICAgICAgICAgICBmb3JtTWV0aG9kID0gbnVsbCxcbiAgICAgICAgICAgIGZvcm1UYXJnZXQgPSBudWxsLFxuICAgICAgICAgICAgdmFsdWUkanNjb21wJDEgPSBudWxsLFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlJGpzY29tcCQwID0gbnVsbCxcbiAgICAgICAgICAgIGNoZWNrZWQgPSBudWxsLFxuICAgICAgICAgICAgZGVmYXVsdENoZWNrZWQgPSBudWxsLFxuICAgICAgICAgICAgcHJvcEtleSRqc2NvbXAkMztcbiAgICAgICAgICBmb3IgKHByb3BLZXkkanNjb21wJDMgaW4gcHJvcHMpXG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSRqc2NvbXAkMykpIHtcbiAgICAgICAgICAgICAgdmFyIHByb3BWYWx1ZSRqc2NvbXAkMyA9IHByb3BzW3Byb3BLZXkkanNjb21wJDNdO1xuICAgICAgICAgICAgICBpZiAobnVsbCAhPSBwcm9wVmFsdWUkanNjb21wJDMpXG4gICAgICAgICAgICAgICAgc3dpdGNoIChwcm9wS2V5JGpzY29tcCQzKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICBcImlucHV0IGlzIGEgc2VsZi1jbG9zaW5nIHRhZyBhbmQgbXVzdCBuZWl0aGVyIGhhdmUgYGNoaWxkcmVuYCBub3IgdXNlIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuXCJcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJuYW1lXCI6XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBwcm9wVmFsdWUkanNjb21wJDM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImZvcm1BY3Rpb25cIjpcbiAgICAgICAgICAgICAgICAgICAgZm9ybUFjdGlvbiA9IHByb3BWYWx1ZSRqc2NvbXAkMztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZm9ybUVuY1R5cGVcIjpcbiAgICAgICAgICAgICAgICAgICAgZm9ybUVuY1R5cGUgPSBwcm9wVmFsdWUkanNjb21wJDM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImZvcm1NZXRob2RcIjpcbiAgICAgICAgICAgICAgICAgICAgZm9ybU1ldGhvZCA9IHByb3BWYWx1ZSRqc2NvbXAkMztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZm9ybVRhcmdldFwiOlxuICAgICAgICAgICAgICAgICAgICBmb3JtVGFyZ2V0ID0gcHJvcFZhbHVlJGpzY29tcCQzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJkZWZhdWx0Q2hlY2tlZFwiOlxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0Q2hlY2tlZCA9IHByb3BWYWx1ZSRqc2NvbXAkMztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZGVmYXVsdFZhbHVlXCI6XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZSRqc2NvbXAkMCA9IHByb3BWYWx1ZSRqc2NvbXAkMztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiY2hlY2tlZFwiOlxuICAgICAgICAgICAgICAgICAgICBjaGVja2VkID0gcHJvcFZhbHVlJGpzY29tcCQzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJ2YWx1ZVwiOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSRqc2NvbXAkMSA9IHByb3BWYWx1ZSRqc2NvbXAkMztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBwdXNoQXR0cmlidXRlKFxuICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQzLFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BWYWx1ZSRqc2NvbXAkM1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICBudWxsID09PSBmb3JtQWN0aW9uIHx8XG4gICAgICAgICAgICBcImltYWdlXCIgPT09IHByb3BzLnR5cGUgfHxcbiAgICAgICAgICAgIFwic3VibWl0XCIgPT09IHByb3BzLnR5cGUgfHxcbiAgICAgICAgICAgIGRpZFdhcm5Gb3JtQWN0aW9uVHlwZSB8fFxuICAgICAgICAgICAgKChkaWRXYXJuRm9ybUFjdGlvblR5cGUgPSAhMCksXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAnQW4gaW5wdXQgY2FuIG9ubHkgc3BlY2lmeSBhIGZvcm1BY3Rpb24gYWxvbmcgd2l0aCB0eXBlPVwic3VibWl0XCIgb3IgdHlwZT1cImltYWdlXCIuJ1xuICAgICAgICAgICAgKSk7XG4gICAgICAgICAgdmFyIGZvcm1EYXRhID0gcHVzaEZvcm1BY3Rpb25BdHRyaWJ1dGUoXG4gICAgICAgICAgICB0YXJnZXQkanNjb21wJDAsXG4gICAgICAgICAgICByZXN1bWFibGVTdGF0ZSxcbiAgICAgICAgICAgIHJlbmRlclN0YXRlLFxuICAgICAgICAgICAgZm9ybUFjdGlvbixcbiAgICAgICAgICAgIGZvcm1FbmNUeXBlLFxuICAgICAgICAgICAgZm9ybU1ldGhvZCxcbiAgICAgICAgICAgIGZvcm1UYXJnZXQsXG4gICAgICAgICAgICBuYW1lXG4gICAgICAgICAgKTtcbiAgICAgICAgICBudWxsID09PSBjaGVja2VkIHx8XG4gICAgICAgICAgICBudWxsID09PSBkZWZhdWx0Q2hlY2tlZCB8fFxuICAgICAgICAgICAgZGlkV2FybkRlZmF1bHRDaGVja2VkIHx8XG4gICAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCIlcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCBjaGVja2VkIGFuZCBkZWZhdWx0Q2hlY2tlZCBwcm9wcy4gSW5wdXQgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgKHNwZWNpZnkgZWl0aGVyIHRoZSBjaGVja2VkIHByb3AsIG9yIHRoZSBkZWZhdWx0Q2hlY2tlZCBwcm9wLCBidXQgbm90IGJvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0IGVsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9jb250cm9sbGVkLWNvbXBvbmVudHNcIixcbiAgICAgICAgICAgICAgXCJBIGNvbXBvbmVudFwiLFxuICAgICAgICAgICAgICBwcm9wcy50eXBlXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgKGRpZFdhcm5EZWZhdWx0Q2hlY2tlZCA9ICEwKSk7XG4gICAgICAgICAgbnVsbCA9PT0gdmFsdWUkanNjb21wJDEgfHxcbiAgICAgICAgICAgIG51bGwgPT09IGRlZmF1bHRWYWx1ZSRqc2NvbXAkMCB8fFxuICAgICAgICAgICAgZGlkV2FybkRlZmF1bHRJbnB1dFZhbHVlIHx8XG4gICAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCIlcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCB2YWx1ZSBhbmQgZGVmYXVsdFZhbHVlIHByb3BzLiBJbnB1dCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCBib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCBlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86IGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvY29udHJvbGxlZC1jb21wb25lbnRzXCIsXG4gICAgICAgICAgICAgIFwiQSBjb21wb25lbnRcIixcbiAgICAgICAgICAgICAgcHJvcHMudHlwZVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIChkaWRXYXJuRGVmYXVsdElucHV0VmFsdWUgPSAhMCkpO1xuICAgICAgICAgIG51bGwgIT09IGNoZWNrZWRcbiAgICAgICAgICAgID8gcHVzaEJvb2xlYW5BdHRyaWJ1dGUodGFyZ2V0JGpzY29tcCQwLCBcImNoZWNrZWRcIiwgY2hlY2tlZClcbiAgICAgICAgICAgIDogbnVsbCAhPT0gZGVmYXVsdENoZWNrZWQgJiZcbiAgICAgICAgICAgICAgcHVzaEJvb2xlYW5BdHRyaWJ1dGUodGFyZ2V0JGpzY29tcCQwLCBcImNoZWNrZWRcIiwgZGVmYXVsdENoZWNrZWQpO1xuICAgICAgICAgIG51bGwgIT09IHZhbHVlJGpzY29tcCQxXG4gICAgICAgICAgICA/IHB1c2hBdHRyaWJ1dGUodGFyZ2V0JGpzY29tcCQwLCBcInZhbHVlXCIsIHZhbHVlJGpzY29tcCQxKVxuICAgICAgICAgICAgOiBudWxsICE9PSBkZWZhdWx0VmFsdWUkanNjb21wJDAgJiZcbiAgICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQkanNjb21wJDAsIFwidmFsdWVcIiwgZGVmYXVsdFZhbHVlJGpzY29tcCQwKTtcbiAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChlbmRPZlN0YXJ0VGFnU2VsZkNsb3NpbmcpO1xuICAgICAgICAgIG51bGwgIT0gZm9ybURhdGEgJiZcbiAgICAgICAgICAgIGZvcm1EYXRhLmZvckVhY2gocHVzaEFkZGl0aW9uYWxGb3JtRmllbGQsIHRhcmdldCRqc2NvbXAkMCk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNhc2UgXCJidXR0b25cIjpcbiAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChzdGFydENodW5rRm9yVGFnKFwiYnV0dG9uXCIpKTtcbiAgICAgICAgICB2YXIgY2hpbGRyZW4kanNjb21wJDMgPSBudWxsLFxuICAgICAgICAgICAgaW5uZXJIVE1MJGpzY29tcCQyID0gbnVsbCxcbiAgICAgICAgICAgIG5hbWUkanNjb21wJDAgPSBudWxsLFxuICAgICAgICAgICAgZm9ybUFjdGlvbiRqc2NvbXAkMCA9IG51bGwsXG4gICAgICAgICAgICBmb3JtRW5jVHlwZSRqc2NvbXAkMCA9IG51bGwsXG4gICAgICAgICAgICBmb3JtTWV0aG9kJGpzY29tcCQwID0gbnVsbCxcbiAgICAgICAgICAgIGZvcm1UYXJnZXQkanNjb21wJDAgPSBudWxsLFxuICAgICAgICAgICAgcHJvcEtleSRqc2NvbXAkNDtcbiAgICAgICAgICBmb3IgKHByb3BLZXkkanNjb21wJDQgaW4gcHJvcHMpXG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSRqc2NvbXAkNCkpIHtcbiAgICAgICAgICAgICAgdmFyIHByb3BWYWx1ZSRqc2NvbXAkNCA9IHByb3BzW3Byb3BLZXkkanNjb21wJDRdO1xuICAgICAgICAgICAgICBpZiAobnVsbCAhPSBwcm9wVmFsdWUkanNjb21wJDQpXG4gICAgICAgICAgICAgICAgc3dpdGNoIChwcm9wS2V5JGpzY29tcCQ0KSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4kanNjb21wJDMgPSBwcm9wVmFsdWUkanNjb21wJDQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgICAgICAgICAgIGlubmVySFRNTCRqc2NvbXAkMiA9IHByb3BWYWx1ZSRqc2NvbXAkNDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwibmFtZVwiOlxuICAgICAgICAgICAgICAgICAgICBuYW1lJGpzY29tcCQwID0gcHJvcFZhbHVlJGpzY29tcCQ0O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJmb3JtQWN0aW9uXCI6XG4gICAgICAgICAgICAgICAgICAgIGZvcm1BY3Rpb24kanNjb21wJDAgPSBwcm9wVmFsdWUkanNjb21wJDQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImZvcm1FbmNUeXBlXCI6XG4gICAgICAgICAgICAgICAgICAgIGZvcm1FbmNUeXBlJGpzY29tcCQwID0gcHJvcFZhbHVlJGpzY29tcCQ0O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJmb3JtTWV0aG9kXCI6XG4gICAgICAgICAgICAgICAgICAgIGZvcm1NZXRob2QkanNjb21wJDAgPSBwcm9wVmFsdWUkanNjb21wJDQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImZvcm1UYXJnZXRcIjpcbiAgICAgICAgICAgICAgICAgICAgZm9ybVRhcmdldCRqc2NvbXAkMCA9IHByb3BWYWx1ZSRqc2NvbXAkNDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBwdXNoQXR0cmlidXRlKFxuICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQ0LFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BWYWx1ZSRqc2NvbXAkNFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICBudWxsID09PSBmb3JtQWN0aW9uJGpzY29tcCQwIHx8XG4gICAgICAgICAgICBudWxsID09IHByb3BzLnR5cGUgfHxcbiAgICAgICAgICAgIFwic3VibWl0XCIgPT09IHByb3BzLnR5cGUgfHxcbiAgICAgICAgICAgIGRpZFdhcm5Gb3JtQWN0aW9uVHlwZSB8fFxuICAgICAgICAgICAgKChkaWRXYXJuRm9ybUFjdGlvblR5cGUgPSAhMCksXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAnQSBidXR0b24gY2FuIG9ubHkgc3BlY2lmeSBhIGZvcm1BY3Rpb24gYWxvbmcgd2l0aCB0eXBlPVwic3VibWl0XCIgb3Igbm8gdHlwZS4nXG4gICAgICAgICAgICApKTtcbiAgICAgICAgICB2YXIgZm9ybURhdGEkanNjb21wJDAgPSBwdXNoRm9ybUFjdGlvbkF0dHJpYnV0ZShcbiAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLFxuICAgICAgICAgICAgcmVuZGVyU3RhdGUsXG4gICAgICAgICAgICBmb3JtQWN0aW9uJGpzY29tcCQwLFxuICAgICAgICAgICAgZm9ybUVuY1R5cGUkanNjb21wJDAsXG4gICAgICAgICAgICBmb3JtTWV0aG9kJGpzY29tcCQwLFxuICAgICAgICAgICAgZm9ybVRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgIG5hbWUkanNjb21wJDBcbiAgICAgICAgICApO1xuICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKGVuZE9mU3RhcnRUYWcpO1xuICAgICAgICAgIG51bGwgIT0gZm9ybURhdGEkanNjb21wJDAgJiZcbiAgICAgICAgICAgIGZvcm1EYXRhJGpzY29tcCQwLmZvckVhY2gocHVzaEFkZGl0aW9uYWxGb3JtRmllbGQsIHRhcmdldCRqc2NvbXAkMCk7XG4gICAgICAgICAgcHVzaElubmVySFRNTCh0YXJnZXQkanNjb21wJDAsIGlubmVySFRNTCRqc2NvbXAkMiwgY2hpbGRyZW4kanNjb21wJDMpO1xuICAgICAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgY2hpbGRyZW4kanNjb21wJDMpIHtcbiAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKFxuICAgICAgICAgICAgICBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKGNoaWxkcmVuJGpzY29tcCQzKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQxID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2UgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQxID0gY2hpbGRyZW4kanNjb21wJDM7XG4gICAgICAgICAgcmV0dXJuIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMTtcbiAgICAgICAgY2FzZSBcImZvcm1cIjpcbiAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChzdGFydENodW5rRm9yVGFnKFwiZm9ybVwiKSk7XG4gICAgICAgICAgdmFyIGNoaWxkcmVuJGpzY29tcCQ0ID0gbnVsbCxcbiAgICAgICAgICAgIGlubmVySFRNTCRqc2NvbXAkMyA9IG51bGwsXG4gICAgICAgICAgICBmb3JtQWN0aW9uJGpzY29tcCQxID0gbnVsbCxcbiAgICAgICAgICAgIGZvcm1FbmNUeXBlJGpzY29tcCQxID0gbnVsbCxcbiAgICAgICAgICAgIGZvcm1NZXRob2QkanNjb21wJDEgPSBudWxsLFxuICAgICAgICAgICAgZm9ybVRhcmdldCRqc2NvbXAkMSA9IG51bGwsXG4gICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQ1O1xuICAgICAgICAgIGZvciAocHJvcEtleSRqc2NvbXAkNSBpbiBwcm9wcylcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5JGpzY29tcCQ1KSkge1xuICAgICAgICAgICAgICB2YXIgcHJvcFZhbHVlJGpzY29tcCQ1ID0gcHJvcHNbcHJvcEtleSRqc2NvbXAkNV07XG4gICAgICAgICAgICAgIGlmIChudWxsICE9IHByb3BWYWx1ZSRqc2NvbXAkNSlcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHByb3BLZXkkanNjb21wJDUpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbiRqc2NvbXAkNCA9IHByb3BWYWx1ZSRqc2NvbXAkNTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJIVE1MJGpzY29tcCQzID0gcHJvcFZhbHVlJGpzY29tcCQ1O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJhY3Rpb25cIjpcbiAgICAgICAgICAgICAgICAgICAgZm9ybUFjdGlvbiRqc2NvbXAkMSA9IHByb3BWYWx1ZSRqc2NvbXAkNTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZW5jVHlwZVwiOlxuICAgICAgICAgICAgICAgICAgICBmb3JtRW5jVHlwZSRqc2NvbXAkMSA9IHByb3BWYWx1ZSRqc2NvbXAkNTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwibWV0aG9kXCI6XG4gICAgICAgICAgICAgICAgICAgIGZvcm1NZXRob2QkanNjb21wJDEgPSBwcm9wVmFsdWUkanNjb21wJDU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcInRhcmdldFwiOlxuICAgICAgICAgICAgICAgICAgICBmb3JtVGFyZ2V0JGpzY29tcCQxID0gcHJvcFZhbHVlJGpzY29tcCQ1O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHB1c2hBdHRyaWJ1dGUoXG4gICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BLZXkkanNjb21wJDUsXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcFZhbHVlJGpzY29tcCQ1XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIHZhciBmb3JtRGF0YSRqc2NvbXAkMSA9IG51bGwsXG4gICAgICAgICAgICBmb3JtQWN0aW9uTmFtZSA9IG51bGw7XG4gICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGZvcm1BY3Rpb24kanNjb21wJDEpIHtcbiAgICAgICAgICAgIChudWxsID09PSBmb3JtRW5jVHlwZSRqc2NvbXAkMSAmJiBudWxsID09PSBmb3JtTWV0aG9kJGpzY29tcCQxKSB8fFxuICAgICAgICAgICAgICBkaWRXYXJuRm9ybUFjdGlvbk1ldGhvZCB8fFxuICAgICAgICAgICAgICAoKGRpZFdhcm5Gb3JtQWN0aW9uTWV0aG9kID0gITApLFxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiQ2Fubm90IHNwZWNpZnkgYSBlbmNUeXBlIG9yIG1ldGhvZCBmb3IgYSBmb3JtIHRoYXQgc3BlY2lmaWVzIGEgZnVuY3Rpb24gYXMgdGhlIGFjdGlvbi4gUmVhY3QgcHJvdmlkZXMgdGhvc2UgYXV0b21hdGljYWxseS4gVGhleSB3aWxsIGdldCBvdmVycmlkZGVuLlwiXG4gICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgbnVsbCA9PT0gZm9ybVRhcmdldCRqc2NvbXAkMSB8fFxuICAgICAgICAgICAgICBkaWRXYXJuRm9ybUFjdGlvblRhcmdldCB8fFxuICAgICAgICAgICAgICAoKGRpZFdhcm5Gb3JtQWN0aW9uVGFyZ2V0ID0gITApLFxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiQ2Fubm90IHNwZWNpZnkgYSB0YXJnZXQgZm9yIGEgZm9ybSB0aGF0IHNwZWNpZmllcyBhIGZ1bmN0aW9uIGFzIHRoZSBhY3Rpb24uIFRoZSBmdW5jdGlvbiB3aWxsIGFsd2F5cyBiZSBleGVjdXRlZCBpbiB0aGUgc2FtZSB3aW5kb3cuXCJcbiAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICB2YXIgY3VzdG9tRmllbGRzID0gZ2V0Q3VzdG9tRm9ybUZpZWxkcyhcbiAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUsXG4gICAgICAgICAgICAgIGZvcm1BY3Rpb24kanNjb21wJDFcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBudWxsICE9PSBjdXN0b21GaWVsZHNcbiAgICAgICAgICAgICAgPyAoKGZvcm1BY3Rpb24kanNjb21wJDEgPSBjdXN0b21GaWVsZHMuYWN0aW9uIHx8IFwiXCIpLFxuICAgICAgICAgICAgICAgIChmb3JtRW5jVHlwZSRqc2NvbXAkMSA9IGN1c3RvbUZpZWxkcy5lbmNUeXBlKSxcbiAgICAgICAgICAgICAgICAoZm9ybU1ldGhvZCRqc2NvbXAkMSA9IGN1c3RvbUZpZWxkcy5tZXRob2QpLFxuICAgICAgICAgICAgICAgIChmb3JtVGFyZ2V0JGpzY29tcCQxID0gY3VzdG9tRmllbGRzLnRhcmdldCksXG4gICAgICAgICAgICAgICAgKGZvcm1EYXRhJGpzY29tcCQxID0gY3VzdG9tRmllbGRzLmRhdGEpLFxuICAgICAgICAgICAgICAgIChmb3JtQWN0aW9uTmFtZSA9IGN1c3RvbUZpZWxkcy5uYW1lKSlcbiAgICAgICAgICAgICAgOiAodGFyZ2V0JGpzY29tcCQwLnB1c2goXG4gICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVTZXBhcmF0b3IsXG4gICAgICAgICAgICAgICAgICBzdHJpbmdUb0NodW5rKFwiYWN0aW9uXCIpLFxuICAgICAgICAgICAgICAgICAgYXR0cmlidXRlQXNzaWduLFxuICAgICAgICAgICAgICAgICAgYWN0aW9uSmF2YVNjcmlwdFVSTCxcbiAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUVuZFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgKGZvcm1UYXJnZXQkanNjb21wJDEgPVxuICAgICAgICAgICAgICAgICAgZm9ybU1ldGhvZCRqc2NvbXAkMSA9XG4gICAgICAgICAgICAgICAgICBmb3JtRW5jVHlwZSRqc2NvbXAkMSA9XG4gICAgICAgICAgICAgICAgICBmb3JtQWN0aW9uJGpzY29tcCQxID1cbiAgICAgICAgICAgICAgICAgICAgbnVsbCksXG4gICAgICAgICAgICAgICAgaW5qZWN0Rm9ybVJlcGxheWluZ1J1bnRpbWUocmVzdW1hYmxlU3RhdGUsIHJlbmRlclN0YXRlKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG51bGwgIT0gZm9ybUFjdGlvbiRqc2NvbXAkMSAmJlxuICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQkanNjb21wJDAsIFwiYWN0aW9uXCIsIGZvcm1BY3Rpb24kanNjb21wJDEpO1xuICAgICAgICAgIG51bGwgIT0gZm9ybUVuY1R5cGUkanNjb21wJDEgJiZcbiAgICAgICAgICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0JGpzY29tcCQwLCBcImVuY1R5cGVcIiwgZm9ybUVuY1R5cGUkanNjb21wJDEpO1xuICAgICAgICAgIG51bGwgIT0gZm9ybU1ldGhvZCRqc2NvbXAkMSAmJlxuICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQkanNjb21wJDAsIFwibWV0aG9kXCIsIGZvcm1NZXRob2QkanNjb21wJDEpO1xuICAgICAgICAgIG51bGwgIT0gZm9ybVRhcmdldCRqc2NvbXAkMSAmJlxuICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQkanNjb21wJDAsIFwidGFyZ2V0XCIsIGZvcm1UYXJnZXQkanNjb21wJDEpO1xuICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKGVuZE9mU3RhcnRUYWcpO1xuICAgICAgICAgIG51bGwgIT09IGZvcm1BY3Rpb25OYW1lICYmXG4gICAgICAgICAgICAodGFyZ2V0JGpzY29tcCQwLnB1c2goc3RhcnRIaWRkZW5JbnB1dENodW5rKSxcbiAgICAgICAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0JGpzY29tcCQwLCBcIm5hbWVcIiwgZm9ybUFjdGlvbk5hbWUpLFxuICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goZW5kT2ZTdGFydFRhZ1NlbGZDbG9zaW5nKSxcbiAgICAgICAgICAgIG51bGwgIT0gZm9ybURhdGEkanNjb21wJDEgJiZcbiAgICAgICAgICAgICAgZm9ybURhdGEkanNjb21wJDEuZm9yRWFjaChcbiAgICAgICAgICAgICAgICBwdXNoQWRkaXRpb25hbEZvcm1GaWVsZCxcbiAgICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDBcbiAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgcHVzaElubmVySFRNTCh0YXJnZXQkanNjb21wJDAsIGlubmVySFRNTCRqc2NvbXAkMywgY2hpbGRyZW4kanNjb21wJDQpO1xuICAgICAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgY2hpbGRyZW4kanNjb21wJDQpIHtcbiAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKFxuICAgICAgICAgICAgICBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKGNoaWxkcmVuJGpzY29tcCQ0KSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQyID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2UgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQyID0gY2hpbGRyZW4kanNjb21wJDQ7XG4gICAgICAgICAgcmV0dXJuIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMjtcbiAgICAgICAgY2FzZSBcIm1lbnVpdGVtXCI6XG4gICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goc3RhcnRDaHVua0ZvclRhZyhcIm1lbnVpdGVtXCIpKTtcbiAgICAgICAgICBmb3IgKHZhciBwcm9wS2V5JGpzY29tcCQ2IGluIHByb3BzKVxuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkkanNjb21wJDYpKSB7XG4gICAgICAgICAgICAgIHZhciBwcm9wVmFsdWUkanNjb21wJDYgPSBwcm9wc1twcm9wS2V5JGpzY29tcCQ2XTtcbiAgICAgICAgICAgICAgaWYgKG51bGwgIT0gcHJvcFZhbHVlJGpzY29tcCQ2KVxuICAgICAgICAgICAgICAgIHN3aXRjaCAocHJvcEtleSRqc2NvbXAkNikge1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgXCJtZW51aXRlbXMgY2Fubm90IGhhdmUgYGNoaWxkcmVuYCBub3IgYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC5cIlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZShcbiAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcEtleSRqc2NvbXAkNixcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wVmFsdWUkanNjb21wJDZcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChzdGFydENodW5rRm9yVGFnKFwib2JqZWN0XCIpKTtcbiAgICAgICAgICB2YXIgY2hpbGRyZW4kanNjb21wJDUgPSBudWxsLFxuICAgICAgICAgICAgaW5uZXJIVE1MJGpzY29tcCQ0ID0gbnVsbCxcbiAgICAgICAgICAgIHByb3BLZXkkanNjb21wJDc7XG4gICAgICAgICAgZm9yIChwcm9wS2V5JGpzY29tcCQ3IGluIHByb3BzKVxuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkkanNjb21wJDcpKSB7XG4gICAgICAgICAgICAgIHZhciBwcm9wVmFsdWUkanNjb21wJDcgPSBwcm9wc1twcm9wS2V5JGpzY29tcCQ3XTtcbiAgICAgICAgICAgICAgaWYgKG51bGwgIT0gcHJvcFZhbHVlJGpzY29tcCQ3KVxuICAgICAgICAgICAgICAgIHN3aXRjaCAocHJvcEtleSRqc2NvbXAkNykge1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuJGpzY29tcCQ1ID0gcHJvcFZhbHVlJGpzY29tcCQ3O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICAgICAgICAgICAgICBpbm5lckhUTUwkanNjb21wJDQgPSBwcm9wVmFsdWUkanNjb21wJDc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImRhdGFcIjpcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbihwcm9wVmFsdWUkanNjb21wJDcsIFwiZGF0YVwiKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNhbml0aXplZFZhbHVlID0gc2FuaXRpemVVUkwoXCJcIiArIHByb3BWYWx1ZSRqc2NvbXAkNyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcIlwiID09PSBzYW5pdGl6ZWRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAnQW4gZW1wdHkgc3RyaW5nIChcIlwiKSB3YXMgcGFzc2VkIHRvIHRoZSAlcyBhdHRyaWJ1dGUuIFRvIGZpeCB0aGlzLCBlaXRoZXIgZG8gbm90IHJlbmRlciB0aGUgZWxlbWVudCBhdCBhbGwgb3IgcGFzcyBudWxsIHRvICVzIGluc3RlYWQgb2YgYW4gZW1wdHkgc3RyaW5nLicsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQ3LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcEtleSRqc2NvbXAkN1xuICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlU2VwYXJhdG9yLFxuICAgICAgICAgICAgICAgICAgICAgIHN0cmluZ1RvQ2h1bmsoXCJkYXRhXCIpLFxuICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUFzc2lnbixcbiAgICAgICAgICAgICAgICAgICAgICBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKHNhbml0aXplZFZhbHVlKSksXG4gICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlRW5kXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZShcbiAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcEtleSRqc2NvbXAkNyxcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wVmFsdWUkanNjb21wJDdcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gICAgICAgICAgcHVzaElubmVySFRNTCh0YXJnZXQkanNjb21wJDAsIGlubmVySFRNTCRqc2NvbXAkNCwgY2hpbGRyZW4kanNjb21wJDUpO1xuICAgICAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgY2hpbGRyZW4kanNjb21wJDUpIHtcbiAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKFxuICAgICAgICAgICAgICBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKGNoaWxkcmVuJGpzY29tcCQ1KSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQzID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2UgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQzID0gY2hpbGRyZW4kanNjb21wJDU7XG4gICAgICAgICAgcmV0dXJuIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMztcbiAgICAgICAgY2FzZSBcInRpdGxlXCI6XG4gICAgICAgICAgdmFyIG5vc2NyaXB0VGFnSW5TY29wZSA9IGZvcm1hdENvbnRleHQudGFnU2NvcGUgJiAxLFxuICAgICAgICAgICAgaXNGYWxsYmFjayA9IGZvcm1hdENvbnRleHQudGFnU2NvcGUgJiA0O1xuICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBcImNoaWxkcmVuXCIpKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4kanNjb21wJDYgPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgICAgICAgICAgY2hpbGQgPSBBcnJheS5pc0FycmF5KGNoaWxkcmVuJGpzY29tcCQ2KVxuICAgICAgICAgICAgICAgID8gMiA+IGNoaWxkcmVuJGpzY29tcCQ2Lmxlbmd0aFxuICAgICAgICAgICAgICAgICAgPyBjaGlsZHJlbiRqc2NvbXAkNlswXVxuICAgICAgICAgICAgICAgICAgOiBudWxsXG4gICAgICAgICAgICAgICAgOiBjaGlsZHJlbiRqc2NvbXAkNjtcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkoY2hpbGRyZW4kanNjb21wJDYpICYmIDEgPCBjaGlsZHJlbiRqc2NvbXAkNi5sZW5ndGhcbiAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJSZWFjdCBleHBlY3RzIHRoZSBgY2hpbGRyZW5gIHByb3Agb2YgPHRpdGxlPiB0YWdzIHRvIGJlIGEgc3RyaW5nLCBudW1iZXIsIGJpZ2ludCwgb3Igb2JqZWN0IHdpdGggYSBub3ZlbCBgdG9TdHJpbmdgIG1ldGhvZCBidXQgZm91bmQgYW4gQXJyYXkgd2l0aCBsZW5ndGggJXMgaW5zdGVhZC4gQnJvd3NlcnMgdHJlYXQgYWxsIGNoaWxkIE5vZGVzIG9mIDx0aXRsZT4gdGFncyBhcyBUZXh0IGNvbnRlbnQgYW5kIFJlYWN0IGV4cGVjdHMgdG8gYmUgYWJsZSB0byBjb252ZXJ0IGBjaGlsZHJlbmAgb2YgPHRpdGxlPiB0YWdzIHRvIGEgc2luZ2xlIHN0cmluZyB2YWx1ZSB3aGljaCBpcyB3aHkgQXJyYXlzIG9mIGxlbmd0aCBncmVhdGVyIHRoYW4gMSBhcmUgbm90IHN1cHBvcnRlZC4gV2hlbiB1c2luZyBKU1ggaXQgY2FuIGJlIGNvbW1vbiB0byBjb21iaW5lIHRleHQgbm9kZXMgYW5kIHZhbHVlIG5vZGVzLiBGb3IgZXhhbXBsZTogPHRpdGxlPmhlbGxvIHtuYW1lT2ZVc2VyfTwvdGl0bGU+LiBXaGlsZSBub3QgaW1tZWRpYXRlbHkgYXBwYXJlbnQsIGBjaGlsZHJlbmAgaW4gdGhpcyBjYXNlIGlzIGFuIEFycmF5IHdpdGggbGVuZ3RoIDIuIElmIHlvdXIgYGNoaWxkcmVuYCBwcm9wIGlzIHVzaW5nIHRoaXMgZm9ybSB0cnkgcmV3cml0aW5nIGl0IHVzaW5nIGEgdGVtcGxhdGUgc3RyaW5nOiA8dGl0bGU+e2BoZWxsbyAke25hbWVPZlVzZXJ9YH08L3RpdGxlPi5cIixcbiAgICAgICAgICAgICAgICAgIGNoaWxkcmVuJGpzY29tcCQ2Lmxlbmd0aFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgOiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBjaGlsZCB8fCBcInN5bWJvbFwiID09PSB0eXBlb2YgY2hpbGRcbiAgICAgICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiUmVhY3QgZXhwZWN0IGNoaWxkcmVuIG9mIDx0aXRsZT4gdGFncyB0byBiZSBhIHN0cmluZywgbnVtYmVyLCBiaWdpbnQsIG9yIG9iamVjdCB3aXRoIGEgbm92ZWwgYHRvU3RyaW5nYCBtZXRob2QgYnV0IGZvdW5kICVzIGluc3RlYWQuIEJyb3dzZXJzIHRyZWF0IGFsbCBjaGlsZCBOb2RlcyBvZiA8dGl0bGU+IHRhZ3MgYXMgVGV4dCBjb250ZW50IGFuZCBSZWFjdCBleHBlY3RzIHRvIGJlIGFibGUgdG8gY29udmVydCBjaGlsZHJlbiBvZiA8dGl0bGU+IHRhZ3MgdG8gYSBzaW5nbGUgc3RyaW5nIHZhbHVlLlwiLFxuICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBjaGlsZCA/IFwiYSBGdW5jdGlvblwiIDogXCJhIFN5Ym1vbFwiXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgOiBjaGlsZCAmJlxuICAgICAgICAgICAgICAgICAgY2hpbGQudG9TdHJpbmcgPT09IHt9LnRvU3RyaW5nICYmXG4gICAgICAgICAgICAgICAgICAobnVsbCAhPSBjaGlsZC4kJHR5cGVvZlxuICAgICAgICAgICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlJlYWN0IGV4cGVjdHMgdGhlIGBjaGlsZHJlbmAgcHJvcCBvZiA8dGl0bGU+IHRhZ3MgdG8gYmUgYSBzdHJpbmcsIG51bWJlciwgYmlnaW50LCBvciBvYmplY3Qgd2l0aCBhIG5vdmVsIGB0b1N0cmluZ2AgbWV0aG9kIGJ1dCBmb3VuZCBhbiBvYmplY3QgdGhhdCBhcHBlYXJzIHRvIGJlIGEgUmVhY3QgZWxlbWVudCB3aGljaCBuZXZlciBpbXBsZW1lbnRzIGEgc3VpdGFibGUgYHRvU3RyaW5nYCBtZXRob2QuIEJyb3dzZXJzIHRyZWF0IGFsbCBjaGlsZCBOb2RlcyBvZiA8dGl0bGU+IHRhZ3MgYXMgVGV4dCBjb250ZW50IGFuZCBSZWFjdCBleHBlY3RzIHRvIGJlIGFibGUgdG8gY29udmVydCBjaGlsZHJlbiBvZiA8dGl0bGU+IHRhZ3MgdG8gYSBzaW5nbGUgc3RyaW5nIHZhbHVlIHdoaWNoIGlzIHdoeSByZW5kZXJpbmcgUmVhY3QgZWxlbWVudHMgaXMgbm90IHN1cHBvcnRlZC4gSWYgdGhlIGBjaGlsZHJlbmAgb2YgPHRpdGxlPiBpcyBhIFJlYWN0IENvbXBvbmVudCB0cnkgbW92aW5nIHRoZSA8dGl0bGU+IHRhZyBpbnRvIHRoYXQgY29tcG9uZW50LiBJZiB0aGUgYGNoaWxkcmVuYCBvZiA8dGl0bGU+IGlzIHNvbWUgSFRNTCBtYXJrdXAgY2hhbmdlIGl0IHRvIGJlIFRleHQgb25seSB0byBiZSB2YWxpZCBIVE1MLlwiXG4gICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICA6IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlJlYWN0IGV4cGVjdHMgdGhlIGBjaGlsZHJlbmAgcHJvcCBvZiA8dGl0bGU+IHRhZ3MgdG8gYmUgYSBzdHJpbmcsIG51bWJlciwgYmlnaW50LCBvciBvYmplY3Qgd2l0aCBhIG5vdmVsIGB0b1N0cmluZ2AgbWV0aG9kIGJ1dCBmb3VuZCBhbiBvYmplY3QgdGhhdCBkb2VzIG5vdCBpbXBsZW1lbnQgYSBzdWl0YWJsZSBgdG9TdHJpbmdgIG1ldGhvZC4gQnJvd3NlcnMgdHJlYXQgYWxsIGNoaWxkIE5vZGVzIG9mIDx0aXRsZT4gdGFncyBhcyBUZXh0IGNvbnRlbnQgYW5kIFJlYWN0IGV4cGVjdHMgdG8gYmUgYWJsZSB0byBjb252ZXJ0IGNoaWxkcmVuIG9mIDx0aXRsZT4gdGFncyB0byBhIHNpbmdsZSBzdHJpbmcgdmFsdWUuIFVzaW5nIHRoZSBkZWZhdWx0IGB0b1N0cmluZ2AgbWV0aG9kIGF2YWlsYWJsZSBvbiBldmVyeSBvYmplY3QgaXMgYWxtb3N0IGNlcnRhaW5seSBhbiBlcnJvci4gQ29uc2lkZXIgd2hldGhlciB0aGUgYGNoaWxkcmVuYCBvZiB0aGlzIDx0aXRsZT4gaXMgYW4gb2JqZWN0IGluIGVycm9yIGFuZCBjaGFuZ2UgaXQgdG8gYSBzdHJpbmcgb3IgbnVtYmVyIHZhbHVlIGlmIHNvLiBPdGhlcndpc2UgaW1wbGVtZW50IGEgYHRvU3RyaW5nYCBtZXRob2QgdGhhdCBSZWFjdCBjYW4gdXNlIHRvIHByb2R1Y2UgYSB2YWxpZCA8dGl0bGU+LlwiXG4gICAgICAgICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSA9PT0gU1ZHX01PREUgfHxcbiAgICAgICAgICAgIG5vc2NyaXB0VGFnSW5TY29wZSB8fFxuICAgICAgICAgICAgbnVsbCAhPSBwcm9wcy5pdGVtUHJvcFxuICAgICAgICAgIClcbiAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDQgPSBwdXNoVGl0bGVJbXBsKFxuICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAsXG4gICAgICAgICAgICAgIHByb3BzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGlzRmFsbGJhY2tcbiAgICAgICAgICAgICAgPyAoSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQ0ID0gbnVsbClcbiAgICAgICAgICAgICAgOiAocHVzaFRpdGxlSW1wbChyZW5kZXJTdGF0ZS5ob2lzdGFibGVDaHVua3MsIHByb3BzKSxcbiAgICAgICAgICAgICAgICAoSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQ0ID0gdm9pZCAwKSk7XG4gICAgICAgICAgcmV0dXJuIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkNDtcbiAgICAgICAgY2FzZSBcImxpbmtcIjpcbiAgICAgICAgICB2YXIgbm9zY3JpcHRUYWdJblNjb3BlJGpzY29tcCQwID0gZm9ybWF0Q29udGV4dC50YWdTY29wZSAmIDEsXG4gICAgICAgICAgICBpc0ZhbGxiYWNrJGpzY29tcCQwID0gZm9ybWF0Q29udGV4dC50YWdTY29wZSAmIDQsXG4gICAgICAgICAgICByZWwgPSBwcm9wcy5yZWwsXG4gICAgICAgICAgICBocmVmID0gcHJvcHMuaHJlZixcbiAgICAgICAgICAgIHByZWNlZGVuY2UgPSBwcm9wcy5wcmVjZWRlbmNlO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSA9PT0gU1ZHX01PREUgfHxcbiAgICAgICAgICAgIG5vc2NyaXB0VGFnSW5TY29wZSRqc2NvbXAkMCB8fFxuICAgICAgICAgICAgbnVsbCAhPSBwcm9wcy5pdGVtUHJvcCB8fFxuICAgICAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIHJlbCB8fFxuICAgICAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIGhyZWYgfHxcbiAgICAgICAgICAgIFwiXCIgPT09IGhyZWZcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIFwic3R5bGVzaGVldFwiID09PSByZWwgJiZcbiAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHByb3BzLnByZWNlZGVuY2UgJiZcbiAgICAgICAgICAgICAgKChcInN0cmluZ1wiID09PSB0eXBlb2YgaHJlZiAmJiBocmVmKSB8fFxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAnUmVhY3QgZW5jb3VudGVyZWQgYSBgPGxpbmsgcmVsPVwic3R5bGVzaGVldFwiIC4uLi8+YCB3aXRoIGEgYHByZWNlZGVuY2VgIHByb3AgYW5kIGV4cGVjdGVkIHRoZSBgaHJlZmAgcHJvcCB0byBiZSBhIG5vbi1lbXB0eSBzdHJpbmcgYnV0IGVjb3VudGVyZWQgJXMgaW5zdGVhZC4gSWYgeW91ciBpbnRlbnQgd2FzIHRvIGhhdmUgUmVhY3QgaG9pc3QgYW5kIGRlZHVwbGNpYXRlIHRoaXMgc3R5bGVzaGVldCB1c2luZyB0aGUgYHByZWNlZGVuY2VgIHByb3AgZW5zdXJlIHRoZXJlIGlzIGEgbm9uLWVtcHR5IHN0cmluZyBgaHJlZmAgcHJvcCBhcyB3ZWxsLCBvdGhlcndpc2UgcmVtb3ZlIHRoZSBgcHJlY2VkZW5jZWAgcHJvcC4nLFxuICAgICAgICAgICAgICAgICAgbnVsbCA9PT0gaHJlZlxuICAgICAgICAgICAgICAgICAgICA/IFwiYG51bGxgXCJcbiAgICAgICAgICAgICAgICAgICAgOiB2b2lkIDAgPT09IGhyZWZcbiAgICAgICAgICAgICAgICAgICAgICA/IFwiYHVuZGVmaW5lZGBcIlxuICAgICAgICAgICAgICAgICAgICAgIDogXCJcIiA9PT0gaHJlZlxuICAgICAgICAgICAgICAgICAgICAgICAgPyBcImFuIGVtcHR5IHN0cmluZ1wiXG4gICAgICAgICAgICAgICAgICAgICAgICA6ICdzb21ldGhpbmcgd2l0aCB0eXBlIFwiJyArIHR5cGVvZiBocmVmICsgJ1wiJ1xuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgcHVzaExpbmtJbXBsKHRhcmdldCRqc2NvbXAkMCwgcHJvcHMpO1xuICAgICAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkNSA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIGlmIChcInN0eWxlc2hlZXRcIiA9PT0gcHJvcHMucmVsKVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBcInN0cmluZ1wiICE9PSB0eXBlb2YgcHJlY2VkZW5jZSB8fFxuICAgICAgICAgICAgICBudWxsICE9IHByb3BzLmRpc2FibGVkIHx8XG4gICAgICAgICAgICAgIHByb3BzLm9uTG9hZCB8fFxuICAgICAgICAgICAgICBwcm9wcy5vbkVycm9yXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBwcmVjZWRlbmNlKVxuICAgICAgICAgICAgICAgIGlmIChudWxsICE9IHByb3BzLmRpc2FibGVkKVxuICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgJ1JlYWN0IGVuY291bnRlcmVkIGEgYDxsaW5rIHJlbD1cInN0eWxlc2hlZXRcIiAuLi4vPmAgd2l0aCBhIGBwcmVjZWRlbmNlYCBwcm9wIGFuZCBhIGBkaXNhYmxlZGAgcHJvcC4gVGhlIHByZXNlbmNlIG9mIHRoZSBgZGlzYWJsZWRgIHByb3AgaW5kaWNhdGVzIGFuIGludGVudCB0byBtYW5hZ2UgdGhlIHN0eWxlc2hlZXQgYWN0aXZlIHN0YXRlIGZyb20geW91ciBmcm9tIHlvdXIgQ29tcG9uZW50IGNvZGUgYW5kIFJlYWN0IHdpbGwgbm90IGhvaXN0IG9yIGRlZHVwbGljYXRlIHRoaXMgc3R5bGVzaGVldC4gSWYgeW91ciBpbnRlbnQgd2FzIHRvIGhhdmUgUmVhY3QgaG9pc3QgYW5kIGRlZHVwbGNpYXRlIHRoaXMgc3R5bGVzaGVldCB1c2luZyB0aGUgYHByZWNlZGVuY2VgIHByb3AgcmVtb3ZlIHRoZSBgZGlzYWJsZWRgIHByb3AsIG90aGVyd2lzZSByZW1vdmUgdGhlIGBwcmVjZWRlbmNlYCBwcm9wLidcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocHJvcHMub25Mb2FkIHx8IHByb3BzLm9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBwcm9wRGVzY3JpcHRpb24gPVxuICAgICAgICAgICAgICAgICAgICBwcm9wcy5vbkxvYWQgJiYgcHJvcHMub25FcnJvclxuICAgICAgICAgICAgICAgICAgICAgID8gXCJgb25Mb2FkYCBhbmQgYG9uRXJyb3JgIHByb3BzXCJcbiAgICAgICAgICAgICAgICAgICAgICA6IHByb3BzLm9uTG9hZFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBcImBvbkxvYWRgIHByb3BcIlxuICAgICAgICAgICAgICAgICAgICAgICAgOiBcImBvbkVycm9yYCBwcm9wXCI7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAnUmVhY3QgZW5jb3VudGVyZWQgYSBgPGxpbmsgcmVsPVwic3R5bGVzaGVldFwiIC4uLi8+YCB3aXRoIGEgYHByZWNlZGVuY2VgIHByb3AgYW5kICVzLiBUaGUgcHJlc2VuY2Ugb2YgbG9hZGluZyBhbmQgZXJyb3IgaGFuZGxlcnMgaW5kaWNhdGVzIGFuIGludGVudCB0byBtYW5hZ2UgdGhlIHN0eWxlc2hlZXQgbG9hZGluZyBzdGF0ZSBmcm9tIHlvdXIgZnJvbSB5b3VyIENvbXBvbmVudCBjb2RlIGFuZCBSZWFjdCB3aWxsIG5vdCBob2lzdCBvciBkZWR1cGxpY2F0ZSB0aGlzIHN0eWxlc2hlZXQuIElmIHlvdXIgaW50ZW50IHdhcyB0byBoYXZlIFJlYWN0IGhvaXN0IGFuZCBkZWR1cGxjaWF0ZSB0aGlzIHN0eWxlc2hlZXQgdXNpbmcgdGhlIGBwcmVjZWRlbmNlYCBwcm9wIHJlbW92ZSB0aGUgJXMsIG90aGVyd2lzZSByZW1vdmUgdGhlIGBwcmVjZWRlbmNlYCBwcm9wLicsXG4gICAgICAgICAgICAgICAgICAgIHByb3BEZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgICAgcHJvcERlc2NyaXB0aW9uXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQ1ID0gcHVzaExpbmtJbXBsKFxuICAgICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICBwcm9wc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHN0eWxlUXVldWUgPSByZW5kZXJTdGF0ZS5zdHlsZXMuZ2V0KHByZWNlZGVuY2UpLFxuICAgICAgICAgICAgICAgIHJlc291cmNlU3RhdGUgPSByZXN1bWFibGVTdGF0ZS5zdHlsZVJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShcbiAgICAgICAgICAgICAgICAgIGhyZWZcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICA/IHJlc3VtYWJsZVN0YXRlLnN0eWxlUmVzb3VyY2VzW2hyZWZdXG4gICAgICAgICAgICAgICAgICA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgaWYgKHJlc291cmNlU3RhdGUgIT09IEVYSVNUUykge1xuICAgICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLnN0eWxlUmVzb3VyY2VzW2hyZWZdID0gRVhJU1RTO1xuICAgICAgICAgICAgICAgIHN0eWxlUXVldWUgfHxcbiAgICAgICAgICAgICAgICAgICgoc3R5bGVRdWV1ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihwcmVjZWRlbmNlKSksXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgaHJlZnM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBzaGVldHM6IG5ldyBNYXAoKVxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5zdHlsZXMuc2V0KHByZWNlZGVuY2UsIHN0eWxlUXVldWUpKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVzb3VyY2UgPSB7XG4gICAgICAgICAgICAgICAgICBzdGF0ZTogUEVORElORyQxLFxuICAgICAgICAgICAgICAgICAgcHJvcHM6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICAgICAgICAgICAgXCJkYXRhLXByZWNlZGVuY2VcIjogcHJvcHMucHJlY2VkZW5jZSxcbiAgICAgICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogbnVsbFxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChyZXNvdXJjZVN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAyID09PSByZXNvdXJjZVN0YXRlLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICBhZG9wdFByZWxvYWRDcmVkZW50aWFscyhyZXNvdXJjZS5wcm9wcywgcmVzb3VyY2VTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICB2YXIgcHJlbG9hZFJlc291cmNlID1cbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUucHJlbG9hZHMuc3R5bGVzaGVldHMuZ2V0KGhyZWYpO1xuICAgICAgICAgICAgICAgICAgcHJlbG9hZFJlc291cmNlICYmIDAgPCBwcmVsb2FkUmVzb3VyY2UubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgID8gKHByZWxvYWRSZXNvdXJjZS5sZW5ndGggPSAwKVxuICAgICAgICAgICAgICAgICAgICA6IChyZXNvdXJjZS5zdGF0ZSA9IFBSRUxPQURFRCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0eWxlUXVldWUuc2hlZXRzLnNldChocmVmLCByZXNvdXJjZSk7XG4gICAgICAgICAgICAgICAgaG9pc3RhYmxlU3RhdGUgJiYgaG9pc3RhYmxlU3RhdGUuc3R5bGVzaGVldHMuYWRkKHJlc291cmNlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdHlsZVF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9yZXNvdXJjZSA9IHN0eWxlUXVldWUuc2hlZXRzLmdldChocmVmKTtcbiAgICAgICAgICAgICAgICBfcmVzb3VyY2UgJiZcbiAgICAgICAgICAgICAgICAgIGhvaXN0YWJsZVN0YXRlICYmXG4gICAgICAgICAgICAgICAgICBob2lzdGFibGVTdGF0ZS5zdHlsZXNoZWV0cy5hZGQoX3Jlc291cmNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0ZXh0RW1iZWRkZWQgJiYgdGFyZ2V0JGpzY29tcCQwLnB1c2godGV4dFNlcGFyYXRvcik7XG4gICAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkNSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgcHJvcHMub25Mb2FkIHx8IHByb3BzLm9uRXJyb3JcbiAgICAgICAgICAgICAgPyAoSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQ1ID0gcHVzaExpbmtJbXBsKFxuICAgICAgICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgcHJvcHNcbiAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgICA6ICh0ZXh0RW1iZWRkZWQgJiYgdGFyZ2V0JGpzY29tcCQwLnB1c2godGV4dFNlcGFyYXRvciksXG4gICAgICAgICAgICAgICAgKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkNSA9IGlzRmFsbGJhY2skanNjb21wJDBcbiAgICAgICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICAgICAgOiBwdXNoTGlua0ltcGwocmVuZGVyU3RhdGUuaG9pc3RhYmxlQ2h1bmtzLCBwcm9wcykpKTtcbiAgICAgICAgICByZXR1cm4gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQ1O1xuICAgICAgICBjYXNlIFwic2NyaXB0XCI6XG4gICAgICAgICAgdmFyIG5vc2NyaXB0VGFnSW5TY29wZSRqc2NvbXAkMSA9IGZvcm1hdENvbnRleHQudGFnU2NvcGUgJiAxLFxuICAgICAgICAgICAgYXN5bmNQcm9wID0gcHJvcHMuYXN5bmM7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIHByb3BzLnNyYyB8fFxuICAgICAgICAgICAgIXByb3BzLnNyYyB8fFxuICAgICAgICAgICAgIWFzeW5jUHJvcCB8fFxuICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgYXN5bmNQcm9wIHx8XG4gICAgICAgICAgICBcInN5bWJvbFwiID09PSB0eXBlb2YgYXN5bmNQcm9wIHx8XG4gICAgICAgICAgICBwcm9wcy5vbkxvYWQgfHxcbiAgICAgICAgICAgIHByb3BzLm9uRXJyb3IgfHxcbiAgICAgICAgICAgIGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSA9PT0gU1ZHX01PREUgfHxcbiAgICAgICAgICAgIG5vc2NyaXB0VGFnSW5TY29wZSRqc2NvbXAkMSB8fFxuICAgICAgICAgICAgbnVsbCAhPSBwcm9wcy5pdGVtUHJvcFxuICAgICAgICAgIClcbiAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDYgPSBwdXNoU2NyaXB0SW1wbChcbiAgICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLFxuICAgICAgICAgICAgICBwcm9wc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBwcm9wcy5zcmM7XG4gICAgICAgICAgICBpZiAoXCJtb2R1bGVcIiA9PT0gcHJvcHMudHlwZSkge1xuICAgICAgICAgICAgICB2YXIgcmVzb3VyY2VzID0gcmVzdW1hYmxlU3RhdGUubW9kdWxlU2NyaXB0UmVzb3VyY2VzO1xuICAgICAgICAgICAgICB2YXIgcHJlbG9hZHMgPSByZW5kZXJTdGF0ZS5wcmVsb2Fkcy5tb2R1bGVTY3JpcHRzO1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgIChyZXNvdXJjZXMgPSByZXN1bWFibGVTdGF0ZS5zY3JpcHRSZXNvdXJjZXMpLFxuICAgICAgICAgICAgICAgIChwcmVsb2FkcyA9IHJlbmRlclN0YXRlLnByZWxvYWRzLnNjcmlwdHMpO1xuICAgICAgICAgICAgdmFyIHJlc291cmNlU3RhdGUkanNjb21wJDAgPSByZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoa2V5KVxuICAgICAgICAgICAgICA/IHJlc291cmNlc1trZXldXG4gICAgICAgICAgICAgIDogdm9pZCAwO1xuICAgICAgICAgICAgaWYgKHJlc291cmNlU3RhdGUkanNjb21wJDAgIT09IEVYSVNUUykge1xuICAgICAgICAgICAgICByZXNvdXJjZXNba2V5XSA9IEVYSVNUUztcbiAgICAgICAgICAgICAgdmFyIHNjcmlwdFByb3BzID0gcHJvcHM7XG4gICAgICAgICAgICAgIGlmIChyZXNvdXJjZVN0YXRlJGpzY29tcCQwKSB7XG4gICAgICAgICAgICAgICAgMiA9PT0gcmVzb3VyY2VTdGF0ZSRqc2NvbXAkMC5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICgoc2NyaXB0UHJvcHMgPSBhc3NpZ24oe30sIHByb3BzKSksXG4gICAgICAgICAgICAgICAgICBhZG9wdFByZWxvYWRDcmVkZW50aWFscyhzY3JpcHRQcm9wcywgcmVzb3VyY2VTdGF0ZSRqc2NvbXAkMCkpO1xuICAgICAgICAgICAgICAgIHZhciBwcmVsb2FkUmVzb3VyY2UkanNjb21wJDAgPSBwcmVsb2Fkcy5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICBwcmVsb2FkUmVzb3VyY2UkanNjb21wJDAgJiZcbiAgICAgICAgICAgICAgICAgIChwcmVsb2FkUmVzb3VyY2UkanNjb21wJDAubGVuZ3RoID0gMCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIHJlc291cmNlJGpzY29tcCQwID0gW107XG4gICAgICAgICAgICAgIHJlbmRlclN0YXRlLnNjcmlwdHMuYWRkKHJlc291cmNlJGpzY29tcCQwKTtcbiAgICAgICAgICAgICAgcHVzaFNjcmlwdEltcGwocmVzb3VyY2UkanNjb21wJDAsIHNjcmlwdFByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRleHRFbWJlZGRlZCAmJiB0YXJnZXQkanNjb21wJDAucHVzaCh0ZXh0U2VwYXJhdG9yKTtcbiAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkNiA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDY7XG4gICAgICAgIGNhc2UgXCJzdHlsZVwiOlxuICAgICAgICAgIHZhciBub3NjcmlwdFRhZ0luU2NvcGUkanNjb21wJDIgPSBmb3JtYXRDb250ZXh0LnRhZ1Njb3BlICYgMTtcbiAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgXCJjaGlsZHJlblwiKSkge1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuJGpzY29tcCQ3ID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgICAgICAgICAgIGNoaWxkJGpzY29tcCQwID0gQXJyYXkuaXNBcnJheShjaGlsZHJlbiRqc2NvbXAkNylcbiAgICAgICAgICAgICAgICA/IDIgPiBjaGlsZHJlbiRqc2NvbXAkNy5sZW5ndGhcbiAgICAgICAgICAgICAgICAgID8gY2hpbGRyZW4kanNjb21wJDdbMF1cbiAgICAgICAgICAgICAgICAgIDogbnVsbFxuICAgICAgICAgICAgICAgIDogY2hpbGRyZW4kanNjb21wJDc7XG4gICAgICAgICAgICAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY2hpbGQkanNjb21wJDAgfHxcbiAgICAgICAgICAgICAgXCJzeW1ib2xcIiA9PT0gdHlwZW9mIGNoaWxkJGpzY29tcCQwIHx8XG4gICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkoY2hpbGQkanNjb21wJDApKSAmJlxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiUmVhY3QgZXhwZWN0IGNoaWxkcmVuIG9mIDxzdHlsZT4gdGFncyB0byBiZSBhIHN0cmluZywgbnVtYmVyLCBvciBvYmplY3Qgd2l0aCBhIGB0b1N0cmluZ2AgbWV0aG9kIGJ1dCBmb3VuZCAlcyBpbnN0ZWFkLiBJbiBicm93c2VycyBzdHlsZSBFbGVtZW50cyBjYW4gb25seSBoYXZlIGBUZXh0YCBOb2RlcyBhcyBjaGlsZHJlbi5cIixcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBjaGlsZCRqc2NvbXAkMFxuICAgICAgICAgICAgICAgICAgPyBcImEgRnVuY3Rpb25cIlxuICAgICAgICAgICAgICAgICAgOiBcInN5bWJvbFwiID09PSB0eXBlb2YgY2hpbGQkanNjb21wJDBcbiAgICAgICAgICAgICAgICAgICAgPyBcImEgU3libW9sXCJcbiAgICAgICAgICAgICAgICAgICAgOiBcImFuIEFycmF5XCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHByZWNlZGVuY2UkanNjb21wJDAgPSBwcm9wcy5wcmVjZWRlbmNlLFxuICAgICAgICAgICAgaHJlZiRqc2NvbXAkMCA9IHByb3BzLmhyZWYsXG4gICAgICAgICAgICBub25jZSA9IHByb3BzLm5vbmNlO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSA9PT0gU1ZHX01PREUgfHxcbiAgICAgICAgICAgIG5vc2NyaXB0VGFnSW5TY29wZSRqc2NvbXAkMiB8fFxuICAgICAgICAgICAgbnVsbCAhPSBwcm9wcy5pdGVtUHJvcCB8fFxuICAgICAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIHByZWNlZGVuY2UkanNjb21wJDAgfHxcbiAgICAgICAgICAgIFwic3RyaW5nXCIgIT09IHR5cGVvZiBocmVmJGpzY29tcCQwIHx8XG4gICAgICAgICAgICBcIlwiID09PSBocmVmJGpzY29tcCQwXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChzdGFydENodW5rRm9yVGFnKFwic3R5bGVcIikpO1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuJGpzY29tcCQ4ID0gbnVsbCxcbiAgICAgICAgICAgICAgaW5uZXJIVE1MJGpzY29tcCQ1ID0gbnVsbCxcbiAgICAgICAgICAgICAgcHJvcEtleSRqc2NvbXAkODtcbiAgICAgICAgICAgIGZvciAocHJvcEtleSRqc2NvbXAkOCBpbiBwcm9wcylcbiAgICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkkanNjb21wJDgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb3BWYWx1ZSRqc2NvbXAkOCA9IHByb3BzW3Byb3BLZXkkanNjb21wJDhdO1xuICAgICAgICAgICAgICAgIGlmIChudWxsICE9IHByb3BWYWx1ZSRqc2NvbXAkOClcbiAgICAgICAgICAgICAgICAgIHN3aXRjaCAocHJvcEtleSRqc2NvbXAkOCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbiRqc2NvbXAkOCA9IHByb3BWYWx1ZSRqc2NvbXAkODtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgICAgICAgICAgICAgaW5uZXJIVE1MJGpzY29tcCQ1ID0gcHJvcFZhbHVlJGpzY29tcCQ4O1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgIHB1c2hBdHRyaWJ1dGUoXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQ4LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcFZhbHVlJGpzY29tcCQ4XG4gICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gICAgICAgICAgICB2YXIgY2hpbGQkanNjb21wJDEgPSBBcnJheS5pc0FycmF5KGNoaWxkcmVuJGpzY29tcCQ4KVxuICAgICAgICAgICAgICA/IDIgPiBjaGlsZHJlbiRqc2NvbXAkOC5sZW5ndGhcbiAgICAgICAgICAgICAgICA/IGNoaWxkcmVuJGpzY29tcCQ4WzBdXG4gICAgICAgICAgICAgICAgOiBudWxsXG4gICAgICAgICAgICAgIDogY2hpbGRyZW4kanNjb21wJDg7XG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBjaGlsZCRqc2NvbXAkMSAmJlxuICAgICAgICAgICAgICBcInN5bWJvbFwiICE9PSB0eXBlb2YgY2hpbGQkanNjb21wJDEgJiZcbiAgICAgICAgICAgICAgbnVsbCAhPT0gY2hpbGQkanNjb21wJDEgJiZcbiAgICAgICAgICAgICAgdm9pZCAwICE9PSBjaGlsZCRqc2NvbXAkMSAmJlxuICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChcbiAgICAgICAgICAgICAgICBzdHJpbmdUb0NodW5rKGVzY2FwZVN0eWxlVGV4dENvbnRlbnQoY2hpbGQkanNjb21wJDEpKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgcHVzaElubmVySFRNTChcbiAgICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLFxuICAgICAgICAgICAgICBpbm5lckhUTUwkanNjb21wJDUsXG4gICAgICAgICAgICAgIGNoaWxkcmVuJGpzY29tcCQ4XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goZW5kQ2h1bmtGb3JUYWcoXCJzdHlsZVwiKSk7XG4gICAgICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQ3ID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaHJlZiRqc2NvbXAkMC5pbmNsdWRlcyhcIiBcIikgJiZcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAnUmVhY3QgZXhwZWN0ZWQgdGhlIGBocmVmYCBwcm9wIGZvciBhIDxzdHlsZT4gdGFnIG9wdGluZyBpbnRvIGhvaXN0aW5nIHNlbWFudGljcyB1c2luZyB0aGUgYHByZWNlZGVuY2VgIHByb3AgdG8gbm90IGhhdmUgYW55IHNwYWNlcyBidXQgZWNvdW50ZXJlZCBzcGFjZXMgaW5zdGVhZC4gdXNpbmcgc3BhY2VzIGluIHRoaXMgcHJvcCB3aWxsIGNhdXNlIGh5ZHJhdGlvbiBvZiB0aGlzIHN0eWxlIHRvIGZhaWwgb24gdGhlIGNsaWVudC4gVGhlIGhyZWYgZm9yIHRoZSA8c3R5bGU+IHdoZXJlIHRoaXMgb2N1cnJlZCBpcyBcIiVzXCIuJyxcbiAgICAgICAgICAgICAgICBocmVmJGpzY29tcCQwXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB2YXIgc3R5bGVRdWV1ZSRqc2NvbXAkMCA9XG4gICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUuc3R5bGVzLmdldChwcmVjZWRlbmNlJGpzY29tcCQwKSxcbiAgICAgICAgICAgICAgcmVzb3VyY2VTdGF0ZSRqc2NvbXAkMSA9XG4gICAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUuc3R5bGVSZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoaHJlZiRqc2NvbXAkMClcbiAgICAgICAgICAgICAgICAgID8gcmVzdW1hYmxlU3RhdGUuc3R5bGVSZXNvdXJjZXNbaHJlZiRqc2NvbXAkMF1cbiAgICAgICAgICAgICAgICAgIDogdm9pZCAwO1xuICAgICAgICAgICAgaWYgKHJlc291cmNlU3RhdGUkanNjb21wJDEgIT09IEVYSVNUUykge1xuICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZS5zdHlsZVJlc291cmNlc1tocmVmJGpzY29tcCQwXSA9IEVYSVNUUztcbiAgICAgICAgICAgICAgcmVzb3VyY2VTdGF0ZSRqc2NvbXAkMSAmJlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAnUmVhY3QgZW5jb3VudGVyZWQgYSBob2lzdGFibGUgc3R5bGUgdGFnIGZvciB0aGUgc2FtZSBocmVmIGFzIGEgcHJlbG9hZDogXCIlc1wiLiBXaGVuIHVzaW5nIGEgc3R5bGUgdGFnIHRvIGlubGluZSBzdHlsZXMgeW91IHNob3VsZCBub3QgYWxzbyBwcmVsb2FkIGl0IGFzIGEgc3R5bHNoZWV0LicsXG4gICAgICAgICAgICAgICAgICBocmVmJGpzY29tcCQwXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgc3R5bGVRdWV1ZSRqc2NvbXAkMCB8fFxuICAgICAgICAgICAgICAgICgoc3R5bGVRdWV1ZSRqc2NvbXAkMCA9IHtcbiAgICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IHN0cmluZ1RvQ2h1bmsoXG4gICAgICAgICAgICAgICAgICAgIGVzY2FwZVRleHRGb3JCcm93c2VyKHByZWNlZGVuY2UkanNjb21wJDApXG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgcnVsZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgaHJlZnM6IFtdLFxuICAgICAgICAgICAgICAgICAgc2hlZXRzOiBuZXcgTWFwKClcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5zdHlsZXMuc2V0KFxuICAgICAgICAgICAgICAgICAgcHJlY2VkZW5jZSRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgIHN0eWxlUXVldWUkanNjb21wJDBcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgICAgdmFyIG5vbmNlU3R5bGUgPSByZW5kZXJTdGF0ZS5ub25jZS5zdHlsZTtcbiAgICAgICAgICAgICAgaWYgKG5vbmNlU3R5bGUgJiYgbm9uY2VTdHlsZSAhPT0gbm9uY2UpXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICdSZWFjdCBlbmNvdW50ZXJlZCBhIHN0eWxlIHRhZyB3aXRoIGBwcmVjZWRlbmNlYCBcIiVzXCIgYW5kIGBub25jZWAgXCIlc1wiLiBXaGVuIFJlYWN0IG1hbmFnZXMgc3R5bGUgcnVsZXMgdXNpbmcgYHByZWNlZGVuY2VgIGl0IHdpbGwgb25seSBpbmNsdWRlIHJ1bGVzIGlmIHRoZSBub25jZSBtYXRjaGVzIHRoZSBzdHlsZSBub25jZSBcIiVzXCIgdGhhdCB3YXMgaW5jbHVkZWQgd2l0aCB0aGlzIHJlbmRlci4nLFxuICAgICAgICAgICAgICAgICAgcHJlY2VkZW5jZSRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgIG5vbmNlLFxuICAgICAgICAgICAgICAgICAgbm9uY2VTdHlsZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICFub25jZVN0eWxlICYmXG4gICAgICAgICAgICAgICAgICBub25jZSAmJlxuICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgJ1JlYWN0IGVuY291bnRlcmVkIGEgc3R5bGUgdGFnIHdpdGggYHByZWNlZGVuY2VgIFwiJXNcIiBhbmQgYG5vbmNlYCBcIiVzXCIuIFdoZW4gUmVhY3QgbWFuYWdlcyBzdHlsZSBydWxlcyB1c2luZyBgcHJlY2VkZW5jZWAgaXQgd2lsbCBvbmx5IGluY2x1ZGUgYSBub25jZSBhdHRyaWJ1dGVzIGlmIHlvdSBhbHNvIHByb3ZpZGUgdGhlIHNhbWUgc3R5bGUgbm9uY2UgdmFsdWUgYXMgYSByZW5kZXIgb3B0aW9uLicsXG4gICAgICAgICAgICAgICAgICAgIHByZWNlZGVuY2UkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgIG5vbmNlXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHN0eWxlUXVldWUkanNjb21wJDAuaHJlZnMucHVzaChcbiAgICAgICAgICAgICAgICAgIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoaHJlZiRqc2NvbXAkMCkpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gc3R5bGVRdWV1ZSRqc2NvbXAkMC5ydWxlcyxcbiAgICAgICAgICAgICAgICAgIGNoaWxkcmVuJGpzY29tcCQ5ID0gbnVsbCxcbiAgICAgICAgICAgICAgICAgIGlubmVySFRNTCRqc2NvbXAkNiA9IG51bGwsXG4gICAgICAgICAgICAgICAgICBwcm9wS2V5JGpzY29tcCQ5O1xuICAgICAgICAgICAgICAgIGZvciAocHJvcEtleSRqc2NvbXAkOSBpbiBwcm9wcylcbiAgICAgICAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5JGpzY29tcCQ5KSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcFZhbHVlJGpzY29tcCQ5ID0gcHJvcHNbcHJvcEtleSRqc2NvbXAkOV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChudWxsICE9IHByb3BWYWx1ZSRqc2NvbXAkOSlcbiAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHByb3BLZXkkanNjb21wJDkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbiRqc2NvbXAkOSA9IHByb3BWYWx1ZSRqc2NvbXAkOTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXJIVE1MJGpzY29tcCQ2ID0gcHJvcFZhbHVlJGpzY29tcCQ5O1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQkanNjb21wJDIgPSBBcnJheS5pc0FycmF5KGNoaWxkcmVuJGpzY29tcCQ5KVxuICAgICAgICAgICAgICAgICAgPyAyID4gY2hpbGRyZW4kanNjb21wJDkubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgID8gY2hpbGRyZW4kanNjb21wJDlbMF1cbiAgICAgICAgICAgICAgICAgICAgOiBudWxsXG4gICAgICAgICAgICAgICAgICA6IGNoaWxkcmVuJGpzY29tcCQ5O1xuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGNoaWxkJGpzY29tcCQyICYmXG4gICAgICAgICAgICAgICAgICBcInN5bWJvbFwiICE9PSB0eXBlb2YgY2hpbGQkanNjb21wJDIgJiZcbiAgICAgICAgICAgICAgICAgIG51bGwgIT09IGNoaWxkJGpzY29tcCQyICYmXG4gICAgICAgICAgICAgICAgICB2b2lkIDAgIT09IGNoaWxkJGpzY29tcCQyICYmXG4gICAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nVG9DaHVuayhlc2NhcGVTdHlsZVRleHRDb250ZW50KGNoaWxkJGpzY29tcCQyKSlcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcHVzaElubmVySFRNTCh0YXJnZXQsIGlubmVySFRNTCRqc2NvbXAkNiwgY2hpbGRyZW4kanNjb21wJDkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHlsZVF1ZXVlJGpzY29tcCQwICYmXG4gICAgICAgICAgICAgIGhvaXN0YWJsZVN0YXRlICYmXG4gICAgICAgICAgICAgIGhvaXN0YWJsZVN0YXRlLnN0eWxlcy5hZGQoc3R5bGVRdWV1ZSRqc2NvbXAkMCk7XG4gICAgICAgICAgICB0ZXh0RW1iZWRkZWQgJiYgdGFyZ2V0JGpzY29tcCQwLnB1c2godGV4dFNlcGFyYXRvcik7XG4gICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDcgPSB2b2lkIDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDc7XG4gICAgICAgIGNhc2UgXCJtZXRhXCI6XG4gICAgICAgICAgdmFyIG5vc2NyaXB0VGFnSW5TY29wZSRqc2NvbXAkMyA9IGZvcm1hdENvbnRleHQudGFnU2NvcGUgJiAxLFxuICAgICAgICAgICAgaXNGYWxsYmFjayRqc2NvbXAkMSA9IGZvcm1hdENvbnRleHQudGFnU2NvcGUgJiA0O1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSA9PT0gU1ZHX01PREUgfHxcbiAgICAgICAgICAgIG5vc2NyaXB0VGFnSW5TY29wZSRqc2NvbXAkMyB8fFxuICAgICAgICAgICAgbnVsbCAhPSBwcm9wcy5pdGVtUHJvcFxuICAgICAgICAgIClcbiAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDggPSBwdXNoU2VsZkNsb3NpbmcoXG4gICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICAgIFwibWV0YVwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRleHRFbWJlZGRlZCAmJiB0YXJnZXQkanNjb21wJDAucHVzaCh0ZXh0U2VwYXJhdG9yKSxcbiAgICAgICAgICAgICAgKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkOCA9IGlzRmFsbGJhY2skanNjb21wJDFcbiAgICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgICA6IFwic3RyaW5nXCIgPT09IHR5cGVvZiBwcm9wcy5jaGFyU2V0XG4gICAgICAgICAgICAgICAgICA/IHB1c2hTZWxmQ2xvc2luZyhyZW5kZXJTdGF0ZS5jaGFyc2V0Q2h1bmtzLCBwcm9wcywgXCJtZXRhXCIpXG4gICAgICAgICAgICAgICAgICA6IFwidmlld3BvcnRcIiA9PT0gcHJvcHMubmFtZVxuICAgICAgICAgICAgICAgICAgICA/IHB1c2hTZWxmQ2xvc2luZyhyZW5kZXJTdGF0ZS52aWV3cG9ydENodW5rcywgcHJvcHMsIFwibWV0YVwiKVxuICAgICAgICAgICAgICAgICAgICA6IHB1c2hTZWxmQ2xvc2luZyhcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlLmhvaXN0YWJsZUNodW5rcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJtZXRhXCJcbiAgICAgICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICByZXR1cm4gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQ4O1xuICAgICAgICBjYXNlIFwibGlzdGluZ1wiOlxuICAgICAgICBjYXNlIFwicHJlXCI6XG4gICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goc3RhcnRDaHVua0ZvclRhZyh0eXBlKSk7XG4gICAgICAgICAgdmFyIGNoaWxkcmVuJGpzY29tcCQxMCA9IG51bGwsXG4gICAgICAgICAgICBpbm5lckhUTUwkanNjb21wJDcgPSBudWxsLFxuICAgICAgICAgICAgcHJvcEtleSRqc2NvbXAkMTA7XG4gICAgICAgICAgZm9yIChwcm9wS2V5JGpzY29tcCQxMCBpbiBwcm9wcylcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5JGpzY29tcCQxMCkpIHtcbiAgICAgICAgICAgICAgdmFyIHByb3BWYWx1ZSRqc2NvbXAkMTAgPSBwcm9wc1twcm9wS2V5JGpzY29tcCQxMF07XG4gICAgICAgICAgICAgIGlmIChudWxsICE9IHByb3BWYWx1ZSRqc2NvbXAkMTApXG4gICAgICAgICAgICAgICAgc3dpdGNoIChwcm9wS2V5JGpzY29tcCQxMCkge1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuJGpzY29tcCQxMCA9IHByb3BWYWx1ZSRqc2NvbXAkMTA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgICAgICAgICAgIGlubmVySFRNTCRqc2NvbXAkNyA9IHByb3BWYWx1ZSRqc2NvbXAkMTA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcHVzaEF0dHJpYnV0ZShcbiAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcEtleSRqc2NvbXAkMTAsXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcFZhbHVlJGpzY29tcCQxMFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChlbmRPZlN0YXJ0VGFnKTtcbiAgICAgICAgICBpZiAobnVsbCAhPSBpbm5lckhUTUwkanNjb21wJDcpIHtcbiAgICAgICAgICAgIGlmIChudWxsICE9IGNoaWxkcmVuJGpzY29tcCQxMClcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJDYW4gb25seSBzZXQgb25lIG9mIGBjaGlsZHJlbmAgb3IgYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC5cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBcIm9iamVjdFwiICE9PSB0eXBlb2YgaW5uZXJIVE1MJGpzY29tcCQ3IHx8XG4gICAgICAgICAgICAgICEoXCJfX2h0bWxcIiBpbiBpbm5lckhUTUwkanNjb21wJDcpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBtdXN0IGJlIGluIHRoZSBmb3JtIGB7X19odG1sOiAuLi59YC4gUGxlYXNlIHZpc2l0IGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvZGFuZ2Vyb3VzbHktc2V0LWlubmVyLWh0bWwgZm9yIG1vcmUgaW5mb3JtYXRpb24uXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHZhciBodG1sID0gaW5uZXJIVE1MJGpzY29tcCQ3Ll9faHRtbDtcbiAgICAgICAgICAgIG51bGwgIT09IGh0bWwgJiZcbiAgICAgICAgICAgICAgdm9pZCAwICE9PSBodG1sICYmXG4gICAgICAgICAgICAgIChcInN0cmluZ1wiID09PSB0eXBlb2YgaHRtbCAmJiAwIDwgaHRtbC5sZW5ndGggJiYgXCJcXG5cIiA9PT0gaHRtbFswXVxuICAgICAgICAgICAgICAgID8gdGFyZ2V0JGpzY29tcCQwLnB1c2gobGVhZGluZ05ld2xpbmUsIHN0cmluZ1RvQ2h1bmsoaHRtbCkpXG4gICAgICAgICAgICAgICAgOiAoY2hlY2tIdG1sU3RyaW5nQ29lcmNpb24oaHRtbCksXG4gICAgICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChzdHJpbmdUb0NodW5rKFwiXCIgKyBodG1sKSkpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGNoaWxkcmVuJGpzY29tcCQxMCAmJlxuICAgICAgICAgICAgXCJcXG5cIiA9PT0gY2hpbGRyZW4kanNjb21wJDEwWzBdICYmXG4gICAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChsZWFkaW5nTmV3bGluZSk7XG4gICAgICAgICAgcmV0dXJuIGNoaWxkcmVuJGpzY29tcCQxMDtcbiAgICAgICAgY2FzZSBcImltZ1wiOlxuICAgICAgICAgIHZhciBwaWN0dXJlT3JOb1NjcmlwdFRhZ0luU2NvcGUgPSBmb3JtYXRDb250ZXh0LnRhZ1Njb3BlICYgMyxcbiAgICAgICAgICAgIHNyYyA9IHByb3BzLnNyYyxcbiAgICAgICAgICAgIHNyY1NldCA9IHByb3BzLnNyY1NldDtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhKFxuICAgICAgICAgICAgICBcImxhenlcIiA9PT0gcHJvcHMubG9hZGluZyB8fFxuICAgICAgICAgICAgICAoIXNyYyAmJiAhc3JjU2V0KSB8fFxuICAgICAgICAgICAgICAoXCJzdHJpbmdcIiAhPT0gdHlwZW9mIHNyYyAmJiBudWxsICE9IHNyYykgfHxcbiAgICAgICAgICAgICAgKFwic3RyaW5nXCIgIT09IHR5cGVvZiBzcmNTZXQgJiYgbnVsbCAhPSBzcmNTZXQpIHx8XG4gICAgICAgICAgICAgIFwibG93XCIgPT09IHByb3BzLmZldGNoUHJpb3JpdHkgfHxcbiAgICAgICAgICAgICAgcGljdHVyZU9yTm9TY3JpcHRUYWdJblNjb3BlXG4gICAgICAgICAgICApICYmXG4gICAgICAgICAgICAoXCJzdHJpbmdcIiAhPT0gdHlwZW9mIHNyYyB8fFxuICAgICAgICAgICAgICBcIjpcIiAhPT0gc3JjWzRdIHx8XG4gICAgICAgICAgICAgIChcImRcIiAhPT0gc3JjWzBdICYmIFwiRFwiICE9PSBzcmNbMF0pIHx8XG4gICAgICAgICAgICAgIChcImFcIiAhPT0gc3JjWzFdICYmIFwiQVwiICE9PSBzcmNbMV0pIHx8XG4gICAgICAgICAgICAgIChcInRcIiAhPT0gc3JjWzJdICYmIFwiVFwiICE9PSBzcmNbMl0pIHx8XG4gICAgICAgICAgICAgIChcImFcIiAhPT0gc3JjWzNdICYmIFwiQVwiICE9PSBzcmNbM10pKSAmJlxuICAgICAgICAgICAgKFwic3RyaW5nXCIgIT09IHR5cGVvZiBzcmNTZXQgfHxcbiAgICAgICAgICAgICAgXCI6XCIgIT09IHNyY1NldFs0XSB8fFxuICAgICAgICAgICAgICAoXCJkXCIgIT09IHNyY1NldFswXSAmJiBcIkRcIiAhPT0gc3JjU2V0WzBdKSB8fFxuICAgICAgICAgICAgICAoXCJhXCIgIT09IHNyY1NldFsxXSAmJiBcIkFcIiAhPT0gc3JjU2V0WzFdKSB8fFxuICAgICAgICAgICAgICAoXCJ0XCIgIT09IHNyY1NldFsyXSAmJiBcIlRcIiAhPT0gc3JjU2V0WzJdKSB8fFxuICAgICAgICAgICAgICAoXCJhXCIgIT09IHNyY1NldFszXSAmJiBcIkFcIiAhPT0gc3JjU2V0WzNdKSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIG51bGwgIT09IGhvaXN0YWJsZVN0YXRlICYmXG4gICAgICAgICAgICAgIGZvcm1hdENvbnRleHQudGFnU2NvcGUgJiA2NCAmJlxuICAgICAgICAgICAgICAoaG9pc3RhYmxlU3RhdGUuc3VzcGVuc2V5SW1hZ2VzID0gITApO1xuICAgICAgICAgICAgdmFyIHNpemVzID0gXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHByb3BzLnNpemVzID8gcHJvcHMuc2l6ZXMgOiB2b2lkIDAsXG4gICAgICAgICAgICAgIGtleSRqc2NvbXAkMCA9IHNyY1NldCA/IHNyY1NldCArIFwiXFxuXCIgKyAoc2l6ZXMgfHwgXCJcIikgOiBzcmMsXG4gICAgICAgICAgICAgIHByb21vdGFibGVQcmVsb2FkcyA9IHJlbmRlclN0YXRlLnByZWxvYWRzLmltYWdlcyxcbiAgICAgICAgICAgICAgcmVzb3VyY2UkanNjb21wJDEgPSBwcm9tb3RhYmxlUHJlbG9hZHMuZ2V0KGtleSRqc2NvbXAkMCk7XG4gICAgICAgICAgICBpZiAocmVzb3VyY2UkanNjb21wJDEpIHtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIFwiaGlnaFwiID09PSBwcm9wcy5mZXRjaFByaW9yaXR5IHx8XG4gICAgICAgICAgICAgICAgMTAgPiByZW5kZXJTdGF0ZS5oaWdoSW1hZ2VQcmVsb2Fkcy5zaXplXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICBwcm9tb3RhYmxlUHJlbG9hZHMuZGVsZXRlKGtleSRqc2NvbXAkMCksXG4gICAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5oaWdoSW1hZ2VQcmVsb2Fkcy5hZGQocmVzb3VyY2UkanNjb21wJDEpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgIXJlc3VtYWJsZVN0YXRlLmltYWdlUmVzb3VyY2VzLmhhc093blByb3BlcnR5KGtleSRqc2NvbXAkMClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZS5pbWFnZVJlc291cmNlc1trZXkkanNjb21wJDBdID0gUFJFTE9BRF9OT19DUkVEUztcbiAgICAgICAgICAgICAgdmFyIGlucHV0ID0gcHJvcHMuY3Jvc3NPcmlnaW47XG4gICAgICAgICAgICAgIHZhciBjcm9zc09yaWdpbiA9XG4gICAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGlucHV0XG4gICAgICAgICAgICAgICAgICA/IFwidXNlLWNyZWRlbnRpYWxzXCIgPT09IGlucHV0XG4gICAgICAgICAgICAgICAgICAgID8gaW5wdXRcbiAgICAgICAgICAgICAgICAgICAgOiBcIlwiXG4gICAgICAgICAgICAgICAgICA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgdmFyIGhlYWRlcnMgPSByZW5kZXJTdGF0ZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIGhlYWRlcjtcbiAgICAgICAgICAgICAgaGVhZGVycyAmJlxuICAgICAgICAgICAgICAwIDwgaGVhZGVycy5yZW1haW5pbmdDYXBhY2l0eSAmJlxuICAgICAgICAgICAgICBcInN0cmluZ1wiICE9PSB0eXBlb2YgcHJvcHMuc3JjU2V0ICYmXG4gICAgICAgICAgICAgIChcImhpZ2hcIiA9PT0gcHJvcHMuZmV0Y2hQcmlvcml0eSB8fFxuICAgICAgICAgICAgICAgIDUwMCA+IGhlYWRlcnMuaGlnaEltYWdlUHJlbG9hZHMubGVuZ3RoKSAmJlxuICAgICAgICAgICAgICAoKGhlYWRlciA9IGdldFByZWxvYWRBc0hlYWRlcihzcmMsIFwiaW1hZ2VcIiwge1xuICAgICAgICAgICAgICAgIGltYWdlU3JjU2V0OiBwcm9wcy5zcmNTZXQsXG4gICAgICAgICAgICAgICAgaW1hZ2VTaXplczogcHJvcHMuc2l6ZXMsXG4gICAgICAgICAgICAgICAgY3Jvc3NPcmlnaW46IGNyb3NzT3JpZ2luLFxuICAgICAgICAgICAgICAgIGludGVncml0eTogcHJvcHMuaW50ZWdyaXR5LFxuICAgICAgICAgICAgICAgIG5vbmNlOiBwcm9wcy5ub25jZSxcbiAgICAgICAgICAgICAgICB0eXBlOiBwcm9wcy50eXBlLFxuICAgICAgICAgICAgICAgIGZldGNoUHJpb3JpdHk6IHByb3BzLmZldGNoUHJpb3JpdHksXG4gICAgICAgICAgICAgICAgcmVmZXJyZXJQb2xpY3k6IHByb3BzLnJlZmVyZXJQb2xpY3lcbiAgICAgICAgICAgICAgfSkpLFxuICAgICAgICAgICAgICAwIDw9IChoZWFkZXJzLnJlbWFpbmluZ0NhcGFjaXR5IC09IGhlYWRlci5sZW5ndGggKyAyKSlcbiAgICAgICAgICAgICAgICA/ICgocmVuZGVyU3RhdGUucmVzZXRzLmltYWdlW2tleSRqc2NvbXAkMF0gPSBQUkVMT0FEX05PX0NSRURTKSxcbiAgICAgICAgICAgICAgICAgIGhlYWRlcnMuaGlnaEltYWdlUHJlbG9hZHMgJiZcbiAgICAgICAgICAgICAgICAgICAgKGhlYWRlcnMuaGlnaEltYWdlUHJlbG9hZHMgKz0gXCIsIFwiKSxcbiAgICAgICAgICAgICAgICAgIChoZWFkZXJzLmhpZ2hJbWFnZVByZWxvYWRzICs9IGhlYWRlcikpXG4gICAgICAgICAgICAgICAgOiAoKHJlc291cmNlJGpzY29tcCQxID0gW10pLFxuICAgICAgICAgICAgICAgICAgcHVzaExpbmtJbXBsKHJlc291cmNlJGpzY29tcCQxLCB7XG4gICAgICAgICAgICAgICAgICAgIHJlbDogXCJwcmVsb2FkXCIsXG4gICAgICAgICAgICAgICAgICAgIGFzOiBcImltYWdlXCIsXG4gICAgICAgICAgICAgICAgICAgIGhyZWY6IHNyY1NldCA/IHZvaWQgMCA6IHNyYyxcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VTcmNTZXQ6IHNyY1NldCxcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VTaXplczogc2l6ZXMsXG4gICAgICAgICAgICAgICAgICAgIGNyb3NzT3JpZ2luOiBjcm9zc09yaWdpbixcbiAgICAgICAgICAgICAgICAgICAgaW50ZWdyaXR5OiBwcm9wcy5pbnRlZ3JpdHksXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHByb3BzLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGZldGNoUHJpb3JpdHk6IHByb3BzLmZldGNoUHJpb3JpdHksXG4gICAgICAgICAgICAgICAgICAgIHJlZmVycmVyUG9saWN5OiBwcm9wcy5yZWZlcnJlclBvbGljeVxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICBcImhpZ2hcIiA9PT0gcHJvcHMuZmV0Y2hQcmlvcml0eSB8fFxuICAgICAgICAgICAgICAgICAgMTAgPiByZW5kZXJTdGF0ZS5oaWdoSW1hZ2VQcmVsb2Fkcy5zaXplXG4gICAgICAgICAgICAgICAgICAgID8gcmVuZGVyU3RhdGUuaGlnaEltYWdlUHJlbG9hZHMuYWRkKHJlc291cmNlJGpzY29tcCQxKVxuICAgICAgICAgICAgICAgICAgICA6IChyZW5kZXJTdGF0ZS5idWxrUHJlbG9hZHMuYWRkKHJlc291cmNlJGpzY29tcCQxKSxcbiAgICAgICAgICAgICAgICAgICAgICBwcm9tb3RhYmxlUHJlbG9hZHMuc2V0KGtleSRqc2NvbXAkMCwgcmVzb3VyY2UkanNjb21wJDEpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwdXNoU2VsZkNsb3NpbmcodGFyZ2V0JGpzY29tcCQwLCBwcm9wcywgXCJpbWdcIik7XG4gICAgICAgIGNhc2UgXCJiYXNlXCI6XG4gICAgICAgIGNhc2UgXCJhcmVhXCI6XG4gICAgICAgIGNhc2UgXCJiclwiOlxuICAgICAgICBjYXNlIFwiY29sXCI6XG4gICAgICAgIGNhc2UgXCJlbWJlZFwiOlxuICAgICAgICBjYXNlIFwiaHJcIjpcbiAgICAgICAgY2FzZSBcImtleWdlblwiOlxuICAgICAgICBjYXNlIFwicGFyYW1cIjpcbiAgICAgICAgY2FzZSBcInNvdXJjZVwiOlxuICAgICAgICBjYXNlIFwidHJhY2tcIjpcbiAgICAgICAgY2FzZSBcIndiclwiOlxuICAgICAgICAgIHJldHVybiBwdXNoU2VsZkNsb3NpbmcodGFyZ2V0JGpzY29tcCQwLCBwcm9wcywgdHlwZSk7XG4gICAgICAgIGNhc2UgXCJhbm5vdGF0aW9uLXhtbFwiOlxuICAgICAgICBjYXNlIFwiY29sb3ItcHJvZmlsZVwiOlxuICAgICAgICBjYXNlIFwiZm9udC1mYWNlXCI6XG4gICAgICAgIGNhc2UgXCJmb250LWZhY2Utc3JjXCI6XG4gICAgICAgIGNhc2UgXCJmb250LWZhY2UtdXJpXCI6XG4gICAgICAgIGNhc2UgXCJmb250LWZhY2UtZm9ybWF0XCI6XG4gICAgICAgIGNhc2UgXCJmb250LWZhY2UtbmFtZVwiOlxuICAgICAgICBjYXNlIFwibWlzc2luZy1nbHlwaFwiOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiaGVhZFwiOlxuICAgICAgICAgIGlmIChmb3JtYXRDb250ZXh0Lmluc2VydGlvbk1vZGUgPCBIVE1MX01PREUpIHtcbiAgICAgICAgICAgIHZhciBwcmVhbWJsZSA9IHByZWFtYmxlU3RhdGUgfHwgcmVuZGVyU3RhdGUucHJlYW1ibGU7XG4gICAgICAgICAgICBpZiAocHJlYW1ibGUuaGVhZENodW5rcylcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJUaGUgYDxoZWFkPmAgdGFnIG1heSBvbmx5IGJlIHJlbmRlcmVkIG9uY2UuXCIpO1xuICAgICAgICAgICAgbnVsbCAhPT0gcHJlYW1ibGVTdGF0ZSAmJlxuICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChoZWFkUHJlYW1ibGVDb250cmlidXRpb25DaHVuayk7XG4gICAgICAgICAgICBwcmVhbWJsZS5oZWFkQ2h1bmtzID0gW107XG4gICAgICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQ5ID0gcHVzaFN0YXJ0U2luZ2xldG9uRWxlbWVudChcbiAgICAgICAgICAgICAgcHJlYW1ibGUuaGVhZENodW5rcyxcbiAgICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICAgIFwiaGVhZFwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQ5ID0gcHVzaFN0YXJ0R2VuZXJpY0VsZW1lbnQoXG4gICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICAgIFwiaGVhZFwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDk7XG4gICAgICAgIGNhc2UgXCJib2R5XCI6XG4gICAgICAgICAgaWYgKGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSA8IEhUTUxfTU9ERSkge1xuICAgICAgICAgICAgdmFyIHByZWFtYmxlJGpzY29tcCQwID0gcHJlYW1ibGVTdGF0ZSB8fCByZW5kZXJTdGF0ZS5wcmVhbWJsZTtcbiAgICAgICAgICAgIGlmIChwcmVhbWJsZSRqc2NvbXAkMC5ib2R5Q2h1bmtzKVxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIlRoZSBgPGJvZHk+YCB0YWcgbWF5IG9ubHkgYmUgcmVuZGVyZWQgb25jZS5cIik7XG4gICAgICAgICAgICBudWxsICE9PSBwcmVhbWJsZVN0YXRlICYmXG4gICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKGJvZHlQcmVhbWJsZUNvbnRyaWJ1dGlvbkNodW5rKTtcbiAgICAgICAgICAgIHByZWFtYmxlJGpzY29tcCQwLmJvZHlDaHVua3MgPSBbXTtcbiAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDEwID0gcHVzaFN0YXJ0U2luZ2xldG9uRWxlbWVudChcbiAgICAgICAgICAgICAgcHJlYW1ibGUkanNjb21wJDAuYm9keUNodW5rcyxcbiAgICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICAgIFwiYm9keVwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQxMCA9IHB1c2hTdGFydEdlbmVyaWNFbGVtZW50KFxuICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAsXG4gICAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgICBcImJvZHlcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQxMDtcbiAgICAgICAgY2FzZSBcImh0bWxcIjpcbiAgICAgICAgICBpZiAoZm9ybWF0Q29udGV4dC5pbnNlcnRpb25Nb2RlID09PSBST09UX0hUTUxfTU9ERSkge1xuICAgICAgICAgICAgdmFyIHByZWFtYmxlJGpzY29tcCQxID0gcHJlYW1ibGVTdGF0ZSB8fCByZW5kZXJTdGF0ZS5wcmVhbWJsZTtcbiAgICAgICAgICAgIGlmIChwcmVhbWJsZSRqc2NvbXAkMS5odG1sQ2h1bmtzKVxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIlRoZSBgPGh0bWw+YCB0YWcgbWF5IG9ubHkgYmUgcmVuZGVyZWQgb25jZS5cIik7XG4gICAgICAgICAgICBudWxsICE9PSBwcmVhbWJsZVN0YXRlICYmXG4gICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKGh0bWxQcmVhbWJsZUNvbnRyaWJ1dGlvbkNodW5rKTtcbiAgICAgICAgICAgIHByZWFtYmxlJGpzY29tcCQxLmh0bWxDaHVua3MgPSBbZG9jdHlwZUNodW5rXTtcbiAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDExID0gcHVzaFN0YXJ0U2luZ2xldG9uRWxlbWVudChcbiAgICAgICAgICAgICAgcHJlYW1ibGUkanNjb21wJDEuaHRtbENodW5rcyxcbiAgICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICAgIFwiaHRtbFwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQxMSA9IHB1c2hTdGFydEdlbmVyaWNFbGVtZW50KFxuICAgICAgICAgICAgICB0YXJnZXQkanNjb21wJDAsXG4gICAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgICBcImh0bWxcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQxMTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoLTEgIT09IHR5cGUuaW5kZXhPZihcIi1cIikpIHtcbiAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcodHlwZSkpO1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuJGpzY29tcCQxMSA9IG51bGwsXG4gICAgICAgICAgICAgIGlubmVySFRNTCRqc2NvbXAkOCA9IG51bGwsXG4gICAgICAgICAgICAgIHByb3BLZXkkanNjb21wJDExO1xuICAgICAgICAgICAgZm9yIChwcm9wS2V5JGpzY29tcCQxMSBpbiBwcm9wcylcbiAgICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkkanNjb21wJDExKSkge1xuICAgICAgICAgICAgICAgIHZhciBwcm9wVmFsdWUkanNjb21wJDExID0gcHJvcHNbcHJvcEtleSRqc2NvbXAkMTFdO1xuICAgICAgICAgICAgICAgIGlmIChudWxsICE9IHByb3BWYWx1ZSRqc2NvbXAkMTEpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gcHJvcEtleSRqc2NvbXAkMTE7XG4gICAgICAgICAgICAgICAgICBzd2l0Y2ggKHByb3BLZXkkanNjb21wJDExKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuJGpzY29tcCQxMSA9IHByb3BWYWx1ZSRqc2NvbXAkMTE7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICAgICAgICAgICAgICAgIGlubmVySFRNTCRqc2NvbXAkOCA9IHByb3BWYWx1ZSRqc2NvbXAkMTE7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzdHlsZVwiOlxuICAgICAgICAgICAgICAgICAgICAgIHB1c2hTdHlsZUF0dHJpYnV0ZSh0YXJnZXQkanNjb21wJDAsIHByb3BWYWx1ZSRqc2NvbXAkMTEpO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmdcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInJlZlwiOlxuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiY2xhc3NOYW1lXCI6XG4gICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlTmFtZSA9IFwiY2xhc3NcIjtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0F0dHJpYnV0ZU5hbWVTYWZlKHByb3BLZXkkanNjb21wJDExKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgcHJvcFZhbHVlJGpzY29tcCQxMSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgXCJzeW1ib2xcIiAhPT0gdHlwZW9mIHByb3BWYWx1ZSRqc2NvbXAkMTEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICExICE9PSBwcm9wVmFsdWUkanNjb21wJDExXG4gICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoITAgPT09IHByb3BWYWx1ZSRqc2NvbXAkMTEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BWYWx1ZSRqc2NvbXAkMTEgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHByb3BWYWx1ZSRqc2NvbXAkMTEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0JGpzY29tcCQwLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZVNlcGFyYXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nVG9DaHVuayhhdHRyaWJ1dGVOYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlQXNzaWduLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmdUb0NodW5rKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVzY2FwZVRleHRGb3JCcm93c2VyKHByb3BWYWx1ZSRqc2NvbXAkMTEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUVuZFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXJnZXQkanNjb21wJDAucHVzaChlbmRPZlN0YXJ0VGFnKTtcbiAgICAgICAgICAgIHB1c2hJbm5lckhUTUwoXG4gICAgICAgICAgICAgIHRhcmdldCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgaW5uZXJIVE1MJGpzY29tcCQ4LFxuICAgICAgICAgICAgICBjaGlsZHJlbiRqc2NvbXAkMTFcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGRyZW4kanNjb21wJDExO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBwdXNoU3RhcnRHZW5lcmljRWxlbWVudCh0YXJnZXQkanNjb21wJDAsIHByb3BzLCB0eXBlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW5kQ2h1bmtGb3JUYWcodGFnKSB7XG4gICAgICB2YXIgY2h1bmsgPSBlbmRUYWdDYWNoZS5nZXQodGFnKTtcbiAgICAgIHZvaWQgMCA9PT0gY2h1bmsgJiZcbiAgICAgICAgKChjaHVuayA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhcIjwvXCIgKyB0YWcgKyBcIj5cIikpLFxuICAgICAgICBlbmRUYWdDYWNoZS5zZXQodGFnLCBjaHVuaykpO1xuICAgICAgcmV0dXJuIGNodW5rO1xuICAgIH1cbiAgICBmdW5jdGlvbiBob2lzdFByZWFtYmxlU3RhdGUocmVuZGVyU3RhdGUsIHByZWFtYmxlU3RhdGUpIHtcbiAgICAgIHJlbmRlclN0YXRlID0gcmVuZGVyU3RhdGUucHJlYW1ibGU7XG4gICAgICBudWxsID09PSByZW5kZXJTdGF0ZS5odG1sQ2h1bmtzICYmXG4gICAgICAgIHByZWFtYmxlU3RhdGUuaHRtbENodW5rcyAmJlxuICAgICAgICAocmVuZGVyU3RhdGUuaHRtbENodW5rcyA9IHByZWFtYmxlU3RhdGUuaHRtbENodW5rcyk7XG4gICAgICBudWxsID09PSByZW5kZXJTdGF0ZS5oZWFkQ2h1bmtzICYmXG4gICAgICAgIHByZWFtYmxlU3RhdGUuaGVhZENodW5rcyAmJlxuICAgICAgICAocmVuZGVyU3RhdGUuaGVhZENodW5rcyA9IHByZWFtYmxlU3RhdGUuaGVhZENodW5rcyk7XG4gICAgICBudWxsID09PSByZW5kZXJTdGF0ZS5ib2R5Q2h1bmtzICYmXG4gICAgICAgIHByZWFtYmxlU3RhdGUuYm9keUNodW5rcyAmJlxuICAgICAgICAocmVuZGVyU3RhdGUuYm9keUNodW5rcyA9IHByZWFtYmxlU3RhdGUuYm9keUNodW5rcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdyaXRlQm9vdHN0cmFwKGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZSkge1xuICAgICAgcmVuZGVyU3RhdGUgPSByZW5kZXJTdGF0ZS5ib290c3RyYXBDaHVua3M7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlbmRlclN0YXRlLmxlbmd0aCAtIDE7IGkrKylcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGVbaV0pO1xuICAgICAgcmV0dXJuIGkgPCByZW5kZXJTdGF0ZS5sZW5ndGhcbiAgICAgICAgPyAoKGkgPSByZW5kZXJTdGF0ZVtpXSksXG4gICAgICAgICAgKHJlbmRlclN0YXRlLmxlbmd0aCA9IDApLFxuICAgICAgICAgIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGkpKVxuICAgICAgICA6ICEwO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3cml0ZVN0YXJ0UGVuZGluZ1N1c3BlbnNlQm91bmRhcnkoZGVzdGluYXRpb24sIHJlbmRlclN0YXRlLCBpZCkge1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RhcnRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeTEpO1xuICAgICAgaWYgKG51bGwgPT09IGlkKVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIkFuIElEIG11c3QgaGF2ZSBiZWVuIGFzc2lnbmVkIGJlZm9yZSB3ZSBjYW4gY29tcGxldGUgdGhlIGJvdW5kYXJ5LlwiXG4gICAgICAgICk7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZS5ib3VuZGFyeVByZWZpeCk7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGlkLnRvU3RyaW5nKDE2KSkpO1xuICAgICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIHN0YXJ0UGVuZGluZ1N1c3BlbnNlQm91bmRhcnkyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd3JpdGVTdGFydFNlZ21lbnQoZGVzdGluYXRpb24sIHJlbmRlclN0YXRlLCBmb3JtYXRDb250ZXh0LCBpZCkge1xuICAgICAgc3dpdGNoIChmb3JtYXRDb250ZXh0Lmluc2VydGlvbk1vZGUpIHtcbiAgICAgICAgY2FzZSBST09UX0hUTUxfTU9ERTpcbiAgICAgICAgY2FzZSBIVE1MX0hUTUxfTU9ERTpcbiAgICAgICAgY2FzZSBIVE1MX0hFQURfTU9ERTpcbiAgICAgICAgY2FzZSBIVE1MX01PREU6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0YXJ0U2VnbWVudEhUTUwpLFxuICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUuc2VnbWVudFByZWZpeCksXG4gICAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGlkLnRvU3RyaW5nKDE2KSkpLFxuICAgICAgICAgICAgd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgc3RhcnRTZWdtZW50SFRNTDIpXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBTVkdfTU9ERTpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RhcnRTZWdtZW50U1ZHKSxcbiAgICAgICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHJlbmRlclN0YXRlLnNlZ21lbnRQcmVmaXgpLFxuICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhpZC50b1N0cmluZygxNikpKSxcbiAgICAgICAgICAgIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIHN0YXJ0U2VnbWVudFNWRzIpXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBNQVRITUxfTU9ERTpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RhcnRTZWdtZW50TWF0aE1MKSxcbiAgICAgICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHJlbmRlclN0YXRlLnNlZ21lbnRQcmVmaXgpLFxuICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhpZC50b1N0cmluZygxNikpKSxcbiAgICAgICAgICAgIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIHN0YXJ0U2VnbWVudE1hdGhNTDIpXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBIVE1MX1RBQkxFX01PREU6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0YXJ0U2VnbWVudFRhYmxlKSxcbiAgICAgICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHJlbmRlclN0YXRlLnNlZ21lbnRQcmVmaXgpLFxuICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhpZC50b1N0cmluZygxNikpKSxcbiAgICAgICAgICAgIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIHN0YXJ0U2VnbWVudFRhYmxlMilcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIEhUTUxfVEFCTEVfQk9EWV9NT0RFOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRUYWJsZUJvZHkpLFxuICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUuc2VnbWVudFByZWZpeCksXG4gICAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGlkLnRvU3RyaW5nKDE2KSkpLFxuICAgICAgICAgICAgd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgc3RhcnRTZWdtZW50VGFibGVCb2R5MilcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIEhUTUxfVEFCTEVfUk9XX01PREU6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0YXJ0U2VnbWVudFRhYmxlUm93KSxcbiAgICAgICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHJlbmRlclN0YXRlLnNlZ21lbnRQcmVmaXgpLFxuICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhpZC50b1N0cmluZygxNikpKSxcbiAgICAgICAgICAgIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIHN0YXJ0U2VnbWVudFRhYmxlUm93MilcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIEhUTUxfQ09MR1JPVVBfTU9ERTpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RhcnRTZWdtZW50Q29sR3JvdXApLFxuICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUuc2VnbWVudFByZWZpeCksXG4gICAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGlkLnRvU3RyaW5nKDE2KSkpLFxuICAgICAgICAgICAgd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgc3RhcnRTZWdtZW50Q29sR3JvdXAyKVxuICAgICAgICAgICk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXCJVbmtub3duIGluc2VydGlvbiBtb2RlLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gd3JpdGVFbmRTZWdtZW50KGRlc3RpbmF0aW9uLCBmb3JtYXRDb250ZXh0KSB7XG4gICAgICBzd2l0Y2ggKGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSkge1xuICAgICAgICBjYXNlIFJPT1RfSFRNTF9NT0RFOlxuICAgICAgICBjYXNlIEhUTUxfSFRNTF9NT0RFOlxuICAgICAgICBjYXNlIEhUTUxfSEVBRF9NT0RFOlxuICAgICAgICBjYXNlIEhUTUxfTU9ERTpcbiAgICAgICAgICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgZW5kU2VnbWVudEhUTUwpO1xuICAgICAgICBjYXNlIFNWR19NT0RFOlxuICAgICAgICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBlbmRTZWdtZW50U1ZHKTtcbiAgICAgICAgY2FzZSBNQVRITUxfTU9ERTpcbiAgICAgICAgICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgZW5kU2VnbWVudE1hdGhNTCk7XG4gICAgICAgIGNhc2UgSFRNTF9UQUJMRV9NT0RFOlxuICAgICAgICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBlbmRTZWdtZW50VGFibGUpO1xuICAgICAgICBjYXNlIEhUTUxfVEFCTEVfQk9EWV9NT0RFOlxuICAgICAgICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBlbmRTZWdtZW50VGFibGVCb2R5KTtcbiAgICAgICAgY2FzZSBIVE1MX1RBQkxFX1JPV19NT0RFOlxuICAgICAgICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBlbmRTZWdtZW50VGFibGVSb3cpO1xuICAgICAgICBjYXNlIEhUTUxfQ09MR1JPVVBfTU9ERTpcbiAgICAgICAgICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgZW5kU2VnbWVudENvbEdyb3VwKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBFcnJvcihcIlVua25vd24gaW5zZXJ0aW9uIG1vZGUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBlc2NhcGVKU1N0cmluZ3NGb3JJbnN0cnVjdGlvblNjcmlwdHMoaW5wdXQpIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShpbnB1dCkucmVwbGFjZShcbiAgICAgICAgcmVnZXhGb3JKU1N0cmluZ3NJbkluc3RydWN0aW9uU2NyaXB0cyxcbiAgICAgICAgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgc3dpdGNoIChtYXRjaCkge1xuICAgICAgICAgICAgY2FzZSBcIjxcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIFwiXFxcXHUwMDNjXCI7XG4gICAgICAgICAgICBjYXNlIFwiXFx1MjAyOFwiOlxuICAgICAgICAgICAgICByZXR1cm4gXCJcXFxcdTIwMjhcIjtcbiAgICAgICAgICAgIGNhc2UgXCJcXHUyMDI5XCI6XG4gICAgICAgICAgICAgIHJldHVybiBcIlxcXFx1MjAyOVwiO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJlc2NhcGVKU1N0cmluZ3NGb3JJbnN0cnVjdGlvblNjcmlwdHMgZW5jb3VudGVyZWQgYSBtYXRjaCBpdCBkb2VzIG5vdCBrbm93IGhvdyB0byByZXBsYWNlLiB0aGlzIG1lYW5zIHRoZSBtYXRjaCByZWdleCBhbmQgdGhlIHJlcGxhY2VtZW50IGNoYXJhY3RlcnMgYXJlIG5vIGxvbmdlciBpbiBzeW5jLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0XCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVzY2FwZUpTT2JqZWN0Rm9ySW5zdHJ1Y3Rpb25TY3JpcHRzKGlucHV0KSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoaW5wdXQpLnJlcGxhY2UoXG4gICAgICAgIHJlZ2V4Rm9ySlNTdHJpbmdzSW5TY3JpcHRzLFxuICAgICAgICBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgICBzd2l0Y2ggKG1hdGNoKSB7XG4gICAgICAgICAgICBjYXNlIFwiJlwiOlxuICAgICAgICAgICAgICByZXR1cm4gXCJcXFxcdTAwMjZcIjtcbiAgICAgICAgICAgIGNhc2UgXCI+XCI6XG4gICAgICAgICAgICAgIHJldHVybiBcIlxcXFx1MDAzZVwiO1xuICAgICAgICAgICAgY2FzZSBcIjxcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIFwiXFxcXHUwMDNjXCI7XG4gICAgICAgICAgICBjYXNlIFwiXFx1MjAyOFwiOlxuICAgICAgICAgICAgICByZXR1cm4gXCJcXFxcdTIwMjhcIjtcbiAgICAgICAgICAgIGNhc2UgXCJcXHUyMDI5XCI6XG4gICAgICAgICAgICAgIHJldHVybiBcIlxcXFx1MjAyOVwiO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJlc2NhcGVKU09iamVjdEZvckluc3RydWN0aW9uU2NyaXB0cyBlbmNvdW50ZXJlZCBhIG1hdGNoIGl0IGRvZXMgbm90IGtub3cgaG93IHRvIHJlcGxhY2UuIHRoaXMgbWVhbnMgdGhlIG1hdGNoIHJlZ2V4IGFuZCB0aGUgcmVwbGFjZW1lbnQgY2hhcmFjdGVycyBhcmUgbm8gbG9uZ2VyIGluIHN5bmMuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3RcIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmx1c2hTdHlsZVRhZ3NMYXRlRm9yQm91bmRhcnkoc3R5bGVRdWV1ZSkge1xuICAgICAgdmFyIHJ1bGVzID0gc3R5bGVRdWV1ZS5ydWxlcyxcbiAgICAgICAgaHJlZnMgPSBzdHlsZVF1ZXVlLmhyZWZzO1xuICAgICAgMCA8IHJ1bGVzLmxlbmd0aCAmJlxuICAgICAgICAwID09PSBocmVmcy5sZW5ndGggJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlJlYWN0IGV4cGVjdGVkIHRvIGhhdmUgYXQgbGVhc3Qgb25lIGhyZWYgZm9yIGFuIGEgaG9pc3RhYmxlIHN0eWxlIGJ1dCBmb3VuZCBub25lLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICk7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICBpZiAoaHJlZnMubGVuZ3RoKSB7XG4gICAgICAgIHdyaXRlQ2h1bmsodGhpcywgY3VycmVudGx5Rmx1c2hpbmdSZW5kZXJTdGF0ZS5zdGFydElubGluZVN0eWxlKTtcbiAgICAgICAgd3JpdGVDaHVuayh0aGlzLCBsYXRlU3R5bGVUYWdSZXNvdXJjZU9wZW4xKTtcbiAgICAgICAgd3JpdGVDaHVuayh0aGlzLCBzdHlsZVF1ZXVlLnByZWNlZGVuY2UpO1xuICAgICAgICBmb3IgKFxuICAgICAgICAgIHdyaXRlQ2h1bmsodGhpcywgbGF0ZVN0eWxlVGFnUmVzb3VyY2VPcGVuMik7XG4gICAgICAgICAgaSA8IGhyZWZzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgaSsrXG4gICAgICAgIClcbiAgICAgICAgICB3cml0ZUNodW5rKHRoaXMsIGhyZWZzW2ldKSwgd3JpdGVDaHVuayh0aGlzLCBzcGFjZVNlcGFyYXRvcik7XG4gICAgICAgIHdyaXRlQ2h1bmsodGhpcywgaHJlZnNbaV0pO1xuICAgICAgICB3cml0ZUNodW5rKHRoaXMsIGxhdGVTdHlsZVRhZ1Jlc291cmNlT3BlbjMpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHdyaXRlQ2h1bmsodGhpcywgcnVsZXNbaV0pO1xuICAgICAgICBkZXN0aW5hdGlvbkhhc0NhcGFjaXR5ID0gd3JpdGVDaHVua0FuZFJldHVybihcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIGxhdGVTdHlsZVRhZ1RlbXBsYXRlQ2xvc2VcbiAgICAgICAgKTtcbiAgICAgICAgY3VycmVudGx5UmVuZGVyaW5nQm91bmRhcnlIYXNTdHlsZXNUb0hvaXN0ID0gITA7XG4gICAgICAgIHJ1bGVzLmxlbmd0aCA9IDA7XG4gICAgICAgIGhyZWZzLmxlbmd0aCA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhc1N0eWxlc1RvSG9pc3Qoc3R5bGVzaGVldCkge1xuICAgICAgcmV0dXJuIHN0eWxlc2hlZXQuc3RhdGUgIT09IFBSRUFNQkxFXG4gICAgICAgID8gKGN1cnJlbnRseVJlbmRlcmluZ0JvdW5kYXJ5SGFzU3R5bGVzVG9Ib2lzdCA9ICEwKVxuICAgICAgICA6ICExO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3cml0ZUhvaXN0YWJsZXNGb3JCb3VuZGFyeShcbiAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgaG9pc3RhYmxlU3RhdGUsXG4gICAgICByZW5kZXJTdGF0ZVxuICAgICkge1xuICAgICAgY3VycmVudGx5UmVuZGVyaW5nQm91bmRhcnlIYXNTdHlsZXNUb0hvaXN0ID0gITE7XG4gICAgICBkZXN0aW5hdGlvbkhhc0NhcGFjaXR5ID0gITA7XG4gICAgICBjdXJyZW50bHlGbHVzaGluZ1JlbmRlclN0YXRlID0gcmVuZGVyU3RhdGU7XG4gICAgICBob2lzdGFibGVTdGF0ZS5zdHlsZXMuZm9yRWFjaChmbHVzaFN0eWxlVGFnc0xhdGVGb3JCb3VuZGFyeSwgZGVzdGluYXRpb24pO1xuICAgICAgY3VycmVudGx5Rmx1c2hpbmdSZW5kZXJTdGF0ZSA9IG51bGw7XG4gICAgICBob2lzdGFibGVTdGF0ZS5zdHlsZXNoZWV0cy5mb3JFYWNoKGhhc1N0eWxlc1RvSG9pc3QpO1xuICAgICAgY3VycmVudGx5UmVuZGVyaW5nQm91bmRhcnlIYXNTdHlsZXNUb0hvaXN0ICYmXG4gICAgICAgIChyZW5kZXJTdGF0ZS5zdHlsZXNUb0hvaXN0ID0gITApO1xuICAgICAgcmV0dXJuIGRlc3RpbmF0aW9uSGFzQ2FwYWNpdHk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZsdXNoUmVzb3VyY2UocmVzb3VyY2UpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzb3VyY2UubGVuZ3RoOyBpKyspIHdyaXRlQ2h1bmsodGhpcywgcmVzb3VyY2VbaV0pO1xuICAgICAgcmVzb3VyY2UubGVuZ3RoID0gMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmx1c2hTdHlsZUluUHJlYW1ibGUoc3R5bGVzaGVldCkge1xuICAgICAgcHVzaExpbmtJbXBsKHN0eWxlc2hlZXRGbHVzaGluZ1F1ZXVlLCBzdHlsZXNoZWV0LnByb3BzKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzaGVldEZsdXNoaW5nUXVldWUubGVuZ3RoOyBpKyspXG4gICAgICAgIHdyaXRlQ2h1bmsodGhpcywgc3R5bGVzaGVldEZsdXNoaW5nUXVldWVbaV0pO1xuICAgICAgc3R5bGVzaGVldEZsdXNoaW5nUXVldWUubGVuZ3RoID0gMDtcbiAgICAgIHN0eWxlc2hlZXQuc3RhdGUgPSBQUkVBTUJMRTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmx1c2hTdHlsZXNJblByZWFtYmxlKHN0eWxlUXVldWUpIHtcbiAgICAgIHZhciBoYXNTdHlsZXNoZWV0cyA9IDAgPCBzdHlsZVF1ZXVlLnNoZWV0cy5zaXplO1xuICAgICAgc3R5bGVRdWV1ZS5zaGVldHMuZm9yRWFjaChmbHVzaFN0eWxlSW5QcmVhbWJsZSwgdGhpcyk7XG4gICAgICBzdHlsZVF1ZXVlLnNoZWV0cy5jbGVhcigpO1xuICAgICAgdmFyIHJ1bGVzID0gc3R5bGVRdWV1ZS5ydWxlcyxcbiAgICAgICAgaHJlZnMgPSBzdHlsZVF1ZXVlLmhyZWZzO1xuICAgICAgaWYgKCFoYXNTdHlsZXNoZWV0cyB8fCBocmVmcy5sZW5ndGgpIHtcbiAgICAgICAgd3JpdGVDaHVuayh0aGlzLCBjdXJyZW50bHlGbHVzaGluZ1JlbmRlclN0YXRlLnN0YXJ0SW5saW5lU3R5bGUpO1xuICAgICAgICB3cml0ZUNodW5rKHRoaXMsIHN0eWxlVGFnUmVzb3VyY2VPcGVuMSk7XG4gICAgICAgIHdyaXRlQ2h1bmsodGhpcywgc3R5bGVRdWV1ZS5wcmVjZWRlbmNlKTtcbiAgICAgICAgc3R5bGVRdWV1ZSA9IDA7XG4gICAgICAgIGlmIChocmVmcy5sZW5ndGgpIHtcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgd3JpdGVDaHVuayh0aGlzLCBzdHlsZVRhZ1Jlc291cmNlT3BlbjIpO1xuICAgICAgICAgICAgc3R5bGVRdWV1ZSA8IGhyZWZzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBzdHlsZVF1ZXVlKytcbiAgICAgICAgICApXG4gICAgICAgICAgICB3cml0ZUNodW5rKHRoaXMsIGhyZWZzW3N0eWxlUXVldWVdKSxcbiAgICAgICAgICAgICAgd3JpdGVDaHVuayh0aGlzLCBzcGFjZVNlcGFyYXRvcik7XG4gICAgICAgICAgd3JpdGVDaHVuayh0aGlzLCBocmVmc1tzdHlsZVF1ZXVlXSk7XG4gICAgICAgIH1cbiAgICAgICAgd3JpdGVDaHVuayh0aGlzLCBzdHlsZVRhZ1Jlc291cmNlT3BlbjMpO1xuICAgICAgICBmb3IgKHN0eWxlUXVldWUgPSAwOyBzdHlsZVF1ZXVlIDwgcnVsZXMubGVuZ3RoOyBzdHlsZVF1ZXVlKyspXG4gICAgICAgICAgd3JpdGVDaHVuayh0aGlzLCBydWxlc1tzdHlsZVF1ZXVlXSk7XG4gICAgICAgIHdyaXRlQ2h1bmsodGhpcywgc3R5bGVUYWdSZXNvdXJjZUNsb3NlKTtcbiAgICAgICAgcnVsZXMubGVuZ3RoID0gMDtcbiAgICAgICAgaHJlZnMubGVuZ3RoID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcHJlbG9hZExhdGVTdHlsZShzdHlsZXNoZWV0KSB7XG4gICAgICBpZiAoc3R5bGVzaGVldC5zdGF0ZSA9PT0gUEVORElORyQxKSB7XG4gICAgICAgIHN0eWxlc2hlZXQuc3RhdGUgPSBQUkVMT0FERUQ7XG4gICAgICAgIHZhciBwcm9wcyA9IHN0eWxlc2hlZXQucHJvcHM7XG4gICAgICAgIHB1c2hMaW5rSW1wbChzdHlsZXNoZWV0Rmx1c2hpbmdRdWV1ZSwge1xuICAgICAgICAgIHJlbDogXCJwcmVsb2FkXCIsXG4gICAgICAgICAgYXM6IFwic3R5bGVcIixcbiAgICAgICAgICBocmVmOiBzdHlsZXNoZWV0LnByb3BzLmhyZWYsXG4gICAgICAgICAgY3Jvc3NPcmlnaW46IHByb3BzLmNyb3NzT3JpZ2luLFxuICAgICAgICAgIGZldGNoUHJpb3JpdHk6IHByb3BzLmZldGNoUHJpb3JpdHksXG4gICAgICAgICAgaW50ZWdyaXR5OiBwcm9wcy5pbnRlZ3JpdHksXG4gICAgICAgICAgbWVkaWE6IHByb3BzLm1lZGlhLFxuICAgICAgICAgIGhyZWZMYW5nOiBwcm9wcy5ocmVmTGFuZyxcbiAgICAgICAgICByZWZlcnJlclBvbGljeTogcHJvcHMucmVmZXJyZXJQb2xpY3lcbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgc3R5bGVzaGVldCA9IDA7XG4gICAgICAgICAgc3R5bGVzaGVldCA8IHN0eWxlc2hlZXRGbHVzaGluZ1F1ZXVlLmxlbmd0aDtcbiAgICAgICAgICBzdHlsZXNoZWV0KytcbiAgICAgICAgKVxuICAgICAgICAgIHdyaXRlQ2h1bmsodGhpcywgc3R5bGVzaGVldEZsdXNoaW5nUXVldWVbc3R5bGVzaGVldF0pO1xuICAgICAgICBzdHlsZXNoZWV0Rmx1c2hpbmdRdWV1ZS5sZW5ndGggPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwcmVsb2FkTGF0ZVN0eWxlcyhzdHlsZVF1ZXVlKSB7XG4gICAgICBzdHlsZVF1ZXVlLnNoZWV0cy5mb3JFYWNoKHByZWxvYWRMYXRlU3R5bGUsIHRoaXMpO1xuICAgICAgc3R5bGVRdWV1ZS5zaGVldHMuY2xlYXIoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaENvbXBsZXRlZFNoZWxsSWRBdHRyaWJ1dGUodGFyZ2V0LCByZXN1bWFibGVTdGF0ZSkge1xuICAgICAgKHJlc3VtYWJsZVN0YXRlLmluc3RydWN0aW9ucyAmIFNlbnRDb21wbGV0ZWRTaGVsbElkKSA9PT0gTm90aGluZ1NlbnQgJiZcbiAgICAgICAgKChyZXN1bWFibGVTdGF0ZS5pbnN0cnVjdGlvbnMgfD0gU2VudENvbXBsZXRlZFNoZWxsSWQpLFxuICAgICAgICB0YXJnZXQucHVzaChcbiAgICAgICAgICBjb21wbGV0ZWRTaGVsbElkQXR0cmlidXRlU3RhcnQsXG4gICAgICAgICAgc3RyaW5nVG9DaHVuayhcbiAgICAgICAgICAgIGVzY2FwZVRleHRGb3JCcm93c2VyKFwiX1wiICsgcmVzdW1hYmxlU3RhdGUuaWRQcmVmaXggKyBcIlJfXCIpXG4gICAgICAgICAgKSxcbiAgICAgICAgICBhdHRyaWJ1dGVFbmRcbiAgICAgICAgKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdyaXRlU3R5bGVSZXNvdXJjZURlcGVuZGVuY2llc0luSlMoZGVzdGluYXRpb24sIGhvaXN0YWJsZVN0YXRlKSB7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBhcnJheUZpcnN0T3BlbkJyYWNrZXQpO1xuICAgICAgdmFyIG5leHRBcnJheU9wZW5CcmFja0NodW5rID0gYXJyYXlGaXJzdE9wZW5CcmFja2V0O1xuICAgICAgaG9pc3RhYmxlU3RhdGUuc3R5bGVzaGVldHMuZm9yRWFjaChmdW5jdGlvbiAocmVzb3VyY2UpIHtcbiAgICAgICAgaWYgKHJlc291cmNlLnN0YXRlICE9PSBQUkVBTUJMRSlcbiAgICAgICAgICBpZiAocmVzb3VyY2Uuc3RhdGUgPT09IExBVEUpXG4gICAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBuZXh0QXJyYXlPcGVuQnJhY2tDaHVuayksXG4gICAgICAgICAgICAgIChyZXNvdXJjZSA9IHJlc291cmNlLnByb3BzLmhyZWYpLFxuICAgICAgICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHJlc291cmNlLCBcImhyZWZcIiksXG4gICAgICAgICAgICAgIHdyaXRlQ2h1bmsoXG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb24sXG4gICAgICAgICAgICAgICAgc3RyaW5nVG9DaHVuayhcbiAgICAgICAgICAgICAgICAgIGVzY2FwZUpTT2JqZWN0Rm9ySW5zdHJ1Y3Rpb25TY3JpcHRzKFwiXCIgKyByZXNvdXJjZSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGFycmF5Q2xvc2VCcmFja2V0KSxcbiAgICAgICAgICAgICAgKG5leHRBcnJheU9wZW5CcmFja0NodW5rID0gYXJyYXlTdWJzZXF1ZW50T3BlbkJyYWNrZXQpO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgbmV4dEFycmF5T3BlbkJyYWNrQ2h1bmspO1xuICAgICAgICAgICAgdmFyIHByZWNlZGVuY2UgPSByZXNvdXJjZS5wcm9wc1tcImRhdGEtcHJlY2VkZW5jZVwiXSxcbiAgICAgICAgICAgICAgcHJvcHMgPSByZXNvdXJjZS5wcm9wcyxcbiAgICAgICAgICAgICAgY29lcmNlZEhyZWYgPSBzYW5pdGl6ZVVSTChcIlwiICsgcmVzb3VyY2UucHJvcHMuaHJlZik7XG4gICAgICAgICAgICB3cml0ZUNodW5rKFxuICAgICAgICAgICAgICBkZXN0aW5hdGlvbixcbiAgICAgICAgICAgICAgc3RyaW5nVG9DaHVuayhlc2NhcGVKU09iamVjdEZvckluc3RydWN0aW9uU2NyaXB0cyhjb2VyY2VkSHJlZikpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbihwcmVjZWRlbmNlLCBcInByZWNlZGVuY2VcIik7XG4gICAgICAgICAgICBwcmVjZWRlbmNlID0gXCJcIiArIHByZWNlZGVuY2U7XG4gICAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBhcnJheUludGVyc3RpdGlhbCk7XG4gICAgICAgICAgICB3cml0ZUNodW5rKFxuICAgICAgICAgICAgICBkZXN0aW5hdGlvbixcbiAgICAgICAgICAgICAgc3RyaW5nVG9DaHVuayhlc2NhcGVKU09iamVjdEZvckluc3RydWN0aW9uU2NyaXB0cyhwcmVjZWRlbmNlKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKVxuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkgJiZcbiAgICAgICAgICAgICAgICAoKHByZWNlZGVuY2UgPSBwcm9wc1twcm9wS2V5XSksIG51bGwgIT0gcHJlY2VkZW5jZSlcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImhyZWZcIjpcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJyZWxcIjpcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJwcmVjZWRlbmNlXCI6XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZGF0YS1wcmVjZWRlbmNlXCI6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgXCJsaW5rIGlzIGEgc2VsZi1jbG9zaW5nIHRhZyBhbmQgbXVzdCBuZWl0aGVyIGhhdmUgYGNoaWxkcmVuYCBub3IgdXNlIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuXCJcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlU3R5bGVSZXNvdXJjZUF0dHJpYnV0ZUluSlMoXG4gICAgICAgICAgICAgICAgICAgICAgZGVzdGluYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcEtleSxcbiAgICAgICAgICAgICAgICAgICAgICBwcmVjZWRlbmNlXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgYXJyYXlDbG9zZUJyYWNrZXQpO1xuICAgICAgICAgICAgbmV4dEFycmF5T3BlbkJyYWNrQ2h1bmsgPSBhcnJheVN1YnNlcXVlbnRPcGVuQnJhY2tldDtcbiAgICAgICAgICAgIHJlc291cmNlLnN0YXRlID0gTEFURTtcbiAgICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGFycmF5Q2xvc2VCcmFja2V0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd3JpdGVTdHlsZVJlc291cmNlQXR0cmlidXRlSW5KUyhkZXN0aW5hdGlvbiwgbmFtZSwgdmFsdWUpIHtcbiAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgY2FzZSBcImlubmVySFRNTFwiOlxuICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgY2FzZSBcInN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZ1wiOlxuICAgICAgICBjYXNlIFwic3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nXCI6XG4gICAgICAgIGNhc2UgXCJzdHlsZVwiOlxuICAgICAgICBjYXNlIFwicmVmXCI6XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlIFwiY2xhc3NOYW1lXCI6XG4gICAgICAgICAgYXR0cmlidXRlTmFtZSA9IFwiY2xhc3NcIjtcbiAgICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlLCBhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgICBuYW1lID0gXCJcIiArIHZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiaGlkZGVuXCI6XG4gICAgICAgICAgaWYgKCExID09PSB2YWx1ZSkgcmV0dXJuO1xuICAgICAgICAgIG5hbWUgPSBcIlwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic3JjXCI6XG4gICAgICAgIGNhc2UgXCJocmVmXCI6XG4gICAgICAgICAgdmFsdWUgPSBzYW5pdGl6ZVVSTCh2YWx1ZSk7XG4gICAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbih2YWx1ZSwgYXR0cmlidXRlTmFtZSk7XG4gICAgICAgICAgbmFtZSA9IFwiXCIgKyB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAoMiA8IG5hbWUubGVuZ3RoICYmXG4gICAgICAgICAgICAgIChcIm9cIiA9PT0gbmFtZVswXSB8fCBcIk9cIiA9PT0gbmFtZVswXSkgJiZcbiAgICAgICAgICAgICAgKFwiblwiID09PSBuYW1lWzFdIHx8IFwiTlwiID09PSBuYW1lWzFdKSkgfHxcbiAgICAgICAgICAgICFpc0F0dHJpYnV0ZU5hbWVTYWZlKG5hbWUpXG4gICAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24odmFsdWUsIGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICAgIG5hbWUgPSBcIlwiICsgdmFsdWU7XG4gICAgICB9XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBhcnJheUludGVyc3RpdGlhbCk7XG4gICAgICB3cml0ZUNodW5rKFxuICAgICAgICBkZXN0aW5hdGlvbixcbiAgICAgICAgc3RyaW5nVG9DaHVuayhlc2NhcGVKU09iamVjdEZvckluc3RydWN0aW9uU2NyaXB0cyhhdHRyaWJ1dGVOYW1lKSlcbiAgICAgICk7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBhcnJheUludGVyc3RpdGlhbCk7XG4gICAgICB3cml0ZUNodW5rKFxuICAgICAgICBkZXN0aW5hdGlvbixcbiAgICAgICAgc3RyaW5nVG9DaHVuayhlc2NhcGVKU09iamVjdEZvckluc3RydWN0aW9uU2NyaXB0cyhuYW1lKSlcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUhvaXN0YWJsZVN0YXRlKCkge1xuICAgICAgcmV0dXJuIHsgc3R5bGVzOiBuZXcgU2V0KCksIHN0eWxlc2hlZXRzOiBuZXcgU2V0KCksIHN1c3BlbnNleUltYWdlczogITEgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJlbG9hZEJvb3RzdHJhcFNjcmlwdE9yTW9kdWxlKFxuICAgICAgcmVzdW1hYmxlU3RhdGUsXG4gICAgICByZW5kZXJTdGF0ZSxcbiAgICAgIGhyZWYsXG4gICAgICBwcm9wc1xuICAgICkge1xuICAgICAgKHJlc3VtYWJsZVN0YXRlLnNjcmlwdFJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShocmVmKSB8fFxuICAgICAgICByZXN1bWFibGVTdGF0ZS5tb2R1bGVTY3JpcHRSZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoaHJlZikpICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgJ0ludGVybmFsIFJlYWN0IEVycm9yOiBSZWFjdCBleHBlY3RlZCBib290c3RyYXAgc2NyaXB0IG9yIG1vZHVsZSB3aXRoIHNyYyBcIiVzXCIgdG8gbm90IGhhdmUgYmVlbiBwcmVsb2FkZWQgYWxyZWFkeS4gcGxlYXNlIGZpbGUgYW4gaXNzdWUnLFxuICAgICAgICAgIGhyZWZcbiAgICAgICAgKTtcbiAgICAgIHJlc3VtYWJsZVN0YXRlLnNjcmlwdFJlc291cmNlc1tocmVmXSA9IEVYSVNUUztcbiAgICAgIHJlc3VtYWJsZVN0YXRlLm1vZHVsZVNjcmlwdFJlc291cmNlc1tocmVmXSA9IEVYSVNUUztcbiAgICAgIHJlc3VtYWJsZVN0YXRlID0gW107XG4gICAgICBwdXNoTGlua0ltcGwocmVzdW1hYmxlU3RhdGUsIHByb3BzKTtcbiAgICAgIHJlbmRlclN0YXRlLmJvb3RzdHJhcFNjcmlwdHMuYWRkKHJlc3VtYWJsZVN0YXRlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWRvcHRQcmVsb2FkQ3JlZGVudGlhbHModGFyZ2V0LCBwcmVsb2FkU3RhdGUpIHtcbiAgICAgIG51bGwgPT0gdGFyZ2V0LmNyb3NzT3JpZ2luICYmICh0YXJnZXQuY3Jvc3NPcmlnaW4gPSBwcmVsb2FkU3RhdGVbMF0pO1xuICAgICAgbnVsbCA9PSB0YXJnZXQuaW50ZWdyaXR5ICYmICh0YXJnZXQuaW50ZWdyaXR5ID0gcHJlbG9hZFN0YXRlWzFdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0UHJlbG9hZEFzSGVhZGVyKGhyZWYsIGFzLCBwYXJhbXMpIHtcbiAgICAgIGhyZWYgPSBlc2NhcGVIcmVmRm9yTGlua0hlYWRlclVSTENvbnRleHQoaHJlZik7XG4gICAgICBhcyA9IGVzY2FwZVN0cmluZ0ZvckxpbmtIZWFkZXJRdW90ZWRQYXJhbVZhbHVlQ29udGV4dChhcywgXCJhc1wiKTtcbiAgICAgIGFzID0gXCI8XCIgKyBocmVmICsgJz47IHJlbD1wcmVsb2FkOyBhcz1cIicgKyBhcyArICdcIic7XG4gICAgICBmb3IgKHZhciBwYXJhbU5hbWUgaW4gcGFyYW1zKVxuICAgICAgICBoYXNPd25Qcm9wZXJ0eS5jYWxsKHBhcmFtcywgcGFyYW1OYW1lKSAmJlxuICAgICAgICAgICgoaHJlZiA9IHBhcmFtc1twYXJhbU5hbWVdKSxcbiAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgaHJlZiAmJlxuICAgICAgICAgICAgKGFzICs9XG4gICAgICAgICAgICAgIFwiOyBcIiArXG4gICAgICAgICAgICAgIHBhcmFtTmFtZS50b0xvd2VyQ2FzZSgpICtcbiAgICAgICAgICAgICAgJz1cIicgK1xuICAgICAgICAgICAgICBlc2NhcGVTdHJpbmdGb3JMaW5rSGVhZGVyUXVvdGVkUGFyYW1WYWx1ZUNvbnRleHQoXG4gICAgICAgICAgICAgICAgaHJlZixcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWVcbiAgICAgICAgICAgICAgKSArXG4gICAgICAgICAgICAgICdcIicpKTtcbiAgICAgIHJldHVybiBhcztcbiAgICB9XG4gICAgZnVuY3Rpb24gZXNjYXBlSHJlZkZvckxpbmtIZWFkZXJVUkxDb250ZXh0KGhyZWZJbnB1dCkge1xuICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbihocmVmSW5wdXQsIFwiaHJlZlwiKTtcbiAgICAgIHJldHVybiAoXCJcIiArIGhyZWZJbnB1dCkucmVwbGFjZShcbiAgICAgICAgcmVnZXhGb3JIcmVmSW5MaW5rSGVhZGVyVVJMQ29udGV4dCxcbiAgICAgICAgZXNjYXBlSHJlZkZvckxpbmtIZWFkZXJVUkxDb250ZXh0UmVwbGFjZXJcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVzY2FwZUhyZWZGb3JMaW5rSGVhZGVyVVJMQ29udGV4dFJlcGxhY2VyKG1hdGNoKSB7XG4gICAgICBzd2l0Y2ggKG1hdGNoKSB7XG4gICAgICAgIGNhc2UgXCI8XCI6XG4gICAgICAgICAgcmV0dXJuIFwiJTNDXCI7XG4gICAgICAgIGNhc2UgXCI+XCI6XG4gICAgICAgICAgcmV0dXJuIFwiJTNFXCI7XG4gICAgICAgIGNhc2UgXCJcXG5cIjpcbiAgICAgICAgICByZXR1cm4gXCIlMEFcIjtcbiAgICAgICAgY2FzZSBcIlxcclwiOlxuICAgICAgICAgIHJldHVybiBcIiUwRFwiO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJlc2NhcGVMaW5rSHJlZkZvckhlYWRlckNvbnRleHRSZXBsYWNlciBlbmNvdW50ZXJlZCBhIG1hdGNoIGl0IGRvZXMgbm90IGtub3cgaG93IHRvIHJlcGxhY2UuIHRoaXMgbWVhbnMgdGhlIG1hdGNoIHJlZ2V4IGFuZCB0aGUgcmVwbGFjZW1lbnQgY2hhcmFjdGVycyBhcmUgbm8gbG9uZ2VyIGluIHN5bmMuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3RcIlxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVzY2FwZVN0cmluZ0ZvckxpbmtIZWFkZXJRdW90ZWRQYXJhbVZhbHVlQ29udGV4dCh2YWx1ZSwgbmFtZSkge1xuICAgICAgd2lsbENvZXJjaW9uVGhyb3codmFsdWUpICYmXG4gICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiVGhlIHByb3ZpZGVkIGAlc2Agb3B0aW9uIGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSB1c2luZyBpdCBoZXJlLlwiLFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgdHlwZU5hbWUodmFsdWUpXG4gICAgICAgICksXG4gICAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSkpO1xuICAgICAgcmV0dXJuIChcIlwiICsgdmFsdWUpLnJlcGxhY2UoXG4gICAgICAgIHJlZ2V4Rm9yTGlua0hlYWRlclF1b3RlZFBhcmFtVmFsdWVDb250ZXh0LFxuICAgICAgICBlc2NhcGVTdHJpbmdGb3JMaW5rSGVhZGVyUXVvdGVkUGFyYW1WYWx1ZUNvbnRleHRSZXBsYWNlclxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZXNjYXBlU3RyaW5nRm9yTGlua0hlYWRlclF1b3RlZFBhcmFtVmFsdWVDb250ZXh0UmVwbGFjZXIobWF0Y2gpIHtcbiAgICAgIHN3aXRjaCAobWF0Y2gpIHtcbiAgICAgICAgY2FzZSAnXCInOlxuICAgICAgICAgIHJldHVybiBcIiUyMlwiO1xuICAgICAgICBjYXNlIFwiJ1wiOlxuICAgICAgICAgIHJldHVybiBcIiUyN1wiO1xuICAgICAgICBjYXNlIFwiO1wiOlxuICAgICAgICAgIHJldHVybiBcIiUzQlwiO1xuICAgICAgICBjYXNlIFwiLFwiOlxuICAgICAgICAgIHJldHVybiBcIiUyQ1wiO1xuICAgICAgICBjYXNlIFwiXFxuXCI6XG4gICAgICAgICAgcmV0dXJuIFwiJTBBXCI7XG4gICAgICAgIGNhc2UgXCJcXHJcIjpcbiAgICAgICAgICByZXR1cm4gXCIlMERcIjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiZXNjYXBlU3RyaW5nRm9yTGlua0hlYWRlclF1b3RlZFBhcmFtVmFsdWVDb250ZXh0UmVwbGFjZXIgZW5jb3VudGVyZWQgYSBtYXRjaCBpdCBkb2VzIG5vdCBrbm93IGhvdyB0byByZXBsYWNlLiB0aGlzIG1lYW5zIHRoZSBtYXRjaCByZWdleCBhbmQgdGhlIHJlcGxhY2VtZW50IGNoYXJhY3RlcnMgYXJlIG5vIGxvbmdlciBpbiBzeW5jLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0XCJcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBob2lzdFN0eWxlUXVldWVEZXBlbmRlbmN5KHN0eWxlUXVldWUpIHtcbiAgICAgIHRoaXMuc3R5bGVzLmFkZChzdHlsZVF1ZXVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaG9pc3RTdHlsZXNoZWV0RGVwZW5kZW5jeShzdHlsZXNoZWV0KSB7XG4gICAgICB0aGlzLnN0eWxlc2hlZXRzLmFkZChzdHlsZXNoZWV0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaG9pc3RIb2lzdGFibGVzKHBhcmVudFN0YXRlLCBjaGlsZFN0YXRlKSB7XG4gICAgICBjaGlsZFN0YXRlLnN0eWxlcy5mb3JFYWNoKGhvaXN0U3R5bGVRdWV1ZURlcGVuZGVuY3ksIHBhcmVudFN0YXRlKTtcbiAgICAgIGNoaWxkU3RhdGUuc3R5bGVzaGVldHMuZm9yRWFjaChob2lzdFN0eWxlc2hlZXREZXBlbmRlbmN5LCBwYXJlbnRTdGF0ZSk7XG4gICAgICBjaGlsZFN0YXRlLnN1c3BlbnNleUltYWdlcyAmJiAocGFyZW50U3RhdGUuc3VzcGVuc2V5SW1hZ2VzID0gITApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYXNTdXNwZW5zZXlDb250ZW50KGhvaXN0YWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICAwIDwgaG9pc3RhYmxlU3RhdGUuc3R5bGVzaGVldHMuc2l6ZSB8fCBob2lzdGFibGVTdGF0ZS5zdXNwZW5zZXlJbWFnZXNcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB7XG4gICAgICBpZiAobnVsbCA9PSB0eXBlKSByZXR1cm4gbnVsbDtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlKVxuICAgICAgICByZXR1cm4gdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRVxuICAgICAgICAgID8gbnVsbFxuICAgICAgICAgIDogdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgdHlwZSkgcmV0dXJuIHR5cGU7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIkZyYWdtZW50XCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJQcm9maWxlclwiO1xuICAgICAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiU3RyaWN0TW9kZVwiO1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VMaXN0XCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfQUNUSVZJVFlfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJBY3Rpdml0eVwiO1xuICAgICAgfVxuICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiB0eXBlKVxuICAgICAgICBzd2l0Y2ggKFxuICAgICAgICAgIChcIm51bWJlclwiID09PSB0eXBlb2YgdHlwZS50YWcgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICB0eXBlLiQkdHlwZW9mKVxuICAgICAgICApIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIFwiUG9ydGFsXCI7XG4gICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIjtcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTlNVTUVSX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKHR5cGUuX2NvbnRleHQuZGlzcGxheU5hbWUgfHwgXCJDb250ZXh0XCIpICsgXCIuQ29uc3VtZXJcIjtcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICB2YXIgaW5uZXJUeXBlID0gdHlwZS5yZW5kZXI7XG4gICAgICAgICAgICB0eXBlID0gdHlwZS5kaXNwbGF5TmFtZTtcbiAgICAgICAgICAgIHR5cGUgfHxcbiAgICAgICAgICAgICAgKCh0eXBlID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8IFwiXCIpLFxuICAgICAgICAgICAgICAodHlwZSA9IFwiXCIgIT09IHR5cGUgPyBcIkZvcndhcmRSZWYoXCIgKyB0eXBlICsgXCIpXCIgOiBcIkZvcndhcmRSZWZcIikpO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAoaW5uZXJUeXBlID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsKSxcbiAgICAgICAgICAgICAgbnVsbCAhPT0gaW5uZXJUeXBlXG4gICAgICAgICAgICAgICAgPyBpbm5lclR5cGVcbiAgICAgICAgICAgICAgICA6IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8IFwiTWVtb1wiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgaW5uZXJUeXBlID0gdHlwZS5fcGF5bG9hZDtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLl9pbml0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKGlubmVyVHlwZSkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvcFRvTmVhcmVzdENvbW1vbkFuY2VzdG9yKHByZXYsIG5leHQpIHtcbiAgICAgIGlmIChwcmV2ICE9PSBuZXh0KSB7XG4gICAgICAgIHByZXYuY29udGV4dC5fY3VycmVudFZhbHVlID0gcHJldi5wYXJlbnRWYWx1ZTtcbiAgICAgICAgcHJldiA9IHByZXYucGFyZW50O1xuICAgICAgICB2YXIgcGFyZW50TmV4dCA9IG5leHQucGFyZW50O1xuICAgICAgICBpZiAobnVsbCA9PT0gcHJldikge1xuICAgICAgICAgIGlmIChudWxsICE9PSBwYXJlbnROZXh0KVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgIFwiVGhlIHN0YWNrcyBtdXN0IHJlYWNoIHRoZSByb290IGF0IHRoZSBzYW1lIHRpbWUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKG51bGwgPT09IHBhcmVudE5leHQpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgXCJUaGUgc3RhY2tzIG11c3QgcmVhY2ggdGhlIHJvb3QgYXQgdGhlIHNhbWUgdGltZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBwb3BUb05lYXJlc3RDb21tb25BbmNlc3RvcihwcmV2LCBwYXJlbnROZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBuZXh0LmNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IG5leHQudmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvcEFsbFByZXZpb3VzKHByZXYpIHtcbiAgICAgIHByZXYuY29udGV4dC5fY3VycmVudFZhbHVlID0gcHJldi5wYXJlbnRWYWx1ZTtcbiAgICAgIHByZXYgPSBwcmV2LnBhcmVudDtcbiAgICAgIG51bGwgIT09IHByZXYgJiYgcG9wQWxsUHJldmlvdXMocHJldik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hBbGxOZXh0KG5leHQpIHtcbiAgICAgIHZhciBwYXJlbnROZXh0ID0gbmV4dC5wYXJlbnQ7XG4gICAgICBudWxsICE9PSBwYXJlbnROZXh0ICYmIHB1c2hBbGxOZXh0KHBhcmVudE5leHQpO1xuICAgICAgbmV4dC5jb250ZXh0Ll9jdXJyZW50VmFsdWUgPSBuZXh0LnZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb3BQcmV2aW91c1RvQ29tbW9uTGV2ZWwocHJldiwgbmV4dCkge1xuICAgICAgcHJldi5jb250ZXh0Ll9jdXJyZW50VmFsdWUgPSBwcmV2LnBhcmVudFZhbHVlO1xuICAgICAgcHJldiA9IHByZXYucGFyZW50O1xuICAgICAgaWYgKG51bGwgPT09IHByZXYpXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiVGhlIGRlcHRoIG11c3QgZXF1YWwgYXQgbGVhc3QgYXQgemVybyBiZWZvcmUgcmVhY2hpbmcgdGhlIHJvb3QuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgKTtcbiAgICAgIHByZXYuZGVwdGggPT09IG5leHQuZGVwdGhcbiAgICAgICAgPyBwb3BUb05lYXJlc3RDb21tb25BbmNlc3RvcihwcmV2LCBuZXh0KVxuICAgICAgICA6IHBvcFByZXZpb3VzVG9Db21tb25MZXZlbChwcmV2LCBuZXh0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9wTmV4dFRvQ29tbW9uTGV2ZWwocHJldiwgbmV4dCkge1xuICAgICAgdmFyIHBhcmVudE5leHQgPSBuZXh0LnBhcmVudDtcbiAgICAgIGlmIChudWxsID09PSBwYXJlbnROZXh0KVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIlRoZSBkZXB0aCBtdXN0IGVxdWFsIGF0IGxlYXN0IGF0IHplcm8gYmVmb3JlIHJlYWNoaW5nIHRoZSByb290LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICk7XG4gICAgICBwcmV2LmRlcHRoID09PSBwYXJlbnROZXh0LmRlcHRoXG4gICAgICAgID8gcG9wVG9OZWFyZXN0Q29tbW9uQW5jZXN0b3IocHJldiwgcGFyZW50TmV4dClcbiAgICAgICAgOiBwb3BOZXh0VG9Db21tb25MZXZlbChwcmV2LCBwYXJlbnROZXh0KTtcbiAgICAgIG5leHQuY29udGV4dC5fY3VycmVudFZhbHVlID0gbmV4dC52YWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3dpdGNoQ29udGV4dChuZXdTbmFwc2hvdCkge1xuICAgICAgdmFyIHByZXYgPSBjdXJyZW50QWN0aXZlU25hcHNob3Q7XG4gICAgICBwcmV2ICE9PSBuZXdTbmFwc2hvdCAmJlxuICAgICAgICAobnVsbCA9PT0gcHJldlxuICAgICAgICAgID8gcHVzaEFsbE5leHQobmV3U25hcHNob3QpXG4gICAgICAgICAgOiBudWxsID09PSBuZXdTbmFwc2hvdFxuICAgICAgICAgICAgPyBwb3BBbGxQcmV2aW91cyhwcmV2KVxuICAgICAgICAgICAgOiBwcmV2LmRlcHRoID09PSBuZXdTbmFwc2hvdC5kZXB0aFxuICAgICAgICAgICAgICA/IHBvcFRvTmVhcmVzdENvbW1vbkFuY2VzdG9yKHByZXYsIG5ld1NuYXBzaG90KVxuICAgICAgICAgICAgICA6IHByZXYuZGVwdGggPiBuZXdTbmFwc2hvdC5kZXB0aFxuICAgICAgICAgICAgICAgID8gcG9wUHJldmlvdXNUb0NvbW1vbkxldmVsKHByZXYsIG5ld1NuYXBzaG90KVxuICAgICAgICAgICAgICAgIDogcG9wTmV4dFRvQ29tbW9uTGV2ZWwocHJldiwgbmV3U25hcHNob3QpLFxuICAgICAgICAoY3VycmVudEFjdGl2ZVNuYXBzaG90ID0gbmV3U25hcHNob3QpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrKSB7XG4gICAgICBpZiAobnVsbCAhPT0gY2FsbGJhY2sgJiYgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGtleSA9IFN0cmluZyhjYWxsYmFjayk7XG4gICAgICAgIGRpZFdhcm5PbkludmFsaWRDYWxsYmFjay5oYXMoa2V5KSB8fFxuICAgICAgICAgIChkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2suYWRkKGtleSksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiRXhwZWN0ZWQgdGhlIGxhc3Qgb3B0aW9uYWwgYGNhbGxiYWNrYCBhcmd1bWVudCB0byBiZSBhIGZ1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy5cIixcbiAgICAgICAgICAgIGNhbGxiYWNrXG4gICAgICAgICAgKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XG4gICAgICBwdWJsaWNJbnN0YW5jZSA9XG4gICAgICAgICgocHVibGljSW5zdGFuY2UgPSBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3RvcikgJiZcbiAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUocHVibGljSW5zdGFuY2UpKSB8fFxuICAgICAgICBcIlJlYWN0Q2xhc3NcIjtcbiAgICAgIHZhciB3YXJuaW5nS2V5ID0gcHVibGljSW5zdGFuY2UgKyBcIi5cIiArIGNhbGxlck5hbWU7XG4gICAgICBkaWRXYXJuQWJvdXROb29wVXBkYXRlRm9yQ29tcG9uZW50W3dhcm5pbmdLZXldIHx8XG4gICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiQ2FuIG9ubHkgdXBkYXRlIGEgbW91bnRpbmcgY29tcG9uZW50LiBUaGlzIHVzdWFsbHkgbWVhbnMgeW91IGNhbGxlZCAlcygpIG91dHNpZGUgY29tcG9uZW50V2lsbE1vdW50KCkgb24gdGhlIHNlcnZlci4gVGhpcyBpcyBhIG5vLW9wLlxcblxcblBsZWFzZSBjaGVjayB0aGUgY29kZSBmb3IgdGhlICVzIGNvbXBvbmVudC5cIixcbiAgICAgICAgICBjYWxsZXJOYW1lLFxuICAgICAgICAgIHB1YmxpY0luc3RhbmNlXG4gICAgICAgICksXG4gICAgICAgIChkaWRXYXJuQWJvdXROb29wVXBkYXRlRm9yQ29tcG9uZW50W3dhcm5pbmdLZXldID0gITApKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaFRyZWVDb250ZXh0KGJhc2VDb250ZXh0LCB0b3RhbENoaWxkcmVuLCBpbmRleCkge1xuICAgICAgdmFyIGJhc2VJZFdpdGhMZWFkaW5nQml0ID0gYmFzZUNvbnRleHQuaWQ7XG4gICAgICBiYXNlQ29udGV4dCA9IGJhc2VDb250ZXh0Lm92ZXJmbG93O1xuICAgICAgdmFyIGJhc2VMZW5ndGggPSAzMiAtIGNsejMyKGJhc2VJZFdpdGhMZWFkaW5nQml0KSAtIDE7XG4gICAgICBiYXNlSWRXaXRoTGVhZGluZ0JpdCAmPSB+KDEgPDwgYmFzZUxlbmd0aCk7XG4gICAgICBpbmRleCArPSAxO1xuICAgICAgdmFyIGxlbmd0aCA9IDMyIC0gY2x6MzIodG90YWxDaGlsZHJlbikgKyBiYXNlTGVuZ3RoO1xuICAgICAgaWYgKDMwIDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBudW1iZXJPZk92ZXJmbG93Qml0cyA9IGJhc2VMZW5ndGggLSAoYmFzZUxlbmd0aCAlIDUpO1xuICAgICAgICBsZW5ndGggPSAoXG4gICAgICAgICAgYmFzZUlkV2l0aExlYWRpbmdCaXQgJlxuICAgICAgICAgICgoMSA8PCBudW1iZXJPZk92ZXJmbG93Qml0cykgLSAxKVxuICAgICAgICApLnRvU3RyaW5nKDMyKTtcbiAgICAgICAgYmFzZUlkV2l0aExlYWRpbmdCaXQgPj49IG51bWJlck9mT3ZlcmZsb3dCaXRzO1xuICAgICAgICBiYXNlTGVuZ3RoIC09IG51bWJlck9mT3ZlcmZsb3dCaXRzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlkOlxuICAgICAgICAgICAgKDEgPDwgKDMyIC0gY2x6MzIodG90YWxDaGlsZHJlbikgKyBiYXNlTGVuZ3RoKSkgfFxuICAgICAgICAgICAgKGluZGV4IDw8IGJhc2VMZW5ndGgpIHxcbiAgICAgICAgICAgIGJhc2VJZFdpdGhMZWFkaW5nQml0LFxuICAgICAgICAgIG92ZXJmbG93OiBsZW5ndGggKyBiYXNlQ29udGV4dFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6ICgxIDw8IGxlbmd0aCkgfCAoaW5kZXggPDwgYmFzZUxlbmd0aCkgfCBiYXNlSWRXaXRoTGVhZGluZ0JpdCxcbiAgICAgICAgb3ZlcmZsb3c6IGJhc2VDb250ZXh0XG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbHozMkZhbGxiYWNrKHgpIHtcbiAgICAgIHggPj4+PSAwO1xuICAgICAgcmV0dXJuIDAgPT09IHggPyAzMiA6ICgzMSAtICgobG9nKHgpIC8gTE4yKSB8IDApKSB8IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vb3AoKSB7fVxuICAgIGZ1bmN0aW9uIHRyYWNrVXNlZFRoZW5hYmxlKHRoZW5hYmxlU3RhdGUsIHRoZW5hYmxlLCBpbmRleCkge1xuICAgICAgaW5kZXggPSB0aGVuYWJsZVN0YXRlW2luZGV4XTtcbiAgICAgIHZvaWQgMCA9PT0gaW5kZXhcbiAgICAgICAgPyB0aGVuYWJsZVN0YXRlLnB1c2godGhlbmFibGUpXG4gICAgICAgIDogaW5kZXggIT09IHRoZW5hYmxlICYmICh0aGVuYWJsZS50aGVuKG5vb3AsIG5vb3ApLCAodGhlbmFibGUgPSBpbmRleCkpO1xuICAgICAgc3dpdGNoICh0aGVuYWJsZS5zdGF0dXMpIHtcbiAgICAgICAgY2FzZSBcImZ1bGZpbGxlZFwiOlxuICAgICAgICAgIHJldHVybiB0aGVuYWJsZS52YWx1ZTtcbiAgICAgICAgY2FzZSBcInJlamVjdGVkXCI6XG4gICAgICAgICAgdGhyb3cgdGhlbmFibGUucmVhc29uO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiB0aGVuYWJsZS5zdGF0dXNcbiAgICAgICAgICAgID8gdGhlbmFibGUudGhlbihub29wLCBub29wKVxuICAgICAgICAgICAgOiAoKHRoZW5hYmxlU3RhdGUgPSB0aGVuYWJsZSksXG4gICAgICAgICAgICAgICh0aGVuYWJsZVN0YXRlLnN0YXR1cyA9IFwicGVuZGluZ1wiKSxcbiAgICAgICAgICAgICAgdGhlbmFibGVTdGF0ZS50aGVuKFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChmdWxmaWxsZWRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKFwicGVuZGluZ1wiID09PSB0aGVuYWJsZS5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZ1bGZpbGxlZFRoZW5hYmxlID0gdGhlbmFibGU7XG4gICAgICAgICAgICAgICAgICAgIGZ1bGZpbGxlZFRoZW5hYmxlLnN0YXR1cyA9IFwiZnVsZmlsbGVkXCI7XG4gICAgICAgICAgICAgICAgICAgIGZ1bGZpbGxlZFRoZW5hYmxlLnZhbHVlID0gZnVsZmlsbGVkVmFsdWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChcInBlbmRpbmdcIiA9PT0gdGhlbmFibGUuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWplY3RlZFRoZW5hYmxlID0gdGhlbmFibGU7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdGVkVGhlbmFibGUuc3RhdHVzID0gXCJyZWplY3RlZFwiO1xuICAgICAgICAgICAgICAgICAgICByZWplY3RlZFRoZW5hYmxlLnJlYXNvbiA9IGVycm9yO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgc3dpdGNoICh0aGVuYWJsZS5zdGF0dXMpIHtcbiAgICAgICAgICAgIGNhc2UgXCJmdWxmaWxsZWRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIHRoZW5hYmxlLnZhbHVlO1xuICAgICAgICAgICAgY2FzZSBcInJlamVjdGVkXCI6XG4gICAgICAgICAgICAgIHRocm93IHRoZW5hYmxlLnJlYXNvbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3VzcGVuZGVkVGhlbmFibGUgPSB0aGVuYWJsZTtcbiAgICAgICAgICB0aHJvdyBTdXNwZW5zZUV4Y2VwdGlvbjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0U3VzcGVuZGVkVGhlbmFibGUoKSB7XG4gICAgICBpZiAobnVsbCA9PT0gc3VzcGVuZGVkVGhlbmFibGUpXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiRXhwZWN0ZWQgYSBzdXNwZW5kZWQgdGhlbmFibGUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICk7XG4gICAgICB2YXIgdGhlbmFibGUgPSBzdXNwZW5kZWRUaGVuYWJsZTtcbiAgICAgIHN1c3BlbmRlZFRoZW5hYmxlID0gbnVsbDtcbiAgICAgIHJldHVybiB0aGVuYWJsZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXMoeCwgeSkge1xuICAgICAgcmV0dXJuICh4ID09PSB5ICYmICgwICE9PSB4IHx8IDEgLyB4ID09PSAxIC8geSkpIHx8ICh4ICE9PSB4ICYmIHkgIT09IHkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCkge1xuICAgICAgaWYgKG51bGwgPT09IGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudClcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJJbnZhbGlkIGhvb2sgY2FsbC4gSG9va3MgY2FuIG9ubHkgYmUgY2FsbGVkIGluc2lkZSBvZiB0aGUgYm9keSBvZiBhIGZ1bmN0aW9uIGNvbXBvbmVudC4gVGhpcyBjb3VsZCBoYXBwZW4gZm9yIG9uZSBvZiB0aGUgZm9sbG93aW5nIHJlYXNvbnM6XFxuMS4gWW91IG1pZ2h0IGhhdmUgbWlzbWF0Y2hpbmcgdmVyc2lvbnMgb2YgUmVhY3QgYW5kIHRoZSByZW5kZXJlciAoc3VjaCBhcyBSZWFjdCBET00pXFxuMi4gWW91IG1pZ2h0IGJlIGJyZWFraW5nIHRoZSBSdWxlcyBvZiBIb29rc1xcbjMuIFlvdSBtaWdodCBoYXZlIG1vcmUgdGhhbiBvbmUgY29weSBvZiBSZWFjdCBpbiB0aGUgc2FtZSBhcHBcXG5TZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9pbnZhbGlkLWhvb2stY2FsbCBmb3IgdGlwcyBhYm91dCBob3cgdG8gZGVidWcgYW5kIGZpeCB0aGlzIHByb2JsZW0uXCJcbiAgICAgICAgKTtcbiAgICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiRG8gbm90IGNhbGwgSG9va3MgaW5zaWRlIHVzZUVmZmVjdCguLi4pLCB1c2VNZW1vKC4uLiksIG9yIG90aGVyIGJ1aWx0LWluIEhvb2tzLiBZb3UgY2FuIG9ubHkgY2FsbCBIb29rcyBhdCB0aGUgdG9wIGxldmVsIG9mIHlvdXIgUmVhY3QgZnVuY3Rpb24uIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9ydWxlcy1vZi1ob29rc1wiXG4gICAgICAgICk7XG4gICAgICByZXR1cm4gY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVIb29rKCkge1xuICAgICAgaWYgKDAgPCBudW1iZXJPZlJlUmVuZGVycylcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJSZW5kZXJlZCBtb3JlIGhvb2tzIHRoYW4gZHVyaW5nIHRoZSBwcmV2aW91cyByZW5kZXJcIik7XG4gICAgICByZXR1cm4geyBtZW1vaXplZFN0YXRlOiBudWxsLCBxdWV1ZTogbnVsbCwgbmV4dDogbnVsbCB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKSB7XG4gICAgICBudWxsID09PSB3b3JrSW5Qcm9ncmVzc0hvb2tcbiAgICAgICAgPyBudWxsID09PSBmaXJzdFdvcmtJblByb2dyZXNzSG9va1xuICAgICAgICAgID8gKChpc1JlUmVuZGVyID0gITEpLFxuICAgICAgICAgICAgKGZpcnN0V29ya0luUHJvZ3Jlc3NIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rID0gY3JlYXRlSG9vaygpKSlcbiAgICAgICAgICA6ICgoaXNSZVJlbmRlciA9ICEwKSwgKHdvcmtJblByb2dyZXNzSG9vayA9IGZpcnN0V29ya0luUHJvZ3Jlc3NIb29rKSlcbiAgICAgICAgOiBudWxsID09PSB3b3JrSW5Qcm9ncmVzc0hvb2submV4dFxuICAgICAgICAgID8gKChpc1JlUmVuZGVyID0gITEpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vay5uZXh0ID0gY3JlYXRlSG9vaygpKSlcbiAgICAgICAgICA6ICgoaXNSZVJlbmRlciA9ICEwKSwgKHdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vay5uZXh0KSk7XG4gICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3NIb29rO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRUaGVuYWJsZVN0YXRlQWZ0ZXJTdXNwZW5kaW5nKCkge1xuICAgICAgdmFyIHN0YXRlID0gdGhlbmFibGVTdGF0ZTtcbiAgICAgIHRoZW5hYmxlU3RhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNldEhvb2tzU3RhdGUoKSB7XG4gICAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSAhMTtcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0tleVBhdGggPVxuICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdSZXF1ZXN0ID1cbiAgICAgICAgY3VycmVudGx5UmVuZGVyaW5nVGFzayA9XG4gICAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCA9XG4gICAgICAgICAgbnVsbDtcbiAgICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSAhMTtcbiAgICAgIGZpcnN0V29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcbiAgICAgIG51bWJlck9mUmVSZW5kZXJzID0gMDtcbiAgICAgIHdvcmtJblByb2dyZXNzSG9vayA9IHJlbmRlclBoYXNlVXBkYXRlcyA9IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlYWRDb250ZXh0KGNvbnRleHQpIHtcbiAgICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiQ29udGV4dCBjYW4gb25seSBiZSByZWFkIHdoaWxlIFJlYWN0IGlzIHJlbmRlcmluZy4gSW4gY2xhc3NlcywgeW91IGNhbiByZWFkIGl0IGluIHRoZSByZW5kZXIgbWV0aG9kIG9yIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4gSW4gZnVuY3Rpb24gY29tcG9uZW50cywgeW91IGNhbiByZWFkIGl0IGRpcmVjdGx5IGluIHRoZSBmdW5jdGlvbiBib2R5LCBidXQgbm90IGluc2lkZSBIb29rcyBsaWtlIHVzZVJlZHVjZXIoKSBvciB1c2VNZW1vKCkuXCJcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiBjb250ZXh0Ll9jdXJyZW50VmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJhc2ljU3RhdGVSZWR1Y2VyKHN0YXRlLCBhY3Rpb24pIHtcbiAgICAgIHJldHVybiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBhY3Rpb24gPyBhY3Rpb24oc3RhdGUpIDogYWN0aW9uO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1c2VSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgICAgIHJlZHVjZXIgIT09IGJhc2ljU3RhdGVSZWR1Y2VyICYmIChjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlUmVkdWNlclwiKTtcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCA9IHJlc29sdmVDdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQoKTtcbiAgICAgIHdvcmtJblByb2dyZXNzSG9vayA9IGNyZWF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgaWYgKGlzUmVSZW5kZXIpIHtcbiAgICAgICAgaW5pdCA9IHdvcmtJblByb2dyZXNzSG9vay5xdWV1ZTtcbiAgICAgICAgaW5pdGlhbEFyZyA9IGluaXQuZGlzcGF0Y2g7XG4gICAgICAgIGlmIChudWxsICE9PSByZW5kZXJQaGFzZVVwZGF0ZXMpIHtcbiAgICAgICAgICB2YXIgZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZSA9IHJlbmRlclBoYXNlVXBkYXRlcy5nZXQoaW5pdCk7XG4gICAgICAgICAgaWYgKHZvaWQgMCAhPT0gZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZSkge1xuICAgICAgICAgICAgcmVuZGVyUGhhc2VVcGRhdGVzLmRlbGV0ZShpbml0KTtcbiAgICAgICAgICAgIGluaXQgPSB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgdmFyIGFjdGlvbiA9IGZpcnN0UmVuZGVyUGhhc2VVcGRhdGUuYWN0aW9uO1xuICAgICAgICAgICAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSAhMDtcbiAgICAgICAgICAgICAgaW5pdCA9IHJlZHVjZXIoaW5pdCwgYWN0aW9uKTtcbiAgICAgICAgICAgICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gITE7XG4gICAgICAgICAgICAgIGZpcnN0UmVuZGVyUGhhc2VVcGRhdGUgPSBmaXJzdFJlbmRlclBoYXNlVXBkYXRlLm5leHQ7XG4gICAgICAgICAgICB9IHdoaWxlIChudWxsICE9PSBmaXJzdFJlbmRlclBoYXNlVXBkYXRlKTtcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlID0gaW5pdDtcbiAgICAgICAgICAgIHJldHVybiBbaW5pdCwgaW5pdGlhbEFyZ107XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGUsIGluaXRpYWxBcmddO1xuICAgICAgfVxuICAgICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gITA7XG4gICAgICByZWR1Y2VyID1cbiAgICAgICAgcmVkdWNlciA9PT0gYmFzaWNTdGF0ZVJlZHVjZXJcbiAgICAgICAgICA/IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluaXRpYWxBcmdcbiAgICAgICAgICAgID8gaW5pdGlhbEFyZygpXG4gICAgICAgICAgICA6IGluaXRpYWxBcmdcbiAgICAgICAgICA6IHZvaWQgMCAhPT0gaW5pdFxuICAgICAgICAgICAgPyBpbml0KGluaXRpYWxBcmcpXG4gICAgICAgICAgICA6IGluaXRpYWxBcmc7XG4gICAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSAhMTtcbiAgICAgIHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlID0gcmVkdWNlcjtcbiAgICAgIHJlZHVjZXIgPSB3b3JrSW5Qcm9ncmVzc0hvb2sucXVldWUgPSB7IGxhc3Q6IG51bGwsIGRpc3BhdGNoOiBudWxsIH07XG4gICAgICByZWR1Y2VyID0gcmVkdWNlci5kaXNwYXRjaCA9IGRpc3BhdGNoQWN0aW9uLmJpbmQoXG4gICAgICAgIG51bGwsXG4gICAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCxcbiAgICAgICAgcmVkdWNlclxuICAgICAgKTtcbiAgICAgIHJldHVybiBbd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGUsIHJlZHVjZXJdO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1c2VNZW1vKG5leHRDcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCA9IHJlc29sdmVDdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQoKTtcbiAgICAgIHdvcmtJblByb2dyZXNzSG9vayA9IGNyZWF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgZGVwcyA9IHZvaWQgMCA9PT0gZGVwcyA/IG51bGwgOiBkZXBzO1xuICAgICAgaWYgKG51bGwgIT09IHdvcmtJblByb2dyZXNzSG9vaykge1xuICAgICAgICB2YXIgcHJldlN0YXRlID0gd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIGlmIChudWxsICE9PSBwcmV2U3RhdGUgJiYgbnVsbCAhPT0gZGVwcykge1xuICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSBwcmV2U3RhdGVbMV07XG4gICAgICAgICAgICBpZiAobnVsbCA9PT0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0KVxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiJXMgcmVjZWl2ZWQgYSBmaW5hbCBhcmd1bWVudCBkdXJpbmcgdGhpcyByZW5kZXIsIGJ1dCBub3QgZHVyaW5nIHRoZSBwcmV2aW91cyByZW5kZXIuIEV2ZW4gdGhvdWdoIHRoZSBmaW5hbCBhcmd1bWVudCBpcyBvcHRpb25hbCwgaXRzIHR5cGUgY2Fubm90IGNoYW5nZSBiZXR3ZWVuIHJlbmRlcnMuXCIsXG4gICAgICAgICAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXZcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAoSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITEpO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGRlcHMubGVuZ3RoICE9PSBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiVGhlIGZpbmFsIGFyZ3VtZW50IHBhc3NlZCB0byAlcyBjaGFuZ2VkIHNpemUgYmV0d2VlbiByZW5kZXJzLiBUaGUgb3JkZXIgYW5kIHNpemUgb2YgdGhpcyBhcnJheSBtdXN0IHJlbWFpbiBjb25zdGFudC5cXG5cXG5QcmV2aW91czogJXNcXG5JbmNvbWluZzogJXNcIixcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2LFxuICAgICAgICAgICAgICAgICAgXCJbXCIgKyBkZXBzLmpvaW4oXCIsIFwiKSArIFwiXVwiLFxuICAgICAgICAgICAgICAgICAgXCJbXCIgKyBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQuam9pbihcIiwgXCIpICsgXCJdXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgICAgICBpIDwgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0Lmxlbmd0aCAmJiBpIDwgZGVwcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaSsrXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICBpZiAoIW9iamVjdElzKGRlcHNbaV0sIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdFtpXSkpIHtcbiAgICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICExO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICEwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0KSByZXR1cm4gcHJldlN0YXRlWzBdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSAhMDtcbiAgICAgIG5leHRDcmVhdGUgPSBuZXh0Q3JlYXRlKCk7XG4gICAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSAhMTtcbiAgICAgIHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlID0gW25leHRDcmVhdGUsIGRlcHNdO1xuICAgICAgcmV0dXJuIG5leHRDcmVhdGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRpc3BhdGNoQWN0aW9uKGNvbXBvbmVudElkZW50aXR5LCBxdWV1ZSwgYWN0aW9uKSB7XG4gICAgICBpZiAoMjUgPD0gbnVtYmVyT2ZSZVJlbmRlcnMpXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiVG9vIG1hbnkgcmUtcmVuZGVycy4gUmVhY3QgbGltaXRzIHRoZSBudW1iZXIgb2YgcmVuZGVycyB0byBwcmV2ZW50IGFuIGluZmluaXRlIGxvb3AuXCJcbiAgICAgICAgKTtcbiAgICAgIGlmIChjb21wb25lbnRJZGVudGl0eSA9PT0gY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KVxuICAgICAgICBpZiAoXG4gICAgICAgICAgKChkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gITApLFxuICAgICAgICAgIChjb21wb25lbnRJZGVudGl0eSA9IHsgYWN0aW9uOiBhY3Rpb24sIG5leHQ6IG51bGwgfSksXG4gICAgICAgICAgbnVsbCA9PT0gcmVuZGVyUGhhc2VVcGRhdGVzICYmIChyZW5kZXJQaGFzZVVwZGF0ZXMgPSBuZXcgTWFwKCkpLFxuICAgICAgICAgIChhY3Rpb24gPSByZW5kZXJQaGFzZVVwZGF0ZXMuZ2V0KHF1ZXVlKSksXG4gICAgICAgICAgdm9pZCAwID09PSBhY3Rpb24pXG4gICAgICAgIClcbiAgICAgICAgICByZW5kZXJQaGFzZVVwZGF0ZXMuc2V0KHF1ZXVlLCBjb21wb25lbnRJZGVudGl0eSk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGZvciAocXVldWUgPSBhY3Rpb247IG51bGwgIT09IHF1ZXVlLm5leHQ7ICkgcXVldWUgPSBxdWV1ZS5uZXh0O1xuICAgICAgICAgIHF1ZXVlLm5leHQgPSBjb21wb25lbnRJZGVudGl0eTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0aHJvd09uVXNlRWZmZWN0RXZlbnRDYWxsKCkge1xuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgIFwiQSBmdW5jdGlvbiB3cmFwcGVkIGluIHVzZUVmZmVjdEV2ZW50IGNhbid0IGJlIGNhbGxlZCBkdXJpbmcgcmVuZGVyaW5nLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1bnN1cHBvcnRlZFN0YXJ0VHJhbnNpdGlvbigpIHtcbiAgICAgIHRocm93IEVycm9yKFwic3RhcnRUcmFuc2l0aW9uIGNhbm5vdCBiZSBjYWxsZWQgZHVyaW5nIHNlcnZlciByZW5kZXJpbmcuXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1bnN1cHBvcnRlZFNldE9wdGltaXN0aWNTdGF0ZSgpIHtcbiAgICAgIHRocm93IEVycm9yKFwiQ2Fubm90IHVwZGF0ZSBvcHRpbWlzdGljIHN0YXRlIHdoaWxlIHJlbmRlcmluZy5cIik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVzZUFjdGlvblN0YXRlKGFjdGlvbiwgaW5pdGlhbFN0YXRlLCBwZXJtYWxpbmspIHtcbiAgICAgIHJlc29sdmVDdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQoKTtcbiAgICAgIHZhciBhY3Rpb25TdGF0ZUhvb2tJbmRleCA9IGFjdGlvblN0YXRlQ291bnRlcisrLFxuICAgICAgICByZXF1ZXN0ID0gY3VycmVudGx5UmVuZGVyaW5nUmVxdWVzdDtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBhY3Rpb24uJCRGT1JNX0FDVElPTikge1xuICAgICAgICB2YXIgbmV4dFBvc3RiYWNrU3RhdGVLZXkgPSBudWxsLFxuICAgICAgICAgIGNvbXBvbmVudEtleVBhdGggPSBjdXJyZW50bHlSZW5kZXJpbmdLZXlQYXRoO1xuICAgICAgICByZXF1ZXN0ID0gcmVxdWVzdC5mb3JtU3RhdGU7XG4gICAgICAgIHZhciBpc1NpZ25hdHVyZUVxdWFsID0gYWN0aW9uLiQkSVNfU0lHTkFUVVJFX0VRVUFMO1xuICAgICAgICBpZiAobnVsbCAhPT0gcmVxdWVzdCAmJiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpc1NpZ25hdHVyZUVxdWFsKSB7XG4gICAgICAgICAgdmFyIHBvc3RiYWNrS2V5ID0gcmVxdWVzdFsxXTtcbiAgICAgICAgICBpc1NpZ25hdHVyZUVxdWFsLmNhbGwoYWN0aW9uLCByZXF1ZXN0WzJdLCByZXF1ZXN0WzNdKSAmJlxuICAgICAgICAgICAgKChuZXh0UG9zdGJhY2tTdGF0ZUtleSA9XG4gICAgICAgICAgICAgIHZvaWQgMCAhPT0gcGVybWFsaW5rXG4gICAgICAgICAgICAgICAgPyBcInBcIiArIHBlcm1hbGlua1xuICAgICAgICAgICAgICAgIDogXCJrXCIgK1xuICAgICAgICAgICAgICAgICAgbXVybXVyaGFzaDNfMzJfZ2MoXG4gICAgICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KFtcbiAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRLZXlQYXRoLFxuICAgICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgYWN0aW9uU3RhdGVIb29rSW5kZXhcbiAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgcG9zdGJhY2tLZXkgPT09IG5leHRQb3N0YmFja1N0YXRlS2V5ICYmXG4gICAgICAgICAgICAgICgoYWN0aW9uU3RhdGVNYXRjaGluZ0luZGV4ID0gYWN0aW9uU3RhdGVIb29rSW5kZXgpLFxuICAgICAgICAgICAgICAoaW5pdGlhbFN0YXRlID0gcmVxdWVzdFswXSkpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYm91bmRBY3Rpb24gPSBhY3Rpb24uYmluZChudWxsLCBpbml0aWFsU3RhdGUpO1xuICAgICAgICBhY3Rpb24gPSBmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgICAgICAgIGJvdW5kQWN0aW9uKHBheWxvYWQpO1xuICAgICAgICB9O1xuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBib3VuZEFjdGlvbi4kJEZPUk1fQUNUSU9OICYmXG4gICAgICAgICAgKGFjdGlvbi4kJEZPUk1fQUNUSU9OID0gZnVuY3Rpb24gKHByZWZpeCkge1xuICAgICAgICAgICAgcHJlZml4ID0gYm91bmRBY3Rpb24uJCRGT1JNX0FDVElPTihwcmVmaXgpO1xuICAgICAgICAgICAgdm9pZCAwICE9PSBwZXJtYWxpbmsgJiZcbiAgICAgICAgICAgICAgKGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24ocGVybWFsaW5rLCBcInRhcmdldFwiKSxcbiAgICAgICAgICAgICAgKHBlcm1hbGluayArPSBcIlwiKSxcbiAgICAgICAgICAgICAgKHByZWZpeC5hY3Rpb24gPSBwZXJtYWxpbmspKTtcbiAgICAgICAgICAgIHZhciBmb3JtRGF0YSA9IHByZWZpeC5kYXRhO1xuICAgICAgICAgICAgZm9ybURhdGEgJiZcbiAgICAgICAgICAgICAgKG51bGwgPT09IG5leHRQb3N0YmFja1N0YXRlS2V5ICYmXG4gICAgICAgICAgICAgICAgKG5leHRQb3N0YmFja1N0YXRlS2V5ID1cbiAgICAgICAgICAgICAgICAgIHZvaWQgMCAhPT0gcGVybWFsaW5rXG4gICAgICAgICAgICAgICAgICAgID8gXCJwXCIgKyBwZXJtYWxpbmtcbiAgICAgICAgICAgICAgICAgICAgOiBcImtcIiArXG4gICAgICAgICAgICAgICAgICAgICAgbXVybXVyaGFzaDNfMzJfZ2MoXG4gICAgICAgICAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShbXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEtleVBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvblN0YXRlSG9va0luZGV4XG4gICAgICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKFwiJEFDVElPTl9LRVlcIiwgbmV4dFBvc3RiYWNrU3RhdGVLZXkpKTtcbiAgICAgICAgICAgIHJldHVybiBwcmVmaXg7XG4gICAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBbaW5pdGlhbFN0YXRlLCBhY3Rpb24sICExXTtcbiAgICAgIH1cbiAgICAgIHZhciBfYm91bmRBY3Rpb24gPSBhY3Rpb24uYmluZChudWxsLCBpbml0aWFsU3RhdGUpO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgaW5pdGlhbFN0YXRlLFxuICAgICAgICBmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgICAgICAgIF9ib3VuZEFjdGlvbihwYXlsb2FkKTtcbiAgICAgICAgfSxcbiAgICAgICAgITFcbiAgICAgIF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVud3JhcFRoZW5hYmxlKHRoZW5hYmxlKSB7XG4gICAgICB2YXIgaW5kZXggPSB0aGVuYWJsZUluZGV4Q291bnRlcjtcbiAgICAgIHRoZW5hYmxlSW5kZXhDb3VudGVyICs9IDE7XG4gICAgICBudWxsID09PSB0aGVuYWJsZVN0YXRlICYmICh0aGVuYWJsZVN0YXRlID0gW10pO1xuICAgICAgcmV0dXJuIHRyYWNrVXNlZFRoZW5hYmxlKHRoZW5hYmxlU3RhdGUsIHRoZW5hYmxlLCBpbmRleCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVuc3VwcG9ydGVkUmVmcmVzaCgpIHtcbiAgICAgIHRocm93IEVycm9yKFwiQ2FjaGUgY2Fubm90IGJlIHJlZnJlc2hlZCBkdXJpbmcgc2VydmVyIHJlbmRlcmluZy5cIik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cbiAgICBmdW5jdGlvbiBkaXNhYmxlTG9ncygpIHtcbiAgICAgIGlmICgwID09PSBkaXNhYmxlZERlcHRoKSB7XG4gICAgICAgIHByZXZMb2cgPSBjb25zb2xlLmxvZztcbiAgICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgICBwcmV2RXJyb3IgPSBjb25zb2xlLmVycm9yO1xuICAgICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgICBwcmV2R3JvdXBFbmQgPSBjb25zb2xlLmdyb3VwRW5kO1xuICAgICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICB2YWx1ZTogZGlzYWJsZWRMb2csXG4gICAgICAgICAgd3JpdGFibGU6ICEwXG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICAgIHdhcm46IHByb3BzLFxuICAgICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHByb3BzLFxuICAgICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGRpc2FibGVkRGVwdGgrKztcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICAgICAgZGlzYWJsZWREZXB0aC0tO1xuICAgICAgaWYgKDAgPT09IGRpc2FibGVkRGVwdGgpIHtcbiAgICAgICAgdmFyIHByb3BzID0geyBjb25maWd1cmFibGU6ICEwLCBlbnVtZXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZMb2cgfSksXG4gICAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldkluZm8gfSksXG4gICAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldldhcm4gfSksXG4gICAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZFcnJvciB9KSxcbiAgICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldkdyb3VwIH0pLFxuICAgICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWQgfSksXG4gICAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZHcm91cEVuZCB9KVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIDAgPiBkaXNhYmxlZERlcHRoICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZm9ybWF0T3duZXJTdGFjayhlcnJvcikge1xuICAgICAgdmFyIHByZXZQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlO1xuICAgICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB2b2lkIDA7XG4gICAgICBlcnJvciA9IGVycm9yLnN0YWNrO1xuICAgICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2UHJlcGFyZVN0YWNrVHJhY2U7XG4gICAgICBlcnJvci5zdGFydHNXaXRoKFwiRXJyb3I6IHJlYWN0LXN0YWNrLXRvcC1mcmFtZVxcblwiKSAmJlxuICAgICAgICAoZXJyb3IgPSBlcnJvci5zbGljZSgyOSkpO1xuICAgICAgcHJldlByZXBhcmVTdGFja1RyYWNlID0gZXJyb3IuaW5kZXhPZihcIlxcblwiKTtcbiAgICAgIC0xICE9PSBwcmV2UHJlcGFyZVN0YWNrVHJhY2UgJiZcbiAgICAgICAgKGVycm9yID0gZXJyb3Iuc2xpY2UocHJldlByZXBhcmVTdGFja1RyYWNlICsgMSkpO1xuICAgICAgcHJldlByZXBhcmVTdGFja1RyYWNlID0gZXJyb3IuaW5kZXhPZihcInJlYWN0X3N0YWNrX2JvdHRvbV9mcmFtZVwiKTtcbiAgICAgIC0xICE9PSBwcmV2UHJlcGFyZVN0YWNrVHJhY2UgJiZcbiAgICAgICAgKHByZXZQcmVwYXJlU3RhY2tUcmFjZSA9IGVycm9yLmxhc3RJbmRleE9mKFxuICAgICAgICAgIFwiXFxuXCIsXG4gICAgICAgICAgcHJldlByZXBhcmVTdGFja1RyYWNlXG4gICAgICAgICkpO1xuICAgICAgaWYgKC0xICE9PSBwcmV2UHJlcGFyZVN0YWNrVHJhY2UpXG4gICAgICAgIGVycm9yID0gZXJyb3Iuc2xpY2UoMCwgcHJldlByZXBhcmVTdGFja1RyYWNlKTtcbiAgICAgIGVsc2UgcmV0dXJuIFwiXCI7XG4gICAgICByZXR1cm4gZXJyb3I7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIHtcbiAgICAgIGlmICh2b2lkIDAgPT09IHByZWZpeClcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgICBwcmVmaXggPSAobWF0Y2ggJiYgbWF0Y2hbMV0pIHx8IFwiXCI7XG4gICAgICAgICAgc3VmZml4ID1cbiAgICAgICAgICAgIC0xIDwgeC5zdGFjay5pbmRleE9mKFwiXFxuICAgIGF0XCIpXG4gICAgICAgICAgICAgID8gXCIgKDxhbm9ueW1vdXM+KVwiXG4gICAgICAgICAgICAgIDogLTEgPCB4LnN0YWNrLmluZGV4T2YoXCJAXCIpXG4gICAgICAgICAgICAgICAgPyBcIkB1bmtub3duOjA6MFwiXG4gICAgICAgICAgICAgICAgOiBcIlwiO1xuICAgICAgICB9XG4gICAgICByZXR1cm4gXCJcXG5cIiArIHByZWZpeCArIG5hbWUgKyBzdWZmaXg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAgICAgaWYgKCFmbiB8fCByZWVudHJ5KSByZXR1cm4gXCJcIjtcbiAgICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcbiAgICAgIGlmICh2b2lkIDAgIT09IGZyYW1lKSByZXR1cm4gZnJhbWU7XG4gICAgICByZWVudHJ5ID0gITA7XG4gICAgICBmcmFtZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlO1xuICAgICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB2b2lkIDA7XG4gICAgICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyID0gbnVsbDtcbiAgICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gbnVsbDtcbiAgICAgIGRpc2FibGVMb2dzKCk7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgUnVuSW5Sb290RnJhbWUgPSB7XG4gICAgICAgICAgRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCBcInByb3BzXCIsIHtcbiAgICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgUmVmbGVjdCAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udHJvbCA9IHg7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHgkMCkge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sID0geCQwO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHgkMSkge1xuICAgICAgICAgICAgICAgICAgY29udHJvbCA9IHgkMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKEZha2UgPSBmbigpKSAmJlxuICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgRmFrZS5jYXRjaCAmJlxuICAgICAgICAgICAgICAgICAgRmFrZS5jYXRjaChmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgICAgICAgICAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHNhbXBsZS5zdGFjaylcbiAgICAgICAgICAgICAgICByZXR1cm4gW3NhbXBsZS5zdGFjaywgY29udHJvbC5zdGFja107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW251bGwsIG51bGxdO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LmRpc3BsYXlOYW1lID1cbiAgICAgICAgICBcIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdFwiO1xuICAgICAgICB2YXIgbmFtZVByb3BEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihcbiAgICAgICAgICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QsXG4gICAgICAgICAgXCJuYW1lXCJcbiAgICAgICAgKTtcbiAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yICYmXG4gICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSAmJlxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgICAgIFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCxcbiAgICAgICAgICAgIFwibmFtZVwiLFxuICAgICAgICAgICAgeyB2YWx1ZTogXCJEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3RcIiB9XG4gICAgICAgICAgKTtcbiAgICAgICAgdmFyIF9SdW5JblJvb3RGcmFtZSREZXRlciA9XG4gICAgICAgICAgICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QoKSxcbiAgICAgICAgICBzYW1wbGVTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclswXSxcbiAgICAgICAgICBjb250cm9sU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMV07XG4gICAgICAgIGlmIChzYW1wbGVTdGFjayAmJiBjb250cm9sU3RhY2spIHtcbiAgICAgICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGVTdGFjay5zcGxpdChcIlxcblwiKSxcbiAgICAgICAgICAgIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2xTdGFjay5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyID0gbmFtZVByb3BEZXNjcmlwdG9yID0gMDtcbiAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvciA8IHNhbXBsZUxpbmVzLmxlbmd0aCAmJlxuICAgICAgICAgICAgIXNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0uaW5jbHVkZXMoXG4gICAgICAgICAgICAgIFwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290XCJcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICApXG4gICAgICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IrKztcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyIDwgY29udHJvbExpbmVzLmxlbmd0aCAmJlxuICAgICAgICAgICAgIWNvbnRyb2xMaW5lc1tfUnVuSW5Sb290RnJhbWUkRGV0ZXJdLmluY2x1ZGVzKFxuICAgICAgICAgICAgICBcIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdFwiXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgKVxuICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyKys7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yID09PSBzYW1wbGVMaW5lcy5sZW5ndGggfHxcbiAgICAgICAgICAgIF9SdW5JblJvb3RGcmFtZSREZXRlciA9PT0gY29udHJvbExpbmVzLmxlbmd0aFxuICAgICAgICAgIClcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvciA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDEsXG4gICAgICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgIDEgPD0gbmFtZVByb3BEZXNjcmlwdG9yICYmXG4gICAgICAgICAgICAgIDAgPD0gX1J1bkluUm9vdEZyYW1lJERldGVyICYmXG4gICAgICAgICAgICAgIHNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0gIT09XG4gICAgICAgICAgICAgICAgY29udHJvbExpbmVzW19SdW5JblJvb3RGcmFtZSREZXRlcl07XG5cbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyLS07XG4gICAgICAgICAgZm9yIChcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIDEgPD0gbmFtZVByb3BEZXNjcmlwdG9yICYmIDAgPD0gX1J1bkluUm9vdEZyYW1lJERldGVyO1xuICAgICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yLS0sIF9SdW5JblJvb3RGcmFtZSREZXRlci0tXG4gICAgICAgICAgKVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBzYW1wbGVMaW5lc1tuYW1lUHJvcERlc2NyaXB0b3JdICE9PVxuICAgICAgICAgICAgICBjb250cm9sTGluZXNbX1J1bkluUm9vdEZyYW1lJERldGVyXVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGlmICgxICE9PSBuYW1lUHJvcERlc2NyaXB0b3IgfHwgMSAhPT0gX1J1bkluUm9vdEZyYW1lJERldGVyKSB7XG4gICAgICAgICAgICAgICAgZG9cbiAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgKG5hbWVQcm9wRGVzY3JpcHRvci0tLFxuICAgICAgICAgICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXItLSxcbiAgICAgICAgICAgICAgICAgICAgMCA+IF9SdW5JblJvb3RGcmFtZSREZXRlciB8fFxuICAgICAgICAgICAgICAgICAgICAgIHNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0gIT09XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sTGluZXNbX1J1bkluUm9vdEZyYW1lJERldGVyXSlcbiAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID1cbiAgICAgICAgICAgICAgICAgICAgICBcIlxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgICBzYW1wbGVMaW5lc1tuYW1lUHJvcERlc2NyaXB0b3JdLnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiBhdCBuZXcgXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiBhdCBcIlxuICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGZuLmRpc3BsYXlOYW1lICYmXG4gICAgICAgICAgICAgICAgICAgICAgX2ZyYW1lLmluY2x1ZGVzKFwiPGFub255bW91cz5cIikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAoX2ZyYW1lID0gX2ZyYW1lLnJlcGxhY2UoXCI8YW5vbnltb3VzPlwiLCBmbi5kaXNwbGF5TmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBmbiAmJlxuICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlICgxIDw9IG5hbWVQcm9wRGVzY3JpcHRvciAmJiAwIDw9IF9SdW5JblJvb3RGcmFtZSREZXRlcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIChyZWVudHJ5ID0gITEpLFxuICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldmlvdXNEaXNwYXRjaGVyKSxcbiAgICAgICAgICByZWVuYWJsZUxvZ3MoKSxcbiAgICAgICAgICAoRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBmcmFtZSk7XG4gICAgICB9XG4gICAgICBzYW1wbGVMaW5lcyA9IChzYW1wbGVMaW5lcyA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6IFwiXCIpXG4gICAgICAgID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoc2FtcGxlTGluZXMpXG4gICAgICAgIDogXCJcIjtcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGZuICYmIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzYW1wbGVMaW5lcyk7XG4gICAgICByZXR1cm4gc2FtcGxlTGluZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlQ29tcG9uZW50U3RhY2tCeVR5cGUodHlwZSkge1xuICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlKSByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgcmV0dXJuIHR5cGUucHJvdG90eXBlICYmIHR5cGUucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnRcbiAgICAgICAgICA/IGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgITApXG4gICAgICAgICAgOiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKHR5cGUsICExKTtcbiAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSAmJiBudWxsICE9PSB0eXBlKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyLCAhMSk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLnR5cGUsICExKTtcbiAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZSxcbiAgICAgICAgICAgICAgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgICBsYXp5Q29tcG9uZW50ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHR5cGUgPSBsYXp5Q29tcG9uZW50KHBheWxvYWQpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoXCJMYXp5XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlQ29tcG9uZW50U3RhY2tCeVR5cGUodHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlLm5hbWUpIHtcbiAgICAgICAgICBhOiB7XG4gICAgICAgICAgICBwYXlsb2FkID0gdHlwZS5uYW1lO1xuICAgICAgICAgICAgbGF6eUNvbXBvbmVudCA9IHR5cGUuZW52O1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuZGVidWdMb2NhdGlvbjtcbiAgICAgICAgICAgIGlmIChudWxsICE9IHR5cGUpIHtcbiAgICAgICAgICAgICAgdHlwZSA9IGZvcm1hdE93bmVyU3RhY2sodHlwZSk7XG4gICAgICAgICAgICAgIHZhciBpZHggPSB0eXBlLmxhc3RJbmRleE9mKFwiXFxuXCIpO1xuICAgICAgICAgICAgICB0eXBlID0gLTEgPT09IGlkeCA/IHR5cGUgOiB0eXBlLnNsaWNlKGlkeCArIDEpO1xuICAgICAgICAgICAgICBpZiAoLTEgIT09IHR5cGUuaW5kZXhPZihwYXlsb2FkKSkge1xuICAgICAgICAgICAgICAgIHBheWxvYWQgPSBcIlxcblwiICsgdHlwZTtcbiAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXlsb2FkID0gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoXG4gICAgICAgICAgICAgIHBheWxvYWQgKyAobGF6eUNvbXBvbmVudCA/IFwiIFtcIiArIGxhenlDb21wb25lbnQgKyBcIl1cIiA6IFwiXCIpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShcIlN1c3BlbnNlTGlzdFwiKTtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShcIlN1c3BlbnNlXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc2V0T3duZXJTdGFja0xpbWl0KCkge1xuICAgICAgdmFyIG5vdyA9IGdldEN1cnJlbnRUaW1lKCk7XG4gICAgICAxZTMgPCBub3cgLSBsYXN0UmVzZXRUaW1lICYmXG4gICAgICAgICgoUmVhY3RTaGFyZWRJbnRlcm5hbHMucmVjZW50bHlDcmVhdGVkT3duZXJTdGFja3MgPSAwKSxcbiAgICAgICAgKGxhc3RSZXNldFRpbWUgPSBub3cpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNFbGlnaWJsZUZvck91dGxpbmluZyhyZXF1ZXN0LCBib3VuZGFyeSkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgKDUwMCA8IGJvdW5kYXJ5LmJ5dGVTaXplIHx8XG4gICAgICAgICAgaGFzU3VzcGVuc2V5Q29udGVudChib3VuZGFyeS5jb250ZW50U3RhdGUpKSAmJlxuICAgICAgICBudWxsID09PSBib3VuZGFyeS5jb250ZW50UHJlYW1ibGVcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmF1bHRFcnJvckhhbmRsZXIoZXJyb3IpIHtcbiAgICAgIGlmIChcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGVycm9yICYmXG4gICAgICAgIG51bGwgIT09IGVycm9yICYmXG4gICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBlcnJvci5lbnZpcm9ubWVudE5hbWVcbiAgICAgICkge1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gZXJyb3IuZW52aXJvbm1lbnROYW1lO1xuICAgICAgICBlcnJvciA9IFtlcnJvcl0uc2xpY2UoMCk7XG4gICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBlcnJvclswXVxuICAgICAgICAgID8gZXJyb3Iuc3BsaWNlKFxuICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAxLFxuICAgICAgICAgICAgICBcIiVjJXMlYyBcIiArIGVycm9yWzBdLFxuICAgICAgICAgICAgICBcImJhY2tncm91bmQ6ICNlNmU2ZTY7YmFja2dyb3VuZDogbGlnaHQtZGFyayhyZ2JhKDAsMCwwLDAuMSksIHJnYmEoMjU1LDI1NSwyNTUsMC4yNSkpO2NvbG9yOiAjMDAwMDAwO2NvbG9yOiBsaWdodC1kYXJrKCMwMDAwMDAsICNmZmZmZmYpO2JvcmRlci1yYWRpdXM6IDJweFwiLFxuICAgICAgICAgICAgICBcIiBcIiArIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCArIFwiIFwiLFxuICAgICAgICAgICAgICBcIlwiXG4gICAgICAgICAgICApXG4gICAgICAgICAgOiBlcnJvci5zcGxpY2UoXG4gICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgIFwiJWMlcyVjXCIsXG4gICAgICAgICAgICAgIFwiYmFja2dyb3VuZDogI2U2ZTZlNjtiYWNrZ3JvdW5kOiBsaWdodC1kYXJrKHJnYmEoMCwwLDAsMC4xKSwgcmdiYSgyNTUsMjU1LDI1NSwwLjI1KSk7Y29sb3I6ICMwMDAwMDA7Y29sb3I6IGxpZ2h0LWRhcmsoIzAwMDAwMCwgI2ZmZmZmZik7Ym9yZGVyLXJhZGl1czogMnB4XCIsXG4gICAgICAgICAgICAgIFwiIFwiICsgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ICsgXCIgXCIsXG4gICAgICAgICAgICAgIFwiXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgIGVycm9yLnVuc2hpZnQoY29uc29sZSk7XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IGJpbmQuYXBwbHkoY29uc29sZS5lcnJvciwgZXJyb3IpO1xuICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQoKTtcbiAgICAgIH0gZWxzZSBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZXF1ZXN0SW5zdGFuY2UoXG4gICAgICByZXN1bWFibGVTdGF0ZSxcbiAgICAgIHJlbmRlclN0YXRlLFxuICAgICAgcm9vdEZvcm1hdENvbnRleHQsXG4gICAgICBwcm9ncmVzc2l2ZUNodW5rU2l6ZSxcbiAgICAgIG9uRXJyb3IsXG4gICAgICBvbkFsbFJlYWR5LFxuICAgICAgb25TaGVsbFJlYWR5LFxuICAgICAgb25TaGVsbEVycm9yLFxuICAgICAgb25GYXRhbEVycm9yLFxuICAgICAgb25Qb3N0cG9uZSxcbiAgICAgIGZvcm1TdGF0ZVxuICAgICkge1xuICAgICAgdmFyIGFib3J0U2V0ID0gbmV3IFNldCgpO1xuICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IG51bGw7XG4gICAgICB0aGlzLmZsdXNoU2NoZWR1bGVkID0gITE7XG4gICAgICB0aGlzLnJlc3VtYWJsZVN0YXRlID0gcmVzdW1hYmxlU3RhdGU7XG4gICAgICB0aGlzLnJlbmRlclN0YXRlID0gcmVuZGVyU3RhdGU7XG4gICAgICB0aGlzLnJvb3RGb3JtYXRDb250ZXh0ID0gcm9vdEZvcm1hdENvbnRleHQ7XG4gICAgICB0aGlzLnByb2dyZXNzaXZlQ2h1bmtTaXplID1cbiAgICAgICAgdm9pZCAwID09PSBwcm9ncmVzc2l2ZUNodW5rU2l6ZSA/IDEyODAwIDogcHJvZ3Jlc3NpdmVDaHVua1NpemU7XG4gICAgICB0aGlzLnN0YXR1cyA9IDEwO1xuICAgICAgdGhpcy5mYXRhbEVycm9yID0gbnVsbDtcbiAgICAgIHRoaXMucGVuZGluZ1Jvb3RUYXNrcyA9IHRoaXMuYWxsUGVuZGluZ1Rhc2tzID0gdGhpcy5uZXh0U2VnbWVudElkID0gMDtcbiAgICAgIHRoaXMuY29tcGxldGVkUHJlYW1ibGVTZWdtZW50cyA9IHRoaXMuY29tcGxldGVkUm9vdFNlZ21lbnQgPSBudWxsO1xuICAgICAgdGhpcy5ieXRlU2l6ZSA9IDA7XG4gICAgICB0aGlzLmFib3J0YWJsZVRhc2tzID0gYWJvcnRTZXQ7XG4gICAgICB0aGlzLnBpbmdlZFRhc2tzID0gW107XG4gICAgICB0aGlzLmNsaWVudFJlbmRlcmVkQm91bmRhcmllcyA9IFtdO1xuICAgICAgdGhpcy5jb21wbGV0ZWRCb3VuZGFyaWVzID0gW107XG4gICAgICB0aGlzLnBhcnRpYWxCb3VuZGFyaWVzID0gW107XG4gICAgICB0aGlzLnRyYWNrZWRQb3N0cG9uZXMgPSBudWxsO1xuICAgICAgdGhpcy5vbkVycm9yID0gdm9pZCAwID09PSBvbkVycm9yID8gZGVmYXVsdEVycm9ySGFuZGxlciA6IG9uRXJyb3I7XG4gICAgICB0aGlzLm9uUG9zdHBvbmUgPSB2b2lkIDAgPT09IG9uUG9zdHBvbmUgPyBub29wIDogb25Qb3N0cG9uZTtcbiAgICAgIHRoaXMub25BbGxSZWFkeSA9IHZvaWQgMCA9PT0gb25BbGxSZWFkeSA/IG5vb3AgOiBvbkFsbFJlYWR5O1xuICAgICAgdGhpcy5vblNoZWxsUmVhZHkgPSB2b2lkIDAgPT09IG9uU2hlbGxSZWFkeSA/IG5vb3AgOiBvblNoZWxsUmVhZHk7XG4gICAgICB0aGlzLm9uU2hlbGxFcnJvciA9IHZvaWQgMCA9PT0gb25TaGVsbEVycm9yID8gbm9vcCA6IG9uU2hlbGxFcnJvcjtcbiAgICAgIHRoaXMub25GYXRhbEVycm9yID0gdm9pZCAwID09PSBvbkZhdGFsRXJyb3IgPyBub29wIDogb25GYXRhbEVycm9yO1xuICAgICAgdGhpcy5mb3JtU3RhdGUgPSB2b2lkIDAgPT09IGZvcm1TdGF0ZSA/IG51bGwgOiBmb3JtU3RhdGU7XG4gICAgICB0aGlzLmRpZFdhcm5Gb3JLZXkgPSBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVSZXF1ZXN0KFxuICAgICAgY2hpbGRyZW4sXG4gICAgICByZXN1bWFibGVTdGF0ZSxcbiAgICAgIHJlbmRlclN0YXRlLFxuICAgICAgcm9vdEZvcm1hdENvbnRleHQsXG4gICAgICBwcm9ncmVzc2l2ZUNodW5rU2l6ZSxcbiAgICAgIG9uRXJyb3IsXG4gICAgICBvbkFsbFJlYWR5LFxuICAgICAgb25TaGVsbFJlYWR5LFxuICAgICAgb25TaGVsbEVycm9yLFxuICAgICAgb25GYXRhbEVycm9yLFxuICAgICAgb25Qb3N0cG9uZSxcbiAgICAgIGZvcm1TdGF0ZVxuICAgICkge1xuICAgICAgcmVzZXRPd25lclN0YWNrTGltaXQoKTtcbiAgICAgIHJlc3VtYWJsZVN0YXRlID0gbmV3IFJlcXVlc3RJbnN0YW5jZShcbiAgICAgICAgcmVzdW1hYmxlU3RhdGUsXG4gICAgICAgIHJlbmRlclN0YXRlLFxuICAgICAgICByb290Rm9ybWF0Q29udGV4dCxcbiAgICAgICAgcHJvZ3Jlc3NpdmVDaHVua1NpemUsXG4gICAgICAgIG9uRXJyb3IsXG4gICAgICAgIG9uQWxsUmVhZHksXG4gICAgICAgIG9uU2hlbGxSZWFkeSxcbiAgICAgICAgb25TaGVsbEVycm9yLFxuICAgICAgICBvbkZhdGFsRXJyb3IsXG4gICAgICAgIG9uUG9zdHBvbmUsXG4gICAgICAgIGZvcm1TdGF0ZVxuICAgICAgKTtcbiAgICAgIHJlbmRlclN0YXRlID0gY3JlYXRlUGVuZGluZ1NlZ21lbnQoXG4gICAgICAgIHJlc3VtYWJsZVN0YXRlLFxuICAgICAgICAwLFxuICAgICAgICBudWxsLFxuICAgICAgICByb290Rm9ybWF0Q29udGV4dCxcbiAgICAgICAgITEsXG4gICAgICAgICExXG4gICAgICApO1xuICAgICAgcmVuZGVyU3RhdGUucGFyZW50Rmx1c2hlZCA9ICEwO1xuICAgICAgY2hpbGRyZW4gPSBjcmVhdGVSZW5kZXJUYXNrKFxuICAgICAgICByZXN1bWFibGVTdGF0ZSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIC0xLFxuICAgICAgICBudWxsLFxuICAgICAgICByZW5kZXJTdGF0ZSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgcmVzdW1hYmxlU3RhdGUuYWJvcnRhYmxlVGFza3MsXG4gICAgICAgIG51bGwsXG4gICAgICAgIHJvb3RGb3JtYXRDb250ZXh0LFxuICAgICAgICBudWxsLFxuICAgICAgICBlbXB0eVRyZWVDb250ZXh0LFxuICAgICAgICBudWxsLFxuICAgICAgICBudWxsLFxuICAgICAgICBlbXB0eUNvbnRleHRPYmplY3QsXG4gICAgICAgIG51bGxcbiAgICAgICk7XG4gICAgICBwdXNoQ29tcG9uZW50U3RhY2soY2hpbGRyZW4pO1xuICAgICAgcmVzdW1hYmxlU3RhdGUucGluZ2VkVGFza3MucHVzaChjaGlsZHJlbik7XG4gICAgICByZXR1cm4gcmVzdW1hYmxlU3RhdGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVByZXJlbmRlclJlcXVlc3QoXG4gICAgICBjaGlsZHJlbixcbiAgICAgIHJlc3VtYWJsZVN0YXRlLFxuICAgICAgcmVuZGVyU3RhdGUsXG4gICAgICByb290Rm9ybWF0Q29udGV4dCxcbiAgICAgIHByb2dyZXNzaXZlQ2h1bmtTaXplLFxuICAgICAgb25FcnJvcixcbiAgICAgIG9uQWxsUmVhZHksXG4gICAgICBvblNoZWxsUmVhZHksXG4gICAgICBvblNoZWxsRXJyb3IsXG4gICAgICBvbkZhdGFsRXJyb3IsXG4gICAgICBvblBvc3Rwb25lXG4gICAgKSB7XG4gICAgICBjaGlsZHJlbiA9IGNyZWF0ZVJlcXVlc3QoXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICByZXN1bWFibGVTdGF0ZSxcbiAgICAgICAgcmVuZGVyU3RhdGUsXG4gICAgICAgIHJvb3RGb3JtYXRDb250ZXh0LFxuICAgICAgICBwcm9ncmVzc2l2ZUNodW5rU2l6ZSxcbiAgICAgICAgb25FcnJvcixcbiAgICAgICAgb25BbGxSZWFkeSxcbiAgICAgICAgb25TaGVsbFJlYWR5LFxuICAgICAgICBvblNoZWxsRXJyb3IsXG4gICAgICAgIG9uRmF0YWxFcnJvcixcbiAgICAgICAgb25Qb3N0cG9uZSxcbiAgICAgICAgdm9pZCAwXG4gICAgICApO1xuICAgICAgY2hpbGRyZW4udHJhY2tlZFBvc3Rwb25lcyA9IHtcbiAgICAgICAgd29ya2luZ01hcDogbmV3IE1hcCgpLFxuICAgICAgICByb290Tm9kZXM6IFtdLFxuICAgICAgICByb290U2xvdHM6IG51bGxcbiAgICAgIH07XG4gICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc3VtZVJlcXVlc3QoXG4gICAgICBjaGlsZHJlbixcbiAgICAgIHBvc3Rwb25lZFN0YXRlLFxuICAgICAgcmVuZGVyU3RhdGUsXG4gICAgICBvbkVycm9yLFxuICAgICAgb25BbGxSZWFkeSxcbiAgICAgIG9uU2hlbGxSZWFkeSxcbiAgICAgIG9uU2hlbGxFcnJvcixcbiAgICAgIG9uRmF0YWxFcnJvcixcbiAgICAgIG9uUG9zdHBvbmVcbiAgICApIHtcbiAgICAgIHJlc2V0T3duZXJTdGFja0xpbWl0KCk7XG4gICAgICByZW5kZXJTdGF0ZSA9IG5ldyBSZXF1ZXN0SW5zdGFuY2UoXG4gICAgICAgIHBvc3Rwb25lZFN0YXRlLnJlc3VtYWJsZVN0YXRlLFxuICAgICAgICByZW5kZXJTdGF0ZSxcbiAgICAgICAgcG9zdHBvbmVkU3RhdGUucm9vdEZvcm1hdENvbnRleHQsXG4gICAgICAgIHBvc3Rwb25lZFN0YXRlLnByb2dyZXNzaXZlQ2h1bmtTaXplLFxuICAgICAgICBvbkVycm9yLFxuICAgICAgICBvbkFsbFJlYWR5LFxuICAgICAgICBvblNoZWxsUmVhZHksXG4gICAgICAgIG9uU2hlbGxFcnJvcixcbiAgICAgICAgb25GYXRhbEVycm9yLFxuICAgICAgICBvblBvc3Rwb25lLFxuICAgICAgICBudWxsXG4gICAgICApO1xuICAgICAgcmVuZGVyU3RhdGUubmV4dFNlZ21lbnRJZCA9IHBvc3Rwb25lZFN0YXRlLm5leHRTZWdtZW50SWQ7XG4gICAgICBpZiAoXCJudW1iZXJcIiA9PT0gdHlwZW9mIHBvc3Rwb25lZFN0YXRlLnJlcGxheVNsb3RzKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIChvbkVycm9yID0gY3JlYXRlUGVuZGluZ1NlZ21lbnQoXG4gICAgICAgICAgICByZW5kZXJTdGF0ZSxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgcG9zdHBvbmVkU3RhdGUucm9vdEZvcm1hdENvbnRleHQsXG4gICAgICAgICAgICAhMSxcbiAgICAgICAgICAgICExXG4gICAgICAgICAgKSksXG4gICAgICAgICAgKG9uRXJyb3IucGFyZW50Rmx1c2hlZCA9ICEwKSxcbiAgICAgICAgICAoY2hpbGRyZW4gPSBjcmVhdGVSZW5kZXJUYXNrKFxuICAgICAgICAgICAgcmVuZGVyU3RhdGUsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgICAgICAtMSxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBvbkVycm9yLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICByZW5kZXJTdGF0ZS5hYm9ydGFibGVUYXNrcyxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBwb3N0cG9uZWRTdGF0ZS5yb290Rm9ybWF0Q29udGV4dCxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBlbXB0eVRyZWVDb250ZXh0LFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBlbXB0eUNvbnRleHRPYmplY3QsXG4gICAgICAgICAgICBudWxsXG4gICAgICAgICAgKSksXG4gICAgICAgICAgcHVzaENvbXBvbmVudFN0YWNrKGNoaWxkcmVuKSxcbiAgICAgICAgICByZW5kZXJTdGF0ZS5waW5nZWRUYXNrcy5wdXNoKGNoaWxkcmVuKSxcbiAgICAgICAgICByZW5kZXJTdGF0ZVxuICAgICAgICApO1xuICAgICAgY2hpbGRyZW4gPSBjcmVhdGVSZXBsYXlUYXNrKFxuICAgICAgICByZW5kZXJTdGF0ZSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAge1xuICAgICAgICAgIG5vZGVzOiBwb3N0cG9uZWRTdGF0ZS5yZXBsYXlOb2RlcyxcbiAgICAgICAgICBzbG90czogcG9zdHBvbmVkU3RhdGUucmVwbGF5U2xvdHMsXG4gICAgICAgICAgcGVuZGluZ1Rhc2tzOiAwXG4gICAgICAgIH0sXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICAtMSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgcmVuZGVyU3RhdGUuYWJvcnRhYmxlVGFza3MsXG4gICAgICAgIG51bGwsXG4gICAgICAgIHBvc3Rwb25lZFN0YXRlLnJvb3RGb3JtYXRDb250ZXh0LFxuICAgICAgICBudWxsLFxuICAgICAgICBlbXB0eVRyZWVDb250ZXh0LFxuICAgICAgICBudWxsLFxuICAgICAgICBudWxsLFxuICAgICAgICBlbXB0eUNvbnRleHRPYmplY3QsXG4gICAgICAgIG51bGxcbiAgICAgICk7XG4gICAgICBwdXNoQ29tcG9uZW50U3RhY2soY2hpbGRyZW4pO1xuICAgICAgcmVuZGVyU3RhdGUucGluZ2VkVGFza3MucHVzaChjaGlsZHJlbik7XG4gICAgICByZXR1cm4gcmVuZGVyU3RhdGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc3VtZUFuZFByZXJlbmRlclJlcXVlc3QoXG4gICAgICBjaGlsZHJlbixcbiAgICAgIHBvc3Rwb25lZFN0YXRlLFxuICAgICAgcmVuZGVyU3RhdGUsXG4gICAgICBvbkVycm9yLFxuICAgICAgb25BbGxSZWFkeSxcbiAgICAgIG9uU2hlbGxSZWFkeSxcbiAgICAgIG9uU2hlbGxFcnJvcixcbiAgICAgIG9uRmF0YWxFcnJvcixcbiAgICAgIG9uUG9zdHBvbmVcbiAgICApIHtcbiAgICAgIGNoaWxkcmVuID0gcmVzdW1lUmVxdWVzdChcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIHBvc3Rwb25lZFN0YXRlLFxuICAgICAgICByZW5kZXJTdGF0ZSxcbiAgICAgICAgb25FcnJvcixcbiAgICAgICAgb25BbGxSZWFkeSxcbiAgICAgICAgb25TaGVsbFJlYWR5LFxuICAgICAgICBvblNoZWxsRXJyb3IsXG4gICAgICAgIG9uRmF0YWxFcnJvcixcbiAgICAgICAgb25Qb3N0cG9uZVxuICAgICAgKTtcbiAgICAgIGNoaWxkcmVuLnRyYWNrZWRQb3N0cG9uZXMgPSB7XG4gICAgICAgIHdvcmtpbmdNYXA6IG5ldyBNYXAoKSxcbiAgICAgICAgcm9vdE5vZGVzOiBbXSxcbiAgICAgICAgcm9vdFNsb3RzOiBudWxsXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwaW5nVGFzayhyZXF1ZXN0LCB0YXNrKSB7XG4gICAgICByZXF1ZXN0LnBpbmdlZFRhc2tzLnB1c2godGFzayk7XG4gICAgICAxID09PSByZXF1ZXN0LnBpbmdlZFRhc2tzLmxlbmd0aCAmJlxuICAgICAgICAoKHJlcXVlc3QuZmx1c2hTY2hlZHVsZWQgPSBudWxsICE9PSByZXF1ZXN0LmRlc3RpbmF0aW9uKSxcbiAgICAgICAgbnVsbCAhPT0gcmVxdWVzdC50cmFja2VkUG9zdHBvbmVzIHx8IDEwID09PSByZXF1ZXN0LnN0YXR1c1xuICAgICAgICAgID8gc2NoZWR1bGVNaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gcGVyZm9ybVdvcmsocmVxdWVzdCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIDogc2NoZWR1bGVXb3JrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBlcmZvcm1Xb3JrKHJlcXVlc3QpO1xuICAgICAgICAgICAgfSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5KFxuICAgICAgcmVxdWVzdCxcbiAgICAgIHJvdyxcbiAgICAgIGZhbGxiYWNrQWJvcnRhYmxlVGFza3MsXG4gICAgICBjb250ZW50UHJlYW1ibGUsXG4gICAgICBmYWxsYmFja1ByZWFtYmxlXG4gICAgKSB7XG4gICAgICBmYWxsYmFja0Fib3J0YWJsZVRhc2tzID0ge1xuICAgICAgICBzdGF0dXM6IFBFTkRJTkcsXG4gICAgICAgIHJvb3RTZWdtZW50SUQ6IC0xLFxuICAgICAgICBwYXJlbnRGbHVzaGVkOiAhMSxcbiAgICAgICAgcGVuZGluZ1Rhc2tzOiAwLFxuICAgICAgICByb3c6IHJvdyxcbiAgICAgICAgY29tcGxldGVkU2VnbWVudHM6IFtdLFxuICAgICAgICBieXRlU2l6ZTogMCxcbiAgICAgICAgZmFsbGJhY2tBYm9ydGFibGVUYXNrczogZmFsbGJhY2tBYm9ydGFibGVUYXNrcyxcbiAgICAgICAgZXJyb3JEaWdlc3Q6IG51bGwsXG4gICAgICAgIGNvbnRlbnRTdGF0ZTogY3JlYXRlSG9pc3RhYmxlU3RhdGUoKSxcbiAgICAgICAgZmFsbGJhY2tTdGF0ZTogY3JlYXRlSG9pc3RhYmxlU3RhdGUoKSxcbiAgICAgICAgY29udGVudFByZWFtYmxlOiBjb250ZW50UHJlYW1ibGUsXG4gICAgICAgIGZhbGxiYWNrUHJlYW1ibGU6IGZhbGxiYWNrUHJlYW1ibGUsXG4gICAgICAgIHRyYWNrZWRDb250ZW50S2V5UGF0aDogbnVsbCxcbiAgICAgICAgdHJhY2tlZEZhbGxiYWNrTm9kZTogbnVsbCxcbiAgICAgICAgZXJyb3JNZXNzYWdlOiBudWxsLFxuICAgICAgICBlcnJvclN0YWNrOiBudWxsLFxuICAgICAgICBlcnJvckNvbXBvbmVudFN0YWNrOiBudWxsXG4gICAgICB9O1xuICAgICAgbnVsbCAhPT0gcm93ICYmXG4gICAgICAgIChyb3cucGVuZGluZ1Rhc2tzKyssXG4gICAgICAgIChjb250ZW50UHJlYW1ibGUgPSByb3cuYm91bmRhcmllcyksXG4gICAgICAgIG51bGwgIT09IGNvbnRlbnRQcmVhbWJsZSAmJlxuICAgICAgICAgIChyZXF1ZXN0LmFsbFBlbmRpbmdUYXNrcysrLFxuICAgICAgICAgIGZhbGxiYWNrQWJvcnRhYmxlVGFza3MucGVuZGluZ1Rhc2tzKyssXG4gICAgICAgICAgY29udGVudFByZWFtYmxlLnB1c2goZmFsbGJhY2tBYm9ydGFibGVUYXNrcykpLFxuICAgICAgICAocmVxdWVzdCA9IHJvdy5pbmhlcml0ZWRIb2lzdGFibGVzKSxcbiAgICAgICAgbnVsbCAhPT0gcmVxdWVzdCAmJlxuICAgICAgICAgIGhvaXN0SG9pc3RhYmxlcyhmYWxsYmFja0Fib3J0YWJsZVRhc2tzLmNvbnRlbnRTdGF0ZSwgcmVxdWVzdCkpO1xuICAgICAgcmV0dXJuIGZhbGxiYWNrQWJvcnRhYmxlVGFza3M7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlbmRlclRhc2soXG4gICAgICByZXF1ZXN0LFxuICAgICAgdGhlbmFibGVTdGF0ZSxcbiAgICAgIG5vZGUsXG4gICAgICBjaGlsZEluZGV4LFxuICAgICAgYmxvY2tlZEJvdW5kYXJ5LFxuICAgICAgYmxvY2tlZFNlZ21lbnQsXG4gICAgICBibG9ja2VkUHJlYW1ibGUsXG4gICAgICBob2lzdGFibGVTdGF0ZSxcbiAgICAgIGFib3J0U2V0LFxuICAgICAga2V5UGF0aCxcbiAgICAgIGZvcm1hdENvbnRleHQsXG4gICAgICBjb250ZXh0LFxuICAgICAgdHJlZUNvbnRleHQsXG4gICAgICByb3csXG4gICAgICBjb21wb25lbnRTdGFjayxcbiAgICAgIGxlZ2FjeUNvbnRleHQsXG4gICAgICBkZWJ1Z1Rhc2tcbiAgICApIHtcbiAgICAgIHJlcXVlc3QuYWxsUGVuZGluZ1Rhc2tzKys7XG4gICAgICBudWxsID09PSBibG9ja2VkQm91bmRhcnlcbiAgICAgICAgPyByZXF1ZXN0LnBlbmRpbmdSb290VGFza3MrK1xuICAgICAgICA6IGJsb2NrZWRCb3VuZGFyeS5wZW5kaW5nVGFza3MrKztcbiAgICAgIG51bGwgIT09IHJvdyAmJiByb3cucGVuZGluZ1Rhc2tzKys7XG4gICAgICB2YXIgdGFzayA9IHtcbiAgICAgICAgcmVwbGF5OiBudWxsLFxuICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICBjaGlsZEluZGV4OiBjaGlsZEluZGV4LFxuICAgICAgICBwaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHBpbmdUYXNrKHJlcXVlc3QsIHRhc2spO1xuICAgICAgICB9LFxuICAgICAgICBibG9ja2VkQm91bmRhcnk6IGJsb2NrZWRCb3VuZGFyeSxcbiAgICAgICAgYmxvY2tlZFNlZ21lbnQ6IGJsb2NrZWRTZWdtZW50LFxuICAgICAgICBibG9ja2VkUHJlYW1ibGU6IGJsb2NrZWRQcmVhbWJsZSxcbiAgICAgICAgaG9pc3RhYmxlU3RhdGU6IGhvaXN0YWJsZVN0YXRlLFxuICAgICAgICBhYm9ydFNldDogYWJvcnRTZXQsXG4gICAgICAgIGtleVBhdGg6IGtleVBhdGgsXG4gICAgICAgIGZvcm1hdENvbnRleHQ6IGZvcm1hdENvbnRleHQsXG4gICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgIHRyZWVDb250ZXh0OiB0cmVlQ29udGV4dCxcbiAgICAgICAgcm93OiByb3csXG4gICAgICAgIGNvbXBvbmVudFN0YWNrOiBjb21wb25lbnRTdGFjayxcbiAgICAgICAgdGhlbmFibGVTdGF0ZTogdGhlbmFibGVTdGF0ZVxuICAgICAgfTtcbiAgICAgIHRhc2suZGVidWdUYXNrID0gZGVidWdUYXNrO1xuICAgICAgYWJvcnRTZXQuYWRkKHRhc2spO1xuICAgICAgcmV0dXJuIHRhc2s7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlcGxheVRhc2soXG4gICAgICByZXF1ZXN0LFxuICAgICAgdGhlbmFibGVTdGF0ZSxcbiAgICAgIHJlcGxheSxcbiAgICAgIG5vZGUsXG4gICAgICBjaGlsZEluZGV4LFxuICAgICAgYmxvY2tlZEJvdW5kYXJ5LFxuICAgICAgaG9pc3RhYmxlU3RhdGUsXG4gICAgICBhYm9ydFNldCxcbiAgICAgIGtleVBhdGgsXG4gICAgICBmb3JtYXRDb250ZXh0LFxuICAgICAgY29udGV4dCxcbiAgICAgIHRyZWVDb250ZXh0LFxuICAgICAgcm93LFxuICAgICAgY29tcG9uZW50U3RhY2ssXG4gICAgICBsZWdhY3lDb250ZXh0LFxuICAgICAgZGVidWdUYXNrXG4gICAgKSB7XG4gICAgICByZXF1ZXN0LmFsbFBlbmRpbmdUYXNrcysrO1xuICAgICAgbnVsbCA9PT0gYmxvY2tlZEJvdW5kYXJ5XG4gICAgICAgID8gcmVxdWVzdC5wZW5kaW5nUm9vdFRhc2tzKytcbiAgICAgICAgOiBibG9ja2VkQm91bmRhcnkucGVuZGluZ1Rhc2tzKys7XG4gICAgICBudWxsICE9PSByb3cgJiYgcm93LnBlbmRpbmdUYXNrcysrO1xuICAgICAgcmVwbGF5LnBlbmRpbmdUYXNrcysrO1xuICAgICAgdmFyIHRhc2sgPSB7XG4gICAgICAgIHJlcGxheTogcmVwbGF5LFxuICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICBjaGlsZEluZGV4OiBjaGlsZEluZGV4LFxuICAgICAgICBwaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHBpbmdUYXNrKHJlcXVlc3QsIHRhc2spO1xuICAgICAgICB9LFxuICAgICAgICBibG9ja2VkQm91bmRhcnk6IGJsb2NrZWRCb3VuZGFyeSxcbiAgICAgICAgYmxvY2tlZFNlZ21lbnQ6IG51bGwsXG4gICAgICAgIGJsb2NrZWRQcmVhbWJsZTogbnVsbCxcbiAgICAgICAgaG9pc3RhYmxlU3RhdGU6IGhvaXN0YWJsZVN0YXRlLFxuICAgICAgICBhYm9ydFNldDogYWJvcnRTZXQsXG4gICAgICAgIGtleVBhdGg6IGtleVBhdGgsXG4gICAgICAgIGZvcm1hdENvbnRleHQ6IGZvcm1hdENvbnRleHQsXG4gICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgIHRyZWVDb250ZXh0OiB0cmVlQ29udGV4dCxcbiAgICAgICAgcm93OiByb3csXG4gICAgICAgIGNvbXBvbmVudFN0YWNrOiBjb21wb25lbnRTdGFjayxcbiAgICAgICAgdGhlbmFibGVTdGF0ZTogdGhlbmFibGVTdGF0ZVxuICAgICAgfTtcbiAgICAgIHRhc2suZGVidWdUYXNrID0gZGVidWdUYXNrO1xuICAgICAgYWJvcnRTZXQuYWRkKHRhc2spO1xuICAgICAgcmV0dXJuIHRhc2s7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVBlbmRpbmdTZWdtZW50KFxuICAgICAgcmVxdWVzdCxcbiAgICAgIGluZGV4LFxuICAgICAgYm91bmRhcnksXG4gICAgICBwYXJlbnRGb3JtYXRDb250ZXh0LFxuICAgICAgbGFzdFB1c2hlZFRleHQsXG4gICAgICB0ZXh0RW1iZWRkZWRcbiAgICApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXR1czogUEVORElORyxcbiAgICAgICAgcGFyZW50Rmx1c2hlZDogITEsXG4gICAgICAgIGlkOiAtMSxcbiAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICBjaHVua3M6IFtdLFxuICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgIHByZWFtYmxlQ2hpbGRyZW46IFtdLFxuICAgICAgICBwYXJlbnRGb3JtYXRDb250ZXh0OiBwYXJlbnRGb3JtYXRDb250ZXh0LFxuICAgICAgICBib3VuZGFyeTogYm91bmRhcnksXG4gICAgICAgIGxhc3RQdXNoZWRUZXh0OiBsYXN0UHVzaGVkVGV4dCxcbiAgICAgICAgdGV4dEVtYmVkZGVkOiB0ZXh0RW1iZWRkZWRcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEN1cnJlbnRTdGFja0luREVWKCkge1xuICAgICAgaWYgKG51bGwgPT09IGN1cnJlbnRUYXNrSW5ERVYgfHwgbnVsbCA9PT0gY3VycmVudFRhc2tJbkRFVi5jb21wb25lbnRTdGFjaylcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB2YXIgY29tcG9uZW50U3RhY2sgPSBjdXJyZW50VGFza0luREVWLmNvbXBvbmVudFN0YWNrO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGluZm8gPSBcIlwiO1xuICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGNvbXBvbmVudFN0YWNrLnR5cGUpXG4gICAgICAgICAgaW5mbyArPSBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShjb21wb25lbnRTdGFjay50eXBlKTtcbiAgICAgICAgZWxzZSBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY29tcG9uZW50U3RhY2sudHlwZSkge1xuICAgICAgICAgIGlmICghY29tcG9uZW50U3RhY2sub3duZXIpIHtcbiAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX3RlbXBfY29uc3QgPSBpbmZvLFxuICAgICAgICAgICAgICBmbiA9IGNvbXBvbmVudFN0YWNrLnR5cGUsXG4gICAgICAgICAgICAgIG5hbWUgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiBcIlwiO1xuICAgICAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IG5hbWVcbiAgICAgICAgICAgICAgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKVxuICAgICAgICAgICAgICA6IFwiXCI7XG4gICAgICAgICAgICBpbmZvID0gSlNDb21waWxlcl90ZW1wX2NvbnN0ICsgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgY29tcG9uZW50U3RhY2sub3duZXIgfHxcbiAgICAgICAgICAgIChpbmZvICs9IGRlc2NyaWJlQ29tcG9uZW50U3RhY2tCeVR5cGUoY29tcG9uZW50U3RhY2sudHlwZSkpO1xuICAgICAgICBmb3IgKDsgY29tcG9uZW50U3RhY2s7IClcbiAgICAgICAgICAoSlNDb21waWxlcl90ZW1wX2NvbnN0ID0gbnVsbCksXG4gICAgICAgICAgICBudWxsICE9IGNvbXBvbmVudFN0YWNrLmRlYnVnU3RhY2tcbiAgICAgICAgICAgICAgPyAoSlNDb21waWxlcl90ZW1wX2NvbnN0ID0gZm9ybWF0T3duZXJTdGFjayhcbiAgICAgICAgICAgICAgICAgIGNvbXBvbmVudFN0YWNrLmRlYnVnU3RhY2tcbiAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgICA6ICgoSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gY29tcG9uZW50U3RhY2spLFxuICAgICAgICAgICAgICAgIG51bGwgIT0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LnN0YWNrICYmXG4gICAgICAgICAgICAgICAgICAoSlNDb21waWxlcl90ZW1wX2NvbnN0ID1cbiAgICAgICAgICAgICAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdC5zdGFja1xuICAgICAgICAgICAgICAgICAgICAgID8gKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdC5zdGFjayA9IGZvcm1hdE93bmVyU3RhY2soXG4gICAgICAgICAgICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdC5zdGFja1xuICAgICAgICAgICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgICAgICAgICA6IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdC5zdGFjaykpLFxuICAgICAgICAgICAgKGNvbXBvbmVudFN0YWNrID0gY29tcG9uZW50U3RhY2sub3duZXIpICYmXG4gICAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcF9jb25zdCAmJlxuICAgICAgICAgICAgICAoaW5mbyArPSBcIlxcblwiICsgSlNDb21waWxlcl90ZW1wX2NvbnN0KTtcbiAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMCA9IGluZm87XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMCA9XG4gICAgICAgICAgXCJcXG5FcnJvciBnZW5lcmF0aW5nIHN0YWNrOiBcIiArIHgubWVzc2FnZSArIFwiXFxuXCIgKyB4LnN0YWNrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaEhhbHRlZEF3YWl0T25Db21wb25lbnRTdGFjayh0YXNrLCBkZWJ1Z0luZm8pIHtcbiAgICAgIGlmIChudWxsICE9IGRlYnVnSW5mbylcbiAgICAgICAgZm9yICh2YXIgaSA9IGRlYnVnSW5mby5sZW5ndGggLSAxOyAwIDw9IGk7IGktLSkge1xuICAgICAgICAgIHZhciBpbmZvID0gZGVidWdJbmZvW2ldO1xuICAgICAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgaW5mby5uYW1lKSBicmVhaztcbiAgICAgICAgICBpZiAoXCJudW1iZXJcIiA9PT0gdHlwZW9mIGluZm8udGltZSkgYnJlYWs7XG4gICAgICAgICAgaWYgKG51bGwgIT0gaW5mby5hd2FpdGVkKSB7XG4gICAgICAgICAgICB2YXIgYmVzdFN0YWNrID0gbnVsbCA9PSBpbmZvLmRlYnVnU3RhY2sgPyBpbmZvLmF3YWl0ZWQgOiBpbmZvO1xuICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gYmVzdFN0YWNrLmRlYnVnU3RhY2spIHtcbiAgICAgICAgICAgICAgdGFzay5jb21wb25lbnRTdGFjayA9IHtcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IHRhc2suY29tcG9uZW50U3RhY2ssXG4gICAgICAgICAgICAgICAgdHlwZTogaW5mbyxcbiAgICAgICAgICAgICAgICBvd25lcjogYmVzdFN0YWNrLm93bmVyLFxuICAgICAgICAgICAgICAgIHN0YWNrOiBiZXN0U3RhY2suZGVidWdTdGFja1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB0YXNrLmRlYnVnVGFzayA9IGJlc3RTdGFjay5kZWJ1Z1Rhc2s7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoU2VydmVyQ29tcG9uZW50U3RhY2sodGFzaywgZGVidWdJbmZvKSB7XG4gICAgICBpZiAobnVsbCAhPSBkZWJ1Z0luZm8pXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVidWdJbmZvLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGNvbXBvbmVudEluZm8gPSBkZWJ1Z0luZm9baV07XG4gICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGNvbXBvbmVudEluZm8ubmFtZSAmJlxuICAgICAgICAgICAgdm9pZCAwICE9PSBjb21wb25lbnRJbmZvLmRlYnVnU3RhY2sgJiZcbiAgICAgICAgICAgICgodGFzay5jb21wb25lbnRTdGFjayA9IHtcbiAgICAgICAgICAgICAgcGFyZW50OiB0YXNrLmNvbXBvbmVudFN0YWNrLFxuICAgICAgICAgICAgICB0eXBlOiBjb21wb25lbnRJbmZvLFxuICAgICAgICAgICAgICBvd25lcjogY29tcG9uZW50SW5mby5vd25lcixcbiAgICAgICAgICAgICAgc3RhY2s6IGNvbXBvbmVudEluZm8uZGVidWdTdGFja1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAodGFzay5kZWJ1Z1Rhc2sgPSBjb21wb25lbnRJbmZvLmRlYnVnVGFzaykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hDb21wb25lbnRTdGFjayh0YXNrKSB7XG4gICAgICB2YXIgbm9kZSA9IHRhc2subm9kZTtcbiAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2Ygbm9kZSAmJiBudWxsICE9PSBub2RlKVxuICAgICAgICBzd2l0Y2ggKG5vZGUuJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICAgIHZhciB0eXBlID0gbm9kZS50eXBlLFxuICAgICAgICAgICAgICBvd25lciA9IG5vZGUuX293bmVyLFxuICAgICAgICAgICAgICBzdGFjayA9IG5vZGUuX2RlYnVnU3RhY2s7XG4gICAgICAgICAgICBwdXNoU2VydmVyQ29tcG9uZW50U3RhY2sodGFzaywgbm9kZS5fZGVidWdJbmZvKTtcbiAgICAgICAgICAgIHRhc2suZGVidWdUYXNrID0gbm9kZS5fZGVidWdUYXNrO1xuICAgICAgICAgICAgdGFzay5jb21wb25lbnRTdGFjayA9IHtcbiAgICAgICAgICAgICAgcGFyZW50OiB0YXNrLmNvbXBvbmVudFN0YWNrLFxuICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICBvd25lcjogb3duZXIsXG4gICAgICAgICAgICAgIHN0YWNrOiBzdGFja1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgcHVzaFNlcnZlckNvbXBvbmVudFN0YWNrKHRhc2ssIG5vZGUuX2RlYnVnSW5mbyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2Ygbm9kZS50aGVuICYmXG4gICAgICAgICAgICAgIHB1c2hTZXJ2ZXJDb21wb25lbnRTdGFjayh0YXNrLCBub2RlLl9kZWJ1Z0luZm8pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcGxhY2VTdXNwZW5zZUNvbXBvbmVudFN0YWNrV2l0aFN1c3BlbnNlRmFsbGJhY2tTdGFjayhcbiAgICAgIGNvbXBvbmVudFN0YWNrXG4gICAgKSB7XG4gICAgICByZXR1cm4gbnVsbCA9PT0gY29tcG9uZW50U3RhY2tcbiAgICAgICAgPyBudWxsXG4gICAgICAgIDoge1xuICAgICAgICAgICAgcGFyZW50OiBjb21wb25lbnRTdGFjay5wYXJlbnQsXG4gICAgICAgICAgICB0eXBlOiBcIlN1c3BlbnNlIEZhbGxiYWNrXCIsXG4gICAgICAgICAgICBvd25lcjogY29tcG9uZW50U3RhY2sub3duZXIsXG4gICAgICAgICAgICBzdGFjazogY29tcG9uZW50U3RhY2suc3RhY2tcbiAgICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRUaHJvd25JbmZvKG5vZGUkanNjb21wJDApIHtcbiAgICAgIHZhciBlcnJvckluZm8gPSB7fTtcbiAgICAgIG5vZGUkanNjb21wJDAgJiZcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVycm9ySW5mbywgXCJjb21wb25lbnRTdGFja1wiLCB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHZhciBpbmZvID0gXCJcIixcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZSRqc2NvbXAkMDtcbiAgICAgICAgICAgICAgZG9cbiAgICAgICAgICAgICAgICAoaW5mbyArPSBkZXNjcmliZUNvbXBvbmVudFN0YWNrQnlUeXBlKG5vZGUudHlwZSkpLFxuICAgICAgICAgICAgICAgICAgKG5vZGUgPSBub2RlLnBhcmVudCk7XG4gICAgICAgICAgICAgIHdoaWxlIChub2RlKTtcbiAgICAgICAgICAgICAgdmFyIHN0YWNrID0gaW5mbztcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgc3RhY2sgPSBcIlxcbkVycm9yIGdlbmVyYXRpbmcgc3RhY2s6IFwiICsgeC5tZXNzYWdlICsgXCJcXG5cIiArIHguc3RhY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyb3JJbmZvLCBcImNvbXBvbmVudFN0YWNrXCIsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IHN0YWNrXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBzdGFjaztcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgcmV0dXJuIGVycm9ySW5mbztcbiAgICB9XG4gICAgZnVuY3Rpb24gZW5jb2RlRXJyb3JGb3JCb3VuZGFyeShcbiAgICAgIGJvdW5kYXJ5LFxuICAgICAgZGlnZXN0LFxuICAgICAgZXJyb3IsXG4gICAgICB0aHJvd25JbmZvLFxuICAgICAgd2FzQWJvcnRlZFxuICAgICkge1xuICAgICAgYm91bmRhcnkuZXJyb3JEaWdlc3QgPSBkaWdlc3Q7XG4gICAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yXG4gICAgICAgID8gKChkaWdlc3QgPSBTdHJpbmcoZXJyb3IubWVzc2FnZSkpLCAoZXJyb3IgPSBTdHJpbmcoZXJyb3Iuc3RhY2spKSlcbiAgICAgICAgOiAoKGRpZ2VzdCA9XG4gICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgZXJyb3IgJiYgbnVsbCAhPT0gZXJyb3JcbiAgICAgICAgICAgICAgPyBkZXNjcmliZU9iamVjdEZvckVycm9yTWVzc2FnZShlcnJvcilcbiAgICAgICAgICAgICAgOiBTdHJpbmcoZXJyb3IpKSxcbiAgICAgICAgICAoZXJyb3IgPSBudWxsKSk7XG4gICAgICB3YXNBYm9ydGVkID0gd2FzQWJvcnRlZFxuICAgICAgICA/IFwiU3dpdGNoZWQgdG8gY2xpZW50IHJlbmRlcmluZyBiZWNhdXNlIHRoZSBzZXJ2ZXIgcmVuZGVyaW5nIGFib3J0ZWQgZHVlIHRvOlxcblxcblwiXG4gICAgICAgIDogXCJTd2l0Y2hlZCB0byBjbGllbnQgcmVuZGVyaW5nIGJlY2F1c2UgdGhlIHNlcnZlciByZW5kZXJpbmcgZXJyb3JlZDpcXG5cXG5cIjtcbiAgICAgIGJvdW5kYXJ5LmVycm9yTWVzc2FnZSA9IHdhc0Fib3J0ZWQgKyBkaWdlc3Q7XG4gICAgICBib3VuZGFyeS5lcnJvclN0YWNrID0gbnVsbCAhPT0gZXJyb3IgPyB3YXNBYm9ydGVkICsgZXJyb3IgOiBudWxsO1xuICAgICAgYm91bmRhcnkuZXJyb3JDb21wb25lbnRTdGFjayA9IHRocm93bkluZm8uY29tcG9uZW50U3RhY2s7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxvZ1JlY292ZXJhYmxlRXJyb3IocmVxdWVzdCwgZXJyb3IsIGVycm9ySW5mbywgZGVidWdUYXNrKSB7XG4gICAgICByZXF1ZXN0ID0gcmVxdWVzdC5vbkVycm9yO1xuICAgICAgZXJyb3IgPSBkZWJ1Z1Rhc2tcbiAgICAgICAgPyBkZWJ1Z1Rhc2sucnVuKHJlcXVlc3QuYmluZChudWxsLCBlcnJvciwgZXJyb3JJbmZvKSlcbiAgICAgICAgOiByZXF1ZXN0KGVycm9yLCBlcnJvckluZm8pO1xuICAgICAgaWYgKG51bGwgIT0gZXJyb3IgJiYgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIGVycm9yKVxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICdvbkVycm9yIHJldHVybmVkIHNvbWV0aGluZyB3aXRoIGEgdHlwZSBvdGhlciB0aGFuIFwic3RyaW5nXCIuIG9uRXJyb3Igc2hvdWxkIHJldHVybiBhIHN0cmluZyBhbmQgbWF5IHJldHVybiBudWxsIG9yIHVuZGVmaW5lZCBidXQgbXVzdCBub3QgcmV0dXJuIGFueXRoaW5nIGVsc2UuIEl0IHJlY2VpdmVkIHNvbWV0aGluZyBvZiB0eXBlIFwiJXNcIiBpbnN0ZWFkJyxcbiAgICAgICAgICB0eXBlb2YgZXJyb3JcbiAgICAgICAgKTtcbiAgICAgIGVsc2UgcmV0dXJuIGVycm9yO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmYXRhbEVycm9yKHJlcXVlc3QsIGVycm9yLCBlcnJvckluZm8sIGRlYnVnVGFzaykge1xuICAgICAgZXJyb3JJbmZvID0gcmVxdWVzdC5vblNoZWxsRXJyb3I7XG4gICAgICB2YXIgb25GYXRhbEVycm9yID0gcmVxdWVzdC5vbkZhdGFsRXJyb3I7XG4gICAgICBkZWJ1Z1Rhc2tcbiAgICAgICAgPyAoZGVidWdUYXNrLnJ1bihlcnJvckluZm8uYmluZChudWxsLCBlcnJvcikpLFxuICAgICAgICAgIGRlYnVnVGFzay5ydW4ob25GYXRhbEVycm9yLmJpbmQobnVsbCwgZXJyb3IpKSlcbiAgICAgICAgOiAoZXJyb3JJbmZvKGVycm9yKSwgb25GYXRhbEVycm9yKGVycm9yKSk7XG4gICAgICBudWxsICE9PSByZXF1ZXN0LmRlc3RpbmF0aW9uXG4gICAgICAgID8gKChyZXF1ZXN0LnN0YXR1cyA9IENMT1NFRCksXG4gICAgICAgICAgY2xvc2VXaXRoRXJyb3IocmVxdWVzdC5kZXN0aW5hdGlvbiwgZXJyb3IpKVxuICAgICAgICA6ICgocmVxdWVzdC5zdGF0dXMgPSAxMyksIChyZXF1ZXN0LmZhdGFsRXJyb3IgPSBlcnJvcikpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5pc2hTdXNwZW5zZUxpc3RSb3cocmVxdWVzdCwgcm93KSB7XG4gICAgICB1bmJsb2NrU3VzcGVuc2VMaXN0Um93KHJlcXVlc3QsIHJvdy5uZXh0LCByb3cuaG9pc3RhYmxlcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVuYmxvY2tTdXNwZW5zZUxpc3RSb3coXG4gICAgICByZXF1ZXN0LFxuICAgICAgdW5ibG9ja2VkUm93LFxuICAgICAgaW5oZXJpdGVkSG9pc3RhYmxlc1xuICAgICkge1xuICAgICAgZm9yICg7IG51bGwgIT09IHVuYmxvY2tlZFJvdzsgKSB7XG4gICAgICAgIG51bGwgIT09IGluaGVyaXRlZEhvaXN0YWJsZXMgJiZcbiAgICAgICAgICAoaG9pc3RIb2lzdGFibGVzKHVuYmxvY2tlZFJvdy5ob2lzdGFibGVzLCBpbmhlcml0ZWRIb2lzdGFibGVzKSxcbiAgICAgICAgICAodW5ibG9ja2VkUm93LmluaGVyaXRlZEhvaXN0YWJsZXMgPSBpbmhlcml0ZWRIb2lzdGFibGVzKSk7XG4gICAgICAgIHZhciB1bmJsb2NrZWRCb3VuZGFyaWVzID0gdW5ibG9ja2VkUm93LmJvdW5kYXJpZXM7XG4gICAgICAgIGlmIChudWxsICE9PSB1bmJsb2NrZWRCb3VuZGFyaWVzKSB7XG4gICAgICAgICAgdW5ibG9ja2VkUm93LmJvdW5kYXJpZXMgPSBudWxsO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdW5ibG9ja2VkQm91bmRhcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHVuYmxvY2tlZEJvdW5kYXJ5ID0gdW5ibG9ja2VkQm91bmRhcmllc1tpXTtcbiAgICAgICAgICAgIG51bGwgIT09IGluaGVyaXRlZEhvaXN0YWJsZXMgJiZcbiAgICAgICAgICAgICAgaG9pc3RIb2lzdGFibGVzKFxuICAgICAgICAgICAgICAgIHVuYmxvY2tlZEJvdW5kYXJ5LmNvbnRlbnRTdGF0ZSxcbiAgICAgICAgICAgICAgICBpbmhlcml0ZWRIb2lzdGFibGVzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBmaW5pc2hlZFRhc2socmVxdWVzdCwgdW5ibG9ja2VkQm91bmRhcnksIG51bGwsIG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB1bmJsb2NrZWRSb3cucGVuZGluZ1Rhc2tzLS07XG4gICAgICAgIGlmICgwIDwgdW5ibG9ja2VkUm93LnBlbmRpbmdUYXNrcykgYnJlYWs7XG4gICAgICAgIGluaGVyaXRlZEhvaXN0YWJsZXMgPSB1bmJsb2NrZWRSb3cuaG9pc3RhYmxlcztcbiAgICAgICAgdW5ibG9ja2VkUm93ID0gdW5ibG9ja2VkUm93Lm5leHQ7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyeVRvUmVzb2x2ZVRvZ2V0aGVyUm93KHJlcXVlc3QsIHRvZ2V0aGVyUm93KSB7XG4gICAgICB2YXIgYm91bmRhcmllcyA9IHRvZ2V0aGVyUm93LmJvdW5kYXJpZXM7XG4gICAgICBpZiAoXG4gICAgICAgIG51bGwgIT09IGJvdW5kYXJpZXMgJiZcbiAgICAgICAgdG9nZXRoZXJSb3cucGVuZGluZ1Rhc2tzID09PSBib3VuZGFyaWVzLmxlbmd0aFxuICAgICAgKSB7XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgdmFyIGFsbENvbXBsZXRlQW5kSW5saW5hYmxlID0gITAsIGkgPSAwO1xuICAgICAgICAgIGkgPCBib3VuZGFyaWVzLmxlbmd0aDtcbiAgICAgICAgICBpKytcbiAgICAgICAgKSB7XG4gICAgICAgICAgdmFyIHJvd0JvdW5kYXJ5ID0gYm91bmRhcmllc1tpXTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAxICE9PSByb3dCb3VuZGFyeS5wZW5kaW5nVGFza3MgfHxcbiAgICAgICAgICAgIHJvd0JvdW5kYXJ5LnBhcmVudEZsdXNoZWQgfHxcbiAgICAgICAgICAgIGlzRWxpZ2libGVGb3JPdXRsaW5pbmcocmVxdWVzdCwgcm93Qm91bmRhcnkpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBhbGxDb21wbGV0ZUFuZElubGluYWJsZSA9ICExO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFsbENvbXBsZXRlQW5kSW5saW5hYmxlICYmXG4gICAgICAgICAgdW5ibG9ja1N1c3BlbnNlTGlzdFJvdyhyZXF1ZXN0LCB0b2dldGhlclJvdywgdG9nZXRoZXJSb3cuaG9pc3RhYmxlcyk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVN1c3BlbnNlTGlzdFJvdyhwcmV2aW91c1Jvdykge1xuICAgICAgdmFyIG5ld1JvdyA9IHtcbiAgICAgICAgcGVuZGluZ1Rhc2tzOiAxLFxuICAgICAgICBib3VuZGFyaWVzOiBudWxsLFxuICAgICAgICBob2lzdGFibGVzOiBjcmVhdGVIb2lzdGFibGVTdGF0ZSgpLFxuICAgICAgICBpbmhlcml0ZWRIb2lzdGFibGVzOiBudWxsLFxuICAgICAgICB0b2dldGhlcjogITEsXG4gICAgICAgIG5leHQ6IG51bGxcbiAgICAgIH07XG4gICAgICBudWxsICE9PSBwcmV2aW91c1JvdyAmJlxuICAgICAgICAwIDwgcHJldmlvdXNSb3cucGVuZGluZ1Rhc2tzICYmXG4gICAgICAgIChuZXdSb3cucGVuZGluZ1Rhc2tzKyssXG4gICAgICAgIChuZXdSb3cuYm91bmRhcmllcyA9IFtdKSxcbiAgICAgICAgKHByZXZpb3VzUm93Lm5leHQgPSBuZXdSb3cpKTtcbiAgICAgIHJldHVybiBuZXdSb3c7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbmRlclN1c3BlbnNlTGlzdFJvd3MocmVxdWVzdCwgdGFzaywga2V5UGF0aCwgcm93cywgcmV2ZWFsT3JkZXIpIHtcbiAgICAgIHZhciBwcmV2S2V5UGF0aCA9IHRhc2sua2V5UGF0aCxcbiAgICAgICAgcHJldlRyZWVDb250ZXh0ID0gdGFzay50cmVlQ29udGV4dCxcbiAgICAgICAgcHJldlJvdyA9IHRhc2sucm93LFxuICAgICAgICBwcmV2aW91c0NvbXBvbmVudFN0YWNrID0gdGFzay5jb21wb25lbnRTdGFjaztcbiAgICAgIHZhciBwcmV2aW91c0RlYnVnVGFzayA9IHRhc2suZGVidWdUYXNrO1xuICAgICAgcHVzaFNlcnZlckNvbXBvbmVudFN0YWNrKHRhc2ssIHRhc2subm9kZS5wcm9wcy5jaGlsZHJlbi5fZGVidWdJbmZvKTtcbiAgICAgIHRhc2sua2V5UGF0aCA9IGtleVBhdGg7XG4gICAgICBrZXlQYXRoID0gcm93cy5sZW5ndGg7XG4gICAgICB2YXIgcHJldmlvdXNTdXNwZW5zZUxpc3RSb3cgPSBudWxsO1xuICAgICAgaWYgKG51bGwgIT09IHRhc2sucmVwbGF5KSB7XG4gICAgICAgIHZhciByZXN1bWVTbG90cyA9IHRhc2sucmVwbGF5LnNsb3RzO1xuICAgICAgICBpZiAobnVsbCAhPT0gcmVzdW1lU2xvdHMgJiYgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHJlc3VtZVNsb3RzKVxuICAgICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwga2V5UGF0aDsgbisrKSB7XG4gICAgICAgICAgICB2YXIgaSA9XG4gICAgICAgICAgICAgICAgXCJiYWNrd2FyZHNcIiAhPT0gcmV2ZWFsT3JkZXIgJiZcbiAgICAgICAgICAgICAgICBcInVuc3RhYmxlX2xlZ2FjeS1iYWNrd2FyZHNcIiAhPT0gcmV2ZWFsT3JkZXJcbiAgICAgICAgICAgICAgICAgID8gblxuICAgICAgICAgICAgICAgICAgOiBrZXlQYXRoIC0gMSAtIG4sXG4gICAgICAgICAgICAgIG5vZGUgPSByb3dzW2ldO1xuICAgICAgICAgICAgdGFzay5yb3cgPSBwcmV2aW91c1N1c3BlbnNlTGlzdFJvdyA9IGNyZWF0ZVN1c3BlbnNlTGlzdFJvdyhcbiAgICAgICAgICAgICAgcHJldmlvdXNTdXNwZW5zZUxpc3RSb3dcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0YXNrLnRyZWVDb250ZXh0ID0gcHVzaFRyZWVDb250ZXh0KHByZXZUcmVlQ29udGV4dCwga2V5UGF0aCwgaSk7XG4gICAgICAgICAgICB2YXIgcmVzdW1lU2VnbWVudElEID0gcmVzdW1lU2xvdHNbaV07XG4gICAgICAgICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgcmVzdW1lU2VnbWVudElEXG4gICAgICAgICAgICAgID8gKHJlc3VtZU5vZGUocmVxdWVzdCwgdGFzaywgcmVzdW1lU2VnbWVudElELCBub2RlLCBpKSxcbiAgICAgICAgICAgICAgICBkZWxldGUgcmVzdW1lU2xvdHNbaV0pXG4gICAgICAgICAgICAgIDogcmVuZGVyTm9kZShyZXF1ZXN0LCB0YXNrLCBub2RlLCBpKTtcbiAgICAgICAgICAgIDAgPT09IC0tcHJldmlvdXNTdXNwZW5zZUxpc3RSb3cucGVuZGluZ1Rhc2tzICYmXG4gICAgICAgICAgICAgIGZpbmlzaFN1c3BlbnNlTGlzdFJvdyhyZXF1ZXN0LCBwcmV2aW91c1N1c3BlbnNlTGlzdFJvdyk7XG4gICAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgZm9yIChyZXN1bWVTbG90cyA9IDA7IHJlc3VtZVNsb3RzIDwga2V5UGF0aDsgcmVzdW1lU2xvdHMrKylcbiAgICAgICAgICAgIChuID1cbiAgICAgICAgICAgICAgXCJiYWNrd2FyZHNcIiAhPT0gcmV2ZWFsT3JkZXIgJiZcbiAgICAgICAgICAgICAgXCJ1bnN0YWJsZV9sZWdhY3ktYmFja3dhcmRzXCIgIT09IHJldmVhbE9yZGVyXG4gICAgICAgICAgICAgICAgPyByZXN1bWVTbG90c1xuICAgICAgICAgICAgICAgIDoga2V5UGF0aCAtIDEgLSByZXN1bWVTbG90cyksXG4gICAgICAgICAgICAgIChpID0gcm93c1tuXSksXG4gICAgICAgICAgICAgIHdhcm5Gb3JNaXNzaW5nS2V5KHJlcXVlc3QsIHRhc2ssIGkpLFxuICAgICAgICAgICAgICAodGFzay5yb3cgPSBwcmV2aW91c1N1c3BlbnNlTGlzdFJvdyA9XG4gICAgICAgICAgICAgICAgY3JlYXRlU3VzcGVuc2VMaXN0Um93KHByZXZpb3VzU3VzcGVuc2VMaXN0Um93KSksXG4gICAgICAgICAgICAgICh0YXNrLnRyZWVDb250ZXh0ID0gcHVzaFRyZWVDb250ZXh0KHByZXZUcmVlQ29udGV4dCwga2V5UGF0aCwgbikpLFxuICAgICAgICAgICAgICByZW5kZXJOb2RlKHJlcXVlc3QsIHRhc2ssIGksIG4pLFxuICAgICAgICAgICAgICAwID09PSAtLXByZXZpb3VzU3VzcGVuc2VMaXN0Um93LnBlbmRpbmdUYXNrcyAmJlxuICAgICAgICAgICAgICAgIGZpbmlzaFN1c3BlbnNlTGlzdFJvdyhyZXF1ZXN0LCBwcmV2aW91c1N1c3BlbnNlTGlzdFJvdyk7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBcImJhY2t3YXJkc1wiICE9PSByZXZlYWxPcmRlciAmJlxuICAgICAgICBcInVuc3RhYmxlX2xlZ2FjeS1iYWNrd2FyZHNcIiAhPT0gcmV2ZWFsT3JkZXJcbiAgICAgIClcbiAgICAgICAgZm9yIChyZXZlYWxPcmRlciA9IDA7IHJldmVhbE9yZGVyIDwga2V5UGF0aDsgcmV2ZWFsT3JkZXIrKylcbiAgICAgICAgICAocmVzdW1lU2xvdHMgPSByb3dzW3JldmVhbE9yZGVyXSksXG4gICAgICAgICAgICB3YXJuRm9yTWlzc2luZ0tleShyZXF1ZXN0LCB0YXNrLCByZXN1bWVTbG90cyksXG4gICAgICAgICAgICAodGFzay5yb3cgPSBwcmV2aW91c1N1c3BlbnNlTGlzdFJvdyA9XG4gICAgICAgICAgICAgIGNyZWF0ZVN1c3BlbnNlTGlzdFJvdyhwcmV2aW91c1N1c3BlbnNlTGlzdFJvdykpLFxuICAgICAgICAgICAgKHRhc2sudHJlZUNvbnRleHQgPSBwdXNoVHJlZUNvbnRleHQoXG4gICAgICAgICAgICAgIHByZXZUcmVlQ29udGV4dCxcbiAgICAgICAgICAgICAga2V5UGF0aCxcbiAgICAgICAgICAgICAgcmV2ZWFsT3JkZXJcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgcmVuZGVyTm9kZShyZXF1ZXN0LCB0YXNrLCByZXN1bWVTbG90cywgcmV2ZWFsT3JkZXIpLFxuICAgICAgICAgICAgMCA9PT0gLS1wcmV2aW91c1N1c3BlbnNlTGlzdFJvdy5wZW5kaW5nVGFza3MgJiZcbiAgICAgICAgICAgICAgZmluaXNoU3VzcGVuc2VMaXN0Um93KHJlcXVlc3QsIHByZXZpb3VzU3VzcGVuc2VMaXN0Um93KTtcbiAgICAgIGVsc2Uge1xuICAgICAgICByZXZlYWxPcmRlciA9IHRhc2suYmxvY2tlZFNlZ21lbnQ7XG4gICAgICAgIHJlc3VtZVNsb3RzID0gcmV2ZWFsT3JkZXIuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICBuID0gcmV2ZWFsT3JkZXIuY2h1bmtzLmxlbmd0aDtcbiAgICAgICAgZm9yIChpID0ga2V5UGF0aCAtIDE7IDAgPD0gaTsgaS0tKSB7XG4gICAgICAgICAgbm9kZSA9IHJvd3NbaV07XG4gICAgICAgICAgdGFzay5yb3cgPSBwcmV2aW91c1N1c3BlbnNlTGlzdFJvdyA9IGNyZWF0ZVN1c3BlbnNlTGlzdFJvdyhcbiAgICAgICAgICAgIHByZXZpb3VzU3VzcGVuc2VMaXN0Um93XG4gICAgICAgICAgKTtcbiAgICAgICAgICB0YXNrLnRyZWVDb250ZXh0ID0gcHVzaFRyZWVDb250ZXh0KHByZXZUcmVlQ29udGV4dCwga2V5UGF0aCwgaSk7XG4gICAgICAgICAgcmVzdW1lU2VnbWVudElEID0gY3JlYXRlUGVuZGluZ1NlZ21lbnQoXG4gICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgbixcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICB0YXNrLmZvcm1hdENvbnRleHQsXG4gICAgICAgICAgICAwID09PSBpID8gcmV2ZWFsT3JkZXIubGFzdFB1c2hlZFRleHQgOiAhMCxcbiAgICAgICAgICAgICEwXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXZlYWxPcmRlci5jaGlsZHJlbi5zcGxpY2UocmVzdW1lU2xvdHMsIDAsIHJlc3VtZVNlZ21lbnRJRCk7XG4gICAgICAgICAgdGFzay5ibG9ja2VkU2VnbWVudCA9IHJlc3VtZVNlZ21lbnRJRDtcbiAgICAgICAgICB3YXJuRm9yTWlzc2luZ0tleShyZXF1ZXN0LCB0YXNrLCBub2RlKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVuZGVyTm9kZShyZXF1ZXN0LCB0YXNrLCBub2RlLCBpKSxcbiAgICAgICAgICAgICAgcmVzdW1lU2VnbWVudElELmxhc3RQdXNoZWRUZXh0ICYmXG4gICAgICAgICAgICAgICAgcmVzdW1lU2VnbWVudElELnRleHRFbWJlZGRlZCAmJlxuICAgICAgICAgICAgICAgIHJlc3VtZVNlZ21lbnRJRC5jaHVua3MucHVzaCh0ZXh0U2VwYXJhdG9yKSxcbiAgICAgICAgICAgICAgKHJlc3VtZVNlZ21lbnRJRC5zdGF0dXMgPSBDT01QTEVURUQpLFxuICAgICAgICAgICAgICBmaW5pc2hlZFNlZ21lbnQocmVxdWVzdCwgdGFzay5ibG9ja2VkQm91bmRhcnksIHJlc3VtZVNlZ21lbnRJRCksXG4gICAgICAgICAgICAgIDAgPT09IC0tcHJldmlvdXNTdXNwZW5zZUxpc3RSb3cucGVuZGluZ1Rhc2tzICYmXG4gICAgICAgICAgICAgICAgZmluaXNoU3VzcGVuc2VMaXN0Um93KHJlcXVlc3QsIHByZXZpb3VzU3VzcGVuc2VMaXN0Um93KTtcbiAgICAgICAgICB9IGNhdGNoICh0aHJvd25WYWx1ZSkge1xuICAgICAgICAgICAgdGhyb3cgKFxuICAgICAgICAgICAgICAoKHJlc3VtZVNlZ21lbnRJRC5zdGF0dXMgPVxuICAgICAgICAgICAgICAgIDEyID09PSByZXF1ZXN0LnN0YXR1cyA/IEFCT1JURUQgOiBFUlJPUkVEKSxcbiAgICAgICAgICAgICAgdGhyb3duVmFsdWUpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0YXNrLmJsb2NrZWRTZWdtZW50ID0gcmV2ZWFsT3JkZXI7XG4gICAgICAgIHJldmVhbE9yZGVyLmxhc3RQdXNoZWRUZXh0ID0gITE7XG4gICAgICB9XG4gICAgICBudWxsICE9PSBwcmV2Um93ICYmXG4gICAgICAgIG51bGwgIT09IHByZXZpb3VzU3VzcGVuc2VMaXN0Um93ICYmXG4gICAgICAgIDAgPCBwcmV2aW91c1N1c3BlbnNlTGlzdFJvdy5wZW5kaW5nVGFza3MgJiZcbiAgICAgICAgKHByZXZSb3cucGVuZGluZ1Rhc2tzKyssIChwcmV2aW91c1N1c3BlbnNlTGlzdFJvdy5uZXh0ID0gcHJldlJvdykpO1xuICAgICAgdGFzay50cmVlQ29udGV4dCA9IHByZXZUcmVlQ29udGV4dDtcbiAgICAgIHRhc2sucm93ID0gcHJldlJvdztcbiAgICAgIHRhc2sua2V5UGF0aCA9IHByZXZLZXlQYXRoO1xuICAgICAgdGFzay5jb21wb25lbnRTdGFjayA9IHByZXZpb3VzQ29tcG9uZW50U3RhY2s7XG4gICAgICB0YXNrLmRlYnVnVGFzayA9IHByZXZpb3VzRGVidWdUYXNrO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZW5kZXJXaXRoSG9va3MoXG4gICAgICByZXF1ZXN0LFxuICAgICAgdGFzayxcbiAgICAgIGtleVBhdGgsXG4gICAgICBDb21wb25lbnQsXG4gICAgICBwcm9wcyxcbiAgICAgIHNlY29uZEFyZ1xuICAgICkge1xuICAgICAgdmFyIHByZXZUaGVuYWJsZVN0YXRlID0gdGFzay50aGVuYWJsZVN0YXRlO1xuICAgICAgdGFzay50aGVuYWJsZVN0YXRlID0gbnVsbDtcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCA9IHt9O1xuICAgICAgY3VycmVudGx5UmVuZGVyaW5nVGFzayA9IHRhc2s7XG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdSZXF1ZXN0ID0gcmVxdWVzdDtcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0tleVBhdGggPSBrZXlQYXRoO1xuICAgICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gITE7XG4gICAgICBhY3Rpb25TdGF0ZUNvdW50ZXIgPSBsb2NhbElkQ291bnRlciA9IDA7XG4gICAgICBhY3Rpb25TdGF0ZU1hdGNoaW5nSW5kZXggPSAtMTtcbiAgICAgIHRoZW5hYmxlSW5kZXhDb3VudGVyID0gMDtcbiAgICAgIHRoZW5hYmxlU3RhdGUgPSBwcmV2VGhlbmFibGVTdGF0ZTtcbiAgICAgIGZvciAoXG4gICAgICAgIHJlcXVlc3QgPSBjYWxsQ29tcG9uZW50SW5ERVYoQ29tcG9uZW50LCBwcm9wcywgc2Vjb25kQXJnKTtcbiAgICAgICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZTtcblxuICAgICAgKVxuICAgICAgICAoZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9ICExKSxcbiAgICAgICAgICAoYWN0aW9uU3RhdGVDb3VudGVyID0gbG9jYWxJZENvdW50ZXIgPSAwKSxcbiAgICAgICAgICAoYWN0aW9uU3RhdGVNYXRjaGluZ0luZGV4ID0gLTEpLFxuICAgICAgICAgICh0aGVuYWJsZUluZGV4Q291bnRlciA9IDApLFxuICAgICAgICAgIChudW1iZXJPZlJlUmVuZGVycyArPSAxKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbCksXG4gICAgICAgICAgKHJlcXVlc3QgPSBDb21wb25lbnQocHJvcHMsIHNlY29uZEFyZykpO1xuICAgICAgcmVzZXRIb29rc1N0YXRlKCk7XG4gICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmluaXNoRnVuY3Rpb25Db21wb25lbnQoXG4gICAgICByZXF1ZXN0LFxuICAgICAgdGFzayxcbiAgICAgIGtleVBhdGgsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIGhhc0lkLFxuICAgICAgYWN0aW9uU3RhdGVDb3VudCxcbiAgICAgIGFjdGlvblN0YXRlTWF0Y2hpbmdJbmRleFxuICAgICkge1xuICAgICAgdmFyIGRpZEVtaXRBY3Rpb25TdGF0ZU1hcmtlcnMgPSAhMTtcbiAgICAgIGlmICgwICE9PSBhY3Rpb25TdGF0ZUNvdW50ICYmIG51bGwgIT09IHJlcXVlc3QuZm9ybVN0YXRlKSB7XG4gICAgICAgIHZhciBzZWdtZW50ID0gdGFzay5ibG9ja2VkU2VnbWVudDtcbiAgICAgICAgaWYgKG51bGwgIT09IHNlZ21lbnQpIHtcbiAgICAgICAgICBkaWRFbWl0QWN0aW9uU3RhdGVNYXJrZXJzID0gITA7XG4gICAgICAgICAgc2VnbWVudCA9IHNlZ21lbnQuY2h1bmtzO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWN0aW9uU3RhdGVDb3VudDsgaSsrKVxuICAgICAgICAgICAgaSA9PT0gYWN0aW9uU3RhdGVNYXRjaGluZ0luZGV4XG4gICAgICAgICAgICAgID8gc2VnbWVudC5wdXNoKGZvcm1TdGF0ZU1hcmtlcklzTWF0Y2hpbmcpXG4gICAgICAgICAgICAgIDogc2VnbWVudC5wdXNoKGZvcm1TdGF0ZU1hcmtlcklzTm90TWF0Y2hpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhY3Rpb25TdGF0ZUNvdW50ID0gdGFzay5rZXlQYXRoO1xuICAgICAgdGFzay5rZXlQYXRoID0ga2V5UGF0aDtcbiAgICAgIGhhc0lkXG4gICAgICAgID8gKChrZXlQYXRoID0gdGFzay50cmVlQ29udGV4dCksXG4gICAgICAgICAgKHRhc2sudHJlZUNvbnRleHQgPSBwdXNoVHJlZUNvbnRleHQoa2V5UGF0aCwgMSwgMCkpLFxuICAgICAgICAgIHJlbmRlck5vZGUocmVxdWVzdCwgdGFzaywgY2hpbGRyZW4sIC0xKSxcbiAgICAgICAgICAodGFzay50cmVlQ29udGV4dCA9IGtleVBhdGgpKVxuICAgICAgICA6IGRpZEVtaXRBY3Rpb25TdGF0ZU1hcmtlcnNcbiAgICAgICAgICA/IHJlbmRlck5vZGUocmVxdWVzdCwgdGFzaywgY2hpbGRyZW4sIC0xKVxuICAgICAgICAgIDogcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIGNoaWxkcmVuLCAtMSk7XG4gICAgICB0YXNrLmtleVBhdGggPSBhY3Rpb25TdGF0ZUNvdW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiByZW5kZXJFbGVtZW50KHJlcXVlc3QsIHRhc2ssIGtleVBhdGgsIHR5cGUsIHByb3BzLCByZWYpIHtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlKVxuICAgICAgICBpZiAodHlwZS5wcm90b3R5cGUgJiYgdHlwZS5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCkge1xuICAgICAgICAgIHZhciBuZXdQcm9wcyA9IHByb3BzO1xuICAgICAgICAgIGlmIChcInJlZlwiIGluIHByb3BzKSB7XG4gICAgICAgICAgICBuZXdQcm9wcyA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gcHJvcHMpXG4gICAgICAgICAgICAgIFwicmVmXCIgIT09IHByb3BOYW1lICYmIChuZXdQcm9wc1twcm9wTmFtZV0gPSBwcm9wc1twcm9wTmFtZV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XG4gICAgICAgICAgaWYgKGRlZmF1bHRQcm9wcykge1xuICAgICAgICAgICAgbmV3UHJvcHMgPT09IHByb3BzICYmIChuZXdQcm9wcyA9IGFzc2lnbih7fSwgbmV3UHJvcHMsIHByb3BzKSk7XG4gICAgICAgICAgICBmb3IgKHZhciBfcHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKVxuICAgICAgICAgICAgICB2b2lkIDAgPT09IG5ld1Byb3BzW19wcm9wTmFtZV0gJiZcbiAgICAgICAgICAgICAgICAobmV3UHJvcHNbX3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1tfcHJvcE5hbWVdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHJlc29sdmVkUHJvcHMgPSBuZXdQcm9wcztcbiAgICAgICAgICB2YXIgY29udGV4dCA9IGVtcHR5Q29udGV4dE9iamVjdCxcbiAgICAgICAgICAgIGNvbnRleHRUeXBlID0gdHlwZS5jb250ZXh0VHlwZTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBcImNvbnRleHRUeXBlXCIgaW4gdHlwZSAmJlxuICAgICAgICAgICAgbnVsbCAhPT0gY29udGV4dFR5cGUgJiZcbiAgICAgICAgICAgICh2b2lkIDAgPT09IGNvbnRleHRUeXBlIHx8XG4gICAgICAgICAgICAgIGNvbnRleHRUeXBlLiQkdHlwZW9mICE9PSBSRUFDVF9DT05URVhUX1RZUEUpICYmXG4gICAgICAgICAgICAhZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlLmhhcyh0eXBlKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlLmFkZCh0eXBlKTtcbiAgICAgICAgICAgIHZhciBhZGRlbmR1bSA9XG4gICAgICAgICAgICAgIHZvaWQgMCA9PT0gY29udGV4dFR5cGVcbiAgICAgICAgICAgICAgICA/IFwiIEhvd2V2ZXIsIGl0IGlzIHNldCB0byB1bmRlZmluZWQuIFRoaXMgY2FuIGJlIGNhdXNlZCBieSBhIHR5cG8gb3IgYnkgbWl4aW5nIHVwIG5hbWVkIGFuZCBkZWZhdWx0IGltcG9ydHMuIFRoaXMgY2FuIGFsc28gaGFwcGVuIGR1ZSB0byBhIGNpcmN1bGFyIGRlcGVuZGVuY3ksIHNvIHRyeSBtb3ZpbmcgdGhlIGNyZWF0ZUNvbnRleHQoKSBjYWxsIHRvIGEgc2VwYXJhdGUgZmlsZS5cIlxuICAgICAgICAgICAgICAgIDogXCJvYmplY3RcIiAhPT0gdHlwZW9mIGNvbnRleHRUeXBlXG4gICAgICAgICAgICAgICAgICA/IFwiIEhvd2V2ZXIsIGl0IGlzIHNldCB0byBhIFwiICsgdHlwZW9mIGNvbnRleHRUeXBlICsgXCIuXCJcbiAgICAgICAgICAgICAgICAgIDogY29udGV4dFR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlNVTUVSX1RZUEVcbiAgICAgICAgICAgICAgICAgICAgPyBcIiBEaWQgeW91IGFjY2lkZW50YWxseSBwYXNzIHRoZSBDb250ZXh0LkNvbnN1bWVyIGluc3RlYWQ/XCJcbiAgICAgICAgICAgICAgICAgICAgOiBcIiBIb3dldmVyLCBpdCBpcyBzZXQgdG8gYW4gb2JqZWN0IHdpdGgga2V5cyB7XCIgK1xuICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGNvbnRleHRUeXBlKS5qb2luKFwiLCBcIikgK1xuICAgICAgICAgICAgICAgICAgICAgIFwifS5cIjtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiJXMgZGVmaW5lcyBhbiBpbnZhbGlkIGNvbnRleHRUeXBlLiBjb250ZXh0VHlwZSBzaG91bGQgcG9pbnQgdG8gdGhlIENvbnRleHQgb2JqZWN0IHJldHVybmVkIGJ5IFJlYWN0LmNyZWF0ZUNvbnRleHQoKS4lc1wiLFxuICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgXCJDb21wb25lbnRcIixcbiAgICAgICAgICAgICAgYWRkZW5kdW1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBjb250ZXh0VHlwZSAmJlxuICAgICAgICAgICAgbnVsbCAhPT0gY29udGV4dFR5cGUgJiZcbiAgICAgICAgICAgIChjb250ZXh0ID0gY29udGV4dFR5cGUuX2N1cnJlbnRWYWx1ZSk7XG4gICAgICAgICAgdmFyIGluc3RhbmNlID0gbmV3IHR5cGUocmVzb2x2ZWRQcm9wcywgY29udGV4dCk7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgJiZcbiAgICAgICAgICAgIChudWxsID09PSBpbnN0YW5jZS5zdGF0ZSB8fCB2b2lkIDAgPT09IGluc3RhbmNlLnN0YXRlKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgXCJDb21wb25lbnRcIjtcbiAgICAgICAgICAgIGRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZS5oYXMoY29tcG9uZW50TmFtZSkgfHxcbiAgICAgICAgICAgICAgKGRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZS5hZGQoY29tcG9uZW50TmFtZSksXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJgJXNgIHVzZXMgYGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc2AgYnV0IGl0cyBpbml0aWFsIHN0YXRlIGlzICVzLiBUaGlzIGlzIG5vdCByZWNvbW1lbmRlZC4gSW5zdGVhZCwgZGVmaW5lIHRoZSBpbml0aWFsIHN0YXRlIGJ5IGFzc2lnbmluZyBhbiBvYmplY3QgdG8gYHRoaXMuc3RhdGVgIGluIHRoZSBjb25zdHJ1Y3RvciBvZiBgJXNgLiBUaGlzIGVuc3VyZXMgdGhhdCBgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzYCBhcmd1bWVudHMgaGF2ZSBhIGNvbnNpc3RlbnQgc2hhcGUuXCIsXG4gICAgICAgICAgICAgICAgY29tcG9uZW50TmFtZSxcbiAgICAgICAgICAgICAgICBudWxsID09PSBpbnN0YW5jZS5zdGF0ZSA/IFwibnVsbFwiIDogXCJ1bmRlZmluZWRcIixcbiAgICAgICAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAgICAgICAgICAgICkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyB8fFxuICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGVcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciBmb3VuZFdpbGxNb3VudE5hbWUgPSBudWxsLFxuICAgICAgICAgICAgICBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lID0gbnVsbCxcbiAgICAgICAgICAgICAgZm91bmRXaWxsVXBkYXRlTmFtZSA9IG51bGw7XG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgJiZcbiAgICAgICAgICAgICEwICE9PSBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ1xuICAgICAgICAgICAgICA/IChmb3VuZFdpbGxNb3VudE5hbWUgPSBcImNvbXBvbmVudFdpbGxNb3VudFwiKVxuICAgICAgICAgICAgICA6IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgJiZcbiAgICAgICAgICAgICAgICAoZm91bmRXaWxsTW91bnROYW1lID0gXCJVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50XCIpO1xuICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyAmJlxuICAgICAgICAgICAgITAgIT09XG4gICAgICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ1xuICAgICAgICAgICAgICA/IChmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lID0gXCJjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzXCIpXG4gICAgICAgICAgICAgIDogXCJmdW5jdGlvblwiID09PVxuICAgICAgICAgICAgICAgICAgdHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzICYmXG4gICAgICAgICAgICAgICAgKGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgPVxuICAgICAgICAgICAgICAgICAgXCJVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1wiKTtcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUgJiZcbiAgICAgICAgICAgICEwICE9PSBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdcbiAgICAgICAgICAgICAgPyAoZm91bmRXaWxsVXBkYXRlTmFtZSA9IFwiY29tcG9uZW50V2lsbFVwZGF0ZVwiKVxuICAgICAgICAgICAgICA6IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlICYmXG4gICAgICAgICAgICAgICAgKGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSBcIlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlXCIpO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBudWxsICE9PSBmb3VuZFdpbGxNb3VudE5hbWUgfHxcbiAgICAgICAgICAgICAgbnVsbCAhPT0gZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSB8fFxuICAgICAgICAgICAgICBudWxsICE9PSBmb3VuZFdpbGxVcGRhdGVOYW1lXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgdmFyIF9jb21wb25lbnROYW1lID1cbiAgICAgICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB8fCBcIkNvbXBvbmVudFwiLFxuICAgICAgICAgICAgICAgIG5ld0FwaU5hbWUgPVxuICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNcbiAgICAgICAgICAgICAgICAgICAgPyBcImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcygpXCJcbiAgICAgICAgICAgICAgICAgICAgOiBcImdldFNuYXBzaG90QmVmb3JlVXBkYXRlKClcIjtcbiAgICAgICAgICAgICAgZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZS5oYXMoX2NvbXBvbmVudE5hbWUpIHx8XG4gICAgICAgICAgICAgICAgKGRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGUuYWRkKFxuICAgICAgICAgICAgICAgICAgX2NvbXBvbmVudE5hbWVcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIlVuc2FmZSBsZWdhY3kgbGlmZWN5Y2xlcyB3aWxsIG5vdCBiZSBjYWxsZWQgZm9yIGNvbXBvbmVudHMgdXNpbmcgbmV3IGNvbXBvbmVudCBBUElzLlxcblxcbiVzIHVzZXMgJXMgYnV0IGFsc28gY29udGFpbnMgdGhlIGZvbGxvd2luZyBsZWdhY3kgbGlmZWN5Y2xlczolcyVzJXNcXG5cXG5UaGUgYWJvdmUgbGlmZWN5Y2xlcyBzaG91bGQgYmUgcmVtb3ZlZC4gTGVhcm4gbW9yZSBhYm91dCB0aGlzIHdhcm5pbmcgaGVyZTpcXG5odHRwczovL3JlYWN0LmRldi9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlc1wiLFxuICAgICAgICAgICAgICAgICAgX2NvbXBvbmVudE5hbWUsXG4gICAgICAgICAgICAgICAgICBuZXdBcGlOYW1lLFxuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gZm91bmRXaWxsTW91bnROYW1lXG4gICAgICAgICAgICAgICAgICAgID8gXCJcXG4gIFwiICsgZm91bmRXaWxsTW91bnROYW1lXG4gICAgICAgICAgICAgICAgICAgIDogXCJcIixcbiAgICAgICAgICAgICAgICAgIG51bGwgIT09IGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWVcbiAgICAgICAgICAgICAgICAgICAgPyBcIlxcbiAgXCIgKyBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lXG4gICAgICAgICAgICAgICAgICAgIDogXCJcIixcbiAgICAgICAgICAgICAgICAgIG51bGwgIT09IGZvdW5kV2lsbFVwZGF0ZU5hbWVcbiAgICAgICAgICAgICAgICAgICAgPyBcIlxcbiAgXCIgKyBmb3VuZFdpbGxVcGRhdGVOYW1lXG4gICAgICAgICAgICAgICAgICAgIDogXCJcIlxuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB8fCBcIkNvbXBvbmVudFwiO1xuICAgICAgICAgIGluc3RhbmNlLnJlbmRlciB8fFxuICAgICAgICAgICAgKHR5cGUucHJvdG90eXBlICYmIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUucHJvdG90eXBlLnJlbmRlclxuICAgICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIk5vIGByZW5kZXJgIG1ldGhvZCBmb3VuZCBvbiB0aGUgJXMgaW5zdGFuY2U6IGRpZCB5b3UgYWNjaWRlbnRhbGx5IHJldHVybiBhbiBvYmplY3QgZnJvbSB0aGUgY29uc3RydWN0b3I/XCIsXG4gICAgICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICA6IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIk5vIGByZW5kZXJgIG1ldGhvZCBmb3VuZCBvbiB0aGUgJXMgaW5zdGFuY2U6IHlvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gZGVmaW5lIGByZW5kZXJgLlwiLFxuICAgICAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICFpbnN0YW5jZS5nZXRJbml0aWFsU3RhdGUgfHxcbiAgICAgICAgICAgIGluc3RhbmNlLmdldEluaXRpYWxTdGF0ZS5pc1JlYWN0Q2xhc3NBcHByb3ZlZCB8fFxuICAgICAgICAgICAgaW5zdGFuY2Uuc3RhdGUgfHxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiZ2V0SW5pdGlhbFN0YXRlIHdhcyBkZWZpbmVkIG9uICVzLCBhIHBsYWluIEphdmFTY3JpcHQgY2xhc3MuIFRoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gRGlkIHlvdSBtZWFuIHRvIGRlZmluZSBhIHN0YXRlIHByb3BlcnR5IGluc3RlYWQ/XCIsXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgaW5zdGFuY2UuZ2V0RGVmYXVsdFByb3BzICYmXG4gICAgICAgICAgICAhaW5zdGFuY2UuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcImdldERlZmF1bHRQcm9wcyB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiBUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBjbGFzc2VzIGNyZWF0ZWQgdXNpbmcgUmVhY3QuY3JlYXRlQ2xhc3MuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSB0byBkZWZpbmUgZGVmYXVsdFByb3BzIGluc3RlYWQuXCIsXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgaW5zdGFuY2UuY29udGV4dFR5cGUgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiY29udGV4dFR5cGUgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSB0byBkZWZpbmUgY29udGV4dFR5cGUgaW5zdGVhZC5cIixcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB0eXBlLmNoaWxkQ29udGV4dFR5cGVzICYmXG4gICAgICAgICAgICAhZGlkV2FybkFib3V0Q2hpbGRDb250ZXh0VHlwZXMuaGFzKHR5cGUpICYmXG4gICAgICAgICAgICAoZGlkV2FybkFib3V0Q2hpbGRDb250ZXh0VHlwZXMuYWRkKHR5cGUpLFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCIlcyB1c2VzIHRoZSBsZWdhY3kgY2hpbGRDb250ZXh0VHlwZXMgQVBJIHdoaWNoIHdhcyByZW1vdmVkIGluIFJlYWN0IDE5LiBVc2UgUmVhY3QuY3JlYXRlQ29udGV4dCgpIGluc3RlYWQuIChodHRwczovL3JlYWN0LmRldi9saW5rL2xlZ2FjeS1jb250ZXh0KVwiLFxuICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICApKTtcbiAgICAgICAgICB0eXBlLmNvbnRleHRUeXBlcyAmJlxuICAgICAgICAgICAgIWRpZFdhcm5BYm91dENvbnRleHRUeXBlcyQxLmhhcyh0eXBlKSAmJlxuICAgICAgICAgICAgKGRpZFdhcm5BYm91dENvbnRleHRUeXBlcyQxLmFkZCh0eXBlKSxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiJXMgdXNlcyB0aGUgbGVnYWN5IGNvbnRleHRUeXBlcyBBUEkgd2hpY2ggd2FzIHJlbW92ZWQgaW4gUmVhY3QgMTkuIFVzZSBSZWFjdC5jcmVhdGVDb250ZXh0KCkgd2l0aCBzdGF0aWMgY29udGV4dFR5cGUgaW5zdGVhZC4gKGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvbGVnYWN5LWNvbnRleHQpXCIsXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICkpO1xuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFNob3VsZFVwZGF0ZSAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCIlcyBoYXMgYSBtZXRob2QgY2FsbGVkIGNvbXBvbmVudFNob3VsZFVwZGF0ZSgpLiBEaWQgeW91IG1lYW4gc2hvdWxkQ29tcG9uZW50VXBkYXRlKCk/IFRoZSBuYW1lIGlzIHBocmFzZWQgYXMgYSBxdWVzdGlvbiBiZWNhdXNlIHRoZSBmdW5jdGlvbiBpcyBleHBlY3RlZCB0byByZXR1cm4gYSB2YWx1ZS5cIixcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB0eXBlLnByb3RvdHlwZSAmJlxuICAgICAgICAgICAgdHlwZS5wcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQgJiZcbiAgICAgICAgICAgIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBpbnN0YW5jZS5zaG91bGRDb21wb25lbnRVcGRhdGUgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCBzaG91bGRDb21wb25lbnRVcGRhdGUoKS4gc2hvdWxkQ29tcG9uZW50VXBkYXRlIHNob3VsZCBub3QgYmUgdXNlZCB3aGVuIGV4dGVuZGluZyBSZWFjdC5QdXJlQ29tcG9uZW50LiBQbGVhc2UgZXh0ZW5kIFJlYWN0LkNvbXBvbmVudCBpZiBzaG91bGRDb21wb25lbnRVcGRhdGUgaXMgdXNlZC5cIixcbiAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHx8IFwiQSBwdXJlIGNvbXBvbmVudFwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVubW91bnQgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCBjb21wb25lbnREaWRVbm1vdW50KCkuIEJ1dCB0aGVyZSBpcyBubyBzdWNoIGxpZmVjeWNsZSBtZXRob2QuIERpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsVW5tb3VudCgpP1wiLFxuICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFJlY2VpdmVQcm9wcyAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCIlcyBoYXMgYSBtZXRob2QgY2FsbGVkIGNvbXBvbmVudERpZFJlY2VpdmVQcm9wcygpLiBCdXQgdGhlcmUgaXMgbm8gc3VjaCBsaWZlY3ljbGUgbWV0aG9kLiBJZiB5b3UgbWVhbnQgdG8gdXBkYXRlIHRoZSBzdGF0ZSBpbiByZXNwb25zZSB0byBjaGFuZ2luZyBwcm9wcywgdXNlIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKS4gSWYgeW91IG1lYW50IHRvIGZldGNoIGRhdGEgb3IgcnVuIHNpZGUtZWZmZWN0cyBvciBtdXRhdGlvbnMgYWZ0ZXIgUmVhY3QgaGFzIHVwZGF0ZWQgdGhlIFVJLCB1c2UgY29tcG9uZW50RGlkVXBkYXRlKCkuXCIsXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCIlcyBoYXMgYSBtZXRob2QgY2FsbGVkIGNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMoKS4gRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT9cIixcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCIlcyBoYXMgYSBtZXRob2QgY2FsbGVkIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpP1wiLFxuICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHZhciBoYXNNdXRhdGVkUHJvcHMgPSBpbnN0YW5jZS5wcm9wcyAhPT0gcmVzb2x2ZWRQcm9wcztcbiAgICAgICAgICB2b2lkIDAgIT09IGluc3RhbmNlLnByb3BzICYmXG4gICAgICAgICAgICBoYXNNdXRhdGVkUHJvcHMgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiV2hlbiBjYWxsaW5nIHN1cGVyKCkgaW4gYCVzYCwgbWFrZSBzdXJlIHRvIHBhc3MgdXAgdGhlIHNhbWUgcHJvcHMgdGhhdCB5b3VyIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yIHdhcyBwYXNzZWQuXCIsXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgaW5zdGFuY2UuZGVmYXVsdFByb3BzICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlNldHRpbmcgZGVmYXVsdFByb3BzIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzIGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgaWdub3JlZC4gSW5zdGVhZCwgZGVmaW5lIGRlZmF1bHRQcm9wcyBhcyBhIHN0YXRpYyBwcm9wZXJ0eSBvbiAlcy5cIixcbiAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSB8fFxuICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlIHx8XG4gICAgICAgICAgICBkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUuaGFzKHR5cGUpIHx8XG4gICAgICAgICAgICAoZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlLmFkZCh0eXBlKSxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiJXM6IGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCkgc2hvdWxkIGJlIHVzZWQgd2l0aCBjb21wb25lbnREaWRVcGRhdGUoKS4gVGhpcyBjb21wb25lbnQgZGVmaW5lcyBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpIG9ubHkuXCIsXG4gICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKVxuICAgICAgICAgICAgKSk7XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIiVzOiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoKSBpcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIG1ldGhvZCBhbmQgd2lsbCBiZSBpZ25vcmVkLiBJbnN0ZWFkLCBkZWNsYXJlIGl0IGFzIGEgc3RhdGljIG1ldGhvZC5cIixcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiJXM6IGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcigpIGlzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgbWV0aG9kIGFuZCB3aWxsIGJlIGlnbm9yZWQuIEluc3RlYWQsIGRlY2xhcmUgaXQgYXMgYSBzdGF0aWMgbWV0aG9kLlwiLFxuICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiJXM6IGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCkgaXMgZGVmaW5lZCBhcyBhIHN0YXRpYyBtZXRob2QgYW5kIHdpbGwgYmUgaWdub3JlZC4gSW5zdGVhZCwgZGVjbGFyZSBpdCBhcyBhbiBpbnN0YW5jZSBtZXRob2QuXCIsXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgdmFyIHN0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG4gICAgICAgICAgc3RhdGUgJiZcbiAgICAgICAgICAgIChcIm9iamVjdFwiICE9PSB0eXBlb2Ygc3RhdGUgfHwgaXNBcnJheUltcGwoc3RhdGUpKSAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIiVzLnN0YXRlOiBtdXN0IGJlIHNldCB0byBhbiBvYmplY3Qgb3IgbnVsbFwiLCBuYW1lKTtcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQgJiZcbiAgICAgICAgICAgIFwib2JqZWN0XCIgIT09IHR5cGVvZiB0eXBlLmNoaWxkQ29udGV4dFR5cGVzICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIiVzLmdldENoaWxkQ29udGV4dCgpOiBjaGlsZENvbnRleHRUeXBlcyBtdXN0IGJlIGRlZmluZWQgaW4gb3JkZXIgdG8gdXNlIGdldENoaWxkQ29udGV4dCgpLlwiLFxuICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHZhciBpbml0aWFsU3RhdGUgPSB2b2lkIDAgIT09IGluc3RhbmNlLnN0YXRlID8gaW5zdGFuY2Uuc3RhdGUgOiBudWxsO1xuICAgICAgICAgIGluc3RhbmNlLnVwZGF0ZXIgPSBjbGFzc0NvbXBvbmVudFVwZGF0ZXI7XG4gICAgICAgICAgaW5zdGFuY2UucHJvcHMgPSByZXNvbHZlZFByb3BzO1xuICAgICAgICAgIGluc3RhbmNlLnN0YXRlID0gaW5pdGlhbFN0YXRlO1xuICAgICAgICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0geyBxdWV1ZTogW10sIHJlcGxhY2U6ICExIH07XG4gICAgICAgICAgaW5zdGFuY2UuX3JlYWN0SW50ZXJuYWxzID0gaW50ZXJuYWxJbnN0YW5jZTtcbiAgICAgICAgICB2YXIgY29udGV4dFR5cGUkanNjb21wJDAgPSB0eXBlLmNvbnRleHRUeXBlO1xuICAgICAgICAgIGluc3RhbmNlLmNvbnRleHQgPVxuICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGNvbnRleHRUeXBlJGpzY29tcCQwICYmXG4gICAgICAgICAgICBudWxsICE9PSBjb250ZXh0VHlwZSRqc2NvbXAkMFxuICAgICAgICAgICAgICA/IGNvbnRleHRUeXBlJGpzY29tcCQwLl9jdXJyZW50VmFsdWVcbiAgICAgICAgICAgICAgOiBlbXB0eUNvbnRleHRPYmplY3Q7XG4gICAgICAgICAgaWYgKGluc3RhbmNlLnN0YXRlID09PSByZXNvbHZlZFByb3BzKSB7XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50TmFtZSRqc2NvbXAkMCA9XG4gICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB8fCBcIkNvbXBvbmVudFwiO1xuICAgICAgICAgICAgZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGUuaGFzKFxuICAgICAgICAgICAgICBjb21wb25lbnROYW1lJGpzY29tcCQwXG4gICAgICAgICAgICApIHx8XG4gICAgICAgICAgICAgIChkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZS5hZGQoXG4gICAgICAgICAgICAgICAgY29tcG9uZW50TmFtZSRqc2NvbXAkMFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiJXM6IEl0IGlzIG5vdCByZWNvbW1lbmRlZCB0byBhc3NpZ24gcHJvcHMgZGlyZWN0bHkgdG8gc3RhdGUgYmVjYXVzZSB1cGRhdGVzIHRvIHByb3BzIHdvbid0IGJlIHJlZmxlY3RlZCBpbiBzdGF0ZS4gSW4gbW9zdCBjYXNlcywgaXQgaXMgYmV0dGVyIHRvIHVzZSBwcm9wcyBkaXJlY3RseS5cIixcbiAgICAgICAgICAgICAgICBjb21wb25lbnROYW1lJGpzY29tcCQwXG4gICAgICAgICAgICAgICkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID0gdHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM7XG4gICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcykge1xuICAgICAgICAgICAgdmFyIHBhcnRpYWxTdGF0ZSA9IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhcbiAgICAgICAgICAgICAgcmVzb2x2ZWRQcm9wcyxcbiAgICAgICAgICAgICAgaW5pdGlhbFN0YXRlXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKHZvaWQgMCA9PT0gcGFydGlhbFN0YXRlKSB7XG4gICAgICAgICAgICAgIHZhciBjb21wb25lbnROYW1lJGpzY29tcCQxID1cbiAgICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgXCJDb21wb25lbnRcIjtcbiAgICAgICAgICAgICAgZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlLmhhcyhjb21wb25lbnROYW1lJGpzY29tcCQxKSB8fFxuICAgICAgICAgICAgICAgIChkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGUuYWRkKGNvbXBvbmVudE5hbWUkanNjb21wJDEpLFxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIiVzLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcygpOiBBIHZhbGlkIHN0YXRlIG9iamVjdCAob3IgbnVsbCkgbXVzdCBiZSByZXR1cm5lZC4gWW91IGhhdmUgcmV0dXJuZWQgdW5kZWZpbmVkLlwiLFxuICAgICAgICAgICAgICAgICAgY29tcG9uZW50TmFtZSRqc2NvbXAkMVxuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9XG4gICAgICAgICAgICAgIG51bGwgPT09IHBhcnRpYWxTdGF0ZSB8fCB2b2lkIDAgPT09IHBhcnRpYWxTdGF0ZVxuICAgICAgICAgICAgICAgID8gaW5pdGlhbFN0YXRlXG4gICAgICAgICAgICAgICAgOiBhc3NpZ24oe30sIGluaXRpYWxTdGF0ZSwgcGFydGlhbFN0YXRlKTtcbiAgICAgICAgICAgIGluc3RhbmNlLnN0YXRlID0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiB0eXBlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyAmJlxuICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgJiZcbiAgICAgICAgICAgIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50IHx8XG4gICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudClcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciBvbGRTdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xuICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCkge1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgITAgIT09IGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudC5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHZhciBjb21wb25lbnROYW1lJGpzY29tcCQyID1cbiAgICAgICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB8fCBcIlVua25vd25cIjtcbiAgICAgICAgICAgICAgICBkaWRXYXJuQWJvdXREZXByZWNhdGVkV2lsbE1vdW50W2NvbXBvbmVudE5hbWUkanNjb21wJDJdIHx8XG4gICAgICAgICAgICAgICAgICAoY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICAgICBcImNvbXBvbmVudFdpbGxNb3VudCBoYXMgYmVlbiByZW5hbWVkLCBhbmQgaXMgbm90IHJlY29tbWVuZGVkIGZvciB1c2UuIFNlZSBodHRwczovL3JlYWN0LmRldi9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4qIE1vdmUgY29kZSBmcm9tIGNvbXBvbmVudFdpbGxNb3VudCB0byBjb21wb25lbnREaWRNb3VudCAocHJlZmVycmVkIGluIG1vc3QgY2FzZXMpIG9yIHRoZSBjb25zdHJ1Y3Rvci5cXG5cXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXNcIixcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50TmFtZSRqc2NvbXAkMlxuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgIChkaWRXYXJuQWJvdXREZXByZWNhdGVkV2lsbE1vdW50W2NvbXBvbmVudE5hbWUkanNjb21wJDJdID1cbiAgICAgICAgICAgICAgICAgICAgITApKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgJiZcbiAgICAgICAgICAgICAgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgICAgICAgICAgb2xkU3RhdGUgIT09IGluc3RhbmNlLnN0YXRlICYmXG4gICAgICAgICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiJXMuY29tcG9uZW50V2lsbE1vdW50KCk6IEFzc2lnbmluZyBkaXJlY3RseSB0byB0aGlzLnN0YXRlIGlzIGRlcHJlY2F0ZWQgKGV4Y2VwdCBpbnNpZGUgYSBjb21wb25lbnQncyBjb25zdHJ1Y3RvcikuIFVzZSBzZXRTdGF0ZSBpbnN0ZWFkLlwiLFxuICAgICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB8fCBcIkNvbXBvbmVudFwiXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIGNsYXNzQ29tcG9uZW50VXBkYXRlci5lbnF1ZXVlUmVwbGFjZVN0YXRlKFxuICAgICAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgICAgIGluc3RhbmNlLnN0YXRlLFxuICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIG51bGwgIT09IGludGVybmFsSW5zdGFuY2UucXVldWUgJiZcbiAgICAgICAgICAgICAgMCA8IGludGVybmFsSW5zdGFuY2UucXVldWUubGVuZ3RoXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgdmFyIG9sZFF1ZXVlID0gaW50ZXJuYWxJbnN0YW5jZS5xdWV1ZSxcbiAgICAgICAgICAgICAgICBvbGRSZXBsYWNlID0gaW50ZXJuYWxJbnN0YW5jZS5yZXBsYWNlO1xuICAgICAgICAgICAgICBpbnRlcm5hbEluc3RhbmNlLnF1ZXVlID0gbnVsbDtcbiAgICAgICAgICAgICAgaW50ZXJuYWxJbnN0YW5jZS5yZXBsYWNlID0gITE7XG4gICAgICAgICAgICAgIGlmIChvbGRSZXBsYWNlICYmIDEgPT09IG9sZFF1ZXVlLmxlbmd0aClcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5zdGF0ZSA9IG9sZFF1ZXVlWzBdO1xuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgICAgdmFyIG5leHRTdGF0ZSA9IG9sZFJlcGxhY2UgPyBvbGRRdWV1ZVswXSA6IGluc3RhbmNlLnN0YXRlLFxuICAgICAgICAgICAgICAgICAgICBkb250TXV0YXRlID0gITAsXG4gICAgICAgICAgICAgICAgICAgIGkgPSBvbGRSZXBsYWNlID8gMSA6IDA7XG4gICAgICAgICAgICAgICAgICBpIDwgb2xkUXVldWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgaSsrXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcGFydGlhbCA9IG9sZFF1ZXVlW2ldLFxuICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsU3RhdGUkanNjb21wJDAgPVxuICAgICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHBhcnRpYWxcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcGFydGlhbC5jYWxsKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRTdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlZFByb3BzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZvaWQgMFxuICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHBhcnRpYWw7XG4gICAgICAgICAgICAgICAgICBudWxsICE9IHBhcnRpYWxTdGF0ZSRqc2NvbXAkMCAmJlxuICAgICAgICAgICAgICAgICAgICAoZG9udE11dGF0ZVxuICAgICAgICAgICAgICAgICAgICAgID8gKChkb250TXV0YXRlID0gITEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgKG5leHRTdGF0ZSA9IGFzc2lnbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRTdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbFN0YXRlJGpzY29tcCQwXG4gICAgICAgICAgICAgICAgICAgICAgICApKSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGFzc2lnbihuZXh0U3RhdGUsIHBhcnRpYWxTdGF0ZSRqc2NvbXAkMCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5zdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGludGVybmFsSW5zdGFuY2UucXVldWUgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbmV4dENoaWxkcmVuID0gY2FsbFJlbmRlckluREVWKGluc3RhbmNlKTtcbiAgICAgICAgICBpZiAoMTIgPT09IHJlcXVlc3Quc3RhdHVzKSB0aHJvdyBudWxsO1xuICAgICAgICAgIGluc3RhbmNlLnByb3BzICE9PSByZXNvbHZlZFByb3BzICYmXG4gICAgICAgICAgICAoZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcyB8fFxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiSXQgbG9va3MgbGlrZSAlcyBpcyByZWFzc2lnbmluZyBpdHMgb3duIGB0aGlzLnByb3BzYCB3aGlsZSByZW5kZXJpbmcuIFRoaXMgaXMgbm90IHN1cHBvcnRlZCBhbmQgY2FuIGxlYWQgdG8gY29uZnVzaW5nIGJ1Z3MuXCIsXG4gICAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHx8IFwiYSBjb21wb25lbnRcIlxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgKGRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMgPSAhMCkpO1xuICAgICAgICAgIHZhciBwcmV2S2V5UGF0aCA9IHRhc2sua2V5UGF0aDtcbiAgICAgICAgICB0YXNrLmtleVBhdGggPSBrZXlQYXRoO1xuICAgICAgICAgIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBuZXh0Q2hpbGRyZW4sIC0xKTtcbiAgICAgICAgICB0YXNrLmtleVBhdGggPSBwcmV2S2V5UGF0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodHlwZS5wcm90b3R5cGUgJiYgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZS5wcm90b3R5cGUucmVuZGVyKSB7XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50TmFtZSRqc2NvbXAkMyA9XG4gICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB8fCBcIlVua25vd25cIjtcbiAgICAgICAgICAgIGRpZFdhcm5BYm91dEJhZENsYXNzW2NvbXBvbmVudE5hbWUkanNjb21wJDNdIHx8XG4gICAgICAgICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiVGhlIDwlcyAvPiBjb21wb25lbnQgYXBwZWFycyB0byBoYXZlIGEgcmVuZGVyIG1ldGhvZCwgYnV0IGRvZXNuJ3QgZXh0ZW5kIFJlYWN0LkNvbXBvbmVudC4gVGhpcyBpcyBsaWtlbHkgdG8gY2F1c2UgZXJyb3JzLiBDaGFuZ2UgJXMgdG8gZXh0ZW5kIFJlYWN0LkNvbXBvbmVudCBpbnN0ZWFkLlwiLFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudE5hbWUkanNjb21wJDMsXG4gICAgICAgICAgICAgICAgY29tcG9uZW50TmFtZSRqc2NvbXAkM1xuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAoZGlkV2FybkFib3V0QmFkQ2xhc3NbY29tcG9uZW50TmFtZSRqc2NvbXAkM10gPSAhMCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdmFsdWUgPSByZW5kZXJXaXRoSG9va3MoXG4gICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgdGFzayxcbiAgICAgICAgICAgIGtleVBhdGgsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICB2b2lkIDBcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmICgxMiA9PT0gcmVxdWVzdC5zdGF0dXMpIHRocm93IG51bGw7XG4gICAgICAgICAgdmFyIGhhc0lkID0gMCAhPT0gbG9jYWxJZENvdW50ZXIsXG4gICAgICAgICAgICBhY3Rpb25TdGF0ZUNvdW50ID0gYWN0aW9uU3RhdGVDb3VudGVyLFxuICAgICAgICAgICAgYWN0aW9uU3RhdGVNYXRjaGluZ0luZGV4JGpzY29tcCQwID0gYWN0aW9uU3RhdGVNYXRjaGluZ0luZGV4O1xuICAgICAgICAgIGlmICh0eXBlLmNvbnRleHRUeXBlcykge1xuICAgICAgICAgICAgdmFyIF9jb21wb25lbnROYW1lJGpzY29tcCQwID1cbiAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHx8IFwiVW5rbm93blwiO1xuICAgICAgICAgICAgZGlkV2FybkFib3V0Q29udGV4dFR5cGVzW19jb21wb25lbnROYW1lJGpzY29tcCQwXSB8fFxuICAgICAgICAgICAgICAoKGRpZFdhcm5BYm91dENvbnRleHRUeXBlc1tfY29tcG9uZW50TmFtZSRqc2NvbXAkMF0gPSAhMCksXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCIlcyB1c2VzIHRoZSBsZWdhY3kgY29udGV4dFR5cGVzIEFQSSB3aGljaCB3YXMgcmVtb3ZlZCBpbiBSZWFjdCAxOS4gVXNlIFJlYWN0LmNyZWF0ZUNvbnRleHQoKSB3aXRoIFJlYWN0LnVzZUNvbnRleHQoKSBpbnN0ZWFkLiAoaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9sZWdhY3ktY29udGV4dClcIixcbiAgICAgICAgICAgICAgICBfY29tcG9uZW50TmFtZSRqc2NvbXAkMFxuICAgICAgICAgICAgICApKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdHlwZSAmJlxuICAgICAgICAgICAgdHlwZS5jaGlsZENvbnRleHRUeXBlcyAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJjaGlsZENvbnRleHRUeXBlcyBjYW5ub3QgYmUgZGVmaW5lZCBvbiBhIGZ1bmN0aW9uIGNvbXBvbmVudC5cXG4gICVzLmNoaWxkQ29udGV4dFR5cGVzID0gLi4uXCIsXG4gICAgICAgICAgICAgIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IFwiQ29tcG9uZW50XCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKSB7XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50TmFtZSRqc2NvbXAkNCA9XG4gICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB8fCBcIlVua25vd25cIjtcbiAgICAgICAgICAgIGRpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25Db21wb25lbnRbXG4gICAgICAgICAgICAgIGNvbXBvbmVudE5hbWUkanNjb21wJDRcbiAgICAgICAgICAgIF0gfHxcbiAgICAgICAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCIlczogRnVuY3Rpb24gY29tcG9uZW50cyBkbyBub3Qgc3VwcG9ydCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuXCIsXG4gICAgICAgICAgICAgICAgY29tcG9uZW50TmFtZSRqc2NvbXAkNFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAoZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbkNvbXBvbmVudFtcbiAgICAgICAgICAgICAgICBjb21wb25lbnROYW1lJGpzY29tcCQ0XG4gICAgICAgICAgICAgIF0gPSAhMCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZS5jb250ZXh0VHlwZSAmJlxuICAgICAgICAgICAgbnVsbCAhPT0gdHlwZS5jb250ZXh0VHlwZVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdmFyIF9jb21wb25lbnROYW1lMiA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB8fCBcIlVua25vd25cIjtcbiAgICAgICAgICAgIGRpZFdhcm5BYm91dENvbnRleHRUeXBlT25GdW5jdGlvbkNvbXBvbmVudFtfY29tcG9uZW50TmFtZTJdIHx8XG4gICAgICAgICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiJXM6IEZ1bmN0aW9uIGNvbXBvbmVudHMgZG8gbm90IHN1cHBvcnQgY29udGV4dFR5cGUuXCIsXG4gICAgICAgICAgICAgICAgX2NvbXBvbmVudE5hbWUyXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIChkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnRbX2NvbXBvbmVudE5hbWUyXSA9XG4gICAgICAgICAgICAgICAgITApKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmluaXNoRnVuY3Rpb25Db21wb25lbnQoXG4gICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgdGFzayxcbiAgICAgICAgICAgIGtleVBhdGgsXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGhhc0lkLFxuICAgICAgICAgICAgYWN0aW9uU3RhdGVDb3VudCxcbiAgICAgICAgICAgIGFjdGlvblN0YXRlTWF0Y2hpbmdJbmRleCRqc2NvbXAkMFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIGVsc2UgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlKSB7XG4gICAgICAgIHZhciBzZWdtZW50ID0gdGFzay5ibG9ja2VkU2VnbWVudDtcbiAgICAgICAgaWYgKG51bGwgPT09IHNlZ21lbnQpIHtcbiAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgICAgICAgIHByZXZDb250ZXh0ID0gdGFzay5mb3JtYXRDb250ZXh0LFxuICAgICAgICAgICAgcHJldktleVBhdGgkanNjb21wJDAgPSB0YXNrLmtleVBhdGg7XG4gICAgICAgICAgdGFzay5mb3JtYXRDb250ZXh0ID0gZ2V0Q2hpbGRGb3JtYXRDb250ZXh0KHByZXZDb250ZXh0LCB0eXBlLCBwcm9wcyk7XG4gICAgICAgICAgdGFzay5rZXlQYXRoID0ga2V5UGF0aDtcbiAgICAgICAgICByZW5kZXJOb2RlKHJlcXVlc3QsIHRhc2ssIGNoaWxkcmVuLCAtMSk7XG4gICAgICAgICAgdGFzay5mb3JtYXRDb250ZXh0ID0gcHJldkNvbnRleHQ7XG4gICAgICAgICAgdGFzay5rZXlQYXRoID0gcHJldktleVBhdGgkanNjb21wJDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF9jaGlsZHJlbiA9IHB1c2hTdGFydEluc3RhbmNlKFxuICAgICAgICAgICAgc2VnbWVudC5jaHVua3MsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICByZXF1ZXN0LnJlc3VtYWJsZVN0YXRlLFxuICAgICAgICAgICAgcmVxdWVzdC5yZW5kZXJTdGF0ZSxcbiAgICAgICAgICAgIHRhc2suYmxvY2tlZFByZWFtYmxlLFxuICAgICAgICAgICAgdGFzay5ob2lzdGFibGVTdGF0ZSxcbiAgICAgICAgICAgIHRhc2suZm9ybWF0Q29udGV4dCxcbiAgICAgICAgICAgIHNlZ21lbnQubGFzdFB1c2hlZFRleHRcbiAgICAgICAgICApO1xuICAgICAgICAgIHNlZ21lbnQubGFzdFB1c2hlZFRleHQgPSAhMTtcbiAgICAgICAgICB2YXIgX3ByZXZDb250ZXh0MiA9IHRhc2suZm9ybWF0Q29udGV4dCxcbiAgICAgICAgICAgIF9wcmV2S2V5UGF0aDMgPSB0YXNrLmtleVBhdGg7XG4gICAgICAgICAgdGFzay5rZXlQYXRoID0ga2V5UGF0aDtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAodGFzay5mb3JtYXRDb250ZXh0ID0gZ2V0Q2hpbGRGb3JtYXRDb250ZXh0KFxuICAgICAgICAgICAgICBfcHJldkNvbnRleHQyLFxuICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICBwcm9wc1xuICAgICAgICAgICAgKSkuaW5zZXJ0aW9uTW9kZSA9PT0gSFRNTF9IRUFEX01PREVcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciBwcmVhbWJsZVNlZ21lbnQgPSBjcmVhdGVQZW5kaW5nU2VnbWVudChcbiAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgdGFzay5mb3JtYXRDb250ZXh0LFxuICAgICAgICAgICAgICAhMSxcbiAgICAgICAgICAgICAgITFcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBzZWdtZW50LnByZWFtYmxlQ2hpbGRyZW4ucHVzaChwcmVhbWJsZVNlZ21lbnQpO1xuICAgICAgICAgICAgdGFzay5ibG9ja2VkU2VnbWVudCA9IHByZWFtYmxlU2VnbWVudDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIChwcmVhbWJsZVNlZ21lbnQuc3RhdHVzID0gNiksXG4gICAgICAgICAgICAgICAgcmVuZGVyTm9kZShyZXF1ZXN0LCB0YXNrLCBfY2hpbGRyZW4sIC0xKSxcbiAgICAgICAgICAgICAgICBwcmVhbWJsZVNlZ21lbnQubGFzdFB1c2hlZFRleHQgJiZcbiAgICAgICAgICAgICAgICAgIHByZWFtYmxlU2VnbWVudC50ZXh0RW1iZWRkZWQgJiZcbiAgICAgICAgICAgICAgICAgIHByZWFtYmxlU2VnbWVudC5jaHVua3MucHVzaCh0ZXh0U2VwYXJhdG9yKSxcbiAgICAgICAgICAgICAgICAocHJlYW1ibGVTZWdtZW50LnN0YXR1cyA9IENPTVBMRVRFRCksXG4gICAgICAgICAgICAgICAgZmluaXNoZWRTZWdtZW50KHJlcXVlc3QsIHRhc2suYmxvY2tlZEJvdW5kYXJ5LCBwcmVhbWJsZVNlZ21lbnQpO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgdGFzay5ibG9ja2VkU2VnbWVudCA9IHNlZ21lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHJlbmRlck5vZGUocmVxdWVzdCwgdGFzaywgX2NoaWxkcmVuLCAtMSk7XG4gICAgICAgICAgdGFzay5mb3JtYXRDb250ZXh0ID0gX3ByZXZDb250ZXh0MjtcbiAgICAgICAgICB0YXNrLmtleVBhdGggPSBfcHJldktleVBhdGgzO1xuICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBzZWdtZW50LmNodW5rcyxcbiAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUgPSByZXF1ZXN0LnJlc3VtYWJsZVN0YXRlO1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJ0aXRsZVwiOlxuICAgICAgICAgICAgICBjYXNlIFwic3R5bGVcIjpcbiAgICAgICAgICAgICAgY2FzZSBcInNjcmlwdFwiOlxuICAgICAgICAgICAgICBjYXNlIFwiYXJlYVwiOlxuICAgICAgICAgICAgICBjYXNlIFwiYmFzZVwiOlxuICAgICAgICAgICAgICBjYXNlIFwiYnJcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImNvbFwiOlxuICAgICAgICAgICAgICBjYXNlIFwiZW1iZWRcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImhyXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJpbWdcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImlucHV0XCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJrZXlnZW5cIjpcbiAgICAgICAgICAgICAgY2FzZSBcImxpbmtcIjpcbiAgICAgICAgICAgICAgY2FzZSBcIm1ldGFcIjpcbiAgICAgICAgICAgICAgY2FzZSBcInBhcmFtXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJzb3VyY2VcIjpcbiAgICAgICAgICAgICAgY2FzZSBcInRyYWNrXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJ3YnJcIjpcbiAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICBjYXNlIFwiYm9keVwiOlxuICAgICAgICAgICAgICAgIGlmIChfcHJldkNvbnRleHQyLmluc2VydGlvbk1vZGUgPD0gSFRNTF9IVE1MX01PREUpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLmhhc0JvZHkgPSAhMDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwiaHRtbFwiOlxuICAgICAgICAgICAgICAgIGlmIChfcHJldkNvbnRleHQyLmluc2VydGlvbk1vZGUgPT09IFJPT1RfSFRNTF9NT0RFKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZS5oYXNIdG1sID0gITA7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcImhlYWRcIjpcbiAgICAgICAgICAgICAgICBpZiAoX3ByZXZDb250ZXh0Mi5pbnNlcnRpb25Nb2RlIDw9IEhUTUxfSFRNTF9NT0RFKSBicmVhayBhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFyZ2V0LnB1c2goZW5kQ2h1bmtGb3JUYWcodHlwZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWdtZW50Lmxhc3RQdXNoZWRUZXh0ID0gITE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgICAgICAgdmFyIHByZXZLZXlQYXRoJGpzY29tcCQxID0gdGFzay5rZXlQYXRoO1xuICAgICAgICAgICAgdGFzay5rZXlQYXRoID0ga2V5UGF0aDtcbiAgICAgICAgICAgIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBwcm9wcy5jaGlsZHJlbiwgLTEpO1xuICAgICAgICAgICAgdGFzay5rZXlQYXRoID0gcHJldktleVBhdGgkanNjb21wJDE7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgY2FzZSBSRUFDVF9BQ1RJVklUWV9UWVBFOlxuICAgICAgICAgICAgdmFyIHNlZ21lbnQkanNjb21wJDAgPSB0YXNrLmJsb2NrZWRTZWdtZW50O1xuICAgICAgICAgICAgaWYgKG51bGwgPT09IHNlZ21lbnQkanNjb21wJDApIHtcbiAgICAgICAgICAgICAgaWYgKFwiaGlkZGVuXCIgIT09IHByb3BzLm1vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJldktleVBhdGgkanNjb21wJDIgPSB0YXNrLmtleVBhdGg7XG4gICAgICAgICAgICAgICAgdGFzay5rZXlQYXRoID0ga2V5UGF0aDtcbiAgICAgICAgICAgICAgICByZW5kZXJOb2RlKHJlcXVlc3QsIHRhc2ssIHByb3BzLmNoaWxkcmVuLCAtMSk7XG4gICAgICAgICAgICAgICAgdGFzay5rZXlQYXRoID0gcHJldktleVBhdGgkanNjb21wJDI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXCJoaWRkZW5cIiAhPT0gcHJvcHMubW9kZSkge1xuICAgICAgICAgICAgICBzZWdtZW50JGpzY29tcCQwLmNodW5rcy5wdXNoKHN0YXJ0QWN0aXZpdHlCb3VuZGFyeSk7XG4gICAgICAgICAgICAgIHNlZ21lbnQkanNjb21wJDAubGFzdFB1c2hlZFRleHQgPSAhMTtcbiAgICAgICAgICAgICAgdmFyIF9wcmV2S2V5UGF0aDQgPSB0YXNrLmtleVBhdGg7XG4gICAgICAgICAgICAgIHRhc2sua2V5UGF0aCA9IGtleVBhdGg7XG4gICAgICAgICAgICAgIHJlbmRlck5vZGUocmVxdWVzdCwgdGFzaywgcHJvcHMuY2hpbGRyZW4sIC0xKTtcbiAgICAgICAgICAgICAgdGFzay5rZXlQYXRoID0gX3ByZXZLZXlQYXRoNDtcbiAgICAgICAgICAgICAgc2VnbWVudCRqc2NvbXAkMC5jaHVua3MucHVzaChlbmRBY3Rpdml0eUJvdW5kYXJ5KTtcbiAgICAgICAgICAgICAgc2VnbWVudCRqc2NvbXAkMC5sYXN0UHVzaGVkVGV4dCA9ICExO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICAgICAgYToge1xuICAgICAgICAgICAgICB2YXIgY2hpbGRyZW4kanNjb21wJDAgPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgICAgICAgICAgICByZXZlYWxPcmRlciA9IHByb3BzLnJldmVhbE9yZGVyO1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgXCJmb3J3YXJkc1wiID09PSByZXZlYWxPcmRlciB8fFxuICAgICAgICAgICAgICAgIFwiYmFja3dhcmRzXCIgPT09IHJldmVhbE9yZGVyIHx8XG4gICAgICAgICAgICAgICAgXCJ1bnN0YWJsZV9sZWdhY3ktYmFja3dhcmRzXCIgPT09IHJldmVhbE9yZGVyXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGlmIChpc0FycmF5SW1wbChjaGlsZHJlbiRqc2NvbXAkMCkpIHtcbiAgICAgICAgICAgICAgICAgIHJlbmRlclN1c3BlbnNlTGlzdFJvd3MoXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgIHRhc2ssXG4gICAgICAgICAgICAgICAgICAgIGtleVBhdGgsXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuJGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICByZXZlYWxPcmRlclxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihjaGlsZHJlbiRqc2NvbXAkMCk7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgICAgICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChjaGlsZHJlbiRqc2NvbXAkMCk7XG4gICAgICAgICAgICAgICAgICBpZiAoaXRlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVJdGVyYWJsZShcbiAgICAgICAgICAgICAgICAgICAgICB0YXNrLFxuICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuJGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICAgIC0xLFxuICAgICAgICAgICAgICAgICAgICAgIGl0ZXJhdG9yLFxuICAgICAgICAgICAgICAgICAgICAgIGl0ZXJhdG9yRm5cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc3RlcC5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHJvd3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICBkbyByb3dzLnB1c2goc3RlcC52YWx1ZSksIChzdGVwID0gaXRlcmF0b3IubmV4dCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIXN0ZXAuZG9uZSk7XG4gICAgICAgICAgICAgICAgICAgICAgcmVuZGVyU3VzcGVuc2VMaXN0Um93cyhcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrLFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5UGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuJGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV2ZWFsT3JkZXJcbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChcInRvZ2V0aGVyXCIgPT09IHJldmVhbE9yZGVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9wcmV2S2V5UGF0aDIgPSB0YXNrLmtleVBhdGgsXG4gICAgICAgICAgICAgICAgICBwcmV2Um93ID0gdGFzay5yb3csXG4gICAgICAgICAgICAgICAgICBuZXdSb3cgPSAodGFzay5yb3cgPSBjcmVhdGVTdXNwZW5zZUxpc3RSb3cobnVsbCkpO1xuICAgICAgICAgICAgICAgIG5ld1Jvdy5ib3VuZGFyaWVzID0gW107XG4gICAgICAgICAgICAgICAgbmV3Um93LnRvZ2V0aGVyID0gITA7XG4gICAgICAgICAgICAgICAgdGFzay5rZXlQYXRoID0ga2V5UGF0aDtcbiAgICAgICAgICAgICAgICByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgY2hpbGRyZW4kanNjb21wJDAsIC0xKTtcbiAgICAgICAgICAgICAgICAwID09PSAtLW5ld1Jvdy5wZW5kaW5nVGFza3MgJiZcbiAgICAgICAgICAgICAgICAgIGZpbmlzaFN1c3BlbnNlTGlzdFJvdyhyZXF1ZXN0LCBuZXdSb3cpO1xuICAgICAgICAgICAgICAgIHRhc2sua2V5UGF0aCA9IF9wcmV2S2V5UGF0aDI7XG4gICAgICAgICAgICAgICAgdGFzay5yb3cgPSBwcmV2Um93O1xuICAgICAgICAgICAgICAgIG51bGwgIT09IHByZXZSb3cgJiZcbiAgICAgICAgICAgICAgICAgIDAgPCBuZXdSb3cucGVuZGluZ1Rhc2tzICYmXG4gICAgICAgICAgICAgICAgICAocHJldlJvdy5wZW5kaW5nVGFza3MrKywgKG5ld1Jvdy5uZXh0ID0gcHJldlJvdykpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBwcmV2S2V5UGF0aCRqc2NvbXAkMyA9IHRhc2sua2V5UGF0aDtcbiAgICAgICAgICAgICAgICB0YXNrLmtleVBhdGggPSBrZXlQYXRoO1xuICAgICAgICAgICAgICAgIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBjaGlsZHJlbiRqc2NvbXAkMCwgLTEpO1xuICAgICAgICAgICAgICAgIHRhc2sua2V5UGF0aCA9IHByZXZLZXlQYXRoJGpzY29tcCQzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgY2FzZSBSRUFDVF9WSUVXX1RSQU5TSVRJT05fVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NDT1BFX1RZUEU6XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgXCJSZWFjdERPTVNlcnZlciBkb2VzIG5vdCB5ZXQgc3VwcG9ydCBzY29wZSBjb21wb25lbnRzLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICAgIGE6IGlmIChudWxsICE9PSB0YXNrLnJlcGxheSkge1xuICAgICAgICAgICAgICB2YXIgX3ByZXZLZXlQYXRoID0gdGFzay5rZXlQYXRoLFxuICAgICAgICAgICAgICAgIF9wcmV2Q29udGV4dCA9IHRhc2suZm9ybWF0Q29udGV4dCxcbiAgICAgICAgICAgICAgICBfcHJldlJvdyA9IHRhc2sucm93O1xuICAgICAgICAgICAgICB0YXNrLmtleVBhdGggPSBrZXlQYXRoO1xuICAgICAgICAgICAgICB0YXNrLmZvcm1hdENvbnRleHQgPSBnZXRTdXNwZW5zZUNvbnRlbnRGb3JtYXRDb250ZXh0KFxuICAgICAgICAgICAgICAgIHJlcXVlc3QucmVzdW1hYmxlU3RhdGUsXG4gICAgICAgICAgICAgICAgX3ByZXZDb250ZXh0XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHRhc2sucm93ID0gbnVsbDtcbiAgICAgICAgICAgICAgdmFyIF9jb250ZW50ID0gcHJvcHMuY2hpbGRyZW47XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyTm9kZShyZXF1ZXN0LCB0YXNrLCBfY29udGVudCwgLTEpO1xuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICh0YXNrLmtleVBhdGggPSBfcHJldktleVBhdGgpLFxuICAgICAgICAgICAgICAgICAgKHRhc2suZm9ybWF0Q29udGV4dCA9IF9wcmV2Q29udGV4dCksXG4gICAgICAgICAgICAgICAgICAodGFzay5yb3cgPSBfcHJldlJvdyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBwcmV2S2V5UGF0aCRqc2NvbXAkNCA9IHRhc2sua2V5UGF0aCxcbiAgICAgICAgICAgICAgICBwcmV2Q29udGV4dCRqc2NvbXAkMCA9IHRhc2suZm9ybWF0Q29udGV4dCxcbiAgICAgICAgICAgICAgICBwcmV2Um93JGpzY29tcCQwID0gdGFzay5yb3csXG4gICAgICAgICAgICAgICAgcGFyZW50Qm91bmRhcnkgPSB0YXNrLmJsb2NrZWRCb3VuZGFyeSxcbiAgICAgICAgICAgICAgICBwYXJlbnRQcmVhbWJsZSA9IHRhc2suYmxvY2tlZFByZWFtYmxlLFxuICAgICAgICAgICAgICAgIHBhcmVudEhvaXN0YWJsZVN0YXRlID0gdGFzay5ob2lzdGFibGVTdGF0ZSxcbiAgICAgICAgICAgICAgICBwYXJlbnRTZWdtZW50ID0gdGFzay5ibG9ja2VkU2VnbWVudCxcbiAgICAgICAgICAgICAgICBmYWxsYmFjayA9IHByb3BzLmZhbGxiYWNrLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgICAgICAgICAgICBmYWxsYmFja0Fib3J0U2V0ID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgICB2YXIgbmV3Qm91bmRhcnkgPVxuICAgICAgICAgICAgICAgIHRhc2suZm9ybWF0Q29udGV4dC5pbnNlcnRpb25Nb2RlIDwgSFRNTF9NT0RFXG4gICAgICAgICAgICAgICAgICA/IGNyZWF0ZVN1c3BlbnNlQm91bmRhcnkoXG4gICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgICB0YXNrLnJvdyxcbiAgICAgICAgICAgICAgICAgICAgICBmYWxsYmFja0Fib3J0U2V0LFxuICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZVByZWFtYmxlU3RhdGUoKSxcbiAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVQcmVhbWJsZVN0YXRlKClcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgOiBjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5KFxuICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgICAgdGFzay5yb3csXG4gICAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2tBYm9ydFNldCxcbiAgICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgbnVsbCAhPT0gcmVxdWVzdC50cmFja2VkUG9zdHBvbmVzICYmXG4gICAgICAgICAgICAgICAgKG5ld0JvdW5kYXJ5LnRyYWNrZWRDb250ZW50S2V5UGF0aCA9IGtleVBhdGgpO1xuICAgICAgICAgICAgICB2YXIgYm91bmRhcnlTZWdtZW50ID0gY3JlYXRlUGVuZGluZ1NlZ21lbnQoXG4gICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICBwYXJlbnRTZWdtZW50LmNodW5rcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgbmV3Qm91bmRhcnksXG4gICAgICAgICAgICAgICAgdGFzay5mb3JtYXRDb250ZXh0LFxuICAgICAgICAgICAgICAgICExLFxuICAgICAgICAgICAgICAgICExXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHBhcmVudFNlZ21lbnQuY2hpbGRyZW4ucHVzaChib3VuZGFyeVNlZ21lbnQpO1xuICAgICAgICAgICAgICBwYXJlbnRTZWdtZW50Lmxhc3RQdXNoZWRUZXh0ID0gITE7XG4gICAgICAgICAgICAgIHZhciBjb250ZW50Um9vdFNlZ21lbnQgPSBjcmVhdGVQZW5kaW5nU2VnbWVudChcbiAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICB0YXNrLmZvcm1hdENvbnRleHQsXG4gICAgICAgICAgICAgICAgITEsXG4gICAgICAgICAgICAgICAgITFcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgY29udGVudFJvb3RTZWdtZW50LnBhcmVudEZsdXNoZWQgPSAhMDtcbiAgICAgICAgICAgICAgaWYgKG51bGwgIT09IHJlcXVlc3QudHJhY2tlZFBvc3Rwb25lcykge1xuICAgICAgICAgICAgICAgIHZhciBzdXNwZW5zZUNvbXBvbmVudFN0YWNrID0gdGFzay5jb21wb25lbnRTdGFjayxcbiAgICAgICAgICAgICAgICAgIGZhbGxiYWNrS2V5UGF0aCA9IFtcbiAgICAgICAgICAgICAgICAgICAga2V5UGF0aFswXSxcbiAgICAgICAgICAgICAgICAgICAgXCJTdXNwZW5zZSBGYWxsYmFja1wiLFxuICAgICAgICAgICAgICAgICAgICBrZXlQYXRoWzJdXG4gICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgZmFsbGJhY2tSZXBsYXlOb2RlID0gW1xuICAgICAgICAgICAgICAgICAgICBmYWxsYmFja0tleVBhdGhbMV0sXG4gICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrS2V5UGF0aFsyXSxcbiAgICAgICAgICAgICAgICAgICAgW10sXG4gICAgICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgcmVxdWVzdC50cmFja2VkUG9zdHBvbmVzLndvcmtpbmdNYXAuc2V0KFxuICAgICAgICAgICAgICAgICAgZmFsbGJhY2tLZXlQYXRoLFxuICAgICAgICAgICAgICAgICAgZmFsbGJhY2tSZXBsYXlOb2RlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBuZXdCb3VuZGFyeS50cmFja2VkRmFsbGJhY2tOb2RlID0gZmFsbGJhY2tSZXBsYXlOb2RlO1xuICAgICAgICAgICAgICAgIHRhc2suYmxvY2tlZFNlZ21lbnQgPSBib3VuZGFyeVNlZ21lbnQ7XG4gICAgICAgICAgICAgICAgdGFzay5ibG9ja2VkUHJlYW1ibGUgPSBuZXdCb3VuZGFyeS5mYWxsYmFja1ByZWFtYmxlO1xuICAgICAgICAgICAgICAgIHRhc2sua2V5UGF0aCA9IGZhbGxiYWNrS2V5UGF0aDtcbiAgICAgICAgICAgICAgICB0YXNrLmZvcm1hdENvbnRleHQgPSBnZXRTdXNwZW5zZUZhbGxiYWNrRm9ybWF0Q29udGV4dChcbiAgICAgICAgICAgICAgICAgIHJlcXVlc3QucmVzdW1hYmxlU3RhdGUsXG4gICAgICAgICAgICAgICAgICBwcmV2Q29udGV4dCRqc2NvbXAkMFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdGFzay5jb21wb25lbnRTdGFjayA9XG4gICAgICAgICAgICAgICAgICByZXBsYWNlU3VzcGVuc2VDb21wb25lbnRTdGFja1dpdGhTdXNwZW5zZUZhbGxiYWNrU3RhY2soXG4gICAgICAgICAgICAgICAgICAgIHN1c3BlbnNlQ29tcG9uZW50U3RhY2tcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYm91bmRhcnlTZWdtZW50LnN0YXR1cyA9IDY7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHJlbmRlck5vZGUocmVxdWVzdCwgdGFzaywgZmFsbGJhY2ssIC0xKSxcbiAgICAgICAgICAgICAgICAgICAgYm91bmRhcnlTZWdtZW50Lmxhc3RQdXNoZWRUZXh0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgYm91bmRhcnlTZWdtZW50LnRleHRFbWJlZGRlZCAmJlxuICAgICAgICAgICAgICAgICAgICAgIGJvdW5kYXJ5U2VnbWVudC5jaHVua3MucHVzaCh0ZXh0U2VwYXJhdG9yKSxcbiAgICAgICAgICAgICAgICAgICAgKGJvdW5kYXJ5U2VnbWVudC5zdGF0dXMgPSBDT01QTEVURUQpLFxuICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFNlZ21lbnQocmVxdWVzdCwgcGFyZW50Qm91bmRhcnksIGJvdW5kYXJ5U2VnbWVudCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAodGhyb3duVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IChcbiAgICAgICAgICAgICAgICAgICAgKChib3VuZGFyeVNlZ21lbnQuc3RhdHVzID1cbiAgICAgICAgICAgICAgICAgICAgICAxMiA9PT0gcmVxdWVzdC5zdGF0dXMgPyBBQk9SVEVEIDogRVJST1JFRCksXG4gICAgICAgICAgICAgICAgICAgIHRocm93blZhbHVlKVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgKHRhc2suYmxvY2tlZFNlZ21lbnQgPSBwYXJlbnRTZWdtZW50KSxcbiAgICAgICAgICAgICAgICAgICAgKHRhc2suYmxvY2tlZFByZWFtYmxlID0gcGFyZW50UHJlYW1ibGUpLFxuICAgICAgICAgICAgICAgICAgICAodGFzay5rZXlQYXRoID0gcHJldktleVBhdGgkanNjb21wJDQpLFxuICAgICAgICAgICAgICAgICAgICAodGFzay5mb3JtYXRDb250ZXh0ID0gcHJldkNvbnRleHQkanNjb21wJDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgc3VzcGVuZGVkUHJpbWFyeVRhc2sgPSBjcmVhdGVSZW5kZXJUYXNrKFxuICAgICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgICAgICAgICAgLTEsXG4gICAgICAgICAgICAgICAgICBuZXdCb3VuZGFyeSxcbiAgICAgICAgICAgICAgICAgIGNvbnRlbnRSb290U2VnbWVudCxcbiAgICAgICAgICAgICAgICAgIG5ld0JvdW5kYXJ5LmNvbnRlbnRQcmVhbWJsZSxcbiAgICAgICAgICAgICAgICAgIG5ld0JvdW5kYXJ5LmNvbnRlbnRTdGF0ZSxcbiAgICAgICAgICAgICAgICAgIHRhc2suYWJvcnRTZXQsXG4gICAgICAgICAgICAgICAgICBrZXlQYXRoLFxuICAgICAgICAgICAgICAgICAgZ2V0U3VzcGVuc2VDb250ZW50Rm9ybWF0Q29udGV4dChcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5yZXN1bWFibGVTdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgdGFzay5mb3JtYXRDb250ZXh0XG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgdGFzay5jb250ZXh0LFxuICAgICAgICAgICAgICAgICAgdGFzay50cmVlQ29udGV4dCxcbiAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICBzdXNwZW5zZUNvbXBvbmVudFN0YWNrLFxuICAgICAgICAgICAgICAgICAgZW1wdHlDb250ZXh0T2JqZWN0LFxuICAgICAgICAgICAgICAgICAgdGFzay5kZWJ1Z1Rhc2tcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHB1c2hDb21wb25lbnRTdGFjayhzdXNwZW5kZWRQcmltYXJ5VGFzayk7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5waW5nZWRUYXNrcy5wdXNoKHN1c3BlbmRlZFByaW1hcnlUYXNrKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXNrLmJsb2NrZWRCb3VuZGFyeSA9IG5ld0JvdW5kYXJ5O1xuICAgICAgICAgICAgICAgIHRhc2suYmxvY2tlZFByZWFtYmxlID0gbmV3Qm91bmRhcnkuY29udGVudFByZWFtYmxlO1xuICAgICAgICAgICAgICAgIHRhc2suaG9pc3RhYmxlU3RhdGUgPSBuZXdCb3VuZGFyeS5jb250ZW50U3RhdGU7XG4gICAgICAgICAgICAgICAgdGFzay5ibG9ja2VkU2VnbWVudCA9IGNvbnRlbnRSb290U2VnbWVudDtcbiAgICAgICAgICAgICAgICB0YXNrLmtleVBhdGggPSBrZXlQYXRoO1xuICAgICAgICAgICAgICAgIHRhc2suZm9ybWF0Q29udGV4dCA9IGdldFN1c3BlbnNlQ29udGVudEZvcm1hdENvbnRleHQoXG4gICAgICAgICAgICAgICAgICByZXF1ZXN0LnJlc3VtYWJsZVN0YXRlLFxuICAgICAgICAgICAgICAgICAgcHJldkNvbnRleHQkanNjb21wJDBcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRhc2sucm93ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBjb250ZW50Um9vdFNlZ21lbnQuc3RhdHVzID0gNjtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAocmVuZGVyTm9kZShyZXF1ZXN0LCB0YXNrLCBjb250ZW50LCAtMSksXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRSb290U2VnbWVudC5sYXN0UHVzaGVkVGV4dCAmJlxuICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRSb290U2VnbWVudC50ZXh0RW1iZWRkZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICBjb250ZW50Um9vdFNlZ21lbnQuY2h1bmtzLnB1c2godGV4dFNlcGFyYXRvciksXG4gICAgICAgICAgICAgICAgICAgIChjb250ZW50Um9vdFNlZ21lbnQuc3RhdHVzID0gQ09NUExFVEVEKSxcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRTZWdtZW50KHJlcXVlc3QsIG5ld0JvdW5kYXJ5LCBjb250ZW50Um9vdFNlZ21lbnQpLFxuICAgICAgICAgICAgICAgICAgICBxdWV1ZUNvbXBsZXRlZFNlZ21lbnQobmV3Qm91bmRhcnksIGNvbnRlbnRSb290U2VnbWVudCksXG4gICAgICAgICAgICAgICAgICAgIDAgPT09IG5ld0JvdW5kYXJ5LnBlbmRpbmdUYXNrcyAmJlxuICAgICAgICAgICAgICAgICAgICAgIG5ld0JvdW5kYXJ5LnN0YXR1cyA9PT0gUEVORElORylcbiAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgKChuZXdCb3VuZGFyeS5zdGF0dXMgPSBDT01QTEVURUQpLFxuICAgICAgICAgICAgICAgICAgICAgICFpc0VsaWdpYmxlRm9yT3V0bGluaW5nKHJlcXVlc3QsIG5ld0JvdW5kYXJ5KSlcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gcHJldlJvdyRqc2NvbXAkMCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgMCA9PT0gLS1wcmV2Um93JGpzY29tcCQwLnBlbmRpbmdUYXNrcyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgZmluaXNoU3VzcGVuc2VMaXN0Um93KHJlcXVlc3QsIHByZXZSb3ckanNjb21wJDApO1xuICAgICAgICAgICAgICAgICAgICAgIDAgPT09IHJlcXVlc3QucGVuZGluZ1Jvb3RUYXNrcyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdGFzay5ibG9ja2VkUHJlYW1ibGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXBhcmVQcmVhbWJsZShyZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gcHJldlJvdyRqc2NvbXAkMCAmJlxuICAgICAgICAgICAgICAgICAgICAgIHByZXZSb3ckanNjb21wJDAudG9nZXRoZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgICB0cnlUb1Jlc29sdmVUb2dldGhlclJvdyhyZXF1ZXN0LCBwcmV2Um93JGpzY29tcCQwKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoICh0aHJvd25WYWx1ZSQyKSB7XG4gICAgICAgICAgICAgICAgICBuZXdCb3VuZGFyeS5zdGF0dXMgPSBDTElFTlRfUkVOREVSRUQ7XG4gICAgICAgICAgICAgICAgICBpZiAoMTIgPT09IHJlcXVlc3Quc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRSb290U2VnbWVudC5zdGF0dXMgPSBBQk9SVEVEO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSByZXF1ZXN0LmZhdGFsRXJyb3I7XG4gICAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgKGNvbnRlbnRSb290U2VnbWVudC5zdGF0dXMgPSBFUlJPUkVEKSxcbiAgICAgICAgICAgICAgICAgICAgICAoZXJyb3IgPSB0aHJvd25WYWx1ZSQyKTtcbiAgICAgICAgICAgICAgICAgIHZhciB0aHJvd25JbmZvID0gZ2V0VGhyb3duSW5mbyh0YXNrLmNvbXBvbmVudFN0YWNrKTtcbiAgICAgICAgICAgICAgICAgIHZhciBlcnJvckRpZ2VzdCA9IGxvZ1JlY292ZXJhYmxlRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgICAgICB0aHJvd25JbmZvLFxuICAgICAgICAgICAgICAgICAgICB0YXNrLmRlYnVnVGFza1xuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGVuY29kZUVycm9yRm9yQm91bmRhcnkoXG4gICAgICAgICAgICAgICAgICAgIG5ld0JvdW5kYXJ5LFxuICAgICAgICAgICAgICAgICAgICBlcnJvckRpZ2VzdCxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgIHRocm93bkluZm8sXG4gICAgICAgICAgICAgICAgICAgICExXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgdW50cmFja0JvdW5kYXJ5KHJlcXVlc3QsIG5ld0JvdW5kYXJ5KTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgKHRhc2suYmxvY2tlZEJvdW5kYXJ5ID0gcGFyZW50Qm91bmRhcnkpLFxuICAgICAgICAgICAgICAgICAgICAodGFzay5ibG9ja2VkUHJlYW1ibGUgPSBwYXJlbnRQcmVhbWJsZSksXG4gICAgICAgICAgICAgICAgICAgICh0YXNrLmhvaXN0YWJsZVN0YXRlID0gcGFyZW50SG9pc3RhYmxlU3RhdGUpLFxuICAgICAgICAgICAgICAgICAgICAodGFzay5ibG9ja2VkU2VnbWVudCA9IHBhcmVudFNlZ21lbnQpLFxuICAgICAgICAgICAgICAgICAgICAodGFzay5rZXlQYXRoID0gcHJldktleVBhdGgkanNjb21wJDQpLFxuICAgICAgICAgICAgICAgICAgICAodGFzay5mb3JtYXRDb250ZXh0ID0gcHJldkNvbnRleHQkanNjb21wJDApLFxuICAgICAgICAgICAgICAgICAgICAodGFzay5yb3cgPSBwcmV2Um93JGpzY29tcCQwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHN1c3BlbmRlZEZhbGxiYWNrVGFzayA9IGNyZWF0ZVJlbmRlclRhc2soXG4gICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgIGZhbGxiYWNrLFxuICAgICAgICAgICAgICAgICAgLTEsXG4gICAgICAgICAgICAgICAgICBwYXJlbnRCb3VuZGFyeSxcbiAgICAgICAgICAgICAgICAgIGJvdW5kYXJ5U2VnbWVudCxcbiAgICAgICAgICAgICAgICAgIG5ld0JvdW5kYXJ5LmZhbGxiYWNrUHJlYW1ibGUsXG4gICAgICAgICAgICAgICAgICBuZXdCb3VuZGFyeS5mYWxsYmFja1N0YXRlLFxuICAgICAgICAgICAgICAgICAgZmFsbGJhY2tBYm9ydFNldCxcbiAgICAgICAgICAgICAgICAgIFtrZXlQYXRoWzBdLCBcIlN1c3BlbnNlIEZhbGxiYWNrXCIsIGtleVBhdGhbMl1dLFxuICAgICAgICAgICAgICAgICAgZ2V0U3VzcGVuc2VGYWxsYmFja0Zvcm1hdENvbnRleHQoXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QucmVzdW1hYmxlU3RhdGUsXG4gICAgICAgICAgICAgICAgICAgIHRhc2suZm9ybWF0Q29udGV4dFxuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgIHRhc2suY29udGV4dCxcbiAgICAgICAgICAgICAgICAgIHRhc2sudHJlZUNvbnRleHQsXG4gICAgICAgICAgICAgICAgICB0YXNrLnJvdyxcbiAgICAgICAgICAgICAgICAgIHJlcGxhY2VTdXNwZW5zZUNvbXBvbmVudFN0YWNrV2l0aFN1c3BlbnNlRmFsbGJhY2tTdGFjayhcbiAgICAgICAgICAgICAgICAgICAgdGFzay5jb21wb25lbnRTdGFja1xuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgIGVtcHR5Q29udGV4dE9iamVjdCxcbiAgICAgICAgICAgICAgICAgIHRhc2suZGVidWdUYXNrXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBwdXNoQ29tcG9uZW50U3RhY2soc3VzcGVuZGVkRmFsbGJhY2tUYXNrKTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnBpbmdlZFRhc2tzLnB1c2goc3VzcGVuZGVkRmFsbGJhY2tUYXNrKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSAmJiBudWxsICE9PSB0eXBlKVxuICAgICAgICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgICBpZiAoXCJyZWZcIiBpbiBwcm9wcykge1xuICAgICAgICAgICAgICAgIHZhciBwcm9wc1dpdGhvdXRSZWYgPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpXG4gICAgICAgICAgICAgICAgICBcInJlZlwiICE9PSBrZXkgJiYgKHByb3BzV2l0aG91dFJlZltrZXldID0gcHJvcHNba2V5XSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBwcm9wc1dpdGhvdXRSZWYgPSBwcm9wcztcbiAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuJGpzY29tcCQxID0gcmVuZGVyV2l0aEhvb2tzKFxuICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgdGFzayxcbiAgICAgICAgICAgICAgICBrZXlQYXRoLFxuICAgICAgICAgICAgICAgIHR5cGUucmVuZGVyLFxuICAgICAgICAgICAgICAgIHByb3BzV2l0aG91dFJlZixcbiAgICAgICAgICAgICAgICByZWZcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgZmluaXNoRnVuY3Rpb25Db21wb25lbnQoXG4gICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICB0YXNrLFxuICAgICAgICAgICAgICAgIGtleVBhdGgsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW4kanNjb21wJDEsXG4gICAgICAgICAgICAgICAgMCAhPT0gbG9jYWxJZENvdW50ZXIsXG4gICAgICAgICAgICAgICAgYWN0aW9uU3RhdGVDb3VudGVyLFxuICAgICAgICAgICAgICAgIGFjdGlvblN0YXRlTWF0Y2hpbmdJbmRleFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgICAgcmVuZGVyRWxlbWVudChyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCB0eXBlLnR5cGUsIHByb3BzLCByZWYpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgICAgdmFyIHZhbHVlJGpzY29tcCQwID0gcHJvcHMudmFsdWUsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW4kanNjb21wJDIgPSBwcm9wcy5jaGlsZHJlbjtcbiAgICAgICAgICAgICAgdmFyIHByZXZTbmFwc2hvdCA9IHRhc2suY29udGV4dDtcbiAgICAgICAgICAgICAgdmFyIHByZXZLZXlQYXRoJGpzY29tcCQ1ID0gdGFzay5rZXlQYXRoO1xuICAgICAgICAgICAgICB2YXIgcHJldlZhbHVlID0gdHlwZS5fY3VycmVudFZhbHVlO1xuICAgICAgICAgICAgICB0eXBlLl9jdXJyZW50VmFsdWUgPSB2YWx1ZSRqc2NvbXAkMDtcbiAgICAgICAgICAgICAgdm9pZCAwICE9PSB0eXBlLl9jdXJyZW50UmVuZGVyZXIgJiZcbiAgICAgICAgICAgICAgICBudWxsICE9PSB0eXBlLl9jdXJyZW50UmVuZGVyZXIgJiZcbiAgICAgICAgICAgICAgICB0eXBlLl9jdXJyZW50UmVuZGVyZXIgIT09IHJlbmRlcmVyU2lnaWwgJiZcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJEZXRlY3RlZCBtdWx0aXBsZSByZW5kZXJlcnMgY29uY3VycmVudGx5IHJlbmRlcmluZyB0aGUgc2FtZSBjb250ZXh0IHByb3ZpZGVyLiBUaGlzIGlzIGN1cnJlbnRseSB1bnN1cHBvcnRlZC5cIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHR5cGUuX2N1cnJlbnRSZW5kZXJlciA9IHJlbmRlcmVyU2lnaWw7XG4gICAgICAgICAgICAgIHZhciBwcmV2Tm9kZSA9IGN1cnJlbnRBY3RpdmVTbmFwc2hvdCxcbiAgICAgICAgICAgICAgICBuZXdOb2RlID0ge1xuICAgICAgICAgICAgICAgICAgcGFyZW50OiBwcmV2Tm9kZSxcbiAgICAgICAgICAgICAgICAgIGRlcHRoOiBudWxsID09PSBwcmV2Tm9kZSA/IDAgOiBwcmV2Tm9kZS5kZXB0aCArIDEsXG4gICAgICAgICAgICAgICAgICBjb250ZXh0OiB0eXBlLFxuICAgICAgICAgICAgICAgICAgcGFyZW50VmFsdWU6IHByZXZWYWx1ZSxcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSRqc2NvbXAkMFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGN1cnJlbnRBY3RpdmVTbmFwc2hvdCA9IG5ld05vZGU7XG4gICAgICAgICAgICAgIHRhc2suY29udGV4dCA9IG5ld05vZGU7XG4gICAgICAgICAgICAgIHRhc2sua2V5UGF0aCA9IGtleVBhdGg7XG4gICAgICAgICAgICAgIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBjaGlsZHJlbiRqc2NvbXAkMiwgLTEpO1xuICAgICAgICAgICAgICB2YXIgcHJldlNuYXBzaG90JGpzY29tcCQwID0gY3VycmVudEFjdGl2ZVNuYXBzaG90O1xuICAgICAgICAgICAgICBpZiAobnVsbCA9PT0gcHJldlNuYXBzaG90JGpzY29tcCQwKVxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJUcmllZCB0byBwb3AgYSBDb250ZXh0IGF0IHRoZSByb290IG9mIHRoZSBhcHAuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBwcmV2U25hcHNob3QkanNjb21wJDAuY29udGV4dCAhPT0gdHlwZSAmJlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIlRoZSBwYXJlbnQgY29udGV4dCBpcyBub3QgdGhlIGV4cGVjdGVkIGNvbnRleHQuIFRoaXMgaXMgcHJvYmFibHkgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBwcmV2U25hcHNob3QkanNjb21wJDAuY29udGV4dC5fY3VycmVudFZhbHVlID1cbiAgICAgICAgICAgICAgICBwcmV2U25hcHNob3QkanNjb21wJDAucGFyZW50VmFsdWU7XG4gICAgICAgICAgICAgIHZvaWQgMCAhPT0gdHlwZS5fY3VycmVudFJlbmRlcmVyICYmXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gdHlwZS5fY3VycmVudFJlbmRlcmVyICYmXG4gICAgICAgICAgICAgICAgdHlwZS5fY3VycmVudFJlbmRlcmVyICE9PSByZW5kZXJlclNpZ2lsICYmXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiRGV0ZWN0ZWQgbXVsdGlwbGUgcmVuZGVyZXJzIGNvbmN1cnJlbnRseSByZW5kZXJpbmcgdGhlIHNhbWUgY29udGV4dCBwcm92aWRlci4gVGhpcyBpcyBjdXJyZW50bHkgdW5zdXBwb3J0ZWQuXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB0eXBlLl9jdXJyZW50UmVuZGVyZXIgPSByZW5kZXJlclNpZ2lsO1xuICAgICAgICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwID0gKGN1cnJlbnRBY3RpdmVTbmFwc2hvdCA9XG4gICAgICAgICAgICAgICAgcHJldlNuYXBzaG90JGpzY29tcCQwLnBhcmVudCk7XG4gICAgICAgICAgICAgIHRhc2suY29udGV4dCA9IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMDtcbiAgICAgICAgICAgICAgdGFzay5rZXlQYXRoID0gcHJldktleVBhdGgkanNjb21wJDU7XG4gICAgICAgICAgICAgIHByZXZTbmFwc2hvdCAhPT0gdGFzay5jb250ZXh0ICYmXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiUG9wcGluZyB0aGUgY29udGV4dCBwcm92aWRlciBkaWQgbm90IHJldHVybiBiYWNrIHRvIHRoZSBvcmlnaW5hbCBzbmFwc2hvdC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OU1VNRVJfVFlQRTpcbiAgICAgICAgICAgICAgdmFyIGNvbnRleHQkanNjb21wJDAgPSB0eXBlLl9jb250ZXh0LFxuICAgICAgICAgICAgICAgIHJlbmRlciA9IHByb3BzLmNoaWxkcmVuO1xuICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiByZW5kZXIgJiZcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJBIGNvbnRleHQgY29uc3VtZXIgd2FzIHJlbmRlcmVkIHdpdGggbXVsdGlwbGUgY2hpbGRyZW4sIG9yIGEgY2hpbGQgdGhhdCBpc24ndCBhIGZ1bmN0aW9uLiBBIGNvbnRleHQgY29uc3VtZXIgZXhwZWN0cyBhIHNpbmdsZSBjaGlsZCB0aGF0IGlzIGEgZnVuY3Rpb24uIElmIHlvdSBkaWQgcGFzcyBhIGZ1bmN0aW9uLCBtYWtlIHN1cmUgdGhlcmUgaXMgbm8gdHJhaWxpbmcgb3IgbGVhZGluZyB3aGl0ZXNwYWNlIGFyb3VuZCBpdC5cIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHZhciBuZXdDaGlsZHJlbiA9IHJlbmRlcihjb250ZXh0JGpzY29tcCQwLl9jdXJyZW50VmFsdWUpLFxuICAgICAgICAgICAgICAgIHByZXZLZXlQYXRoJGpzY29tcCQ2ID0gdGFzay5rZXlQYXRoO1xuICAgICAgICAgICAgICB0YXNrLmtleVBhdGggPSBrZXlQYXRoO1xuICAgICAgICAgICAgICByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgbmV3Q2hpbGRyZW4sIC0xKTtcbiAgICAgICAgICAgICAgdGFzay5rZXlQYXRoID0gcHJldktleVBhdGgkanNjb21wJDY7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgICB2YXIgQ29tcG9uZW50ID0gY2FsbExhenlJbml0SW5ERVYodHlwZSk7XG4gICAgICAgICAgICAgIGlmICgxMiA9PT0gcmVxdWVzdC5zdGF0dXMpIHRocm93IG51bGw7XG4gICAgICAgICAgICAgIHJlbmRlckVsZW1lbnQocmVxdWVzdCwgdGFzaywga2V5UGF0aCwgQ29tcG9uZW50LCBwcm9wcywgcmVmKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgdmFyIGluZm8gPSBcIlwiO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgdm9pZCAwID09PSB0eXBlIHx8XG4gICAgICAgICAgKFwib2JqZWN0XCIgPT09IHR5cGVvZiB0eXBlICYmXG4gICAgICAgICAgICBudWxsICE9PSB0eXBlICYmXG4gICAgICAgICAgICAwID09PSBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGgpXG4gICAgICAgIClcbiAgICAgICAgICBpbmZvICs9XG4gICAgICAgICAgICBcIiBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSBpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiRWxlbWVudCB0eXBlIGlzIGludmFsaWQ6IGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKSBidXQgZ290OiBcIiArXG4gICAgICAgICAgICAoKG51bGwgPT0gdHlwZSA/IHR5cGUgOiB0eXBlb2YgdHlwZSkgKyBcIi5cIiArIGluZm8pXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc3VtZU5vZGUocmVxdWVzdCwgdGFzaywgc2VnbWVudElkLCBub2RlLCBjaGlsZEluZGV4KSB7XG4gICAgICB2YXIgcHJldlJlcGxheSA9IHRhc2sucmVwbGF5LFxuICAgICAgICBibG9ja2VkQm91bmRhcnkgPSB0YXNrLmJsb2NrZWRCb3VuZGFyeSxcbiAgICAgICAgcmVzdW1lZFNlZ21lbnQgPSBjcmVhdGVQZW5kaW5nU2VnbWVudChcbiAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgIDAsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICB0YXNrLmZvcm1hdENvbnRleHQsXG4gICAgICAgICAgITEsXG4gICAgICAgICAgITFcbiAgICAgICAgKTtcbiAgICAgIHJlc3VtZWRTZWdtZW50LmlkID0gc2VnbWVudElkO1xuICAgICAgcmVzdW1lZFNlZ21lbnQucGFyZW50Rmx1c2hlZCA9ICEwO1xuICAgICAgdHJ5IHtcbiAgICAgICAgKHRhc2sucmVwbGF5ID0gbnVsbCksXG4gICAgICAgICAgKHRhc2suYmxvY2tlZFNlZ21lbnQgPSByZXN1bWVkU2VnbWVudCksXG4gICAgICAgICAgcmVuZGVyTm9kZShyZXF1ZXN0LCB0YXNrLCBub2RlLCBjaGlsZEluZGV4KSxcbiAgICAgICAgICAocmVzdW1lZFNlZ21lbnQuc3RhdHVzID0gQ09NUExFVEVEKSxcbiAgICAgICAgICBmaW5pc2hlZFNlZ21lbnQocmVxdWVzdCwgYmxvY2tlZEJvdW5kYXJ5LCByZXN1bWVkU2VnbWVudCksXG4gICAgICAgICAgbnVsbCA9PT0gYmxvY2tlZEJvdW5kYXJ5XG4gICAgICAgICAgICA/IChyZXF1ZXN0LmNvbXBsZXRlZFJvb3RTZWdtZW50ID0gcmVzdW1lZFNlZ21lbnQpXG4gICAgICAgICAgICA6IChxdWV1ZUNvbXBsZXRlZFNlZ21lbnQoYmxvY2tlZEJvdW5kYXJ5LCByZXN1bWVkU2VnbWVudCksXG4gICAgICAgICAgICAgIGJsb2NrZWRCb3VuZGFyeS5wYXJlbnRGbHVzaGVkICYmXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5wYXJ0aWFsQm91bmRhcmllcy5wdXNoKGJsb2NrZWRCb3VuZGFyeSkpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgKHRhc2sucmVwbGF5ID0gcHJldlJlcGxheSksICh0YXNrLmJsb2NrZWRTZWdtZW50ID0gbnVsbCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcGxheUVsZW1lbnQoXG4gICAgICByZXF1ZXN0LFxuICAgICAgdGFzayxcbiAgICAgIGtleVBhdGgsXG4gICAgICBuYW1lLFxuICAgICAga2V5T3JJbmRleCxcbiAgICAgIGNoaWxkSW5kZXgsXG4gICAgICB0eXBlLFxuICAgICAgcHJvcHMsXG4gICAgICByZWYsXG4gICAgICByZXBsYXlcbiAgICApIHtcbiAgICAgIGNoaWxkSW5kZXggPSByZXBsYXkubm9kZXM7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkSW5kZXgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSBjaGlsZEluZGV4W2ldO1xuICAgICAgICBpZiAoa2V5T3JJbmRleCA9PT0gbm9kZVsxXSkge1xuICAgICAgICAgIGlmICg0ID09PSBub2RlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKG51bGwgIT09IG5hbWUgJiYgbmFtZSAhPT0gbm9kZVswXSlcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJFeHBlY3RlZCB0aGUgcmVzdW1lIHRvIHJlbmRlciA8XCIgK1xuICAgICAgICAgICAgICAgICAgbm9kZVswXSArXG4gICAgICAgICAgICAgICAgICBcIj4gaW4gdGhpcyBzbG90IGJ1dCBpbnN0ZWFkIGl0IHJlbmRlcmVkIDxcIiArXG4gICAgICAgICAgICAgICAgICBuYW1lICtcbiAgICAgICAgICAgICAgICAgIFwiPi4gVGhlIHRyZWUgZG9lc24ndCBtYXRjaCBzbyBSZWFjdCB3aWxsIGZhbGxiYWNrIHRvIGNsaWVudCByZW5kZXJpbmcuXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHZhciBjaGlsZE5vZGVzID0gbm9kZVsyXTtcbiAgICAgICAgICAgIG5hbWUgPSBub2RlWzNdO1xuICAgICAgICAgICAga2V5T3JJbmRleCA9IHRhc2subm9kZTtcbiAgICAgICAgICAgIHRhc2sucmVwbGF5ID0geyBub2RlczogY2hpbGROb2Rlcywgc2xvdHM6IG5hbWUsIHBlbmRpbmdUYXNrczogMSB9O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmVuZGVyRWxlbWVudChyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCB0eXBlLCBwcm9wcywgcmVmKTtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIDEgPT09IHRhc2sucmVwbGF5LnBlbmRpbmdUYXNrcyAmJlxuICAgICAgICAgICAgICAgIDAgPCB0YXNrLnJlcGxheS5ub2Rlcy5sZW5ndGhcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJDb3VsZG4ndCBmaW5kIGFsbCByZXN1bWFibGUgc2xvdHMgYnkga2V5L2luZGV4IGR1cmluZyByZXBsYXlpbmcuIFRoZSB0cmVlIGRvZXNuJ3QgbWF0Y2ggc28gUmVhY3Qgd2lsbCBmYWxsYmFjayB0byBjbGllbnQgcmVuZGVyaW5nLlwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgdGFzay5yZXBsYXkucGVuZGluZ1Rhc2tzLS07XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgeCAmJlxuICAgICAgICAgICAgICAgIG51bGwgIT09IHggJiZcbiAgICAgICAgICAgICAgICAoeCA9PT0gU3VzcGVuc2VFeGNlcHRpb24gfHwgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgeC50aGVuKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgdGhyb3cgKFxuICAgICAgICAgICAgICAgICAgKHRhc2subm9kZSA9PT0ga2V5T3JJbmRleFxuICAgICAgICAgICAgICAgICAgICA/ICh0YXNrLnJlcGxheSA9IHJlcGxheSlcbiAgICAgICAgICAgICAgICAgICAgOiBjaGlsZEluZGV4LnNwbGljZShpLCAxKSxcbiAgICAgICAgICAgICAgICAgIHgpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgdGFzay5yZXBsYXkucGVuZGluZ1Rhc2tzLS07XG4gICAgICAgICAgICAgIHR5cGUgPSBnZXRUaHJvd25JbmZvKHRhc2suY29tcG9uZW50U3RhY2spO1xuICAgICAgICAgICAgICBwcm9wcyA9IHJlcXVlc3Q7XG4gICAgICAgICAgICAgIHJlcXVlc3QgPSB0YXNrLmJsb2NrZWRCb3VuZGFyeTtcbiAgICAgICAgICAgICAga2V5UGF0aCA9IHg7XG4gICAgICAgICAgICAgIHJlZiA9IG5hbWU7XG4gICAgICAgICAgICAgIG5hbWUgPSBsb2dSZWNvdmVyYWJsZUVycm9yKHByb3BzLCBrZXlQYXRoLCB0eXBlLCB0YXNrLmRlYnVnVGFzayk7XG4gICAgICAgICAgICAgIGFib3J0UmVtYWluaW5nUmVwbGF5Tm9kZXMoXG4gICAgICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICBjaGlsZE5vZGVzLFxuICAgICAgICAgICAgICAgIHJlZixcbiAgICAgICAgICAgICAgICBrZXlQYXRoLFxuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICAhMVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFzay5yZXBsYXkgPSByZXBsYXk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlICE9PSBSRUFDVF9TVVNQRU5TRV9UWVBFKVxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIkV4cGVjdGVkIHRoZSByZXN1bWUgdG8gcmVuZGVyIDxTdXNwZW5zZT4gaW4gdGhpcyBzbG90IGJ1dCBpbnN0ZWFkIGl0IHJlbmRlcmVkIDxcIiArXG4gICAgICAgICAgICAgICAgICAoZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHx8IFwiVW5rbm93blwiKSArXG4gICAgICAgICAgICAgICAgICBcIj4uIFRoZSB0cmVlIGRvZXNuJ3QgbWF0Y2ggc28gUmVhY3Qgd2lsbCBmYWxsYmFjayB0byBjbGllbnQgcmVuZGVyaW5nLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBhOiB7XG4gICAgICAgICAgICAgIHJlcGxheSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgbmFtZSA9IG5vZGVbNV07XG4gICAgICAgICAgICAgIHR5cGUgPSBub2RlWzJdO1xuICAgICAgICAgICAgICByZWYgPSBub2RlWzNdO1xuICAgICAgICAgICAgICBrZXlPckluZGV4ID0gbnVsbCA9PT0gbm9kZVs0XSA/IFtdIDogbm9kZVs0XVsyXTtcbiAgICAgICAgICAgICAgbm9kZSA9IG51bGwgPT09IG5vZGVbNF0gPyBudWxsIDogbm9kZVs0XVszXTtcbiAgICAgICAgICAgICAgdmFyIHByZXZLZXlQYXRoID0gdGFzay5rZXlQYXRoLFxuICAgICAgICAgICAgICAgIHByZXZDb250ZXh0ID0gdGFzay5mb3JtYXRDb250ZXh0LFxuICAgICAgICAgICAgICAgIHByZXZSb3cgPSB0YXNrLnJvdyxcbiAgICAgICAgICAgICAgICBwcmV2aW91c1JlcGxheVNldCA9IHRhc2sucmVwbGF5LFxuICAgICAgICAgICAgICAgIHBhcmVudEJvdW5kYXJ5ID0gdGFzay5ibG9ja2VkQm91bmRhcnksXG4gICAgICAgICAgICAgICAgcGFyZW50SG9pc3RhYmxlU3RhdGUgPSB0YXNrLmhvaXN0YWJsZVN0YXRlLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgICAgICAgICAgICBmYWxsYmFjayA9IHByb3BzLmZhbGxiYWNrLFxuICAgICAgICAgICAgICAgIGZhbGxiYWNrQWJvcnRTZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICAgIHByb3BzID1cbiAgICAgICAgICAgICAgICB0YXNrLmZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSA8IEhUTUxfTU9ERVxuICAgICAgICAgICAgICAgICAgPyBjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5KFxuICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgICAgdGFzay5yb3csXG4gICAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2tBYm9ydFNldCxcbiAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVQcmVhbWJsZVN0YXRlKCksXG4gICAgICAgICAgICAgICAgICAgICAgY3JlYXRlUHJlYW1ibGVTdGF0ZSgpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIDogY3JlYXRlU3VzcGVuc2VCb3VuZGFyeShcbiAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICAgIHRhc2sucm93LFxuICAgICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrQWJvcnRTZXQsXG4gICAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHByb3BzLnBhcmVudEZsdXNoZWQgPSAhMDtcbiAgICAgICAgICAgICAgcHJvcHMucm9vdFNlZ21lbnRJRCA9IG5hbWU7XG4gICAgICAgICAgICAgIHRhc2suYmxvY2tlZEJvdW5kYXJ5ID0gcHJvcHM7XG4gICAgICAgICAgICAgIHRhc2suaG9pc3RhYmxlU3RhdGUgPSBwcm9wcy5jb250ZW50U3RhdGU7XG4gICAgICAgICAgICAgIHRhc2sua2V5UGF0aCA9IGtleVBhdGg7XG4gICAgICAgICAgICAgIHRhc2suZm9ybWF0Q29udGV4dCA9IGdldFN1c3BlbnNlQ29udGVudEZvcm1hdENvbnRleHQoXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5yZXN1bWFibGVTdGF0ZSxcbiAgICAgICAgICAgICAgICBwcmV2Q29udGV4dFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB0YXNrLnJvdyA9IG51bGw7XG4gICAgICAgICAgICAgIHRhc2sucmVwbGF5ID0geyBub2RlczogdHlwZSwgc2xvdHM6IHJlZiwgcGVuZGluZ1Rhc2tzOiAxIH07XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyTm9kZShyZXF1ZXN0LCB0YXNrLCBjb250ZW50LCAtMSk7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgMSA9PT0gdGFzay5yZXBsYXkucGVuZGluZ1Rhc2tzICYmXG4gICAgICAgICAgICAgICAgICAwIDwgdGFzay5yZXBsYXkubm9kZXMubGVuZ3RoXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiQ291bGRuJ3QgZmluZCBhbGwgcmVzdW1hYmxlIHNsb3RzIGJ5IGtleS9pbmRleCBkdXJpbmcgcmVwbGF5aW5nLiBUaGUgdHJlZSBkb2Vzbid0IG1hdGNoIHNvIFJlYWN0IHdpbGwgZmFsbGJhY2sgdG8gY2xpZW50IHJlbmRlcmluZy5cIlxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB0YXNrLnJlcGxheS5wZW5kaW5nVGFza3MtLTtcbiAgICAgICAgICAgICAgICBpZiAoMCA9PT0gcHJvcHMucGVuZGluZ1Rhc2tzICYmIHByb3BzLnN0YXR1cyA9PT0gUEVORElORykge1xuICAgICAgICAgICAgICAgICAgcHJvcHMuc3RhdHVzID0gQ09NUExFVEVEO1xuICAgICAgICAgICAgICAgICAgcmVxdWVzdC5jb21wbGV0ZWRCb3VuZGFyaWVzLnB1c2gocHJvcHMpO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgKHByb3BzLnN0YXR1cyA9IENMSUVOVF9SRU5ERVJFRCksXG4gICAgICAgICAgICAgICAgICAoY2hpbGROb2RlcyA9IGdldFRocm93bkluZm8odGFzay5jb21wb25lbnRTdGFjaykpLFxuICAgICAgICAgICAgICAgICAgKHJlcGxheSA9IGxvZ1JlY292ZXJhYmxlRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGVzLFxuICAgICAgICAgICAgICAgICAgICB0YXNrLmRlYnVnVGFza1xuICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgICBlbmNvZGVFcnJvckZvckJvdW5kYXJ5KHByb3BzLCByZXBsYXksIGVycm9yLCBjaGlsZE5vZGVzLCAhMSksXG4gICAgICAgICAgICAgICAgICB0YXNrLnJlcGxheS5wZW5kaW5nVGFza3MtLSxcbiAgICAgICAgICAgICAgICAgIHJlcXVlc3QuY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzLnB1c2gocHJvcHMpO1xuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICh0YXNrLmJsb2NrZWRCb3VuZGFyeSA9IHBhcmVudEJvdW5kYXJ5KSxcbiAgICAgICAgICAgICAgICAgICh0YXNrLmhvaXN0YWJsZVN0YXRlID0gcGFyZW50SG9pc3RhYmxlU3RhdGUpLFxuICAgICAgICAgICAgICAgICAgKHRhc2sucmVwbGF5ID0gcHJldmlvdXNSZXBsYXlTZXQpLFxuICAgICAgICAgICAgICAgICAgKHRhc2sua2V5UGF0aCA9IHByZXZLZXlQYXRoKSxcbiAgICAgICAgICAgICAgICAgICh0YXNrLmZvcm1hdENvbnRleHQgPSBwcmV2Q29udGV4dCksXG4gICAgICAgICAgICAgICAgICAodGFzay5yb3cgPSBwcmV2Um93KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwcm9wcyA9IGNyZWF0ZVJlcGxheVRhc2soXG4gICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIHsgbm9kZXM6IGtleU9ySW5kZXgsIHNsb3RzOiBub2RlLCBwZW5kaW5nVGFza3M6IDAgfSxcbiAgICAgICAgICAgICAgICBmYWxsYmFjayxcbiAgICAgICAgICAgICAgICAtMSxcbiAgICAgICAgICAgICAgICBwYXJlbnRCb3VuZGFyeSxcbiAgICAgICAgICAgICAgICBwcm9wcy5mYWxsYmFja1N0YXRlLFxuICAgICAgICAgICAgICAgIGZhbGxiYWNrQWJvcnRTZXQsXG4gICAgICAgICAgICAgICAgW2tleVBhdGhbMF0sIFwiU3VzcGVuc2UgRmFsbGJhY2tcIiwga2V5UGF0aFsyXV0sXG4gICAgICAgICAgICAgICAgZ2V0U3VzcGVuc2VGYWxsYmFja0Zvcm1hdENvbnRleHQoXG4gICAgICAgICAgICAgICAgICByZXF1ZXN0LnJlc3VtYWJsZVN0YXRlLFxuICAgICAgICAgICAgICAgICAgdGFzay5mb3JtYXRDb250ZXh0XG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICB0YXNrLmNvbnRleHQsXG4gICAgICAgICAgICAgICAgdGFzay50cmVlQ29udGV4dCxcbiAgICAgICAgICAgICAgICB0YXNrLnJvdyxcbiAgICAgICAgICAgICAgICByZXBsYWNlU3VzcGVuc2VDb21wb25lbnRTdGFja1dpdGhTdXNwZW5zZUZhbGxiYWNrU3RhY2soXG4gICAgICAgICAgICAgICAgICB0YXNrLmNvbXBvbmVudFN0YWNrXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBlbXB0eUNvbnRleHRPYmplY3QsXG4gICAgICAgICAgICAgICAgdGFzay5kZWJ1Z1Rhc2tcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcHVzaENvbXBvbmVudFN0YWNrKHByb3BzKTtcbiAgICAgICAgICAgICAgcmVxdWVzdC5waW5nZWRUYXNrcy5wdXNoKHByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY2hpbGRJbmRleC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVJdGVyYWJsZShcbiAgICAgIHRhc2ssXG4gICAgICBpdGVyYWJsZSxcbiAgICAgIGNoaWxkSW5kZXgsXG4gICAgICBpdGVyYXRvcixcbiAgICAgIGl0ZXJhdG9yRm5cbiAgICApIHtcbiAgICAgIGlmIChpdGVyYXRvciA9PT0gaXRlcmFibGUpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIC0xICE9PSBjaGlsZEluZGV4IHx8XG4gICAgICAgICAgbnVsbCA9PT0gdGFzay5jb21wb25lbnRTdGFjayB8fFxuICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHRhc2suY29tcG9uZW50U3RhY2sudHlwZSB8fFxuICAgICAgICAgIFwiW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl1cIiAhPT1cbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0YXNrLmNvbXBvbmVudFN0YWNrLnR5cGUpIHx8XG4gICAgICAgICAgXCJbb2JqZWN0IEdlbmVyYXRvcl1cIiAhPT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGl0ZXJhdG9yKVxuICAgICAgICApXG4gICAgICAgICAgZGlkV2FybkFib3V0R2VuZXJhdG9ycyB8fFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJVc2luZyBJdGVyYXRvcnMgYXMgY2hpbGRyZW4gaXMgdW5zdXBwb3J0ZWQgYW5kIHdpbGwgbGlrZWx5IHlpZWxkIHVuZXhwZWN0ZWQgcmVzdWx0cyBiZWNhdXNlIGVudW1lcmF0aW5nIGEgZ2VuZXJhdG9yIG11dGF0ZXMgaXQuIFlvdSBtYXkgY29udmVydCBpdCB0byBhbiBhcnJheSB3aXRoIGBBcnJheS5mcm9tKClgIG9yIHRoZSBgWy4uLnNwcmVhZF1gIG9wZXJhdG9yIGJlZm9yZSByZW5kZXJpbmcuIFlvdSBjYW4gYWxzbyB1c2UgYW4gSXRlcmFibGUgdGhhdCBjYW4gaXRlcmF0ZSBtdWx0aXBsZSB0aW1lcyBvdmVyIHRoZSBzYW1lIGl0ZW1zLlwiXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgKGRpZFdhcm5BYm91dEdlbmVyYXRvcnMgPSAhMCk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgaXRlcmFibGUuZW50cmllcyAhPT0gaXRlcmF0b3JGbiB8fFxuICAgICAgICAgIGRpZFdhcm5BYm91dE1hcHMgfHxcbiAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiVXNpbmcgTWFwcyBhcyBjaGlsZHJlbiBpcyBub3Qgc3VwcG9ydGVkLiBVc2UgYW4gYXJyYXkgb2Yga2V5ZWQgUmVhY3RFbGVtZW50cyBpbnN0ZWFkLlwiXG4gICAgICAgICAgKSxcbiAgICAgICAgICAoZGlkV2FybkFib3V0TWFwcyA9ICEwKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBub2RlLCBjaGlsZEluZGV4KSB7XG4gICAgICBudWxsICE9PSB0YXNrLnJlcGxheSAmJiBcIm51bWJlclwiID09PSB0eXBlb2YgdGFzay5yZXBsYXkuc2xvdHNcbiAgICAgICAgPyByZXN1bWVOb2RlKHJlcXVlc3QsIHRhc2ssIHRhc2sucmVwbGF5LnNsb3RzLCBub2RlLCBjaGlsZEluZGV4KVxuICAgICAgICA6ICgodGFzay5ub2RlID0gbm9kZSksXG4gICAgICAgICAgKHRhc2suY2hpbGRJbmRleCA9IGNoaWxkSW5kZXgpLFxuICAgICAgICAgIChub2RlID0gdGFzay5jb21wb25lbnRTdGFjayksXG4gICAgICAgICAgKGNoaWxkSW5kZXggPSB0YXNrLmRlYnVnVGFzayksXG4gICAgICAgICAgcHVzaENvbXBvbmVudFN0YWNrKHRhc2spLFxuICAgICAgICAgIHJldHJ5Tm9kZShyZXF1ZXN0LCB0YXNrKSxcbiAgICAgICAgICAodGFzay5jb21wb25lbnRTdGFjayA9IG5vZGUpLFxuICAgICAgICAgICh0YXNrLmRlYnVnVGFzayA9IGNoaWxkSW5kZXgpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmV0cnlOb2RlKHJlcXVlc3QsIHRhc2spIHtcbiAgICAgIHZhciBub2RlID0gdGFzay5ub2RlLFxuICAgICAgICBjaGlsZEluZGV4ID0gdGFzay5jaGlsZEluZGV4O1xuICAgICAgaWYgKG51bGwgIT09IG5vZGUpIHtcbiAgICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBub2RlKSB7XG4gICAgICAgICAgc3dpdGNoIChub2RlLiQkdHlwZW9mKSB7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICAgICAgdmFyIHR5cGUgPSBub2RlLnR5cGUsXG4gICAgICAgICAgICAgICAga2V5ID0gbm9kZS5rZXk7XG4gICAgICAgICAgICAgIG5vZGUgPSBub2RlLnByb3BzO1xuICAgICAgICAgICAgICB2YXIgcmVmUHJvcCA9IG5vZGUucmVmO1xuICAgICAgICAgICAgICByZWZQcm9wID0gdm9pZCAwICE9PSByZWZQcm9wID8gcmVmUHJvcCA6IG51bGw7XG4gICAgICAgICAgICAgIHZhciBkZWJ1Z1Rhc2sgPSB0YXNrLmRlYnVnVGFzayxcbiAgICAgICAgICAgICAgICBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgICAgICAgICBrZXkgPSBudWxsID09IGtleSA/ICgtMSA9PT0gY2hpbGRJbmRleCA/IDAgOiBjaGlsZEluZGV4KSA6IGtleTtcbiAgICAgICAgICAgICAgdmFyIGtleVBhdGggPSBbdGFzay5rZXlQYXRoLCBuYW1lLCBrZXldO1xuICAgICAgICAgICAgICBudWxsICE9PSB0YXNrLnJlcGxheVxuICAgICAgICAgICAgICAgID8gZGVidWdUYXNrXG4gICAgICAgICAgICAgICAgICA/IGRlYnVnVGFzay5ydW4oXG4gICAgICAgICAgICAgICAgICAgICAgcmVwbGF5RWxlbWVudC5iaW5kKFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrLFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5UGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZEluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZQcm9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFzay5yZXBsYXlcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIDogcmVwbGF5RWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICAgIHRhc2ssXG4gICAgICAgICAgICAgICAgICAgICAga2V5UGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICBjaGlsZEluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICByZWZQcm9wLFxuICAgICAgICAgICAgICAgICAgICAgIHRhc2sucmVwbGF5XG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICA6IGRlYnVnVGFza1xuICAgICAgICAgICAgICAgICAgPyBkZWJ1Z1Rhc2sucnVuKFxuICAgICAgICAgICAgICAgICAgICAgIHJlbmRlckVsZW1lbnQuYmluZChcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFzayxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleVBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZlByb3BcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIDogcmVuZGVyRWxlbWVudChyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCB0eXBlLCBub2RlLCByZWZQcm9wKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJQb3J0YWxzIGFyZSBub3QgY3VycmVudGx5IHN1cHBvcnRlZCBieSB0aGUgc2VydmVyIHJlbmRlcmVyLiBSZW5kZXIgdGhlbSBjb25kaXRpb25hbGx5IHNvIHRoYXQgdGhleSBvbmx5IGFwcGVhciBvbiB0aGUgY2xpZW50IHJlbmRlci5cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAgIHR5cGUgPSBjYWxsTGF6eUluaXRJbkRFVihub2RlKTtcbiAgICAgICAgICAgICAgaWYgKDEyID09PSByZXF1ZXN0LnN0YXR1cykgdGhyb3cgbnVsbDtcbiAgICAgICAgICAgICAgcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIHR5cGUsIGNoaWxkSW5kZXgpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0FycmF5SW1wbChub2RlKSkge1xuICAgICAgICAgICAgcmVuZGVyQ2hpbGRyZW5BcnJheShyZXF1ZXN0LCB0YXNrLCBub2RlLCBjaGlsZEluZGV4KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKChrZXkgPSBnZXRJdGVyYXRvckZuKG5vZGUpKSlcbiAgICAgICAgICAgIGlmICgodHlwZSA9IGtleS5jYWxsKG5vZGUpKSkge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUl0ZXJhYmxlKHRhc2ssIG5vZGUsIGNoaWxkSW5kZXgsIHR5cGUsIGtleSk7XG4gICAgICAgICAgICAgIG5vZGUgPSB0eXBlLm5leHQoKTtcbiAgICAgICAgICAgICAgaWYgKCFub2RlLmRvbmUpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBbXTtcbiAgICAgICAgICAgICAgICBkbyBrZXkucHVzaChub2RlLnZhbHVlKSwgKG5vZGUgPSB0eXBlLm5leHQoKSk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCFub2RlLmRvbmUpO1xuICAgICAgICAgICAgICAgIHJlbmRlckNoaWxkcmVuQXJyYXkocmVxdWVzdCwgdGFzaywga2V5LCBjaGlsZEluZGV4KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG5vZGUudGhlbilcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICh0YXNrLnRoZW5hYmxlU3RhdGUgPSBudWxsKSxcbiAgICAgICAgICAgICAgcmVuZGVyTm9kZURlc3RydWN0aXZlKFxuICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgdGFzayxcbiAgICAgICAgICAgICAgICB1bndyYXBUaGVuYWJsZShub2RlKSxcbiAgICAgICAgICAgICAgICBjaGlsZEluZGV4XG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKG5vZGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSlcbiAgICAgICAgICAgIHJldHVybiByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUoXG4gICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgIHRhc2ssXG4gICAgICAgICAgICAgIG5vZGUuX2N1cnJlbnRWYWx1ZSxcbiAgICAgICAgICAgICAgY2hpbGRJbmRleFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICByZXF1ZXN0ID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5vZGUpO1xuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6IFwiICtcbiAgICAgICAgICAgICAgKFwiW29iamVjdCBPYmplY3RdXCIgPT09IHJlcXVlc3RcbiAgICAgICAgICAgICAgICA/IFwib2JqZWN0IHdpdGgga2V5cyB7XCIgKyBPYmplY3Qua2V5cyhub2RlKS5qb2luKFwiLCBcIikgKyBcIn1cIlxuICAgICAgICAgICAgICAgIDogcmVxdWVzdCkgK1xuICAgICAgICAgICAgICBcIikuIElmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgaW5zdGVhZC5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG5vZGVcbiAgICAgICAgICA/ICgodGFzayA9IHRhc2suYmxvY2tlZFNlZ21lbnQpLFxuICAgICAgICAgICAgbnVsbCAhPT0gdGFzayAmJlxuICAgICAgICAgICAgICAodGFzay5sYXN0UHVzaGVkVGV4dCA9IHB1c2hUZXh0SW5zdGFuY2UoXG4gICAgICAgICAgICAgICAgdGFzay5jaHVua3MsXG4gICAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnJlbmRlclN0YXRlLFxuICAgICAgICAgICAgICAgIHRhc2subGFzdFB1c2hlZFRleHRcbiAgICAgICAgICAgICAgKSkpXG4gICAgICAgICAgOiBcIm51bWJlclwiID09PSB0eXBlb2Ygbm9kZSB8fCBcImJpZ2ludFwiID09PSB0eXBlb2Ygbm9kZVxuICAgICAgICAgICAgPyAoKHRhc2sgPSB0YXNrLmJsb2NrZWRTZWdtZW50KSxcbiAgICAgICAgICAgICAgbnVsbCAhPT0gdGFzayAmJlxuICAgICAgICAgICAgICAgICh0YXNrLmxhc3RQdXNoZWRUZXh0ID0gcHVzaFRleHRJbnN0YW5jZShcbiAgICAgICAgICAgICAgICAgIHRhc2suY2h1bmtzLFxuICAgICAgICAgICAgICAgICAgXCJcIiArIG5vZGUsXG4gICAgICAgICAgICAgICAgICByZXF1ZXN0LnJlbmRlclN0YXRlLFxuICAgICAgICAgICAgICAgICAgdGFzay5sYXN0UHVzaGVkVGV4dFxuICAgICAgICAgICAgICAgICkpKVxuICAgICAgICAgICAgOiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2Ygbm9kZSAmJlxuICAgICAgICAgICAgICAgICgocmVxdWVzdCA9IG5vZGUuZGlzcGxheU5hbWUgfHwgbm9kZS5uYW1lIHx8IFwiQ29tcG9uZW50XCIpLFxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIkZ1bmN0aW9ucyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQuIFRoaXMgbWF5IGhhcHBlbiBpZiB5b3UgcmV0dXJuICVzIGluc3RlYWQgb2YgPCVzIC8+IGZyb20gcmVuZGVyLiBPciBtYXliZSB5b3UgbWVhbnQgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uIHJhdGhlciB0aGFuIHJldHVybiBpdC5cIixcbiAgICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICByZXF1ZXN0XG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIFwic3ltYm9sXCIgPT09IHR5cGVvZiBub2RlICYmXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiU3ltYm9scyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQuXFxuICAlc1wiLFxuICAgICAgICAgICAgICAgICAgU3RyaW5nKG5vZGUpXG4gICAgICAgICAgICAgICAgKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdhcm5Gb3JNaXNzaW5nS2V5KHJlcXVlc3QsIHRhc2ssIGNoaWxkKSB7XG4gICAgICBpZiAoXG4gICAgICAgIG51bGwgIT09IGNoaWxkICYmXG4gICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBjaGlsZCAmJlxuICAgICAgICAoY2hpbGQuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSB8fFxuICAgICAgICAgIGNoaWxkLiQkdHlwZW9mID09PSBSRUFDVF9QT1JUQUxfVFlQRSkgJiZcbiAgICAgICAgY2hpbGQuX3N0b3JlICYmXG4gICAgICAgICgoIWNoaWxkLl9zdG9yZS52YWxpZGF0ZWQgJiYgbnVsbCA9PSBjaGlsZC5rZXkpIHx8XG4gICAgICAgICAgMiA9PT0gY2hpbGQuX3N0b3JlLnZhbGlkYXRlZClcbiAgICAgICkge1xuICAgICAgICBpZiAoXCJvYmplY3RcIiAhPT0gdHlwZW9mIGNoaWxkLl9zdG9yZSlcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiUmVhY3QgQ29tcG9uZW50IGluIHdhcm5Gb3JNaXNzaW5nS2V5IHNob3VsZCBoYXZlIGEgX3N0b3JlLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgY2hpbGQuX3N0b3JlLnZhbGlkYXRlZCA9IDE7XG4gICAgICAgIHZhciBkaWRXYXJuRm9yS2V5ID0gcmVxdWVzdC5kaWRXYXJuRm9yS2V5O1xuICAgICAgICBudWxsID09IGRpZFdhcm5Gb3JLZXkgJiZcbiAgICAgICAgICAoZGlkV2FybkZvcktleSA9IHJlcXVlc3QuZGlkV2FybkZvcktleSA9IG5ldyBXZWFrU2V0KCkpO1xuICAgICAgICByZXF1ZXN0ID0gdGFzay5jb21wb25lbnRTdGFjaztcbiAgICAgICAgaWYgKG51bGwgIT09IHJlcXVlc3QgJiYgIWRpZFdhcm5Gb3JLZXkuaGFzKHJlcXVlc3QpKSB7XG4gICAgICAgICAgZGlkV2FybkZvcktleS5hZGQocmVxdWVzdCk7XG4gICAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoY2hpbGQudHlwZSk7XG4gICAgICAgICAgZGlkV2FybkZvcktleSA9IGNoaWxkLl9vd25lcjtcbiAgICAgICAgICB2YXIgcGFyZW50T3duZXIgPSByZXF1ZXN0Lm93bmVyO1xuICAgICAgICAgIHJlcXVlc3QgPSBcIlwiO1xuICAgICAgICAgIGlmIChwYXJlbnRPd25lciAmJiBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgcGFyZW50T3duZXIudHlwZSkge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUocGFyZW50T3duZXIudHlwZSk7XG4gICAgICAgICAgICBuYW1lICYmXG4gICAgICAgICAgICAgIChyZXF1ZXN0ID0gXCJcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgXCIgKyBuYW1lICsgXCJgLlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVxdWVzdCB8fFxuICAgICAgICAgICAgKGNvbXBvbmVudE5hbWUgJiZcbiAgICAgICAgICAgICAgKHJlcXVlc3QgPVxuICAgICAgICAgICAgICAgIFwiXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8XCIgK1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudE5hbWUgK1xuICAgICAgICAgICAgICAgIFwiPi5cIikpO1xuICAgICAgICAgIGNvbXBvbmVudE5hbWUgPSBcIlwiO1xuICAgICAgICAgIG51bGwgIT0gZGlkV2FybkZvcktleSAmJlxuICAgICAgICAgICAgcGFyZW50T3duZXIgIT09IGRpZFdhcm5Gb3JLZXkgJiZcbiAgICAgICAgICAgICgocGFyZW50T3duZXIgPSBudWxsKSxcbiAgICAgICAgICAgIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBkaWRXYXJuRm9yS2V5LnR5cGVcbiAgICAgICAgICAgICAgPyAocGFyZW50T3duZXIgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZGlkV2FybkZvcktleS50eXBlKSlcbiAgICAgICAgICAgICAgOiBcInN0cmluZ1wiID09PSB0eXBlb2YgZGlkV2FybkZvcktleS5uYW1lICYmXG4gICAgICAgICAgICAgICAgKHBhcmVudE93bmVyID0gZGlkV2FybkZvcktleS5uYW1lKSxcbiAgICAgICAgICAgIHBhcmVudE93bmVyICYmXG4gICAgICAgICAgICAgIChjb21wb25lbnROYW1lID1cbiAgICAgICAgICAgICAgICBcIiBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSBcIiArIHBhcmVudE93bmVyICsgXCIuXCIpKTtcbiAgICAgICAgICBkaWRXYXJuRm9yS2V5ID0gdGFzay5jb21wb25lbnRTdGFjaztcbiAgICAgICAgICB0YXNrLmNvbXBvbmVudFN0YWNrID0ge1xuICAgICAgICAgICAgcGFyZW50OiB0YXNrLmNvbXBvbmVudFN0YWNrLFxuICAgICAgICAgICAgdHlwZTogY2hpbGQudHlwZSxcbiAgICAgICAgICAgIG93bmVyOiBjaGlsZC5fb3duZXIsXG4gICAgICAgICAgICBzdGFjazogY2hpbGQuX2RlYnVnU3RhY2tcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAnRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLiVzJXMgU2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsXG4gICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgICAgICAgICk7XG4gICAgICAgICAgdGFzay5jb21wb25lbnRTdGFjayA9IGRpZFdhcm5Gb3JLZXk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVuZGVyQ2hpbGRyZW5BcnJheShyZXF1ZXN0LCB0YXNrLCBjaGlsZHJlbiwgY2hpbGRJbmRleCkge1xuICAgICAgdmFyIHByZXZLZXlQYXRoID0gdGFzay5rZXlQYXRoLFxuICAgICAgICBwcmV2aW91c0NvbXBvbmVudFN0YWNrID0gdGFzay5jb21wb25lbnRTdGFjaztcbiAgICAgIHZhciBwcmV2aW91c0RlYnVnVGFzayA9IHRhc2suZGVidWdUYXNrO1xuICAgICAgcHVzaFNlcnZlckNvbXBvbmVudFN0YWNrKHRhc2ssIHRhc2subm9kZS5fZGVidWdJbmZvKTtcbiAgICAgIGlmIChcbiAgICAgICAgLTEgIT09IGNoaWxkSW5kZXggJiZcbiAgICAgICAgKCh0YXNrLmtleVBhdGggPSBbdGFzay5rZXlQYXRoLCBcIkZyYWdtZW50XCIsIGNoaWxkSW5kZXhdKSxcbiAgICAgICAgbnVsbCAhPT0gdGFzay5yZXBsYXkpXG4gICAgICApIHtcbiAgICAgICAgZm9yIChcbiAgICAgICAgICB2YXIgcmVwbGF5ID0gdGFzay5yZXBsYXksIHJlcGxheU5vZGVzID0gcmVwbGF5Lm5vZGVzLCBqID0gMDtcbiAgICAgICAgICBqIDwgcmVwbGF5Tm9kZXMubGVuZ3RoO1xuICAgICAgICAgIGorK1xuICAgICAgICApIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IHJlcGxheU5vZGVzW2pdO1xuICAgICAgICAgIGlmIChub2RlWzFdID09PSBjaGlsZEluZGV4KSB7XG4gICAgICAgICAgICBjaGlsZEluZGV4ID0gbm9kZVsyXTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlWzNdO1xuICAgICAgICAgICAgdGFzay5yZXBsYXkgPSB7IG5vZGVzOiBjaGlsZEluZGV4LCBzbG90czogbm9kZSwgcGVuZGluZ1Rhc2tzOiAxIH07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZW5kZXJDaGlsZHJlbkFycmF5KHJlcXVlc3QsIHRhc2ssIGNoaWxkcmVuLCAtMSk7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAxID09PSB0YXNrLnJlcGxheS5wZW5kaW5nVGFza3MgJiZcbiAgICAgICAgICAgICAgICAwIDwgdGFzay5yZXBsYXkubm9kZXMubGVuZ3RoXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiQ291bGRuJ3QgZmluZCBhbGwgcmVzdW1hYmxlIHNsb3RzIGJ5IGtleS9pbmRleCBkdXJpbmcgcmVwbGF5aW5nLiBUaGUgdHJlZSBkb2Vzbid0IG1hdGNoIHNvIFJlYWN0IHdpbGwgZmFsbGJhY2sgdG8gY2xpZW50IHJlbmRlcmluZy5cIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHRhc2sucmVwbGF5LnBlbmRpbmdUYXNrcy0tO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHggJiZcbiAgICAgICAgICAgICAgICBudWxsICE9PSB4ICYmXG4gICAgICAgICAgICAgICAgKHggPT09IFN1c3BlbnNlRXhjZXB0aW9uIHx8IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHgudGhlbilcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIHRocm93IHg7XG4gICAgICAgICAgICAgIHRhc2sucmVwbGF5LnBlbmRpbmdUYXNrcy0tO1xuICAgICAgICAgICAgICB2YXIgdGhyb3duSW5mbyA9IGdldFRocm93bkluZm8odGFzay5jb21wb25lbnRTdGFjayk7XG4gICAgICAgICAgICAgIGNoaWxkcmVuID0gdGFzay5ibG9ja2VkQm91bmRhcnk7XG4gICAgICAgICAgICAgIHZhciBlcnJvciA9IHgsXG4gICAgICAgICAgICAgICAgcmVzdW1lU2xvdHMgPSBub2RlO1xuICAgICAgICAgICAgICBub2RlID0gbG9nUmVjb3ZlcmFibGVFcnJvcihcbiAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgIHRocm93bkluZm8sXG4gICAgICAgICAgICAgICAgdGFzay5kZWJ1Z1Rhc2tcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgYWJvcnRSZW1haW5pbmdSZXBsYXlOb2RlcyhcbiAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuLFxuICAgICAgICAgICAgICAgIGNoaWxkSW5kZXgsXG4gICAgICAgICAgICAgICAgcmVzdW1lU2xvdHMsXG4gICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgICB0aHJvd25JbmZvLFxuICAgICAgICAgICAgICAgICExXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXNrLnJlcGxheSA9IHJlcGxheTtcbiAgICAgICAgICAgIHJlcGxheU5vZGVzLnNwbGljZShqLCAxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0YXNrLmtleVBhdGggPSBwcmV2S2V5UGF0aDtcbiAgICAgICAgdGFzay5jb21wb25lbnRTdGFjayA9IHByZXZpb3VzQ29tcG9uZW50U3RhY2s7XG4gICAgICAgIHRhc2suZGVidWdUYXNrID0gcHJldmlvdXNEZWJ1Z1Rhc2s7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJlcGxheSA9IHRhc2sudHJlZUNvbnRleHQ7XG4gICAgICByZXBsYXlOb2RlcyA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgIGlmIChcbiAgICAgICAgbnVsbCAhPT0gdGFzay5yZXBsYXkgJiZcbiAgICAgICAgKChqID0gdGFzay5yZXBsYXkuc2xvdHMpLCBudWxsICE9PSBqICYmIFwib2JqZWN0XCIgPT09IHR5cGVvZiBqKVxuICAgICAgKSB7XG4gICAgICAgIGZvciAoY2hpbGRJbmRleCA9IDA7IGNoaWxkSW5kZXggPCByZXBsYXlOb2RlczsgY2hpbGRJbmRleCsrKVxuICAgICAgICAgIChub2RlID0gY2hpbGRyZW5bY2hpbGRJbmRleF0pLFxuICAgICAgICAgICAgKHRhc2sudHJlZUNvbnRleHQgPSBwdXNoVHJlZUNvbnRleHQoXG4gICAgICAgICAgICAgIHJlcGxheSxcbiAgICAgICAgICAgICAgcmVwbGF5Tm9kZXMsXG4gICAgICAgICAgICAgIGNoaWxkSW5kZXhcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgKGVycm9yID0galtjaGlsZEluZGV4XSksXG4gICAgICAgICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgZXJyb3JcbiAgICAgICAgICAgICAgPyAocmVzdW1lTm9kZShyZXF1ZXN0LCB0YXNrLCBlcnJvciwgbm9kZSwgY2hpbGRJbmRleCksXG4gICAgICAgICAgICAgICAgZGVsZXRlIGpbY2hpbGRJbmRleF0pXG4gICAgICAgICAgICAgIDogcmVuZGVyTm9kZShyZXF1ZXN0LCB0YXNrLCBub2RlLCBjaGlsZEluZGV4KTtcbiAgICAgICAgdGFzay50cmVlQ29udGV4dCA9IHJlcGxheTtcbiAgICAgICAgdGFzay5rZXlQYXRoID0gcHJldktleVBhdGg7XG4gICAgICAgIHRhc2suY29tcG9uZW50U3RhY2sgPSBwcmV2aW91c0NvbXBvbmVudFN0YWNrO1xuICAgICAgICB0YXNrLmRlYnVnVGFzayA9IHByZXZpb3VzRGVidWdUYXNrO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmb3IgKGogPSAwOyBqIDwgcmVwbGF5Tm9kZXM7IGorKylcbiAgICAgICAgKGNoaWxkSW5kZXggPSBjaGlsZHJlbltqXSksXG4gICAgICAgICAgd2FybkZvck1pc3NpbmdLZXkocmVxdWVzdCwgdGFzaywgY2hpbGRJbmRleCksXG4gICAgICAgICAgKHRhc2sudHJlZUNvbnRleHQgPSBwdXNoVHJlZUNvbnRleHQocmVwbGF5LCByZXBsYXlOb2RlcywgaikpLFxuICAgICAgICAgIHJlbmRlck5vZGUocmVxdWVzdCwgdGFzaywgY2hpbGRJbmRleCwgaik7XG4gICAgICB0YXNrLnRyZWVDb250ZXh0ID0gcmVwbGF5O1xuICAgICAgdGFzay5rZXlQYXRoID0gcHJldktleVBhdGg7XG4gICAgICB0YXNrLmNvbXBvbmVudFN0YWNrID0gcHJldmlvdXNDb21wb25lbnRTdGFjaztcbiAgICAgIHRhc2suZGVidWdUYXNrID0gcHJldmlvdXNEZWJ1Z1Rhc2s7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyYWNrUG9zdHBvbmVkQm91bmRhcnkocmVxdWVzdCwgdHJhY2tlZFBvc3Rwb25lcywgYm91bmRhcnkpIHtcbiAgICAgIGJvdW5kYXJ5LnN0YXR1cyA9IFBPU1RQT05FRDtcbiAgICAgIGJvdW5kYXJ5LnJvb3RTZWdtZW50SUQgPSByZXF1ZXN0Lm5leHRTZWdtZW50SWQrKztcbiAgICAgIHJlcXVlc3QgPSBib3VuZGFyeS50cmFja2VkQ29udGVudEtleVBhdGg7XG4gICAgICBpZiAobnVsbCA9PT0gcmVxdWVzdClcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJJdCBzaG91bGQgbm90IGJlIHBvc3NpYmxlIHRvIHBvc3Rwb25lIGF0IHRoZSByb290LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICk7XG4gICAgICB2YXIgZmFsbGJhY2tSZXBsYXlOb2RlID0gYm91bmRhcnkudHJhY2tlZEZhbGxiYWNrTm9kZSxcbiAgICAgICAgY2hpbGRyZW4gPSBbXSxcbiAgICAgICAgYm91bmRhcnlOb2RlID0gdHJhY2tlZFBvc3Rwb25lcy53b3JraW5nTWFwLmdldChyZXF1ZXN0KTtcbiAgICAgIGlmICh2b2lkIDAgPT09IGJvdW5kYXJ5Tm9kZSlcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAoYm91bmRhcnkgPSBbXG4gICAgICAgICAgICByZXF1ZXN0WzFdLFxuICAgICAgICAgICAgcmVxdWVzdFsyXSxcbiAgICAgICAgICAgIGNoaWxkcmVuLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIGZhbGxiYWNrUmVwbGF5Tm9kZSxcbiAgICAgICAgICAgIGJvdW5kYXJ5LnJvb3RTZWdtZW50SURcbiAgICAgICAgICBdKSxcbiAgICAgICAgICB0cmFja2VkUG9zdHBvbmVzLndvcmtpbmdNYXAuc2V0KHJlcXVlc3QsIGJvdW5kYXJ5KSxcbiAgICAgICAgICBhZGRUb1JlcGxheVBhcmVudChib3VuZGFyeSwgcmVxdWVzdFswXSwgdHJhY2tlZFBvc3Rwb25lcyksXG4gICAgICAgICAgYm91bmRhcnlcbiAgICAgICAgKTtcbiAgICAgIGJvdW5kYXJ5Tm9kZVs0XSA9IGZhbGxiYWNrUmVwbGF5Tm9kZTtcbiAgICAgIGJvdW5kYXJ5Tm9kZVs1XSA9IGJvdW5kYXJ5LnJvb3RTZWdtZW50SUQ7XG4gICAgICByZXR1cm4gYm91bmRhcnlOb2RlO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFja1Bvc3Rwb25lKHJlcXVlc3QsIHRyYWNrZWRQb3N0cG9uZXMsIHRhc2ssIHNlZ21lbnQpIHtcbiAgICAgIHNlZ21lbnQuc3RhdHVzID0gUE9TVFBPTkVEO1xuICAgICAgdmFyIGtleVBhdGggPSB0YXNrLmtleVBhdGgsXG4gICAgICAgIGJvdW5kYXJ5ID0gdGFzay5ibG9ja2VkQm91bmRhcnk7XG4gICAgICBpZiAobnVsbCA9PT0gYm91bmRhcnkpXG4gICAgICAgIChzZWdtZW50LmlkID0gcmVxdWVzdC5uZXh0U2VnbWVudElkKyspLFxuICAgICAgICAgICh0cmFja2VkUG9zdHBvbmVzLnJvb3RTbG90cyA9IHNlZ21lbnQuaWQpLFxuICAgICAgICAgIG51bGwgIT09IHJlcXVlc3QuY29tcGxldGVkUm9vdFNlZ21lbnQgJiZcbiAgICAgICAgICAgIChyZXF1ZXN0LmNvbXBsZXRlZFJvb3RTZWdtZW50LnN0YXR1cyA9IFBPU1RQT05FRCk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKG51bGwgIT09IGJvdW5kYXJ5ICYmIGJvdW5kYXJ5LnN0YXR1cyA9PT0gUEVORElORykge1xuICAgICAgICAgIHZhciBib3VuZGFyeU5vZGUgPSB0cmFja1Bvc3Rwb25lZEJvdW5kYXJ5KFxuICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgIHRyYWNrZWRQb3N0cG9uZXMsXG4gICAgICAgICAgICBib3VuZGFyeVxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgYm91bmRhcnkudHJhY2tlZENvbnRlbnRLZXlQYXRoID09PSBrZXlQYXRoICYmXG4gICAgICAgICAgICAtMSA9PT0gdGFzay5jaGlsZEluZGV4XG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICAtMSA9PT0gc2VnbWVudC5pZCAmJlxuICAgICAgICAgICAgICAoc2VnbWVudC5pZCA9IHNlZ21lbnQucGFyZW50Rmx1c2hlZFxuICAgICAgICAgICAgICAgID8gYm91bmRhcnkucm9vdFNlZ21lbnRJRFxuICAgICAgICAgICAgICAgIDogcmVxdWVzdC5uZXh0U2VnbWVudElkKyspO1xuICAgICAgICAgICAgYm91bmRhcnlOb2RlWzNdID0gc2VnbWVudC5pZDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLTEgPT09IHNlZ21lbnQuaWQgJiZcbiAgICAgICAgICAoc2VnbWVudC5pZCA9XG4gICAgICAgICAgICBzZWdtZW50LnBhcmVudEZsdXNoZWQgJiYgbnVsbCAhPT0gYm91bmRhcnlcbiAgICAgICAgICAgICAgPyBib3VuZGFyeS5yb290U2VnbWVudElEXG4gICAgICAgICAgICAgIDogcmVxdWVzdC5uZXh0U2VnbWVudElkKyspO1xuICAgICAgICBpZiAoLTEgPT09IHRhc2suY2hpbGRJbmRleClcbiAgICAgICAgICBudWxsID09PSBrZXlQYXRoXG4gICAgICAgICAgICA/ICh0cmFja2VkUG9zdHBvbmVzLnJvb3RTbG90cyA9IHNlZ21lbnQuaWQpXG4gICAgICAgICAgICA6ICgodGFzayA9IHRyYWNrZWRQb3N0cG9uZXMud29ya2luZ01hcC5nZXQoa2V5UGF0aCkpLFxuICAgICAgICAgICAgICB2b2lkIDAgPT09IHRhc2tcbiAgICAgICAgICAgICAgICA/ICgodGFzayA9IFtrZXlQYXRoWzFdLCBrZXlQYXRoWzJdLCBbXSwgc2VnbWVudC5pZF0pLFxuICAgICAgICAgICAgICAgICAgYWRkVG9SZXBsYXlQYXJlbnQodGFzaywga2V5UGF0aFswXSwgdHJhY2tlZFBvc3Rwb25lcykpXG4gICAgICAgICAgICAgICAgOiAodGFza1szXSA9IHNlZ21lbnQuaWQpKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKG51bGwgPT09IGtleVBhdGgpXG4gICAgICAgICAgICBpZiAoKChyZXF1ZXN0ID0gdHJhY2tlZFBvc3Rwb25lcy5yb290U2xvdHMpLCBudWxsID09PSByZXF1ZXN0KSlcbiAgICAgICAgICAgICAgcmVxdWVzdCA9IHRyYWNrZWRQb3N0cG9uZXMucm9vdFNsb3RzID0ge307XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKFwibnVtYmVyXCIgPT09IHR5cGVvZiByZXF1ZXN0KVxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJJdCBzaG91bGQgbm90IGJlIHBvc3NpYmxlIHRvIHBvc3Rwb25lIGJvdGggYXQgdGhlIHJvb3Qgb2YgYW4gZWxlbWVudCBhcyB3ZWxsIGFzIGEgc2xvdCBiZWxvdy4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoXG4gICAgICAgICAgICAoKGJvdW5kYXJ5ID0gdHJhY2tlZFBvc3Rwb25lcy53b3JraW5nTWFwKSxcbiAgICAgICAgICAgIChib3VuZGFyeU5vZGUgPSBib3VuZGFyeS5nZXQoa2V5UGF0aCkpLFxuICAgICAgICAgICAgdm9pZCAwID09PSBib3VuZGFyeU5vZGUpXG4gICAgICAgICAgKVxuICAgICAgICAgICAgKHJlcXVlc3QgPSB7fSksXG4gICAgICAgICAgICAgIChib3VuZGFyeU5vZGUgPSBba2V5UGF0aFsxXSwga2V5UGF0aFsyXSwgW10sIHJlcXVlc3RdKSxcbiAgICAgICAgICAgICAgYm91bmRhcnkuc2V0KGtleVBhdGgsIGJvdW5kYXJ5Tm9kZSksXG4gICAgICAgICAgICAgIGFkZFRvUmVwbGF5UGFyZW50KGJvdW5kYXJ5Tm9kZSwga2V5UGF0aFswXSwgdHJhY2tlZFBvc3Rwb25lcyk7XG4gICAgICAgICAgZWxzZSBpZiAoKChyZXF1ZXN0ID0gYm91bmRhcnlOb2RlWzNdKSwgbnVsbCA9PT0gcmVxdWVzdCkpXG4gICAgICAgICAgICByZXF1ZXN0ID0gYm91bmRhcnlOb2RlWzNdID0ge307XG4gICAgICAgICAgZWxzZSBpZiAoXCJudW1iZXJcIiA9PT0gdHlwZW9mIHJlcXVlc3QpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgXCJJdCBzaG91bGQgbm90IGJlIHBvc3NpYmxlIHRvIHBvc3Rwb25lIGJvdGggYXQgdGhlIHJvb3Qgb2YgYW4gZWxlbWVudCBhcyB3ZWxsIGFzIGEgc2xvdCBiZWxvdy4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICByZXF1ZXN0W3Rhc2suY2hpbGRJbmRleF0gPSBzZWdtZW50LmlkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVudHJhY2tCb3VuZGFyeShyZXF1ZXN0LCBib3VuZGFyeSkge1xuICAgICAgcmVxdWVzdCA9IHJlcXVlc3QudHJhY2tlZFBvc3Rwb25lcztcbiAgICAgIG51bGwgIT09IHJlcXVlc3QgJiZcbiAgICAgICAgKChib3VuZGFyeSA9IGJvdW5kYXJ5LnRyYWNrZWRDb250ZW50S2V5UGF0aCksXG4gICAgICAgIG51bGwgIT09IGJvdW5kYXJ5ICYmXG4gICAgICAgICAgKChib3VuZGFyeSA9IHJlcXVlc3Qud29ya2luZ01hcC5nZXQoYm91bmRhcnkpKSxcbiAgICAgICAgICB2b2lkIDAgIT09IGJvdW5kYXJ5ICYmXG4gICAgICAgICAgICAoKGJvdW5kYXJ5Lmxlbmd0aCA9IDQpLCAoYm91bmRhcnlbMl0gPSBbXSksIChib3VuZGFyeVszXSA9IG51bGwpKSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzcGF3bk5ld1N1c3BlbmRlZFJlcGxheVRhc2socmVxdWVzdCwgdGFzaywgdGhlbmFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVJlcGxheVRhc2soXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIHRoZW5hYmxlU3RhdGUsXG4gICAgICAgIHRhc2sucmVwbGF5LFxuICAgICAgICB0YXNrLm5vZGUsXG4gICAgICAgIHRhc2suY2hpbGRJbmRleCxcbiAgICAgICAgdGFzay5ibG9ja2VkQm91bmRhcnksXG4gICAgICAgIHRhc2suaG9pc3RhYmxlU3RhdGUsXG4gICAgICAgIHRhc2suYWJvcnRTZXQsXG4gICAgICAgIHRhc2sua2V5UGF0aCxcbiAgICAgICAgdGFzay5mb3JtYXRDb250ZXh0LFxuICAgICAgICB0YXNrLmNvbnRleHQsXG4gICAgICAgIHRhc2sudHJlZUNvbnRleHQsXG4gICAgICAgIHRhc2sucm93LFxuICAgICAgICB0YXNrLmNvbXBvbmVudFN0YWNrLFxuICAgICAgICBlbXB0eUNvbnRleHRPYmplY3QsXG4gICAgICAgIHRhc2suZGVidWdUYXNrXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzcGF3bk5ld1N1c3BlbmRlZFJlbmRlclRhc2socmVxdWVzdCwgdGFzaywgdGhlbmFibGVTdGF0ZSkge1xuICAgICAgdmFyIHNlZ21lbnQgPSB0YXNrLmJsb2NrZWRTZWdtZW50LFxuICAgICAgICBuZXdTZWdtZW50ID0gY3JlYXRlUGVuZGluZ1NlZ21lbnQoXG4gICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICBzZWdtZW50LmNodW5rcy5sZW5ndGgsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICB0YXNrLmZvcm1hdENvbnRleHQsXG4gICAgICAgICAgc2VnbWVudC5sYXN0UHVzaGVkVGV4dCxcbiAgICAgICAgICAhMFxuICAgICAgICApO1xuICAgICAgc2VnbWVudC5jaGlsZHJlbi5wdXNoKG5ld1NlZ21lbnQpO1xuICAgICAgc2VnbWVudC5sYXN0UHVzaGVkVGV4dCA9ICExO1xuICAgICAgcmV0dXJuIGNyZWF0ZVJlbmRlclRhc2soXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIHRoZW5hYmxlU3RhdGUsXG4gICAgICAgIHRhc2subm9kZSxcbiAgICAgICAgdGFzay5jaGlsZEluZGV4LFxuICAgICAgICB0YXNrLmJsb2NrZWRCb3VuZGFyeSxcbiAgICAgICAgbmV3U2VnbWVudCxcbiAgICAgICAgdGFzay5ibG9ja2VkUHJlYW1ibGUsXG4gICAgICAgIHRhc2suaG9pc3RhYmxlU3RhdGUsXG4gICAgICAgIHRhc2suYWJvcnRTZXQsXG4gICAgICAgIHRhc2sua2V5UGF0aCxcbiAgICAgICAgdGFzay5mb3JtYXRDb250ZXh0LFxuICAgICAgICB0YXNrLmNvbnRleHQsXG4gICAgICAgIHRhc2sudHJlZUNvbnRleHQsXG4gICAgICAgIHRhc2sucm93LFxuICAgICAgICB0YXNrLmNvbXBvbmVudFN0YWNrLFxuICAgICAgICBlbXB0eUNvbnRleHRPYmplY3QsXG4gICAgICAgIHRhc2suZGVidWdUYXNrXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZW5kZXJOb2RlKHJlcXVlc3QsIHRhc2ssIG5vZGUsIGNoaWxkSW5kZXgpIHtcbiAgICAgIHZhciBwcmV2aW91c0Zvcm1hdENvbnRleHQgPSB0YXNrLmZvcm1hdENvbnRleHQsXG4gICAgICAgIHByZXZpb3VzQ29udGV4dCA9IHRhc2suY29udGV4dCxcbiAgICAgICAgcHJldmlvdXNLZXlQYXRoID0gdGFzay5rZXlQYXRoLFxuICAgICAgICBwcmV2aW91c1RyZWVDb250ZXh0ID0gdGFzay50cmVlQ29udGV4dCxcbiAgICAgICAgcHJldmlvdXNDb21wb25lbnRTdGFjayA9IHRhc2suY29tcG9uZW50U3RhY2ssXG4gICAgICAgIHByZXZpb3VzRGVidWdUYXNrID0gdGFzay5kZWJ1Z1Rhc2ssXG4gICAgICAgIHNlZ21lbnQgPSB0YXNrLmJsb2NrZWRTZWdtZW50O1xuICAgICAgaWYgKG51bGwgPT09IHNlZ21lbnQpIHtcbiAgICAgICAgc2VnbWVudCA9IHRhc2sucmVwbGF5O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgbm9kZSwgY2hpbGRJbmRleCk7XG4gICAgICAgIH0gY2F0Y2ggKHRocm93blZhbHVlKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKHJlc2V0SG9va3NTdGF0ZSgpLFxuICAgICAgICAgICAgKG5vZGUgPVxuICAgICAgICAgICAgICB0aHJvd25WYWx1ZSA9PT0gU3VzcGVuc2VFeGNlcHRpb25cbiAgICAgICAgICAgICAgICA/IGdldFN1c3BlbmRlZFRoZW5hYmxlKClcbiAgICAgICAgICAgICAgICA6IHRocm93blZhbHVlKSxcbiAgICAgICAgICAgIDEyICE9PSByZXF1ZXN0LnN0YXR1cyAmJiBcIm9iamVjdFwiID09PSB0eXBlb2Ygbm9kZSAmJiBudWxsICE9PSBub2RlKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG5vZGUudGhlbikge1xuICAgICAgICAgICAgICBjaGlsZEluZGV4ID1cbiAgICAgICAgICAgICAgICB0aHJvd25WYWx1ZSA9PT0gU3VzcGVuc2VFeGNlcHRpb25cbiAgICAgICAgICAgICAgICAgID8gZ2V0VGhlbmFibGVTdGF0ZUFmdGVyU3VzcGVuZGluZygpXG4gICAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICAgIHJlcXVlc3QgPSBzcGF3bk5ld1N1c3BlbmRlZFJlcGxheVRhc2soXG4gICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICB0YXNrLFxuICAgICAgICAgICAgICAgIGNoaWxkSW5kZXhcbiAgICAgICAgICAgICAgKS5waW5nO1xuICAgICAgICAgICAgICBub2RlLnRoZW4ocmVxdWVzdCwgcmVxdWVzdCk7XG4gICAgICAgICAgICAgIHRhc2suZm9ybWF0Q29udGV4dCA9IHByZXZpb3VzRm9ybWF0Q29udGV4dDtcbiAgICAgICAgICAgICAgdGFzay5jb250ZXh0ID0gcHJldmlvdXNDb250ZXh0O1xuICAgICAgICAgICAgICB0YXNrLmtleVBhdGggPSBwcmV2aW91c0tleVBhdGg7XG4gICAgICAgICAgICAgIHRhc2sudHJlZUNvbnRleHQgPSBwcmV2aW91c1RyZWVDb250ZXh0O1xuICAgICAgICAgICAgICB0YXNrLmNvbXBvbmVudFN0YWNrID0gcHJldmlvdXNDb21wb25lbnRTdGFjaztcbiAgICAgICAgICAgICAgdGFzay5yZXBsYXkgPSBzZWdtZW50O1xuICAgICAgICAgICAgICB0YXNrLmRlYnVnVGFzayA9IHByZXZpb3VzRGVidWdUYXNrO1xuICAgICAgICAgICAgICBzd2l0Y2hDb250ZXh0KHByZXZpb3VzQ29udGV4dCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChcIk1heGltdW0gY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIgPT09IG5vZGUubWVzc2FnZSkge1xuICAgICAgICAgICAgICBub2RlID1cbiAgICAgICAgICAgICAgICB0aHJvd25WYWx1ZSA9PT0gU3VzcGVuc2VFeGNlcHRpb25cbiAgICAgICAgICAgICAgICAgID8gZ2V0VGhlbmFibGVTdGF0ZUFmdGVyU3VzcGVuZGluZygpXG4gICAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICAgIG5vZGUgPSBzcGF3bk5ld1N1c3BlbmRlZFJlcGxheVRhc2socmVxdWVzdCwgdGFzaywgbm9kZSk7XG4gICAgICAgICAgICAgIHJlcXVlc3QucGluZ2VkVGFza3MucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgdGFzay5mb3JtYXRDb250ZXh0ID0gcHJldmlvdXNGb3JtYXRDb250ZXh0O1xuICAgICAgICAgICAgICB0YXNrLmNvbnRleHQgPSBwcmV2aW91c0NvbnRleHQ7XG4gICAgICAgICAgICAgIHRhc2sua2V5UGF0aCA9IHByZXZpb3VzS2V5UGF0aDtcbiAgICAgICAgICAgICAgdGFzay50cmVlQ29udGV4dCA9IHByZXZpb3VzVHJlZUNvbnRleHQ7XG4gICAgICAgICAgICAgIHRhc2suY29tcG9uZW50U3RhY2sgPSBwcmV2aW91c0NvbXBvbmVudFN0YWNrO1xuICAgICAgICAgICAgICB0YXNrLnJlcGxheSA9IHNlZ21lbnQ7XG4gICAgICAgICAgICAgIHRhc2suZGVidWdUYXNrID0gcHJldmlvdXNEZWJ1Z1Rhc2s7XG4gICAgICAgICAgICAgIHN3aXRjaENvbnRleHQocHJldmlvdXNDb250ZXh0KTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gc2VnbWVudC5jaGlsZHJlbi5sZW5ndGgsXG4gICAgICAgICAgY2h1bmtMZW5ndGggPSBzZWdtZW50LmNodW5rcy5sZW5ndGg7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBub2RlLCBjaGlsZEluZGV4KTtcbiAgICAgICAgfSBjYXRjaCAodGhyb3duVmFsdWUkMykge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIChyZXNldEhvb2tzU3RhdGUoKSxcbiAgICAgICAgICAgIChzZWdtZW50LmNoaWxkcmVuLmxlbmd0aCA9IGNoaWxkcmVuTGVuZ3RoKSxcbiAgICAgICAgICAgIChzZWdtZW50LmNodW5rcy5sZW5ndGggPSBjaHVua0xlbmd0aCksXG4gICAgICAgICAgICAobm9kZSA9XG4gICAgICAgICAgICAgIHRocm93blZhbHVlJDMgPT09IFN1c3BlbnNlRXhjZXB0aW9uXG4gICAgICAgICAgICAgICAgPyBnZXRTdXNwZW5kZWRUaGVuYWJsZSgpXG4gICAgICAgICAgICAgICAgOiB0aHJvd25WYWx1ZSQzKSxcbiAgICAgICAgICAgIDEyICE9PSByZXF1ZXN0LnN0YXR1cyAmJiBcIm9iamVjdFwiID09PSB0eXBlb2Ygbm9kZSAmJiBudWxsICE9PSBub2RlKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG5vZGUudGhlbikge1xuICAgICAgICAgICAgICBzZWdtZW50ID0gbm9kZTtcbiAgICAgICAgICAgICAgbm9kZSA9XG4gICAgICAgICAgICAgICAgdGhyb3duVmFsdWUkMyA9PT0gU3VzcGVuc2VFeGNlcHRpb25cbiAgICAgICAgICAgICAgICAgID8gZ2V0VGhlbmFibGVTdGF0ZUFmdGVyU3VzcGVuZGluZygpXG4gICAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICAgIHJlcXVlc3QgPSBzcGF3bk5ld1N1c3BlbmRlZFJlbmRlclRhc2socmVxdWVzdCwgdGFzaywgbm9kZSkucGluZztcbiAgICAgICAgICAgICAgc2VnbWVudC50aGVuKHJlcXVlc3QsIHJlcXVlc3QpO1xuICAgICAgICAgICAgICB0YXNrLmZvcm1hdENvbnRleHQgPSBwcmV2aW91c0Zvcm1hdENvbnRleHQ7XG4gICAgICAgICAgICAgIHRhc2suY29udGV4dCA9IHByZXZpb3VzQ29udGV4dDtcbiAgICAgICAgICAgICAgdGFzay5rZXlQYXRoID0gcHJldmlvdXNLZXlQYXRoO1xuICAgICAgICAgICAgICB0YXNrLnRyZWVDb250ZXh0ID0gcHJldmlvdXNUcmVlQ29udGV4dDtcbiAgICAgICAgICAgICAgdGFzay5jb21wb25lbnRTdGFjayA9IHByZXZpb3VzQ29tcG9uZW50U3RhY2s7XG4gICAgICAgICAgICAgIHRhc2suZGVidWdUYXNrID0gcHJldmlvdXNEZWJ1Z1Rhc2s7XG4gICAgICAgICAgICAgIHN3aXRjaENvbnRleHQocHJldmlvdXNDb250ZXh0KTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFwiTWF4aW11bSBjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIiA9PT0gbm9kZS5tZXNzYWdlKSB7XG4gICAgICAgICAgICAgIHNlZ21lbnQgPVxuICAgICAgICAgICAgICAgIHRocm93blZhbHVlJDMgPT09IFN1c3BlbnNlRXhjZXB0aW9uXG4gICAgICAgICAgICAgICAgICA/IGdldFRoZW5hYmxlU3RhdGVBZnRlclN1c3BlbmRpbmcoKVxuICAgICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgICBzZWdtZW50ID0gc3Bhd25OZXdTdXNwZW5kZWRSZW5kZXJUYXNrKHJlcXVlc3QsIHRhc2ssIHNlZ21lbnQpO1xuICAgICAgICAgICAgICByZXF1ZXN0LnBpbmdlZFRhc2tzLnB1c2goc2VnbWVudCk7XG4gICAgICAgICAgICAgIHRhc2suZm9ybWF0Q29udGV4dCA9IHByZXZpb3VzRm9ybWF0Q29udGV4dDtcbiAgICAgICAgICAgICAgdGFzay5jb250ZXh0ID0gcHJldmlvdXNDb250ZXh0O1xuICAgICAgICAgICAgICB0YXNrLmtleVBhdGggPSBwcmV2aW91c0tleVBhdGg7XG4gICAgICAgICAgICAgIHRhc2sudHJlZUNvbnRleHQgPSBwcmV2aW91c1RyZWVDb250ZXh0O1xuICAgICAgICAgICAgICB0YXNrLmNvbXBvbmVudFN0YWNrID0gcHJldmlvdXNDb21wb25lbnRTdGFjaztcbiAgICAgICAgICAgICAgdGFzay5kZWJ1Z1Rhc2sgPSBwcmV2aW91c0RlYnVnVGFzaztcbiAgICAgICAgICAgICAgc3dpdGNoQ29udGV4dChwcmV2aW91c0NvbnRleHQpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0YXNrLmZvcm1hdENvbnRleHQgPSBwcmV2aW91c0Zvcm1hdENvbnRleHQ7XG4gICAgICB0YXNrLmNvbnRleHQgPSBwcmV2aW91c0NvbnRleHQ7XG4gICAgICB0YXNrLmtleVBhdGggPSBwcmV2aW91c0tleVBhdGg7XG4gICAgICB0YXNrLnRyZWVDb250ZXh0ID0gcHJldmlvdXNUcmVlQ29udGV4dDtcbiAgICAgIHN3aXRjaENvbnRleHQocHJldmlvdXNDb250ZXh0KTtcbiAgICAgIHRocm93IG5vZGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFib3J0VGFza1NvZnQodGFzaykge1xuICAgICAgdmFyIGJvdW5kYXJ5ID0gdGFzay5ibG9ja2VkQm91bmRhcnksXG4gICAgICAgIHNlZ21lbnQgPSB0YXNrLmJsb2NrZWRTZWdtZW50O1xuICAgICAgbnVsbCAhPT0gc2VnbWVudCAmJlxuICAgICAgICAoKHNlZ21lbnQuc3RhdHVzID0gQUJPUlRFRCksXG4gICAgICAgIGZpbmlzaGVkVGFzayh0aGlzLCBib3VuZGFyeSwgdGFzay5yb3csIHNlZ21lbnQpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWJvcnRSZW1haW5pbmdSZXBsYXlOb2RlcyhcbiAgICAgIHJlcXVlc3QkanNjb21wJDAsXG4gICAgICBib3VuZGFyeSxcbiAgICAgIG5vZGVzLFxuICAgICAgc2xvdHMsXG4gICAgICBlcnJvciRqc2NvbXAkMCxcbiAgICAgIGVycm9yRGlnZXN0JGpzY29tcCQwLFxuICAgICAgZXJyb3JJbmZvJGpzY29tcCQwLFxuICAgICAgYWJvcnRlZFxuICAgICkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBpZiAoNCA9PT0gbm9kZS5sZW5ndGgpXG4gICAgICAgICAgYWJvcnRSZW1haW5pbmdSZXBsYXlOb2RlcyhcbiAgICAgICAgICAgIHJlcXVlc3QkanNjb21wJDAsXG4gICAgICAgICAgICBib3VuZGFyeSxcbiAgICAgICAgICAgIG5vZGVbMl0sXG4gICAgICAgICAgICBub2RlWzNdLFxuICAgICAgICAgICAgZXJyb3IkanNjb21wJDAsXG4gICAgICAgICAgICBlcnJvckRpZ2VzdCRqc2NvbXAkMCxcbiAgICAgICAgICAgIGVycm9ySW5mbyRqc2NvbXAkMCxcbiAgICAgICAgICAgIGFib3J0ZWRcbiAgICAgICAgICApO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgcmVxdWVzdCA9IHJlcXVlc3QkanNjb21wJDA7XG4gICAgICAgICAgbm9kZSA9IG5vZGVbNV07XG4gICAgICAgICAgdmFyIGVycm9yID0gZXJyb3IkanNjb21wJDAsXG4gICAgICAgICAgICBlcnJvckRpZ2VzdCA9IGVycm9yRGlnZXN0JGpzY29tcCQwLFxuICAgICAgICAgICAgZXJyb3JJbmZvID0gZXJyb3JJbmZvJGpzY29tcCQwLFxuICAgICAgICAgICAgd2FzQWJvcnRlZCA9IGFib3J0ZWQsXG4gICAgICAgICAgICByZXN1bWVkQm91bmRhcnkgPSBjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5KFxuICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICBuZXcgU2V0KCksXG4gICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgcmVzdW1lZEJvdW5kYXJ5LnBhcmVudEZsdXNoZWQgPSAhMDtcbiAgICAgICAgICByZXN1bWVkQm91bmRhcnkucm9vdFNlZ21lbnRJRCA9IG5vZGU7XG4gICAgICAgICAgcmVzdW1lZEJvdW5kYXJ5LnN0YXR1cyA9IENMSUVOVF9SRU5ERVJFRDtcbiAgICAgICAgICBlbmNvZGVFcnJvckZvckJvdW5kYXJ5KFxuICAgICAgICAgICAgcmVzdW1lZEJvdW5kYXJ5LFxuICAgICAgICAgICAgZXJyb3JEaWdlc3QsXG4gICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgIGVycm9ySW5mbyxcbiAgICAgICAgICAgIHdhc0Fib3J0ZWRcbiAgICAgICAgICApO1xuICAgICAgICAgIHJlc3VtZWRCb3VuZGFyeS5wYXJlbnRGbHVzaGVkICYmXG4gICAgICAgICAgICByZXF1ZXN0LmNsaWVudFJlbmRlcmVkQm91bmRhcmllcy5wdXNoKHJlc3VtZWRCb3VuZGFyeSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5vZGVzLmxlbmd0aCA9IDA7XG4gICAgICBpZiAobnVsbCAhPT0gc2xvdHMpIHtcbiAgICAgICAgaWYgKG51bGwgPT09IGJvdW5kYXJ5KVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJXZSBzaG91bGQgbm90IGhhdmUgYW55IHJlc3VtYWJsZSBub2RlcyBpbiB0aGUgc2hlbGwuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICApO1xuICAgICAgICBib3VuZGFyeS5zdGF0dXMgIT09IENMSUVOVF9SRU5ERVJFRCAmJlxuICAgICAgICAgICgoYm91bmRhcnkuc3RhdHVzID0gQ0xJRU5UX1JFTkRFUkVEKSxcbiAgICAgICAgICBlbmNvZGVFcnJvckZvckJvdW5kYXJ5KFxuICAgICAgICAgICAgYm91bmRhcnksXG4gICAgICAgICAgICBlcnJvckRpZ2VzdCRqc2NvbXAkMCxcbiAgICAgICAgICAgIGVycm9yJGpzY29tcCQwLFxuICAgICAgICAgICAgZXJyb3JJbmZvJGpzY29tcCQwLFxuICAgICAgICAgICAgYWJvcnRlZFxuICAgICAgICAgICksXG4gICAgICAgICAgYm91bmRhcnkucGFyZW50Rmx1c2hlZCAmJlxuICAgICAgICAgICAgcmVxdWVzdCRqc2NvbXAkMC5jbGllbnRSZW5kZXJlZEJvdW5kYXJpZXMucHVzaChib3VuZGFyeSkpO1xuICAgICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHNsb3RzKVxuICAgICAgICAgIGZvciAodmFyIGluZGV4IGluIHNsb3RzKSBkZWxldGUgc2xvdHNbaW5kZXhdO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBhYm9ydFRhc2sodGFzaywgcmVxdWVzdCwgZXJyb3IpIHtcbiAgICAgIHZhciBib3VuZGFyeSA9IHRhc2suYmxvY2tlZEJvdW5kYXJ5LFxuICAgICAgICBzZWdtZW50ID0gdGFzay5ibG9ja2VkU2VnbWVudDtcbiAgICAgIGlmIChudWxsICE9PSBzZWdtZW50KSB7XG4gICAgICAgIGlmICg2ID09PSBzZWdtZW50LnN0YXR1cykgcmV0dXJuO1xuICAgICAgICBzZWdtZW50LnN0YXR1cyA9IEFCT1JURUQ7XG4gICAgICB9XG4gICAgICB2YXIgZXJyb3JJbmZvID0gZ2V0VGhyb3duSW5mbyh0YXNrLmNvbXBvbmVudFN0YWNrKSxcbiAgICAgICAgbm9kZSA9IHRhc2subm9kZTtcbiAgICAgIG51bGwgIT09IG5vZGUgJiZcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIG5vZGUgJiZcbiAgICAgICAgcHVzaEhhbHRlZEF3YWl0T25Db21wb25lbnRTdGFjayh0YXNrLCBub2RlLl9kZWJ1Z0luZm8pO1xuICAgICAgaWYgKG51bGwgPT09IGJvdW5kYXJ5KSB7XG4gICAgICAgIGlmICgxMyAhPT0gcmVxdWVzdC5zdGF0dXMgJiYgcmVxdWVzdC5zdGF0dXMgIT09IENMT1NFRCkge1xuICAgICAgICAgIGJvdW5kYXJ5ID0gdGFzay5yZXBsYXk7XG4gICAgICAgICAgaWYgKG51bGwgPT09IGJvdW5kYXJ5KSB7XG4gICAgICAgICAgICBudWxsICE9PSByZXF1ZXN0LnRyYWNrZWRQb3N0cG9uZXMgJiYgbnVsbCAhPT0gc2VnbWVudFxuICAgICAgICAgICAgICA/ICgoYm91bmRhcnkgPSByZXF1ZXN0LnRyYWNrZWRQb3N0cG9uZXMpLFxuICAgICAgICAgICAgICAgIGxvZ1JlY292ZXJhYmxlRXJyb3IocmVxdWVzdCwgZXJyb3IsIGVycm9ySW5mbywgdGFzay5kZWJ1Z1Rhc2spLFxuICAgICAgICAgICAgICAgIHRyYWNrUG9zdHBvbmUocmVxdWVzdCwgYm91bmRhcnksIHRhc2ssIHNlZ21lbnQpLFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkVGFzayhyZXF1ZXN0LCBudWxsLCB0YXNrLnJvdywgc2VnbWVudCkpXG4gICAgICAgICAgICAgIDogKGxvZ1JlY292ZXJhYmxlRXJyb3IocmVxdWVzdCwgZXJyb3IsIGVycm9ySW5mbywgdGFzay5kZWJ1Z1Rhc2spLFxuICAgICAgICAgICAgICAgIGZhdGFsRXJyb3IocmVxdWVzdCwgZXJyb3IsIGVycm9ySW5mbywgdGFzay5kZWJ1Z1Rhc2spKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYm91bmRhcnkucGVuZGluZ1Rhc2tzLS07XG4gICAgICAgICAgMCA9PT0gYm91bmRhcnkucGVuZGluZ1Rhc2tzICYmXG4gICAgICAgICAgICAwIDwgYm91bmRhcnkubm9kZXMubGVuZ3RoICYmXG4gICAgICAgICAgICAoKHNlZ21lbnQgPSBsb2dSZWNvdmVyYWJsZUVycm9yKHJlcXVlc3QsIGVycm9yLCBlcnJvckluZm8sIG51bGwpKSxcbiAgICAgICAgICAgIGFib3J0UmVtYWluaW5nUmVwbGF5Tm9kZXMoXG4gICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgIGJvdW5kYXJ5Lm5vZGVzLFxuICAgICAgICAgICAgICBib3VuZGFyeS5zbG90cyxcbiAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgIHNlZ21lbnQsXG4gICAgICAgICAgICAgIGVycm9ySW5mbyxcbiAgICAgICAgICAgICAgITBcbiAgICAgICAgICAgICkpO1xuICAgICAgICAgIHJlcXVlc3QucGVuZGluZ1Jvb3RUYXNrcy0tO1xuICAgICAgICAgIDAgPT09IHJlcXVlc3QucGVuZGluZ1Jvb3RUYXNrcyAmJiBjb21wbGV0ZVNoZWxsKHJlcXVlc3QpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlID0gcmVxdWVzdC50cmFja2VkUG9zdHBvbmVzO1xuICAgICAgICBpZiAoYm91bmRhcnkuc3RhdHVzICE9PSBDTElFTlRfUkVOREVSRUQpIHtcbiAgICAgICAgICBpZiAobnVsbCAhPT0gbm9kZSAmJiBudWxsICE9PSBzZWdtZW50KVxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgbG9nUmVjb3ZlcmFibGVFcnJvcihyZXF1ZXN0LCBlcnJvciwgZXJyb3JJbmZvLCB0YXNrLmRlYnVnVGFzayksXG4gICAgICAgICAgICAgIHRyYWNrUG9zdHBvbmUocmVxdWVzdCwgbm9kZSwgdGFzaywgc2VnbWVudCksXG4gICAgICAgICAgICAgIGJvdW5kYXJ5LmZhbGxiYWNrQWJvcnRhYmxlVGFza3MuZm9yRWFjaChmdW5jdGlvbiAoZmFsbGJhY2tUYXNrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFib3J0VGFzayhmYWxsYmFja1Rhc2ssIHJlcXVlc3QsIGVycm9yKTtcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIGJvdW5kYXJ5LmZhbGxiYWNrQWJvcnRhYmxlVGFza3MuY2xlYXIoKSxcbiAgICAgICAgICAgICAgZmluaXNoZWRUYXNrKHJlcXVlc3QsIGJvdW5kYXJ5LCB0YXNrLnJvdywgc2VnbWVudClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgYm91bmRhcnkuc3RhdHVzID0gQ0xJRU5UX1JFTkRFUkVEO1xuICAgICAgICAgIHNlZ21lbnQgPSBsb2dSZWNvdmVyYWJsZUVycm9yKFxuICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgZXJyb3JJbmZvLFxuICAgICAgICAgICAgdGFzay5kZWJ1Z1Rhc2tcbiAgICAgICAgICApO1xuICAgICAgICAgIGJvdW5kYXJ5LnN0YXR1cyA9IENMSUVOVF9SRU5ERVJFRDtcbiAgICAgICAgICBlbmNvZGVFcnJvckZvckJvdW5kYXJ5KGJvdW5kYXJ5LCBzZWdtZW50LCBlcnJvciwgZXJyb3JJbmZvLCAhMCk7XG4gICAgICAgICAgdW50cmFja0JvdW5kYXJ5KHJlcXVlc3QsIGJvdW5kYXJ5KTtcbiAgICAgICAgICBib3VuZGFyeS5wYXJlbnRGbHVzaGVkICYmXG4gICAgICAgICAgICByZXF1ZXN0LmNsaWVudFJlbmRlcmVkQm91bmRhcmllcy5wdXNoKGJvdW5kYXJ5KTtcbiAgICAgICAgfVxuICAgICAgICBib3VuZGFyeS5wZW5kaW5nVGFza3MtLTtcbiAgICAgICAgZXJyb3JJbmZvID0gYm91bmRhcnkucm93O1xuICAgICAgICBudWxsICE9PSBlcnJvckluZm8gJiZcbiAgICAgICAgICAwID09PSAtLWVycm9ySW5mby5wZW5kaW5nVGFza3MgJiZcbiAgICAgICAgICBmaW5pc2hTdXNwZW5zZUxpc3RSb3cocmVxdWVzdCwgZXJyb3JJbmZvKTtcbiAgICAgICAgYm91bmRhcnkuZmFsbGJhY2tBYm9ydGFibGVUYXNrcy5mb3JFYWNoKGZ1bmN0aW9uIChmYWxsYmFja1Rhc2spIHtcbiAgICAgICAgICByZXR1cm4gYWJvcnRUYXNrKGZhbGxiYWNrVGFzaywgcmVxdWVzdCwgZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICAgICAgYm91bmRhcnkuZmFsbGJhY2tBYm9ydGFibGVUYXNrcy5jbGVhcigpO1xuICAgICAgfVxuICAgICAgdGFzayA9IHRhc2sucm93O1xuICAgICAgbnVsbCAhPT0gdGFzayAmJlxuICAgICAgICAwID09PSAtLXRhc2sucGVuZGluZ1Rhc2tzICYmXG4gICAgICAgIGZpbmlzaFN1c3BlbnNlTGlzdFJvdyhyZXF1ZXN0LCB0YXNrKTtcbiAgICAgIHJlcXVlc3QuYWxsUGVuZGluZ1Rhc2tzLS07XG4gICAgICAwID09PSByZXF1ZXN0LmFsbFBlbmRpbmdUYXNrcyAmJiBjb21wbGV0ZUFsbChyZXF1ZXN0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2FmZWx5RW1pdEVhcmx5UHJlbG9hZHMocmVxdWVzdCwgc2hlbGxDb21wbGV0ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHJlbmRlclN0YXRlID0gcmVxdWVzdC5yZW5kZXJTdGF0ZSxcbiAgICAgICAgICBvbkhlYWRlcnMgPSByZW5kZXJTdGF0ZS5vbkhlYWRlcnM7XG4gICAgICAgIGlmIChvbkhlYWRlcnMpIHtcbiAgICAgICAgICB2YXIgaGVhZGVycyA9IHJlbmRlclN0YXRlLmhlYWRlcnM7XG4gICAgICAgICAgaWYgKGhlYWRlcnMpIHtcbiAgICAgICAgICAgIHJlbmRlclN0YXRlLmhlYWRlcnMgPSBudWxsO1xuICAgICAgICAgICAgdmFyIGxpbmtIZWFkZXIgPSBoZWFkZXJzLnByZWNvbm5lY3RzO1xuICAgICAgICAgICAgaGVhZGVycy5mb250UHJlbG9hZHMgJiZcbiAgICAgICAgICAgICAgKGxpbmtIZWFkZXIgJiYgKGxpbmtIZWFkZXIgKz0gXCIsIFwiKSxcbiAgICAgICAgICAgICAgKGxpbmtIZWFkZXIgKz0gaGVhZGVycy5mb250UHJlbG9hZHMpKTtcbiAgICAgICAgICAgIGhlYWRlcnMuaGlnaEltYWdlUHJlbG9hZHMgJiZcbiAgICAgICAgICAgICAgKGxpbmtIZWFkZXIgJiYgKGxpbmtIZWFkZXIgKz0gXCIsIFwiKSxcbiAgICAgICAgICAgICAgKGxpbmtIZWFkZXIgKz0gaGVhZGVycy5oaWdoSW1hZ2VQcmVsb2FkcykpO1xuICAgICAgICAgICAgaWYgKCFzaGVsbENvbXBsZXRlKSB7XG4gICAgICAgICAgICAgIHZhciBxdWV1ZUl0ZXIgPSByZW5kZXJTdGF0ZS5zdHlsZXMudmFsdWVzKCksXG4gICAgICAgICAgICAgICAgcXVldWVTdGVwID0gcXVldWVJdGVyLm5leHQoKTtcbiAgICAgICAgICAgICAgYjogZm9yIChcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgMCA8IGhlYWRlcnMucmVtYWluaW5nQ2FwYWNpdHkgJiYgIXF1ZXVlU3RlcC5kb25lO1xuICAgICAgICAgICAgICAgIHF1ZXVlU3RlcCA9IHF1ZXVlSXRlci5uZXh0KClcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgICB2YXIgc2hlZXRJdGVyID0gcXVldWVTdGVwLnZhbHVlLnNoZWV0cy52YWx1ZXMoKSxcbiAgICAgICAgICAgICAgICAgICAgc2hlZXRTdGVwID0gc2hlZXRJdGVyLm5leHQoKTtcbiAgICAgICAgICAgICAgICAgIDAgPCBoZWFkZXJzLnJlbWFpbmluZ0NhcGFjaXR5ICYmICFzaGVldFN0ZXAuZG9uZTtcbiAgICAgICAgICAgICAgICAgIHNoZWV0U3RlcCA9IHNoZWV0SXRlci5uZXh0KClcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIHZhciBzaGVldCA9IHNoZWV0U3RlcC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMgPSBzaGVldC5wcm9wcyxcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gcHJvcHMuaHJlZixcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMkanNjb21wJDAgPSBzaGVldC5wcm9wcztcbiAgICAgICAgICAgICAgICAgIHZhciBoZWFkZXIgPSBnZXRQcmVsb2FkQXNIZWFkZXIoXG4gICAgICAgICAgICAgICAgICAgIHByb3BzJGpzY29tcCQwLmhyZWYsXG4gICAgICAgICAgICAgICAgICAgIFwic3R5bGVcIixcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgIGNyb3NzT3JpZ2luOiBwcm9wcyRqc2NvbXAkMC5jcm9zc09yaWdpbixcbiAgICAgICAgICAgICAgICAgICAgICBpbnRlZ3JpdHk6IHByb3BzJGpzY29tcCQwLmludGVncml0eSxcbiAgICAgICAgICAgICAgICAgICAgICBub25jZTogcHJvcHMkanNjb21wJDAubm9uY2UsXG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogcHJvcHMkanNjb21wJDAudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICBmZXRjaFByaW9yaXR5OiBwcm9wcyRqc2NvbXAkMC5mZXRjaFByaW9yaXR5LFxuICAgICAgICAgICAgICAgICAgICAgIHJlZmVycmVyUG9saWN5OiBwcm9wcyRqc2NvbXAkMC5yZWZlcnJlclBvbGljeSxcbiAgICAgICAgICAgICAgICAgICAgICBtZWRpYTogcHJvcHMkanNjb21wJDAubWVkaWFcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGlmICgwIDw9IChoZWFkZXJzLnJlbWFpbmluZ0NhcGFjaXR5IC09IGhlYWRlci5sZW5ndGggKyAyKSlcbiAgICAgICAgICAgICAgICAgICAgKHJlbmRlclN0YXRlLnJlc2V0cy5zdHlsZVtrZXldID0gUFJFTE9BRF9OT19DUkVEUyksXG4gICAgICAgICAgICAgICAgICAgICAgbGlua0hlYWRlciAmJiAobGlua0hlYWRlciArPSBcIiwgXCIpLFxuICAgICAgICAgICAgICAgICAgICAgIChsaW5rSGVhZGVyICs9IGhlYWRlciksXG4gICAgICAgICAgICAgICAgICAgICAgKHJlbmRlclN0YXRlLnJlc2V0cy5zdHlsZVtrZXldID1cbiAgICAgICAgICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBwcm9wcy5jcm9zc09yaWdpbiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHByb3BzLmludGVncml0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICA/IFtwcm9wcy5jcm9zc09yaWdpbiwgcHJvcHMuaW50ZWdyaXR5XVxuICAgICAgICAgICAgICAgICAgICAgICAgICA6IFBSRUxPQURfTk9fQ1JFRFMpO1xuICAgICAgICAgICAgICAgICAgZWxzZSBicmVhayBiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpbmtIZWFkZXIgPyBvbkhlYWRlcnMoeyBMaW5rOiBsaW5rSGVhZGVyIH0pIDogb25IZWFkZXJzKHt9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ1JlY292ZXJhYmxlRXJyb3IocmVxdWVzdCwgZXJyb3IsIHt9LCBudWxsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcGxldGVTaGVsbChyZXF1ZXN0KSB7XG4gICAgICBudWxsID09PSByZXF1ZXN0LnRyYWNrZWRQb3N0cG9uZXMgJiYgc2FmZWx5RW1pdEVhcmx5UHJlbG9hZHMocmVxdWVzdCwgITApO1xuICAgICAgbnVsbCA9PT0gcmVxdWVzdC50cmFja2VkUG9zdHBvbmVzICYmIHByZXBhcmVQcmVhbWJsZShyZXF1ZXN0KTtcbiAgICAgIHJlcXVlc3Qub25TaGVsbEVycm9yID0gbm9vcDtcbiAgICAgIHJlcXVlc3QgPSByZXF1ZXN0Lm9uU2hlbGxSZWFkeTtcbiAgICAgIHJlcXVlc3QoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcGxldGVBbGwocmVxdWVzdCkge1xuICAgICAgc2FmZWx5RW1pdEVhcmx5UHJlbG9hZHMoXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIG51bGwgPT09IHJlcXVlc3QudHJhY2tlZFBvc3Rwb25lc1xuICAgICAgICAgID8gITBcbiAgICAgICAgICA6IG51bGwgPT09IHJlcXVlc3QuY29tcGxldGVkUm9vdFNlZ21lbnQgfHxcbiAgICAgICAgICAgICAgcmVxdWVzdC5jb21wbGV0ZWRSb290U2VnbWVudC5zdGF0dXMgIT09IFBPU1RQT05FRFxuICAgICAgKTtcbiAgICAgIHByZXBhcmVQcmVhbWJsZShyZXF1ZXN0KTtcbiAgICAgIHJlcXVlc3QgPSByZXF1ZXN0Lm9uQWxsUmVhZHk7XG4gICAgICByZXF1ZXN0KCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHF1ZXVlQ29tcGxldGVkU2VnbWVudChib3VuZGFyeSwgc2VnbWVudCkge1xuICAgICAgaWYgKFxuICAgICAgICAwID09PSBzZWdtZW50LmNodW5rcy5sZW5ndGggJiZcbiAgICAgICAgMSA9PT0gc2VnbWVudC5jaGlsZHJlbi5sZW5ndGggJiZcbiAgICAgICAgbnVsbCA9PT0gc2VnbWVudC5jaGlsZHJlblswXS5ib3VuZGFyeSAmJlxuICAgICAgICAtMSA9PT0gc2VnbWVudC5jaGlsZHJlblswXS5pZFxuICAgICAgKSB7XG4gICAgICAgIHZhciBjaGlsZFNlZ21lbnQgPSBzZWdtZW50LmNoaWxkcmVuWzBdO1xuICAgICAgICBjaGlsZFNlZ21lbnQuaWQgPSBzZWdtZW50LmlkO1xuICAgICAgICBjaGlsZFNlZ21lbnQucGFyZW50Rmx1c2hlZCA9ICEwO1xuICAgICAgICAoY2hpbGRTZWdtZW50LnN0YXR1cyAhPT0gQ09NUExFVEVEICYmXG4gICAgICAgICAgY2hpbGRTZWdtZW50LnN0YXR1cyAhPT0gQUJPUlRFRCAmJlxuICAgICAgICAgIGNoaWxkU2VnbWVudC5zdGF0dXMgIT09IEVSUk9SRUQpIHx8XG4gICAgICAgICAgcXVldWVDb21wbGV0ZWRTZWdtZW50KGJvdW5kYXJ5LCBjaGlsZFNlZ21lbnQpO1xuICAgICAgfSBlbHNlIGJvdW5kYXJ5LmNvbXBsZXRlZFNlZ21lbnRzLnB1c2goc2VnbWVudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmlzaGVkU2VnbWVudChyZXF1ZXN0LCBib3VuZGFyeSwgc2VnbWVudCkge1xuICAgICAgaWYgKG51bGwgIT09IGJ5dGVMZW5ndGhPZkNodW5rKSB7XG4gICAgICAgIHNlZ21lbnQgPSBzZWdtZW50LmNodW5rcztcbiAgICAgICAgZm9yICh2YXIgc2VnbWVudEJ5dGVTaXplID0gMCwgaSA9IDA7IGkgPCBzZWdtZW50Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgIHNlZ21lbnRCeXRlU2l6ZSArPSBzZWdtZW50W2ldLmJ5dGVMZW5ndGg7XG4gICAgICAgIG51bGwgPT09IGJvdW5kYXJ5XG4gICAgICAgICAgPyAocmVxdWVzdC5ieXRlU2l6ZSArPSBzZWdtZW50Qnl0ZVNpemUpXG4gICAgICAgICAgOiAoYm91bmRhcnkuYnl0ZVNpemUgKz0gc2VnbWVudEJ5dGVTaXplKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZmluaXNoZWRUYXNrKHJlcXVlc3QsIGJvdW5kYXJ5LCByb3csIHNlZ21lbnQpIHtcbiAgICAgIG51bGwgIT09IHJvdyAmJlxuICAgICAgICAoMCA9PT0gLS1yb3cucGVuZGluZ1Rhc2tzXG4gICAgICAgICAgPyBmaW5pc2hTdXNwZW5zZUxpc3RSb3cocmVxdWVzdCwgcm93KVxuICAgICAgICAgIDogcm93LnRvZ2V0aGVyICYmIHRyeVRvUmVzb2x2ZVRvZ2V0aGVyUm93KHJlcXVlc3QsIHJvdykpO1xuICAgICAgcmVxdWVzdC5hbGxQZW5kaW5nVGFza3MtLTtcbiAgICAgIGlmIChudWxsID09PSBib3VuZGFyeSkge1xuICAgICAgICBpZiAobnVsbCAhPT0gc2VnbWVudCAmJiBzZWdtZW50LnBhcmVudEZsdXNoZWQpIHtcbiAgICAgICAgICBpZiAobnVsbCAhPT0gcmVxdWVzdC5jb21wbGV0ZWRSb290U2VnbWVudClcbiAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICBcIlRoZXJlIGNhbiBvbmx5IGJlIG9uZSByb290IHNlZ21lbnQuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgcmVxdWVzdC5jb21wbGV0ZWRSb290U2VnbWVudCA9IHNlZ21lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdC5wZW5kaW5nUm9vdFRhc2tzLS07XG4gICAgICAgIDAgPT09IHJlcXVlc3QucGVuZGluZ1Jvb3RUYXNrcyAmJiBjb21wbGV0ZVNoZWxsKHJlcXVlc3QpO1xuICAgICAgfSBlbHNlIGlmICgoYm91bmRhcnkucGVuZGluZ1Rhc2tzLS0sIGJvdW5kYXJ5LnN0YXR1cyAhPT0gQ0xJRU5UX1JFTkRFUkVEKSlcbiAgICAgICAgaWYgKDAgPT09IGJvdW5kYXJ5LnBlbmRpbmdUYXNrcylcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAoYm91bmRhcnkuc3RhdHVzID09PSBQRU5ESU5HICYmIChib3VuZGFyeS5zdGF0dXMgPSBDT01QTEVURUQpLFxuICAgICAgICAgICAgbnVsbCAhPT0gc2VnbWVudCAmJlxuICAgICAgICAgICAgICBzZWdtZW50LnBhcmVudEZsdXNoZWQgJiZcbiAgICAgICAgICAgICAgKHNlZ21lbnQuc3RhdHVzID09PSBDT01QTEVURUQgfHwgc2VnbWVudC5zdGF0dXMgPT09IEFCT1JURUQpICYmXG4gICAgICAgICAgICAgIHF1ZXVlQ29tcGxldGVkU2VnbWVudChib3VuZGFyeSwgc2VnbWVudCksXG4gICAgICAgICAgICBib3VuZGFyeS5wYXJlbnRGbHVzaGVkICYmXG4gICAgICAgICAgICAgIHJlcXVlc3QuY29tcGxldGVkQm91bmRhcmllcy5wdXNoKGJvdW5kYXJ5KSxcbiAgICAgICAgICAgIGJvdW5kYXJ5LnN0YXR1cyA9PT0gQ09NUExFVEVEKVxuICAgICAgICAgIClcbiAgICAgICAgICAgIChyb3cgPSBib3VuZGFyeS5yb3cpLFxuICAgICAgICAgICAgICBudWxsICE9PSByb3cgJiZcbiAgICAgICAgICAgICAgICBob2lzdEhvaXN0YWJsZXMocm93LmhvaXN0YWJsZXMsIGJvdW5kYXJ5LmNvbnRlbnRTdGF0ZSksXG4gICAgICAgICAgICAgIGlzRWxpZ2libGVGb3JPdXRsaW5pbmcocmVxdWVzdCwgYm91bmRhcnkpIHx8XG4gICAgICAgICAgICAgICAgKGJvdW5kYXJ5LmZhbGxiYWNrQWJvcnRhYmxlVGFza3MuZm9yRWFjaChcbiAgICAgICAgICAgICAgICAgIGFib3J0VGFza1NvZnQsXG4gICAgICAgICAgICAgICAgICByZXF1ZXN0XG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBib3VuZGFyeS5mYWxsYmFja0Fib3J0YWJsZVRhc2tzLmNsZWFyKCksXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gcm93ICYmXG4gICAgICAgICAgICAgICAgICAwID09PSAtLXJvdy5wZW5kaW5nVGFza3MgJiZcbiAgICAgICAgICAgICAgICAgIGZpbmlzaFN1c3BlbnNlTGlzdFJvdyhyZXF1ZXN0LCByb3cpKSxcbiAgICAgICAgICAgICAgMCA9PT0gcmVxdWVzdC5wZW5kaW5nUm9vdFRhc2tzICYmXG4gICAgICAgICAgICAgICAgbnVsbCA9PT0gcmVxdWVzdC50cmFja2VkUG9zdHBvbmVzICYmXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gYm91bmRhcnkuY29udGVudFByZWFtYmxlICYmXG4gICAgICAgICAgICAgICAgcHJlcGFyZVByZWFtYmxlKHJlcXVlc3QpO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBib3VuZGFyeS5zdGF0dXMgPT09IFBPU1RQT05FRCAmJlxuICAgICAgICAgICAgICAoKGJvdW5kYXJ5ID0gYm91bmRhcnkucm93KSwgbnVsbCAhPT0gYm91bmRhcnkpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgaWYgKG51bGwgIT09IHJlcXVlc3QudHJhY2tlZFBvc3Rwb25lcykge1xuICAgICAgICAgICAgICAgIHJvdyA9IHJlcXVlc3QudHJhY2tlZFBvc3Rwb25lcztcbiAgICAgICAgICAgICAgICB2YXIgcG9zdHBvbmVkUm93ID0gYm91bmRhcnkubmV4dDtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICBudWxsICE9PSBwb3N0cG9uZWRSb3cgJiZcbiAgICAgICAgICAgICAgICAgICgoc2VnbWVudCA9IHBvc3Rwb25lZFJvdy5ib3VuZGFyaWVzKSwgbnVsbCAhPT0gc2VnbWVudClcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgICAgICBwb3N0cG9uZWRSb3cuYm91bmRhcmllcyA9IG51bGwsIHBvc3Rwb25lZFJvdyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHBvc3Rwb25lZFJvdyA8IHNlZ21lbnQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBwb3N0cG9uZWRSb3crK1xuICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3N0cG9uZWRCb3VuZGFyeSA9IHNlZ21lbnRbcG9zdHBvbmVkUm93XTtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2tQb3N0cG9uZWRCb3VuZGFyeShyZXF1ZXN0LCByb3csIHBvc3Rwb25lZEJvdW5kYXJ5KTtcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRUYXNrKHJlcXVlc3QsIHBvc3Rwb25lZEJvdW5kYXJ5LCBudWxsLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAwID09PSAtLWJvdW5kYXJ5LnBlbmRpbmdUYXNrcyAmJlxuICAgICAgICAgICAgICAgIGZpbmlzaFN1c3BlbnNlTGlzdFJvdyhyZXF1ZXN0LCBib3VuZGFyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgbnVsbCA9PT0gc2VnbWVudCB8fFxuICAgICAgICAgICAgIXNlZ21lbnQucGFyZW50Rmx1c2hlZCB8fFxuICAgICAgICAgICAgKHNlZ21lbnQuc3RhdHVzICE9PSBDT01QTEVURUQgJiYgc2VnbWVudC5zdGF0dXMgIT09IEFCT1JURUQpIHx8XG4gICAgICAgICAgICAocXVldWVDb21wbGV0ZWRTZWdtZW50KGJvdW5kYXJ5LCBzZWdtZW50KSxcbiAgICAgICAgICAgIDEgPT09IGJvdW5kYXJ5LmNvbXBsZXRlZFNlZ21lbnRzLmxlbmd0aCAmJlxuICAgICAgICAgICAgICBib3VuZGFyeS5wYXJlbnRGbHVzaGVkICYmXG4gICAgICAgICAgICAgIHJlcXVlc3QucGFydGlhbEJvdW5kYXJpZXMucHVzaChib3VuZGFyeSkpLFxuICAgICAgICAgICAgKGJvdW5kYXJ5ID0gYm91bmRhcnkucm93KSxcbiAgICAgICAgICAgIG51bGwgIT09IGJvdW5kYXJ5ICYmXG4gICAgICAgICAgICAgIGJvdW5kYXJ5LnRvZ2V0aGVyICYmXG4gICAgICAgICAgICAgIHRyeVRvUmVzb2x2ZVRvZ2V0aGVyUm93KHJlcXVlc3QsIGJvdW5kYXJ5KTtcbiAgICAgIDAgPT09IHJlcXVlc3QuYWxsUGVuZGluZ1Rhc2tzICYmIGNvbXBsZXRlQWxsKHJlcXVlc3QpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwZXJmb3JtV29yayhyZXF1ZXN0JGpzY29tcCQyKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHJlcXVlc3QkanNjb21wJDIuc3RhdHVzICE9PSBDTE9TRUQgJiZcbiAgICAgICAgMTMgIT09IHJlcXVlc3QkanNjb21wJDIuc3RhdHVzXG4gICAgICApIHtcbiAgICAgICAgdmFyIHByZXZDb250ZXh0ID0gY3VycmVudEFjdGl2ZVNuYXBzaG90LFxuICAgICAgICAgIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEhvb2tzRGlzcGF0Y2hlcjtcbiAgICAgICAgdmFyIHByZXZBc3luY0Rpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5BO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5BID0gRGVmYXVsdEFzeW5jRGlzcGF0Y2hlcjtcbiAgICAgICAgdmFyIHByZXZSZXF1ZXN0ID0gY3VycmVudFJlcXVlc3Q7XG4gICAgICAgIGN1cnJlbnRSZXF1ZXN0ID0gcmVxdWVzdCRqc2NvbXAkMjtcbiAgICAgICAgdmFyIHByZXZHZXRDdXJyZW50U3RhY2tJbXBsID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuZ2V0Q3VycmVudFN0YWNrO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5nZXRDdXJyZW50U3RhY2sgPSBnZXRDdXJyZW50U3RhY2tJbkRFVjtcbiAgICAgICAgdmFyIHByZXZSZXN1bWFibGVTdGF0ZSA9IGN1cnJlbnRSZXN1bWFibGVTdGF0ZTtcbiAgICAgICAgY3VycmVudFJlc3VtYWJsZVN0YXRlID0gcmVxdWVzdCRqc2NvbXAkMi5yZXN1bWFibGVTdGF0ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgcGluZ2VkVGFza3MgPSByZXF1ZXN0JGpzY29tcCQyLnBpbmdlZFRhc2tzLFxuICAgICAgICAgICAgaTtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGluZ2VkVGFza3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciByZXF1ZXN0ID0gcmVxdWVzdCRqc2NvbXAkMixcbiAgICAgICAgICAgICAgdGFzayA9IHBpbmdlZFRhc2tzW2ldLFxuICAgICAgICAgICAgICBzZWdtZW50ID0gdGFzay5ibG9ja2VkU2VnbWVudDtcbiAgICAgICAgICAgIGlmIChudWxsID09PSBzZWdtZW50KSB7XG4gICAgICAgICAgICAgIHZhciBwcmV2VGFza0luREVWID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgIHJlcXVlc3QkanNjb21wJDAgPSByZXF1ZXN0O1xuICAgICAgICAgICAgICByZXF1ZXN0ID0gdGFzaztcbiAgICAgICAgICAgICAgaWYgKDAgIT09IHJlcXVlc3QucmVwbGF5LnBlbmRpbmdUYXNrcykge1xuICAgICAgICAgICAgICAgIHN3aXRjaENvbnRleHQocmVxdWVzdC5jb250ZXh0KTtcbiAgICAgICAgICAgICAgICBwcmV2VGFza0luREVWID0gY3VycmVudFRhc2tJbkRFVjtcbiAgICAgICAgICAgICAgICBjdXJyZW50VGFza0luREVWID0gcmVxdWVzdDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIHJlcXVlc3QucmVwbGF5LnNsb3RzXG4gICAgICAgICAgICAgICAgICAgID8gcmVzdW1lTm9kZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5yZXBsYXkuc2xvdHMsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0Lm5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmNoaWxkSW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIDogcmV0cnlOb2RlKHJlcXVlc3QkanNjb21wJDAsIHJlcXVlc3QpO1xuICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAxID09PSByZXF1ZXN0LnJlcGxheS5wZW5kaW5nVGFza3MgJiZcbiAgICAgICAgICAgICAgICAgICAgMCA8IHJlcXVlc3QucmVwbGF5Lm5vZGVzLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICBcIkNvdWxkbid0IGZpbmQgYWxsIHJlc3VtYWJsZSBzbG90cyBieSBrZXkvaW5kZXggZHVyaW5nIHJlcGxheWluZy4gVGhlIHRyZWUgZG9lc24ndCBtYXRjaCBzbyBSZWFjdCB3aWxsIGZhbGxiYWNrIHRvIGNsaWVudCByZW5kZXJpbmcuXCJcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIHJlcXVlc3QucmVwbGF5LnBlbmRpbmdUYXNrcy0tO1xuICAgICAgICAgICAgICAgICAgcmVxdWVzdC5hYm9ydFNldC5kZWxldGUocmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFRhc2soXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QuYmxvY2tlZEJvdW5kYXJ5LFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LnJvdyxcbiAgICAgICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoICh0aHJvd25WYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgcmVzZXRIb29rc1N0YXRlKCk7XG4gICAgICAgICAgICAgICAgICB2YXIgeCA9XG4gICAgICAgICAgICAgICAgICAgIHRocm93blZhbHVlID09PSBTdXNwZW5zZUV4Y2VwdGlvblxuICAgICAgICAgICAgICAgICAgICAgID8gZ2V0U3VzcGVuZGVkVGhlbmFibGUoKVxuICAgICAgICAgICAgICAgICAgICAgIDogdGhyb3duVmFsdWU7XG4gICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiB4ICYmXG4gICAgICAgICAgICAgICAgICAgIG51bGwgIT09IHggJiZcbiAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgeC50aGVuXG4gICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBpbmcgPSByZXF1ZXN0LnBpbmc7XG4gICAgICAgICAgICAgICAgICAgIHgudGhlbihwaW5nLCBwaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC50aGVuYWJsZVN0YXRlID1cbiAgICAgICAgICAgICAgICAgICAgICB0aHJvd25WYWx1ZSA9PT0gU3VzcGVuc2VFeGNlcHRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgID8gZ2V0VGhlbmFibGVTdGF0ZUFmdGVyU3VzcGVuZGluZygpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LnJlcGxheS5wZW5kaW5nVGFza3MtLTtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5hYm9ydFNldC5kZWxldGUocmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvckluZm8gPSBnZXRUaHJvd25JbmZvKHJlcXVlc3QuY29tcG9uZW50U3RhY2spLFxuICAgICAgICAgICAgICAgICAgICAgIGVycm9yRGlnZXN0ID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QkanNjb21wJDEgPSByZXF1ZXN0JGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICAgIGJvdW5kYXJ5ID0gcmVxdWVzdC5ibG9ja2VkQm91bmRhcnksXG4gICAgICAgICAgICAgICAgICAgICAgZXJyb3IkanNjb21wJDAgPVxuICAgICAgICAgICAgICAgICAgICAgICAgMTIgPT09IHJlcXVlc3QkanNjb21wJDAuc3RhdHVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgID8gcmVxdWVzdCRqc2NvbXAkMC5mYXRhbEVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogeCxcbiAgICAgICAgICAgICAgICAgICAgICBlcnJvckluZm8kanNjb21wJDAgPSBlcnJvckluZm8sXG4gICAgICAgICAgICAgICAgICAgICAgcmVwbGF5Tm9kZXMgPSByZXF1ZXN0LnJlcGxheS5ub2RlcyxcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bWVTbG90cyA9IHJlcXVlc3QucmVwbGF5LnNsb3RzO1xuICAgICAgICAgICAgICAgICAgICBlcnJvckRpZ2VzdCA9IGxvZ1JlY292ZXJhYmxlRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCRqc2NvbXAkMSxcbiAgICAgICAgICAgICAgICAgICAgICBlcnJvciRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgICBlcnJvckluZm8kanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5kZWJ1Z1Rhc2tcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgYWJvcnRSZW1haW5pbmdSZXBsYXlOb2RlcyhcbiAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0JGpzY29tcCQxLFxuICAgICAgICAgICAgICAgICAgICAgIGJvdW5kYXJ5LFxuICAgICAgICAgICAgICAgICAgICAgIHJlcGxheU5vZGVzLFxuICAgICAgICAgICAgICAgICAgICAgIHJlc3VtZVNsb3RzLFxuICAgICAgICAgICAgICAgICAgICAgIGVycm9yJGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICAgIGVycm9yRGlnZXN0LFxuICAgICAgICAgICAgICAgICAgICAgIGVycm9ySW5mbyRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgICAhMVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0JGpzY29tcCQwLnBlbmRpbmdSb290VGFza3MtLTtcbiAgICAgICAgICAgICAgICAgICAgMCA9PT0gcmVxdWVzdCRqc2NvbXAkMC5wZW5kaW5nUm9vdFRhc2tzICYmXG4gICAgICAgICAgICAgICAgICAgICAgY29tcGxldGVTaGVsbChyZXF1ZXN0JGpzY29tcCQwKTtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCRqc2NvbXAkMC5hbGxQZW5kaW5nVGFza3MtLTtcbiAgICAgICAgICAgICAgICAgICAgMCA9PT0gcmVxdWVzdCRqc2NvbXAkMC5hbGxQZW5kaW5nVGFza3MgJiZcbiAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZUFsbChyZXF1ZXN0JGpzY29tcCQwKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgY3VycmVudFRhc2tJbkRFViA9IHByZXZUYXNrSW5ERVY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAoKHJlcXVlc3QkanNjb21wJDAgPSBwcmV2VGFza0luREVWID0gdm9pZCAwKSxcbiAgICAgICAgICAgICAgKGVycm9yRGlnZXN0ID0gdGFzayksXG4gICAgICAgICAgICAgIChyZXF1ZXN0JGpzY29tcCQxID0gc2VnbWVudCksXG4gICAgICAgICAgICAgIHJlcXVlc3QkanNjb21wJDEuc3RhdHVzID09PSBQRU5ESU5HKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHJlcXVlc3QkanNjb21wJDEuc3RhdHVzID0gNjtcbiAgICAgICAgICAgICAgc3dpdGNoQ29udGV4dChlcnJvckRpZ2VzdC5jb250ZXh0KTtcbiAgICAgICAgICAgICAgcmVxdWVzdCRqc2NvbXAkMCA9IGN1cnJlbnRUYXNrSW5ERVY7XG4gICAgICAgICAgICAgIGN1cnJlbnRUYXNrSW5ERVYgPSBlcnJvckRpZ2VzdDtcbiAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gcmVxdWVzdCRqc2NvbXAkMS5jaGlsZHJlbi5sZW5ndGgsXG4gICAgICAgICAgICAgICAgY2h1bmtMZW5ndGggPSByZXF1ZXN0JGpzY29tcCQxLmNodW5rcy5sZW5ndGg7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0cnlOb2RlKHJlcXVlc3QsIGVycm9yRGlnZXN0KSxcbiAgICAgICAgICAgICAgICAgIHJlcXVlc3QkanNjb21wJDEubGFzdFB1c2hlZFRleHQgJiZcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCRqc2NvbXAkMS50ZXh0RW1iZWRkZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCRqc2NvbXAkMS5jaHVua3MucHVzaCh0ZXh0U2VwYXJhdG9yKSxcbiAgICAgICAgICAgICAgICAgIGVycm9yRGlnZXN0LmFib3J0U2V0LmRlbGV0ZShlcnJvckRpZ2VzdCksXG4gICAgICAgICAgICAgICAgICAocmVxdWVzdCRqc2NvbXAkMS5zdGF0dXMgPSBDT01QTEVURUQpLFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRTZWdtZW50KFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICBlcnJvckRpZ2VzdC5ibG9ja2VkQm91bmRhcnksXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QkanNjb21wJDFcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFRhc2soXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yRGlnZXN0LmJsb2NrZWRCb3VuZGFyeSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JEaWdlc3Qucm93LFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0JGpzY29tcCQxXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9IGNhdGNoICh0aHJvd25WYWx1ZSkge1xuICAgICAgICAgICAgICAgIHJlc2V0SG9va3NTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIHJlcXVlc3QkanNjb21wJDEuY2hpbGRyZW4ubGVuZ3RoID0gY2hpbGRyZW5MZW5ndGg7XG4gICAgICAgICAgICAgICAgcmVxdWVzdCRqc2NvbXAkMS5jaHVua3MubGVuZ3RoID0gY2h1bmtMZW5ndGg7XG4gICAgICAgICAgICAgICAgdmFyIHgkanNjb21wJDAgPVxuICAgICAgICAgICAgICAgICAgdGhyb3duVmFsdWUgPT09IFN1c3BlbnNlRXhjZXB0aW9uXG4gICAgICAgICAgICAgICAgICAgID8gZ2V0U3VzcGVuZGVkVGhlbmFibGUoKVxuICAgICAgICAgICAgICAgICAgICA6IDEyID09PSByZXF1ZXN0LnN0YXR1c1xuICAgICAgICAgICAgICAgICAgICAgID8gcmVxdWVzdC5mYXRhbEVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgOiB0aHJvd25WYWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAxMiA9PT0gcmVxdWVzdC5zdGF0dXMgJiZcbiAgICAgICAgICAgICAgICAgIG51bGwgIT09IHJlcXVlc3QudHJhY2tlZFBvc3Rwb25lc1xuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgdmFyIHRyYWNrZWRQb3N0cG9uZXMgPSByZXF1ZXN0LnRyYWNrZWRQb3N0cG9uZXMsXG4gICAgICAgICAgICAgICAgICAgIHRocm93bkluZm8gPSBnZXRUaHJvd25JbmZvKGVycm9yRGlnZXN0LmNvbXBvbmVudFN0YWNrKTtcbiAgICAgICAgICAgICAgICAgIGVycm9yRGlnZXN0LmFib3J0U2V0LmRlbGV0ZShlcnJvckRpZ2VzdCk7XG4gICAgICAgICAgICAgICAgICBsb2dSZWNvdmVyYWJsZUVycm9yKFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICB4JGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICB0aHJvd25JbmZvLFxuICAgICAgICAgICAgICAgICAgICBlcnJvckRpZ2VzdC5kZWJ1Z1Rhc2tcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICB0cmFja1Bvc3Rwb25lKFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICB0cmFja2VkUG9zdHBvbmVzLFxuICAgICAgICAgICAgICAgICAgICBlcnJvckRpZ2VzdCxcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCRqc2NvbXAkMVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkVGFzayhcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JEaWdlc3QuYmxvY2tlZEJvdW5kYXJ5LFxuICAgICAgICAgICAgICAgICAgICBlcnJvckRpZ2VzdC5yb3csXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QkanNjb21wJDFcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiB4JGpzY29tcCQwICYmXG4gICAgICAgICAgICAgICAgICBudWxsICE9PSB4JGpzY29tcCQwICYmXG4gICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB4JGpzY29tcCQwLnRoZW5cbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIHJlcXVlc3QkanNjb21wJDEuc3RhdHVzID0gUEVORElORztcbiAgICAgICAgICAgICAgICAgIGVycm9yRGlnZXN0LnRoZW5hYmxlU3RhdGUgPVxuICAgICAgICAgICAgICAgICAgICB0aHJvd25WYWx1ZSA9PT0gU3VzcGVuc2VFeGNlcHRpb25cbiAgICAgICAgICAgICAgICAgICAgICA/IGdldFRoZW5hYmxlU3RhdGVBZnRlclN1c3BlbmRpbmcoKVxuICAgICAgICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgIHZhciBwaW5nJGpzY29tcCQwID0gZXJyb3JEaWdlc3QucGluZztcbiAgICAgICAgICAgICAgICAgIHgkanNjb21wJDAudGhlbihwaW5nJGpzY29tcCQwLCBwaW5nJGpzY29tcCQwKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFyIGVycm9ySW5mbyRqc2NvbXAkMSA9IGdldFRocm93bkluZm8oXG4gICAgICAgICAgICAgICAgICAgIGVycm9yRGlnZXN0LmNvbXBvbmVudFN0YWNrXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgZXJyb3JEaWdlc3QuYWJvcnRTZXQuZGVsZXRlKGVycm9yRGlnZXN0KTtcbiAgICAgICAgICAgICAgICAgIHJlcXVlc3QkanNjb21wJDEuc3RhdHVzID0gRVJST1JFRDtcbiAgICAgICAgICAgICAgICAgIHZhciBib3VuZGFyeSRqc2NvbXAkMCA9IGVycm9yRGlnZXN0LmJsb2NrZWRCb3VuZGFyeSxcbiAgICAgICAgICAgICAgICAgICAgcm93ID0gZXJyb3JEaWdlc3Qucm93LFxuICAgICAgICAgICAgICAgICAgICBkZWJ1Z1Rhc2sgPSBlcnJvckRpZ2VzdC5kZWJ1Z1Rhc2s7XG4gICAgICAgICAgICAgICAgICBudWxsICE9PSByb3cgJiZcbiAgICAgICAgICAgICAgICAgICAgMCA9PT0gLS1yb3cucGVuZGluZ1Rhc2tzICYmXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaFN1c3BlbnNlTGlzdFJvdyhyZXF1ZXN0LCByb3cpO1xuICAgICAgICAgICAgICAgICAgcmVxdWVzdC5hbGxQZW5kaW5nVGFza3MtLTtcbiAgICAgICAgICAgICAgICAgIHByZXZUYXNrSW5ERVYgPSBsb2dSZWNvdmVyYWJsZUVycm9yKFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICB4JGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICBlcnJvckluZm8kanNjb21wJDEsXG4gICAgICAgICAgICAgICAgICAgIGRlYnVnVGFza1xuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGlmIChudWxsID09PSBib3VuZGFyeSRqc2NvbXAkMClcbiAgICAgICAgICAgICAgICAgICAgZmF0YWxFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICAgIHgkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgICAgZXJyb3JJbmZvJGpzY29tcCQxLFxuICAgICAgICAgICAgICAgICAgICAgIGRlYnVnVGFza1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgICAgIChib3VuZGFyeSRqc2NvbXAkMC5wZW5kaW5nVGFza3MtLSxcbiAgICAgICAgICAgICAgICAgICAgYm91bmRhcnkkanNjb21wJDAuc3RhdHVzICE9PSBDTElFTlRfUkVOREVSRUQpXG4gICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgYm91bmRhcnkkanNjb21wJDAuc3RhdHVzID0gQ0xJRU5UX1JFTkRFUkVEO1xuICAgICAgICAgICAgICAgICAgICBlbmNvZGVFcnJvckZvckJvdW5kYXJ5KFxuICAgICAgICAgICAgICAgICAgICAgIGJvdW5kYXJ5JGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICAgIHByZXZUYXNrSW5ERVYsXG4gICAgICAgICAgICAgICAgICAgICAgeCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgICBlcnJvckluZm8kanNjb21wJDEsXG4gICAgICAgICAgICAgICAgICAgICAgITFcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgdW50cmFja0JvdW5kYXJ5KHJlcXVlc3QsIGJvdW5kYXJ5JGpzY29tcCQwKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvdW5kYXJ5Um93ID0gYm91bmRhcnkkanNjb21wJDAucm93O1xuICAgICAgICAgICAgICAgICAgICBudWxsICE9PSBib3VuZGFyeVJvdyAmJlxuICAgICAgICAgICAgICAgICAgICAgIDAgPT09IC0tYm91bmRhcnlSb3cucGVuZGluZ1Rhc2tzICYmXG4gICAgICAgICAgICAgICAgICAgICAgZmluaXNoU3VzcGVuc2VMaXN0Um93KHJlcXVlc3QsIGJvdW5kYXJ5Um93KTtcbiAgICAgICAgICAgICAgICAgICAgYm91bmRhcnkkanNjb21wJDAucGFyZW50Rmx1c2hlZCAmJlxuICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QuY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzLnB1c2goYm91bmRhcnkkanNjb21wJDApO1xuICAgICAgICAgICAgICAgICAgICAwID09PSByZXF1ZXN0LnBlbmRpbmdSb290VGFza3MgJiZcbiAgICAgICAgICAgICAgICAgICAgICBudWxsID09PSByZXF1ZXN0LnRyYWNrZWRQb3N0cG9uZXMgJiZcbiAgICAgICAgICAgICAgICAgICAgICBudWxsICE9PSBib3VuZGFyeSRqc2NvbXAkMC5jb250ZW50UHJlYW1ibGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICBwcmVwYXJlUHJlYW1ibGUocmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAwID09PSByZXF1ZXN0LmFsbFBlbmRpbmdUYXNrcyAmJiBjb21wbGV0ZUFsbChyZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFRhc2tJbkRFViA9IHJlcXVlc3QkanNjb21wJDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcGluZ2VkVGFza3Muc3BsaWNlKDAsIGkpO1xuICAgICAgICAgIG51bGwgIT09IHJlcXVlc3QkanNjb21wJDIuZGVzdGluYXRpb24gJiZcbiAgICAgICAgICAgIGZsdXNoQ29tcGxldGVkUXVldWVzKFxuICAgICAgICAgICAgICByZXF1ZXN0JGpzY29tcCQyLFxuICAgICAgICAgICAgICByZXF1ZXN0JGpzY29tcCQyLmRlc3RpbmF0aW9uXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIChwaW5nZWRUYXNrcyA9IHt9KSxcbiAgICAgICAgICAgIGxvZ1JlY292ZXJhYmxlRXJyb3IocmVxdWVzdCRqc2NvbXAkMiwgZXJyb3IsIHBpbmdlZFRhc2tzLCBudWxsKSxcbiAgICAgICAgICAgIGZhdGFsRXJyb3IocmVxdWVzdCRqc2NvbXAkMiwgZXJyb3IsIHBpbmdlZFRhc2tzLCBudWxsKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAoY3VycmVudFJlc3VtYWJsZVN0YXRlID0gcHJldlJlc3VtYWJsZVN0YXRlKSxcbiAgICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXIpLFxuICAgICAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLkEgPSBwcmV2QXN5bmNEaXNwYXRjaGVyKSxcbiAgICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5nZXRDdXJyZW50U3RhY2sgPSBwcmV2R2V0Q3VycmVudFN0YWNrSW1wbCksXG4gICAgICAgICAgICBwcmV2RGlzcGF0Y2hlciA9PT0gSG9va3NEaXNwYXRjaGVyICYmIHN3aXRjaENvbnRleHQocHJldkNvbnRleHQpLFxuICAgICAgICAgICAgKGN1cnJlbnRSZXF1ZXN0ID0gcHJldlJlcXVlc3QpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByZXBhcmVQcmVhbWJsZUZyb21TdWJ0cmVlKFxuICAgICAgcmVxdWVzdCxcbiAgICAgIHNlZ21lbnQsXG4gICAgICBjb2xsZWN0ZWRQcmVhbWJsZVNlZ21lbnRzXG4gICAgKSB7XG4gICAgICBzZWdtZW50LnByZWFtYmxlQ2hpbGRyZW4ubGVuZ3RoICYmXG4gICAgICAgIGNvbGxlY3RlZFByZWFtYmxlU2VnbWVudHMucHVzaChzZWdtZW50LnByZWFtYmxlQ2hpbGRyZW4pO1xuICAgICAgZm9yICh2YXIgcGVuZGluZ1ByZWFtYmxlcyA9ICExLCBpID0gMDsgaSA8IHNlZ21lbnQuY2hpbGRyZW4ubGVuZ3RoOyBpKyspXG4gICAgICAgIHBlbmRpbmdQcmVhbWJsZXMgPVxuICAgICAgICAgIHByZXBhcmVQcmVhbWJsZUZyb21TZWdtZW50KFxuICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgIHNlZ21lbnQuY2hpbGRyZW5baV0sXG4gICAgICAgICAgICBjb2xsZWN0ZWRQcmVhbWJsZVNlZ21lbnRzXG4gICAgICAgICAgKSB8fCBwZW5kaW5nUHJlYW1ibGVzO1xuICAgICAgcmV0dXJuIHBlbmRpbmdQcmVhbWJsZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByZXBhcmVQcmVhbWJsZUZyb21TZWdtZW50KFxuICAgICAgcmVxdWVzdCxcbiAgICAgIHNlZ21lbnQsXG4gICAgICBjb2xsZWN0ZWRQcmVhbWJsZVNlZ21lbnRzXG4gICAgKSB7XG4gICAgICB2YXIgYm91bmRhcnkgPSBzZWdtZW50LmJvdW5kYXJ5O1xuICAgICAgaWYgKG51bGwgPT09IGJvdW5kYXJ5KVxuICAgICAgICByZXR1cm4gcHJlcGFyZVByZWFtYmxlRnJvbVN1YnRyZWUoXG4gICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICBzZWdtZW50LFxuICAgICAgICAgIGNvbGxlY3RlZFByZWFtYmxlU2VnbWVudHNcbiAgICAgICAgKTtcbiAgICAgIHZhciBwcmVhbWJsZSA9IGJvdW5kYXJ5LmNvbnRlbnRQcmVhbWJsZSxcbiAgICAgICAgZmFsbGJhY2tQcmVhbWJsZSA9IGJvdW5kYXJ5LmZhbGxiYWNrUHJlYW1ibGU7XG4gICAgICBpZiAobnVsbCA9PT0gcHJlYW1ibGUgfHwgbnVsbCA9PT0gZmFsbGJhY2tQcmVhbWJsZSkgcmV0dXJuICExO1xuICAgICAgc3dpdGNoIChib3VuZGFyeS5zdGF0dXMpIHtcbiAgICAgICAgY2FzZSBDT01QTEVURUQ6XG4gICAgICAgICAgaG9pc3RQcmVhbWJsZVN0YXRlKHJlcXVlc3QucmVuZGVyU3RhdGUsIHByZWFtYmxlKTtcbiAgICAgICAgICByZXF1ZXN0LmJ5dGVTaXplICs9IGJvdW5kYXJ5LmJ5dGVTaXplO1xuICAgICAgICAgIHNlZ21lbnQgPSBib3VuZGFyeS5jb21wbGV0ZWRTZWdtZW50c1swXTtcbiAgICAgICAgICBpZiAoIXNlZ21lbnQpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgXCJBIHByZXZpb3VzbHkgdW52aXNpdGVkIGJvdW5kYXJ5IG11c3QgaGF2ZSBleGFjdGx5IG9uZSByb290IHNlZ21lbnQuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIHByZXBhcmVQcmVhbWJsZUZyb21TdWJ0cmVlKFxuICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgIHNlZ21lbnQsXG4gICAgICAgICAgICBjb2xsZWN0ZWRQcmVhbWJsZVNlZ21lbnRzXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBQT1NUUE9ORUQ6XG4gICAgICAgICAgaWYgKG51bGwgIT09IHJlcXVlc3QudHJhY2tlZFBvc3Rwb25lcykgcmV0dXJuICEwO1xuICAgICAgICBjYXNlIENMSUVOVF9SRU5ERVJFRDpcbiAgICAgICAgICBpZiAoc2VnbWVudC5zdGF0dXMgPT09IENPTVBMRVRFRClcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIGhvaXN0UHJlYW1ibGVTdGF0ZShyZXF1ZXN0LnJlbmRlclN0YXRlLCBmYWxsYmFja1ByZWFtYmxlKSxcbiAgICAgICAgICAgICAgcHJlcGFyZVByZWFtYmxlRnJvbVN1YnRyZWUoXG4gICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICBzZWdtZW50LFxuICAgICAgICAgICAgICAgIGNvbGxlY3RlZFByZWFtYmxlU2VnbWVudHNcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gITA7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByZXBhcmVQcmVhbWJsZShyZXF1ZXN0KSB7XG4gICAgICBpZiAoXG4gICAgICAgIHJlcXVlc3QuY29tcGxldGVkUm9vdFNlZ21lbnQgJiZcbiAgICAgICAgbnVsbCA9PT0gcmVxdWVzdC5jb21wbGV0ZWRQcmVhbWJsZVNlZ21lbnRzXG4gICAgICApIHtcbiAgICAgICAgdmFyIGNvbGxlY3RlZFByZWFtYmxlU2VnbWVudHMgPSBbXSxcbiAgICAgICAgICBvcmlnaW5hbFJlcXVlc3RCeXRlU2l6ZSA9IHJlcXVlc3QuYnl0ZVNpemUsXG4gICAgICAgICAgaGFzUGVuZGluZ1ByZWFtYmxlcyA9IHByZXBhcmVQcmVhbWJsZUZyb21TZWdtZW50KFxuICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgIHJlcXVlc3QuY29tcGxldGVkUm9vdFNlZ21lbnQsXG4gICAgICAgICAgICBjb2xsZWN0ZWRQcmVhbWJsZVNlZ21lbnRzXG4gICAgICAgICAgKSxcbiAgICAgICAgICBwcmVhbWJsZSA9IHJlcXVlc3QucmVuZGVyU3RhdGUucHJlYW1ibGU7XG4gICAgICAgICExID09PSBoYXNQZW5kaW5nUHJlYW1ibGVzIHx8XG4gICAgICAgIChwcmVhbWJsZS5oZWFkQ2h1bmtzICYmIHByZWFtYmxlLmJvZHlDaHVua3MpXG4gICAgICAgICAgPyAocmVxdWVzdC5jb21wbGV0ZWRQcmVhbWJsZVNlZ21lbnRzID0gY29sbGVjdGVkUHJlYW1ibGVTZWdtZW50cylcbiAgICAgICAgICA6IChyZXF1ZXN0LmJ5dGVTaXplID0gb3JpZ2luYWxSZXF1ZXN0Qnl0ZVNpemUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBmbHVzaFN1YnRyZWUocmVxdWVzdCwgZGVzdGluYXRpb24sIHNlZ21lbnQsIGhvaXN0YWJsZVN0YXRlKSB7XG4gICAgICBzZWdtZW50LnBhcmVudEZsdXNoZWQgPSAhMDtcbiAgICAgIHN3aXRjaCAoc2VnbWVudC5zdGF0dXMpIHtcbiAgICAgICAgY2FzZSBQRU5ESU5HOlxuICAgICAgICAgIHNlZ21lbnQuaWQgPSByZXF1ZXN0Lm5leHRTZWdtZW50SWQrKztcbiAgICAgICAgY2FzZSBQT1NUUE9ORUQ6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChob2lzdGFibGVTdGF0ZSA9IHNlZ21lbnQuaWQpLFxuICAgICAgICAgICAgKHNlZ21lbnQubGFzdFB1c2hlZFRleHQgPSAhMSksXG4gICAgICAgICAgICAoc2VnbWVudC50ZXh0RW1iZWRkZWQgPSAhMSksXG4gICAgICAgICAgICAocmVxdWVzdCA9IHJlcXVlc3QucmVuZGVyU3RhdGUpLFxuICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcGxhY2Vob2xkZXIxKSxcbiAgICAgICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHJlcXVlc3QucGxhY2Vob2xkZXJQcmVmaXgpLFxuICAgICAgICAgICAgKHJlcXVlc3QgPSBzdHJpbmdUb0NodW5rKGhvaXN0YWJsZVN0YXRlLnRvU3RyaW5nKDE2KSkpLFxuICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVxdWVzdCksXG4gICAgICAgICAgICB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBwbGFjZWhvbGRlcjIpXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBDT01QTEVURUQ6XG4gICAgICAgICAgc2VnbWVudC5zdGF0dXMgPSBGTFVTSEVEO1xuICAgICAgICAgIHZhciByID0gITAsXG4gICAgICAgICAgICBjaHVua3MgPSBzZWdtZW50LmNodW5rcyxcbiAgICAgICAgICAgIGNodW5rSWR4ID0gMDtcbiAgICAgICAgICBzZWdtZW50ID0gc2VnbWVudC5jaGlsZHJlbjtcbiAgICAgICAgICBmb3IgKHZhciBjaGlsZElkeCA9IDA7IGNoaWxkSWR4IDwgc2VnbWVudC5sZW5ndGg7IGNoaWxkSWR4KyspIHtcbiAgICAgICAgICAgIGZvciAociA9IHNlZ21lbnRbY2hpbGRJZHhdOyBjaHVua0lkeCA8IHIuaW5kZXg7IGNodW5rSWR4KyspXG4gICAgICAgICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNodW5rc1tjaHVua0lkeF0pO1xuICAgICAgICAgICAgciA9IGZsdXNoU2VnbWVudChyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgciwgaG9pc3RhYmxlU3RhdGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKDsgY2h1bmtJZHggPCBjaHVua3MubGVuZ3RoIC0gMTsgY2h1bmtJZHgrKylcbiAgICAgICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNodW5rc1tjaHVua0lkeF0pO1xuICAgICAgICAgIGNodW5rSWR4IDwgY2h1bmtzLmxlbmd0aCAmJlxuICAgICAgICAgICAgKHIgPSB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBjaHVua3NbY2h1bmtJZHhdKSk7XG4gICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIGNhc2UgQUJPUlRFRDpcbiAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIkFib3J0ZWQsIGVycm9yZWQgb3IgYWxyZWFkeSBmbHVzaGVkIGJvdW5kYXJpZXMgc2hvdWxkIG5vdCBiZSBmbHVzaGVkIGFnYWluLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZmx1c2hTZWdtZW50KHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBzZWdtZW50LCBob2lzdGFibGVTdGF0ZSkge1xuICAgICAgdmFyIGJvdW5kYXJ5ID0gc2VnbWVudC5ib3VuZGFyeTtcbiAgICAgIGlmIChudWxsID09PSBib3VuZGFyeSlcbiAgICAgICAgcmV0dXJuIGZsdXNoU3VidHJlZShyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgc2VnbWVudCwgaG9pc3RhYmxlU3RhdGUpO1xuICAgICAgYm91bmRhcnkucGFyZW50Rmx1c2hlZCA9ICEwO1xuICAgICAgaWYgKGJvdW5kYXJ5LnN0YXR1cyA9PT0gQ0xJRU5UX1JFTkRFUkVEKSB7XG4gICAgICAgIHZhciByb3cgPSBib3VuZGFyeS5yb3c7XG4gICAgICAgIG51bGwgIT09IHJvdyAmJlxuICAgICAgICAgIDAgPT09IC0tcm93LnBlbmRpbmdUYXNrcyAmJlxuICAgICAgICAgIGZpbmlzaFN1c3BlbnNlTGlzdFJvdyhyZXF1ZXN0LCByb3cpO1xuICAgICAgICByb3cgPSBib3VuZGFyeS5lcnJvckRpZ2VzdDtcbiAgICAgICAgdmFyIGVycm9yTWVzc2FnZSA9IGJvdW5kYXJ5LmVycm9yTWVzc2FnZSxcbiAgICAgICAgICBlcnJvclN0YWNrID0gYm91bmRhcnkuZXJyb3JTdGFjaztcbiAgICAgICAgYm91bmRhcnkgPSBib3VuZGFyeS5lcnJvckNvbXBvbmVudFN0YWNrO1xuICAgICAgICB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBzdGFydENsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeSk7XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yMSk7XG4gICAgICAgIHJvdyAmJlxuICAgICAgICAgICh3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjFBKSxcbiAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKHJvdykpKSxcbiAgICAgICAgICB3cml0ZUNodW5rKFxuICAgICAgICAgICAgZGVzdGluYXRpb24sXG4gICAgICAgICAgICBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvckF0dHJJbnRlcnN0aXRpYWxcbiAgICAgICAgICApKTtcbiAgICAgICAgZXJyb3JNZXNzYWdlICYmXG4gICAgICAgICAgKHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yMUIpLFxuICAgICAgICAgIHdyaXRlQ2h1bmsoXG4gICAgICAgICAgICBkZXN0aW5hdGlvbixcbiAgICAgICAgICAgIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoZXJyb3JNZXNzYWdlKSlcbiAgICAgICAgICApLFxuICAgICAgICAgIHdyaXRlQ2h1bmsoXG4gICAgICAgICAgICBkZXN0aW5hdGlvbixcbiAgICAgICAgICAgIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yQXR0ckludGVyc3RpdGlhbFxuICAgICAgICAgICkpO1xuICAgICAgICBlcnJvclN0YWNrICYmXG4gICAgICAgICAgKHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yMUMpLFxuICAgICAgICAgIHdyaXRlQ2h1bmsoXG4gICAgICAgICAgICBkZXN0aW5hdGlvbixcbiAgICAgICAgICAgIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoZXJyb3JTdGFjaykpXG4gICAgICAgICAgKSxcbiAgICAgICAgICB3cml0ZUNodW5rKFxuICAgICAgICAgICAgZGVzdGluYXRpb24sXG4gICAgICAgICAgICBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvckF0dHJJbnRlcnN0aXRpYWxcbiAgICAgICAgICApKTtcbiAgICAgICAgYm91bmRhcnkgJiZcbiAgICAgICAgICAod3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxRCksXG4gICAgICAgICAgd3JpdGVDaHVuayhcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICAgICAgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3Nlcihib3VuZGFyeSkpXG4gICAgICAgICAgKSxcbiAgICAgICAgICB3cml0ZUNodW5rKFxuICAgICAgICAgICAgZGVzdGluYXRpb24sXG4gICAgICAgICAgICBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvckF0dHJJbnRlcnN0aXRpYWxcbiAgICAgICAgICApKTtcbiAgICAgICAgd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IyKTtcbiAgICAgICAgZmx1c2hTdWJ0cmVlKHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBzZWdtZW50LCBob2lzdGFibGVTdGF0ZSk7XG4gICAgICB9IGVsc2UgaWYgKGJvdW5kYXJ5LnN0YXR1cyAhPT0gQ09NUExFVEVEKVxuICAgICAgICBib3VuZGFyeS5zdGF0dXMgPT09IFBFTkRJTkcgJiZcbiAgICAgICAgICAoYm91bmRhcnkucm9vdFNlZ21lbnRJRCA9IHJlcXVlc3QubmV4dFNlZ21lbnRJZCsrKSxcbiAgICAgICAgICAwIDwgYm91bmRhcnkuY29tcGxldGVkU2VnbWVudHMubGVuZ3RoICYmXG4gICAgICAgICAgICByZXF1ZXN0LnBhcnRpYWxCb3VuZGFyaWVzLnB1c2goYm91bmRhcnkpLFxuICAgICAgICAgIHdyaXRlU3RhcnRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeShcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICAgICAgcmVxdWVzdC5yZW5kZXJTdGF0ZSxcbiAgICAgICAgICAgIGJvdW5kYXJ5LnJvb3RTZWdtZW50SURcbiAgICAgICAgICApLFxuICAgICAgICAgIGhvaXN0YWJsZVN0YXRlICYmXG4gICAgICAgICAgICBob2lzdEhvaXN0YWJsZXMoaG9pc3RhYmxlU3RhdGUsIGJvdW5kYXJ5LmZhbGxiYWNrU3RhdGUpLFxuICAgICAgICAgIGZsdXNoU3VidHJlZShyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgc2VnbWVudCwgaG9pc3RhYmxlU3RhdGUpO1xuICAgICAgZWxzZSBpZiAoXG4gICAgICAgICFmbHVzaGluZ1BhcnRpYWxCb3VuZGFyaWVzICYmXG4gICAgICAgIGlzRWxpZ2libGVGb3JPdXRsaW5pbmcocmVxdWVzdCwgYm91bmRhcnkpICYmXG4gICAgICAgIChmbHVzaGVkQnl0ZVNpemUgKyBib3VuZGFyeS5ieXRlU2l6ZSA+IHJlcXVlc3QucHJvZ3Jlc3NpdmVDaHVua1NpemUgfHxcbiAgICAgICAgICBoYXNTdXNwZW5zZXlDb250ZW50KGJvdW5kYXJ5LmNvbnRlbnRTdGF0ZSkpXG4gICAgICApXG4gICAgICAgIChib3VuZGFyeS5yb290U2VnbWVudElEID0gcmVxdWVzdC5uZXh0U2VnbWVudElkKyspLFxuICAgICAgICAgIHJlcXVlc3QuY29tcGxldGVkQm91bmRhcmllcy5wdXNoKGJvdW5kYXJ5KSxcbiAgICAgICAgICB3cml0ZVN0YXJ0UGVuZGluZ1N1c3BlbnNlQm91bmRhcnkoXG4gICAgICAgICAgICBkZXN0aW5hdGlvbixcbiAgICAgICAgICAgIHJlcXVlc3QucmVuZGVyU3RhdGUsXG4gICAgICAgICAgICBib3VuZGFyeS5yb290U2VnbWVudElEXG4gICAgICAgICAgKSxcbiAgICAgICAgICBmbHVzaFN1YnRyZWUocmVxdWVzdCwgZGVzdGluYXRpb24sIHNlZ21lbnQsIGhvaXN0YWJsZVN0YXRlKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBmbHVzaGVkQnl0ZVNpemUgKz0gYm91bmRhcnkuYnl0ZVNpemU7XG4gICAgICAgIGhvaXN0YWJsZVN0YXRlICYmXG4gICAgICAgICAgaG9pc3RIb2lzdGFibGVzKGhvaXN0YWJsZVN0YXRlLCBib3VuZGFyeS5jb250ZW50U3RhdGUpO1xuICAgICAgICBzZWdtZW50ID0gYm91bmRhcnkucm93O1xuICAgICAgICBudWxsICE9PSBzZWdtZW50ICYmXG4gICAgICAgICAgaXNFbGlnaWJsZUZvck91dGxpbmluZyhyZXF1ZXN0LCBib3VuZGFyeSkgJiZcbiAgICAgICAgICAwID09PSAtLXNlZ21lbnQucGVuZGluZ1Rhc2tzICYmXG4gICAgICAgICAgZmluaXNoU3VzcGVuc2VMaXN0Um93KHJlcXVlc3QsIHNlZ21lbnQpO1xuICAgICAgICB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBzdGFydENvbXBsZXRlZFN1c3BlbnNlQm91bmRhcnkpO1xuICAgICAgICBzZWdtZW50ID0gYm91bmRhcnkuY29tcGxldGVkU2VnbWVudHM7XG4gICAgICAgIGlmICgxICE9PSBzZWdtZW50Lmxlbmd0aClcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiQSBwcmV2aW91c2x5IHVudmlzaXRlZCBib3VuZGFyeSBtdXN0IGhhdmUgZXhhY3RseSBvbmUgcm9vdCBzZWdtZW50LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgZmx1c2hTZWdtZW50KHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBzZWdtZW50WzBdLCBob2lzdGFibGVTdGF0ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgZW5kU3VzcGVuc2VCb3VuZGFyeSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZsdXNoU2VnbWVudENvbnRhaW5lcihcbiAgICAgIHJlcXVlc3QsXG4gICAgICBkZXN0aW5hdGlvbixcbiAgICAgIHNlZ21lbnQsXG4gICAgICBob2lzdGFibGVTdGF0ZVxuICAgICkge1xuICAgICAgd3JpdGVTdGFydFNlZ21lbnQoXG4gICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICByZXF1ZXN0LnJlbmRlclN0YXRlLFxuICAgICAgICBzZWdtZW50LnBhcmVudEZvcm1hdENvbnRleHQsXG4gICAgICAgIHNlZ21lbnQuaWRcbiAgICAgICk7XG4gICAgICBmbHVzaFNlZ21lbnQocmVxdWVzdCwgZGVzdGluYXRpb24sIHNlZ21lbnQsIGhvaXN0YWJsZVN0YXRlKTtcbiAgICAgIHJldHVybiB3cml0ZUVuZFNlZ21lbnQoZGVzdGluYXRpb24sIHNlZ21lbnQucGFyZW50Rm9ybWF0Q29udGV4dCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZsdXNoQ29tcGxldGVkQm91bmRhcnkocmVxdWVzdCwgZGVzdGluYXRpb24sIGJvdW5kYXJ5KSB7XG4gICAgICBmbHVzaGVkQnl0ZVNpemUgPSBib3VuZGFyeS5ieXRlU2l6ZTtcbiAgICAgIGZvciAoXG4gICAgICAgIHZhciBjb21wbGV0ZWRTZWdtZW50cyA9IGJvdW5kYXJ5LmNvbXBsZXRlZFNlZ21lbnRzLCBpID0gMDtcbiAgICAgICAgaSA8IGNvbXBsZXRlZFNlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgaSsrXG4gICAgICApXG4gICAgICAgIGZsdXNoUGFydGlhbGx5Q29tcGxldGVkU2VnbWVudChcbiAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICAgIGJvdW5kYXJ5LFxuICAgICAgICAgIGNvbXBsZXRlZFNlZ21lbnRzW2ldXG4gICAgICAgICk7XG4gICAgICBjb21wbGV0ZWRTZWdtZW50cy5sZW5ndGggPSAwO1xuICAgICAgY29tcGxldGVkU2VnbWVudHMgPSBib3VuZGFyeS5yb3c7XG4gICAgICBudWxsICE9PSBjb21wbGV0ZWRTZWdtZW50cyAmJlxuICAgICAgICBpc0VsaWdpYmxlRm9yT3V0bGluaW5nKHJlcXVlc3QsIGJvdW5kYXJ5KSAmJlxuICAgICAgICAwID09PSAtLWNvbXBsZXRlZFNlZ21lbnRzLnBlbmRpbmdUYXNrcyAmJlxuICAgICAgICBmaW5pc2hTdXNwZW5zZUxpc3RSb3cocmVxdWVzdCwgY29tcGxldGVkU2VnbWVudHMpO1xuICAgICAgd3JpdGVIb2lzdGFibGVzRm9yQm91bmRhcnkoXG4gICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICBib3VuZGFyeS5jb250ZW50U3RhdGUsXG4gICAgICAgIHJlcXVlc3QucmVuZGVyU3RhdGVcbiAgICAgICk7XG4gICAgICBjb21wbGV0ZWRTZWdtZW50cyA9IHJlcXVlc3QucmVzdW1hYmxlU3RhdGU7XG4gICAgICByZXF1ZXN0ID0gcmVxdWVzdC5yZW5kZXJTdGF0ZTtcbiAgICAgIGkgPSBib3VuZGFyeS5yb290U2VnbWVudElEO1xuICAgICAgYm91bmRhcnkgPSBib3VuZGFyeS5jb250ZW50U3RhdGU7XG4gICAgICB2YXIgcmVxdWlyZXNTdHlsZUluc2VydGlvbiA9IHJlcXVlc3Quc3R5bGVzVG9Ib2lzdDtcbiAgICAgIHJlcXVlc3Quc3R5bGVzVG9Ib2lzdCA9ICExO1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVxdWVzdC5zdGFydElubGluZVNjcmlwdCk7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBlbmRPZlN0YXJ0VGFnKTtcbiAgICAgIHJlcXVpcmVzU3R5bGVJbnNlcnRpb25cbiAgICAgICAgPyAoKGNvbXBsZXRlZFNlZ21lbnRzLmluc3RydWN0aW9ucyAmIFNlbnRDbGllbnRSZW5kZXJGdW5jdGlvbikgPT09XG4gICAgICAgICAgICBOb3RoaW5nU2VudCAmJlxuICAgICAgICAgICAgKChjb21wbGV0ZWRTZWdtZW50cy5pbnN0cnVjdGlvbnMgfD0gU2VudENsaWVudFJlbmRlckZ1bmN0aW9uKSxcbiAgICAgICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNsaWVudFJlbmRlclNjcmlwdEZ1bmN0aW9uT25seSkpLFxuICAgICAgICAgIChjb21wbGV0ZWRTZWdtZW50cy5pbnN0cnVjdGlvbnMgJiBTZW50Q29tcGxldGVCb3VuZGFyeUZ1bmN0aW9uKSA9PT1cbiAgICAgICAgICAgIE5vdGhpbmdTZW50ICYmXG4gICAgICAgICAgICAoKGNvbXBsZXRlZFNlZ21lbnRzLmluc3RydWN0aW9ucyB8PSBTZW50Q29tcGxldGVCb3VuZGFyeUZ1bmN0aW9uKSxcbiAgICAgICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNvbXBsZXRlQm91bmRhcnlTY3JpcHRGdW5jdGlvbk9ubHkpKSxcbiAgICAgICAgICAoY29tcGxldGVkU2VnbWVudHMuaW5zdHJ1Y3Rpb25zICYgU2VudFN0eWxlSW5zZXJ0aW9uRnVuY3Rpb24pID09PVxuICAgICAgICAgIE5vdGhpbmdTZW50XG4gICAgICAgICAgICA/ICgoY29tcGxldGVkU2VnbWVudHMuaW5zdHJ1Y3Rpb25zIHw9IFNlbnRTdHlsZUluc2VydGlvbkZ1bmN0aW9uKSxcbiAgICAgICAgICAgICAgd3JpdGVDaHVuayhcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbixcbiAgICAgICAgICAgICAgICBjb21wbGV0ZUJvdW5kYXJ5V2l0aFN0eWxlc1NjcmlwdDFGdWxsUGFydGlhbFxuICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgOiB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjb21wbGV0ZUJvdW5kYXJ5V2l0aFN0eWxlc1NjcmlwdDFQYXJ0aWFsKSlcbiAgICAgICAgOiAoKGNvbXBsZXRlZFNlZ21lbnRzLmluc3RydWN0aW9ucyAmIFNlbnRDb21wbGV0ZUJvdW5kYXJ5RnVuY3Rpb24pID09PVxuICAgICAgICAgICAgTm90aGluZ1NlbnQgJiZcbiAgICAgICAgICAgICgoY29tcGxldGVkU2VnbWVudHMuaW5zdHJ1Y3Rpb25zIHw9IFNlbnRDb21wbGV0ZUJvdW5kYXJ5RnVuY3Rpb24pLFxuICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY29tcGxldGVCb3VuZGFyeVNjcmlwdEZ1bmN0aW9uT25seSkpLFxuICAgICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNvbXBsZXRlQm91bmRhcnlTY3JpcHQxUGFydGlhbCkpO1xuICAgICAgY29tcGxldGVkU2VnbWVudHMgPSBzdHJpbmdUb0NodW5rKGkudG9TdHJpbmcoMTYpKTtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHJlcXVlc3QuYm91bmRhcnlQcmVmaXgpO1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY29tcGxldGVkU2VnbWVudHMpO1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY29tcGxldGVCb3VuZGFyeVNjcmlwdDIpO1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVxdWVzdC5zZWdtZW50UHJlZml4KTtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNvbXBsZXRlZFNlZ21lbnRzKTtcbiAgICAgIHJlcXVpcmVzU3R5bGVJbnNlcnRpb25cbiAgICAgICAgPyAod3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY29tcGxldGVCb3VuZGFyeVNjcmlwdDNhKSxcbiAgICAgICAgICB3cml0ZVN0eWxlUmVzb3VyY2VEZXBlbmRlbmNpZXNJbkpTKGRlc3RpbmF0aW9uLCBib3VuZGFyeSkpXG4gICAgICAgIDogd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY29tcGxldGVCb3VuZGFyeVNjcmlwdDNiKTtcbiAgICAgIGJvdW5kYXJ5ID0gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgY29tcGxldGVCb3VuZGFyeVNjcmlwdEVuZCk7XG4gICAgICByZXR1cm4gd3JpdGVCb290c3RyYXAoZGVzdGluYXRpb24sIHJlcXVlc3QpICYmIGJvdW5kYXJ5O1xuICAgIH1cbiAgICBmdW5jdGlvbiBmbHVzaFBhcnRpYWxseUNvbXBsZXRlZFNlZ21lbnQoXG4gICAgICByZXF1ZXN0LFxuICAgICAgZGVzdGluYXRpb24sXG4gICAgICBib3VuZGFyeSxcbiAgICAgIHNlZ21lbnRcbiAgICApIHtcbiAgICAgIGlmIChzZWdtZW50LnN0YXR1cyA9PT0gRkxVU0hFRCkgcmV0dXJuICEwO1xuICAgICAgdmFyIGhvaXN0YWJsZVN0YXRlID0gYm91bmRhcnkuY29udGVudFN0YXRlLFxuICAgICAgICBzZWdtZW50SUQgPSBzZWdtZW50LmlkO1xuICAgICAgaWYgKC0xID09PSBzZWdtZW50SUQpIHtcbiAgICAgICAgaWYgKC0xID09PSAoc2VnbWVudC5pZCA9IGJvdW5kYXJ5LnJvb3RTZWdtZW50SUQpKVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJBIHJvb3Qgc2VnbWVudCBJRCBtdXN0IGhhdmUgYmVlbiBhc3NpZ25lZCBieSBub3cuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICApO1xuICAgICAgICByZXR1cm4gZmx1c2hTZWdtZW50Q29udGFpbmVyKFxuICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgZGVzdGluYXRpb24sXG4gICAgICAgICAgc2VnbWVudCxcbiAgICAgICAgICBob2lzdGFibGVTdGF0ZVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHNlZ21lbnRJRCA9PT0gYm91bmRhcnkucm9vdFNlZ21lbnRJRClcbiAgICAgICAgcmV0dXJuIGZsdXNoU2VnbWVudENvbnRhaW5lcihcbiAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICAgIHNlZ21lbnQsXG4gICAgICAgICAgaG9pc3RhYmxlU3RhdGVcbiAgICAgICAgKTtcbiAgICAgIGZsdXNoU2VnbWVudENvbnRhaW5lcihyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgc2VnbWVudCwgaG9pc3RhYmxlU3RhdGUpO1xuICAgICAgYm91bmRhcnkgPSByZXF1ZXN0LnJlc3VtYWJsZVN0YXRlO1xuICAgICAgcmVxdWVzdCA9IHJlcXVlc3QucmVuZGVyU3RhdGU7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZXF1ZXN0LnN0YXJ0SW5saW5lU2NyaXB0KTtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGVuZE9mU3RhcnRUYWcpO1xuICAgICAgKGJvdW5kYXJ5Lmluc3RydWN0aW9ucyAmIFNlbnRDb21wbGV0ZVNlZ21lbnRGdW5jdGlvbikgPT09IE5vdGhpbmdTZW50XG4gICAgICAgID8gKChib3VuZGFyeS5pbnN0cnVjdGlvbnMgfD0gU2VudENvbXBsZXRlU2VnbWVudEZ1bmN0aW9uKSxcbiAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjb21wbGV0ZVNlZ21lbnRTY3JpcHQxRnVsbCkpXG4gICAgICAgIDogd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY29tcGxldGVTZWdtZW50U2NyaXB0MVBhcnRpYWwpO1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVxdWVzdC5zZWdtZW50UHJlZml4KTtcbiAgICAgIHNlZ21lbnRJRCA9IHN0cmluZ1RvQ2h1bmsoc2VnbWVudElELnRvU3RyaW5nKDE2KSk7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzZWdtZW50SUQpO1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY29tcGxldGVTZWdtZW50U2NyaXB0Mik7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZXF1ZXN0LnBsYWNlaG9sZGVyUHJlZml4KTtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHNlZ21lbnRJRCk7XG4gICAgICBkZXN0aW5hdGlvbiA9IHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGNvbXBsZXRlU2VnbWVudFNjcmlwdEVuZCk7XG4gICAgICByZXR1cm4gZGVzdGluYXRpb247XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZsdXNoQ29tcGxldGVkUXVldWVzKHJlcXVlc3QsIGRlc3RpbmF0aW9uKSB7XG4gICAgICBjdXJyZW50VmlldyA9IG5ldyBVaW50OEFycmF5KDIwNDgpO1xuICAgICAgd3JpdHRlbkJ5dGVzID0gMDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghKDAgPCByZXF1ZXN0LnBlbmRpbmdSb290VGFza3MpKSB7XG4gICAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBjb21wbGV0ZWRSb290U2VnbWVudCA9IHJlcXVlc3QuY29tcGxldGVkUm9vdFNlZ21lbnQ7XG4gICAgICAgICAgaWYgKG51bGwgIT09IGNvbXBsZXRlZFJvb3RTZWdtZW50KSB7XG4gICAgICAgICAgICBpZiAoY29tcGxldGVkUm9vdFNlZ21lbnQuc3RhdHVzID09PSBQT1NUUE9ORUQpIHJldHVybjtcbiAgICAgICAgICAgIHZhciBjb21wbGV0ZWRQcmVhbWJsZVNlZ21lbnRzID0gcmVxdWVzdC5jb21wbGV0ZWRQcmVhbWJsZVNlZ21lbnRzO1xuICAgICAgICAgICAgaWYgKG51bGwgPT09IGNvbXBsZXRlZFByZWFtYmxlU2VnbWVudHMpIHJldHVybjtcbiAgICAgICAgICAgIGZsdXNoZWRCeXRlU2l6ZSA9IHJlcXVlc3QuYnl0ZVNpemU7XG4gICAgICAgICAgICB2YXIgcmVzdW1hYmxlU3RhdGUgPSByZXF1ZXN0LnJlc3VtYWJsZVN0YXRlLFxuICAgICAgICAgICAgICByZW5kZXJTdGF0ZSA9IHJlcXVlc3QucmVuZGVyU3RhdGUsXG4gICAgICAgICAgICAgIHByZWFtYmxlID0gcmVuZGVyU3RhdGUucHJlYW1ibGUsXG4gICAgICAgICAgICAgIGh0bWxDaHVua3MgPSBwcmVhbWJsZS5odG1sQ2h1bmtzLFxuICAgICAgICAgICAgICBoZWFkQ2h1bmtzID0gcHJlYW1ibGUuaGVhZENodW5rcyxcbiAgICAgICAgICAgICAgaSRqc2NvbXAkMDtcbiAgICAgICAgICAgIGlmIChodG1sQ2h1bmtzKSB7XG4gICAgICAgICAgICAgIGZvciAoaSRqc2NvbXAkMCA9IDA7IGkkanNjb21wJDAgPCBodG1sQ2h1bmtzLmxlbmd0aDsgaSRqc2NvbXAkMCsrKVxuICAgICAgICAgICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGh0bWxDaHVua3NbaSRqc2NvbXAkMF0pO1xuICAgICAgICAgICAgICBpZiAoaGVhZENodW5rcylcbiAgICAgICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgICAgaSRqc2NvbXAkMCA9IDA7XG4gICAgICAgICAgICAgICAgICBpJGpzY29tcCQwIDwgaGVhZENodW5rcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICBpJGpzY29tcCQwKytcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBoZWFkQ2h1bmtzW2kkanNjb21wJDBdKTtcbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0YXJ0Q2h1bmtGb3JUYWcoXCJoZWFkXCIpKSxcbiAgICAgICAgICAgICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGVuZE9mU3RhcnRUYWcpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChoZWFkQ2h1bmtzKVxuICAgICAgICAgICAgICBmb3IgKGkkanNjb21wJDAgPSAwOyBpJGpzY29tcCQwIDwgaGVhZENodW5rcy5sZW5ndGg7IGkkanNjb21wJDArKylcbiAgICAgICAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBoZWFkQ2h1bmtzW2kkanNjb21wJDBdKTtcbiAgICAgICAgICAgIHZhciBjaGFyc2V0Q2h1bmtzID0gcmVuZGVyU3RhdGUuY2hhcnNldENodW5rcztcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgIGkkanNjb21wJDAgPSAwO1xuICAgICAgICAgICAgICBpJGpzY29tcCQwIDwgY2hhcnNldENodW5rcy5sZW5ndGg7XG4gICAgICAgICAgICAgIGkkanNjb21wJDArK1xuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjaGFyc2V0Q2h1bmtzW2kkanNjb21wJDBdKTtcbiAgICAgICAgICAgIGNoYXJzZXRDaHVua3MubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHJlbmRlclN0YXRlLnByZWNvbm5lY3RzLmZvckVhY2goZmx1c2hSZXNvdXJjZSwgZGVzdGluYXRpb24pO1xuICAgICAgICAgICAgcmVuZGVyU3RhdGUucHJlY29ubmVjdHMuY2xlYXIoKTtcbiAgICAgICAgICAgIHZhciB2aWV3cG9ydENodW5rcyA9IHJlbmRlclN0YXRlLnZpZXdwb3J0Q2h1bmtzO1xuICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgaSRqc2NvbXAkMCA9IDA7XG4gICAgICAgICAgICAgIGkkanNjb21wJDAgPCB2aWV3cG9ydENodW5rcy5sZW5ndGg7XG4gICAgICAgICAgICAgIGkkanNjb21wJDArK1xuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCB2aWV3cG9ydENodW5rc1tpJGpzY29tcCQwXSk7XG4gICAgICAgICAgICB2aWV3cG9ydENodW5rcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgcmVuZGVyU3RhdGUuZm9udFByZWxvYWRzLmZvckVhY2goZmx1c2hSZXNvdXJjZSwgZGVzdGluYXRpb24pO1xuICAgICAgICAgICAgcmVuZGVyU3RhdGUuZm9udFByZWxvYWRzLmNsZWFyKCk7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZS5oaWdoSW1hZ2VQcmVsb2Fkcy5mb3JFYWNoKGZsdXNoUmVzb3VyY2UsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgIHJlbmRlclN0YXRlLmhpZ2hJbWFnZVByZWxvYWRzLmNsZWFyKCk7XG4gICAgICAgICAgICBjdXJyZW50bHlGbHVzaGluZ1JlbmRlclN0YXRlID0gcmVuZGVyU3RhdGU7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZS5zdHlsZXMuZm9yRWFjaChmbHVzaFN0eWxlc0luUHJlYW1ibGUsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgIGN1cnJlbnRseUZsdXNoaW5nUmVuZGVyU3RhdGUgPSBudWxsO1xuICAgICAgICAgICAgdmFyIGltcG9ydE1hcENodW5rcyA9IHJlbmRlclN0YXRlLmltcG9ydE1hcENodW5rcztcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgIGkkanNjb21wJDAgPSAwO1xuICAgICAgICAgICAgICBpJGpzY29tcCQwIDwgaW1wb3J0TWFwQ2h1bmtzLmxlbmd0aDtcbiAgICAgICAgICAgICAgaSRqc2NvbXAkMCsrXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGltcG9ydE1hcENodW5rc1tpJGpzY29tcCQwXSk7XG4gICAgICAgICAgICBpbXBvcnRNYXBDaHVua3MubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHJlbmRlclN0YXRlLmJvb3RzdHJhcFNjcmlwdHMuZm9yRWFjaChmbHVzaFJlc291cmNlLCBkZXN0aW5hdGlvbik7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZS5zY3JpcHRzLmZvckVhY2goZmx1c2hSZXNvdXJjZSwgZGVzdGluYXRpb24pO1xuICAgICAgICAgICAgcmVuZGVyU3RhdGUuc2NyaXB0cy5jbGVhcigpO1xuICAgICAgICAgICAgcmVuZGVyU3RhdGUuYnVsa1ByZWxvYWRzLmZvckVhY2goZmx1c2hSZXNvdXJjZSwgZGVzdGluYXRpb24pO1xuICAgICAgICAgICAgcmVuZGVyU3RhdGUuYnVsa1ByZWxvYWRzLmNsZWFyKCk7XG4gICAgICAgICAgICBodG1sQ2h1bmtzIHx8XG4gICAgICAgICAgICAgIGhlYWRDaHVua3MgfHxcbiAgICAgICAgICAgICAgKHJlc3VtYWJsZVN0YXRlLmluc3RydWN0aW9ucyB8PSBTZW50Q29tcGxldGVkU2hlbGxJZCk7XG4gICAgICAgICAgICB2YXIgaG9pc3RhYmxlQ2h1bmtzID0gcmVuZGVyU3RhdGUuaG9pc3RhYmxlQ2h1bmtzO1xuICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgaSRqc2NvbXAkMCA9IDA7XG4gICAgICAgICAgICAgIGkkanNjb21wJDAgPCBob2lzdGFibGVDaHVua3MubGVuZ3RoO1xuICAgICAgICAgICAgICBpJGpzY29tcCQwKytcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgaG9pc3RhYmxlQ2h1bmtzW2kkanNjb21wJDBdKTtcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlID0gaG9pc3RhYmxlQ2h1bmtzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlIDwgY29tcGxldGVkUHJlYW1ibGVTZWdtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlKytcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICB2YXIgc2VnbWVudHMgPSBjb21wbGV0ZWRQcmVhbWJsZVNlZ21lbnRzW3Jlc3VtYWJsZVN0YXRlXTtcbiAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZSA9IDA7XG4gICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUgPCBzZWdtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUrK1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgZmx1c2hTZWdtZW50KHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBzZWdtZW50c1tyZW5kZXJTdGF0ZV0sIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHByZWFtYmxlJGpzY29tcCQwID0gcmVxdWVzdC5yZW5kZXJTdGF0ZS5wcmVhbWJsZSxcbiAgICAgICAgICAgICAgaGVhZENodW5rcyRqc2NvbXAkMCA9IHByZWFtYmxlJGpzY29tcCQwLmhlYWRDaHVua3M7XG4gICAgICAgICAgICAocHJlYW1ibGUkanNjb21wJDAuaHRtbENodW5rcyB8fCBoZWFkQ2h1bmtzJGpzY29tcCQwKSAmJlxuICAgICAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBlbmRDaHVua0ZvclRhZyhcImhlYWRcIikpO1xuICAgICAgICAgICAgdmFyIGJvZHlDaHVua3MgPSBwcmVhbWJsZSRqc2NvbXAkMC5ib2R5Q2h1bmtzO1xuICAgICAgICAgICAgaWYgKGJvZHlDaHVua3MpXG4gICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgY29tcGxldGVkUHJlYW1ibGVTZWdtZW50cyA9IDA7XG4gICAgICAgICAgICAgICAgY29tcGxldGVkUHJlYW1ibGVTZWdtZW50cyA8IGJvZHlDaHVua3MubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlZFByZWFtYmxlU2VnbWVudHMrK1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgYm9keUNodW5rc1tjb21wbGV0ZWRQcmVhbWJsZVNlZ21lbnRzXSk7XG4gICAgICAgICAgICBmbHVzaFNlZ21lbnQocmVxdWVzdCwgZGVzdGluYXRpb24sIGNvbXBsZXRlZFJvb3RTZWdtZW50LCBudWxsKTtcbiAgICAgICAgICAgIHJlcXVlc3QuY29tcGxldGVkUm9vdFNlZ21lbnQgPSBudWxsO1xuICAgICAgICAgICAgdmFyIHJlbmRlclN0YXRlJGpzY29tcCQwID0gcmVxdWVzdC5yZW5kZXJTdGF0ZTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgMCAhPT0gcmVxdWVzdC5hbGxQZW5kaW5nVGFza3MgfHxcbiAgICAgICAgICAgICAgMCAhPT0gcmVxdWVzdC5jbGllbnRSZW5kZXJlZEJvdW5kYXJpZXMubGVuZ3RoIHx8XG4gICAgICAgICAgICAgIDAgIT09IHJlcXVlc3QuY29tcGxldGVkQm91bmRhcmllcy5sZW5ndGggfHxcbiAgICAgICAgICAgICAgKG51bGwgIT09IHJlcXVlc3QudHJhY2tlZFBvc3Rwb25lcyAmJlxuICAgICAgICAgICAgICAgICgwICE9PSByZXF1ZXN0LnRyYWNrZWRQb3N0cG9uZXMucm9vdE5vZGVzLmxlbmd0aCB8fFxuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gcmVxdWVzdC50cmFja2VkUG9zdHBvbmVzLnJvb3RTbG90cykpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgdmFyIHJlc3VtYWJsZVN0YXRlJGpzY29tcCQwID0gcmVxdWVzdC5yZXN1bWFibGVTdGF0ZTtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIChyZXN1bWFibGVTdGF0ZSRqc2NvbXAkMC5pbnN0cnVjdGlvbnMgJiBTZW50TWFya1NoZWxsVGltZSkgPT09XG4gICAgICAgICAgICAgICAgTm90aGluZ1NlbnRcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUkanNjb21wJDAuaW5zdHJ1Y3Rpb25zIHw9IFNlbnRNYXJrU2hlbGxUaW1lO1xuICAgICAgICAgICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHJlbmRlclN0YXRlJGpzY29tcCQwLnN0YXJ0SW5saW5lU2NyaXB0KTtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAocmVzdW1hYmxlU3RhdGUkanNjb21wJDAuaW5zdHJ1Y3Rpb25zICZcbiAgICAgICAgICAgICAgICAgICAgU2VudENvbXBsZXRlZFNoZWxsSWQpID09PVxuICAgICAgICAgICAgICAgICAgTm90aGluZ1NlbnRcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlJGpzY29tcCQwLmluc3RydWN0aW9ucyB8PSBTZW50Q29tcGxldGVkU2hlbGxJZDtcbiAgICAgICAgICAgICAgICAgIHZhciBzaGVsbElkID0gXCJfXCIgKyByZXN1bWFibGVTdGF0ZSRqc2NvbXAkMC5pZFByZWZpeCArIFwiUl9cIjtcbiAgICAgICAgICAgICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNvbXBsZXRlZFNoZWxsSWRBdHRyaWJ1dGVTdGFydCk7XG4gICAgICAgICAgICAgICAgICB3cml0ZUNodW5rKFxuICAgICAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbixcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihzaGVsbElkKSlcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBhdHRyaWJ1dGVFbmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBlbmRPZlN0YXJ0VGFnKTtcbiAgICAgICAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzaGVsbFRpbWVSdW50aW1lU2NyaXB0KTtcbiAgICAgICAgICAgICAgICB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBlbmRJbmxpbmVTY3JpcHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3cml0ZUJvb3RzdHJhcChkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUkanNjb21wJDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcmVuZGVyU3RhdGUkanNjb21wJDEgPSByZXF1ZXN0LnJlbmRlclN0YXRlO1xuICAgICAgICAgIGNvbXBsZXRlZFJvb3RTZWdtZW50ID0gMDtcbiAgICAgICAgICB2YXIgdmlld3BvcnRDaHVua3MkanNjb21wJDAgPSByZW5kZXJTdGF0ZSRqc2NvbXAkMS52aWV3cG9ydENodW5rcztcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgY29tcGxldGVkUm9vdFNlZ21lbnQgPSAwO1xuICAgICAgICAgICAgY29tcGxldGVkUm9vdFNlZ21lbnQgPCB2aWV3cG9ydENodW5rcyRqc2NvbXAkMC5sZW5ndGg7XG4gICAgICAgICAgICBjb21wbGV0ZWRSb290U2VnbWVudCsrXG4gICAgICAgICAgKVxuICAgICAgICAgICAgd3JpdGVDaHVuayhcbiAgICAgICAgICAgICAgZGVzdGluYXRpb24sXG4gICAgICAgICAgICAgIHZpZXdwb3J0Q2h1bmtzJGpzY29tcCQwW2NvbXBsZXRlZFJvb3RTZWdtZW50XVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB2aWV3cG9ydENodW5rcyRqc2NvbXAkMC5sZW5ndGggPSAwO1xuICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQxLnByZWNvbm5lY3RzLmZvckVhY2goZmx1c2hSZXNvdXJjZSwgZGVzdGluYXRpb24pO1xuICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQxLnByZWNvbm5lY3RzLmNsZWFyKCk7XG4gICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDEuZm9udFByZWxvYWRzLmZvckVhY2goZmx1c2hSZXNvdXJjZSwgZGVzdGluYXRpb24pO1xuICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQxLmZvbnRQcmVsb2Fkcy5jbGVhcigpO1xuICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQxLmhpZ2hJbWFnZVByZWxvYWRzLmZvckVhY2goXG4gICAgICAgICAgICBmbHVzaFJlc291cmNlLFxuICAgICAgICAgICAgZGVzdGluYXRpb25cbiAgICAgICAgICApO1xuICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQxLmhpZ2hJbWFnZVByZWxvYWRzLmNsZWFyKCk7XG4gICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDEuc3R5bGVzLmZvckVhY2gocHJlbG9hZExhdGVTdHlsZXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMS5zY3JpcHRzLmZvckVhY2goZmx1c2hSZXNvdXJjZSwgZGVzdGluYXRpb24pO1xuICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQxLnNjcmlwdHMuY2xlYXIoKTtcbiAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMS5idWxrUHJlbG9hZHMuZm9yRWFjaChmbHVzaFJlc291cmNlLCBkZXN0aW5hdGlvbik7XG4gICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDEuYnVsa1ByZWxvYWRzLmNsZWFyKCk7XG4gICAgICAgICAgdmFyIGhvaXN0YWJsZUNodW5rcyRqc2NvbXAkMCA9IHJlbmRlclN0YXRlJGpzY29tcCQxLmhvaXN0YWJsZUNodW5rcztcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgY29tcGxldGVkUm9vdFNlZ21lbnQgPSAwO1xuICAgICAgICAgICAgY29tcGxldGVkUm9vdFNlZ21lbnQgPCBob2lzdGFibGVDaHVua3MkanNjb21wJDAubGVuZ3RoO1xuICAgICAgICAgICAgY29tcGxldGVkUm9vdFNlZ21lbnQrK1xuICAgICAgICAgIClcbiAgICAgICAgICAgIHdyaXRlQ2h1bmsoXG4gICAgICAgICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICAgICAgICBob2lzdGFibGVDaHVua3MkanNjb21wJDBbY29tcGxldGVkUm9vdFNlZ21lbnRdXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGhvaXN0YWJsZUNodW5rcyRqc2NvbXAkMC5sZW5ndGggPSAwO1xuICAgICAgICAgIHZhciBjbGllbnRSZW5kZXJlZEJvdW5kYXJpZXMgPSByZXF1ZXN0LmNsaWVudFJlbmRlcmVkQm91bmRhcmllcztcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYm91bmRhcnkgPSBjbGllbnRSZW5kZXJlZEJvdW5kYXJpZXNbaV07XG4gICAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMSA9IGRlc3RpbmF0aW9uO1xuICAgICAgICAgICAgdmFyIHJlc3VtYWJsZVN0YXRlJGpzY29tcCQxID0gcmVxdWVzdC5yZXN1bWFibGVTdGF0ZSxcbiAgICAgICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDIgPSByZXF1ZXN0LnJlbmRlclN0YXRlLFxuICAgICAgICAgICAgICBpZCA9IGJvdW5kYXJ5LnJvb3RTZWdtZW50SUQsXG4gICAgICAgICAgICAgIGVycm9yRGlnZXN0ID0gYm91bmRhcnkuZXJyb3JEaWdlc3QsXG4gICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IGJvdW5kYXJ5LmVycm9yTWVzc2FnZSxcbiAgICAgICAgICAgICAgZXJyb3JTdGFjayA9IGJvdW5kYXJ5LmVycm9yU3RhY2ssXG4gICAgICAgICAgICAgIGVycm9yQ29tcG9uZW50U3RhY2sgPSBib3VuZGFyeS5lcnJvckNvbXBvbmVudFN0YWNrO1xuICAgICAgICAgICAgd3JpdGVDaHVuayhcbiAgICAgICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDEsXG4gICAgICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQyLnN0YXJ0SW5saW5lU2NyaXB0XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgd3JpdGVDaHVuayhyZW5kZXJTdGF0ZSRqc2NvbXAkMSwgZW5kT2ZTdGFydFRhZyk7XG4gICAgICAgICAgICAocmVzdW1hYmxlU3RhdGUkanNjb21wJDEuaW5zdHJ1Y3Rpb25zICZcbiAgICAgICAgICAgICAgU2VudENsaWVudFJlbmRlckZ1bmN0aW9uKSA9PT1cbiAgICAgICAgICAgIE5vdGhpbmdTZW50XG4gICAgICAgICAgICAgID8gKChyZXN1bWFibGVTdGF0ZSRqc2NvbXAkMS5pbnN0cnVjdGlvbnMgfD1cbiAgICAgICAgICAgICAgICAgIFNlbnRDbGllbnRSZW5kZXJGdW5jdGlvbiksXG4gICAgICAgICAgICAgICAgd3JpdGVDaHVuayhyZW5kZXJTdGF0ZSRqc2NvbXAkMSwgY2xpZW50UmVuZGVyU2NyaXB0MUZ1bGwpKVxuICAgICAgICAgICAgICA6IHdyaXRlQ2h1bmsocmVuZGVyU3RhdGUkanNjb21wJDEsIGNsaWVudFJlbmRlclNjcmlwdDFQYXJ0aWFsKTtcbiAgICAgICAgICAgIHdyaXRlQ2h1bmsoXG4gICAgICAgICAgICAgIHJlbmRlclN0YXRlJGpzY29tcCQxLFxuICAgICAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMi5ib3VuZGFyeVByZWZpeFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHdyaXRlQ2h1bmsocmVuZGVyU3RhdGUkanNjb21wJDEsIHN0cmluZ1RvQ2h1bmsoaWQudG9TdHJpbmcoMTYpKSk7XG4gICAgICAgICAgICB3cml0ZUNodW5rKHJlbmRlclN0YXRlJGpzY29tcCQxLCBjbGllbnRSZW5kZXJTY3JpcHQxQSk7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIGVycm9yRGlnZXN0IHx8XG4gICAgICAgICAgICAgIGVycm9yTWVzc2FnZSB8fFxuICAgICAgICAgICAgICBlcnJvclN0YWNrIHx8XG4gICAgICAgICAgICAgIGVycm9yQ29tcG9uZW50U3RhY2tcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgd3JpdGVDaHVuayhcbiAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMSxcbiAgICAgICAgICAgICAgICBjbGllbnRSZW5kZXJFcnJvclNjcmlwdEFyZ0ludGVyc3RpdGlhbFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIHdyaXRlQ2h1bmsoXG4gICAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMSxcbiAgICAgICAgICAgICAgICAgIHN0cmluZ1RvQ2h1bmsoXG4gICAgICAgICAgICAgICAgICAgIGVzY2FwZUpTU3RyaW5nc0Zvckluc3RydWN0aW9uU2NyaXB0cyhlcnJvckRpZ2VzdCB8fCBcIlwiKVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoZXJyb3JNZXNzYWdlIHx8IGVycm9yU3RhY2sgfHwgZXJyb3JDb21wb25lbnRTdGFjaylcbiAgICAgICAgICAgICAgd3JpdGVDaHVuayhcbiAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMSxcbiAgICAgICAgICAgICAgICBjbGllbnRSZW5kZXJFcnJvclNjcmlwdEFyZ0ludGVyc3RpdGlhbFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIHdyaXRlQ2h1bmsoXG4gICAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMSxcbiAgICAgICAgICAgICAgICAgIHN0cmluZ1RvQ2h1bmsoXG4gICAgICAgICAgICAgICAgICAgIGVzY2FwZUpTU3RyaW5nc0Zvckluc3RydWN0aW9uU2NyaXB0cyhlcnJvck1lc3NhZ2UgfHwgXCJcIilcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKGVycm9yU3RhY2sgfHwgZXJyb3JDb21wb25lbnRTdGFjaylcbiAgICAgICAgICAgICAgd3JpdGVDaHVuayhcbiAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMSxcbiAgICAgICAgICAgICAgICBjbGllbnRSZW5kZXJFcnJvclNjcmlwdEFyZ0ludGVyc3RpdGlhbFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIHdyaXRlQ2h1bmsoXG4gICAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMSxcbiAgICAgICAgICAgICAgICAgIHN0cmluZ1RvQ2h1bmsoXG4gICAgICAgICAgICAgICAgICAgIGVzY2FwZUpTU3RyaW5nc0Zvckluc3RydWN0aW9uU2NyaXB0cyhlcnJvclN0YWNrIHx8IFwiXCIpXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGVycm9yQ29tcG9uZW50U3RhY2sgJiZcbiAgICAgICAgICAgICAgKHdyaXRlQ2h1bmsoXG4gICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUkanNjb21wJDEsXG4gICAgICAgICAgICAgICAgY2xpZW50UmVuZGVyRXJyb3JTY3JpcHRBcmdJbnRlcnN0aXRpYWxcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgd3JpdGVDaHVuayhcbiAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMSxcbiAgICAgICAgICAgICAgICBzdHJpbmdUb0NodW5rKFxuICAgICAgICAgICAgICAgICAgZXNjYXBlSlNTdHJpbmdzRm9ySW5zdHJ1Y3Rpb25TY3JpcHRzKGVycm9yQ29tcG9uZW50U3RhY2spXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSB3cml0ZUNodW5rQW5kUmV0dXJuKFxuICAgICAgICAgICAgICByZW5kZXJTdGF0ZSRqc2NvbXAkMSxcbiAgICAgICAgICAgICAgY2xpZW50UmVuZGVyU2NyaXB0RW5kXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKCFKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQpIHtcbiAgICAgICAgICAgICAgcmVxdWVzdC5kZXN0aW5hdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzLnNwbGljZSgwLCBpKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjbGllbnRSZW5kZXJlZEJvdW5kYXJpZXMuc3BsaWNlKDAsIGkpO1xuICAgICAgICAgIHZhciBjb21wbGV0ZWRCb3VuZGFyaWVzID0gcmVxdWVzdC5jb21wbGV0ZWRCb3VuZGFyaWVzO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb21wbGV0ZWRCb3VuZGFyaWVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAhZmx1c2hDb21wbGV0ZWRCb3VuZGFyeShcbiAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICAgICAgICAgIGNvbXBsZXRlZEJvdW5kYXJpZXNbaV1cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHJlcXVlc3QuZGVzdGluYXRpb24gPSBudWxsO1xuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgIGNvbXBsZXRlZEJvdW5kYXJpZXMuc3BsaWNlKDAsIGkpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY29tcGxldGVkQm91bmRhcmllcy5zcGxpY2UoMCwgaSk7XG4gICAgICAgICAgY29tcGxldGVXcml0aW5nKGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICBjdXJyZW50VmlldyA9IG5ldyBVaW50OEFycmF5KDIwNDgpO1xuICAgICAgICAgIHdyaXR0ZW5CeXRlcyA9IDA7XG4gICAgICAgICAgZmx1c2hpbmdQYXJ0aWFsQm91bmRhcmllcyA9ICEwO1xuICAgICAgICAgIHZhciBwYXJ0aWFsQm91bmRhcmllcyA9IHJlcXVlc3QucGFydGlhbEJvdW5kYXJpZXM7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhcnRpYWxCb3VuZGFyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhOiB7XG4gICAgICAgICAgICAgIGNsaWVudFJlbmRlcmVkQm91bmRhcmllcyA9IHJlcXVlc3Q7XG4gICAgICAgICAgICAgIGJvdW5kYXJ5ID0gZGVzdGluYXRpb247XG4gICAgICAgICAgICAgIHZhciBib3VuZGFyeSRqc2NvbXAkMCA9IHBhcnRpYWxCb3VuZGFyaWVzW2ldO1xuICAgICAgICAgICAgICBmbHVzaGVkQnl0ZVNpemUgPSBib3VuZGFyeSRqc2NvbXAkMC5ieXRlU2l6ZTtcbiAgICAgICAgICAgICAgdmFyIGNvbXBsZXRlZFNlZ21lbnRzID0gYm91bmRhcnkkanNjb21wJDAuY29tcGxldGVkU2VnbWVudHM7XG4gICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gMDtcbiAgICAgICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPCBjb21wbGV0ZWRTZWdtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0KytcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICFmbHVzaFBhcnRpYWxseUNvbXBsZXRlZFNlZ21lbnQoXG4gICAgICAgICAgICAgICAgICAgIGNsaWVudFJlbmRlcmVkQm91bmRhcmllcyxcbiAgICAgICAgICAgICAgICAgICAgYm91bmRhcnksXG4gICAgICAgICAgICAgICAgICAgIGJvdW5kYXJ5JGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZWRTZWdtZW50c1tKU0NvbXBpbGVyX2lubGluZV9yZXN1bHRdXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQrKztcbiAgICAgICAgICAgICAgICAgIGNvbXBsZXRlZFNlZ21lbnRzLnNwbGljZSgwLCBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMCA9ICExO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbXBsZXRlZFNlZ21lbnRzLnNwbGljZSgwLCBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQpO1xuICAgICAgICAgICAgICB2YXIgcm93ID0gYm91bmRhcnkkanNjb21wJDAucm93O1xuICAgICAgICAgICAgICBudWxsICE9PSByb3cgJiZcbiAgICAgICAgICAgICAgICByb3cudG9nZXRoZXIgJiZcbiAgICAgICAgICAgICAgICAxID09PSBib3VuZGFyeSRqc2NvbXAkMC5wZW5kaW5nVGFza3MgJiZcbiAgICAgICAgICAgICAgICAoMSA9PT0gcm93LnBlbmRpbmdUYXNrc1xuICAgICAgICAgICAgICAgICAgPyB1bmJsb2NrU3VzcGVuc2VMaXN0Um93KFxuICAgICAgICAgICAgICAgICAgICAgIGNsaWVudFJlbmRlcmVkQm91bmRhcmllcyxcbiAgICAgICAgICAgICAgICAgICAgICByb3csXG4gICAgICAgICAgICAgICAgICAgICAgcm93LmhvaXN0YWJsZXNcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgOiByb3cucGVuZGluZ1Rhc2tzLS0pO1xuICAgICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDAgPSB3cml0ZUhvaXN0YWJsZXNGb3JCb3VuZGFyeShcbiAgICAgICAgICAgICAgICBib3VuZGFyeSxcbiAgICAgICAgICAgICAgICBib3VuZGFyeSRqc2NvbXAkMC5jb250ZW50U3RhdGUsXG4gICAgICAgICAgICAgICAgY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzLnJlbmRlclN0YXRlXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIUpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMCkge1xuICAgICAgICAgICAgICByZXF1ZXN0LmRlc3RpbmF0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICBwYXJ0aWFsQm91bmRhcmllcy5zcGxpY2UoMCwgaSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcGFydGlhbEJvdW5kYXJpZXMuc3BsaWNlKDAsIGkpO1xuICAgICAgICAgIGZsdXNoaW5nUGFydGlhbEJvdW5kYXJpZXMgPSAhMTtcbiAgICAgICAgICB2YXIgbGFyZ2VCb3VuZGFyaWVzID0gcmVxdWVzdC5jb21wbGV0ZWRCb3VuZGFyaWVzO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsYXJnZUJvdW5kYXJpZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICFmbHVzaENvbXBsZXRlZEJvdW5kYXJ5KHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBsYXJnZUJvdW5kYXJpZXNbaV0pXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgcmVxdWVzdC5kZXN0aW5hdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgbGFyZ2VCb3VuZGFyaWVzLnNwbGljZSgwLCBpKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGxhcmdlQm91bmRhcmllcy5zcGxpY2UoMCwgaSk7XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIChmbHVzaGluZ1BhcnRpYWxCb3VuZGFyaWVzID0gITEpLFxuICAgICAgICAgIDAgPT09IHJlcXVlc3QuYWxsUGVuZGluZ1Rhc2tzICYmXG4gICAgICAgICAgMCA9PT0gcmVxdWVzdC5jbGllbnRSZW5kZXJlZEJvdW5kYXJpZXMubGVuZ3RoICYmXG4gICAgICAgICAgMCA9PT0gcmVxdWVzdC5jb21wbGV0ZWRCb3VuZGFyaWVzLmxlbmd0aFxuICAgICAgICAgICAgPyAoKHJlcXVlc3QuZmx1c2hTY2hlZHVsZWQgPSAhMSksXG4gICAgICAgICAgICAgIChpID0gcmVxdWVzdC5yZXN1bWFibGVTdGF0ZSksXG4gICAgICAgICAgICAgIGkuaGFzQm9keSAmJiB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBlbmRDaHVua0ZvclRhZyhcImJvZHlcIikpLFxuICAgICAgICAgICAgICBpLmhhc0h0bWwgJiYgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgZW5kQ2h1bmtGb3JUYWcoXCJodG1sXCIpKSxcbiAgICAgICAgICAgICAgY29tcGxldGVXcml0aW5nKGRlc3RpbmF0aW9uKSxcbiAgICAgICAgICAgICAgMCAhPT0gcmVxdWVzdC5hYm9ydGFibGVUYXNrcy5zaXplICYmXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiVGhlcmUgd2FzIHN0aWxsIGFib3J0YWJsZSB0YXNrIGF0IHRoZSByb290IHdoZW4gd2UgY2xvc2VkLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgKHJlcXVlc3Quc3RhdHVzID0gQ0xPU0VEKSxcbiAgICAgICAgICAgICAgZGVzdGluYXRpb24uY2xvc2UoKSxcbiAgICAgICAgICAgICAgKHJlcXVlc3QuZGVzdGluYXRpb24gPSBudWxsKSlcbiAgICAgICAgICAgIDogY29tcGxldGVXcml0aW5nKGRlc3RpbmF0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc3RhcnRXb3JrKHJlcXVlc3QpIHtcbiAgICAgIHJlcXVlc3QuZmx1c2hTY2hlZHVsZWQgPSBudWxsICE9PSByZXF1ZXN0LmRlc3RpbmF0aW9uO1xuICAgICAgc2NoZWR1bGVNaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcGVyZm9ybVdvcmsocmVxdWVzdCk7XG4gICAgICB9KTtcbiAgICAgIHNjaGVkdWxlV29yayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIDEwID09PSByZXF1ZXN0LnN0YXR1cyAmJiAocmVxdWVzdC5zdGF0dXMgPSAxMSk7XG4gICAgICAgIG51bGwgPT09IHJlcXVlc3QudHJhY2tlZFBvc3Rwb25lcyAmJlxuICAgICAgICAgIHNhZmVseUVtaXRFYXJseVByZWxvYWRzKHJlcXVlc3QsIDAgPT09IHJlcXVlc3QucGVuZGluZ1Jvb3RUYXNrcyk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW5xdWV1ZUZsdXNoKHJlcXVlc3QpIHtcbiAgICAgICExID09PSByZXF1ZXN0LmZsdXNoU2NoZWR1bGVkICYmXG4gICAgICAgIDAgPT09IHJlcXVlc3QucGluZ2VkVGFza3MubGVuZ3RoICYmXG4gICAgICAgIG51bGwgIT09IHJlcXVlc3QuZGVzdGluYXRpb24gJiZcbiAgICAgICAgKChyZXF1ZXN0LmZsdXNoU2NoZWR1bGVkID0gITApLFxuICAgICAgICBzY2hlZHVsZVdvcmsoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHJlcXVlc3QuZGVzdGluYXRpb247XG4gICAgICAgICAgZGVzdGluYXRpb25cbiAgICAgICAgICAgID8gZmx1c2hDb21wbGV0ZWRRdWV1ZXMocmVxdWVzdCwgZGVzdGluYXRpb24pXG4gICAgICAgICAgICA6IChyZXF1ZXN0LmZsdXNoU2NoZWR1bGVkID0gITEpO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0YXJ0Rmxvd2luZyhyZXF1ZXN0LCBkZXN0aW5hdGlvbikge1xuICAgICAgaWYgKDEzID09PSByZXF1ZXN0LnN0YXR1cylcbiAgICAgICAgKHJlcXVlc3Quc3RhdHVzID0gQ0xPU0VEKSxcbiAgICAgICAgICBjbG9zZVdpdGhFcnJvcihkZXN0aW5hdGlvbiwgcmVxdWVzdC5mYXRhbEVycm9yKTtcbiAgICAgIGVsc2UgaWYgKHJlcXVlc3Quc3RhdHVzICE9PSBDTE9TRUQgJiYgbnVsbCA9PT0gcmVxdWVzdC5kZXN0aW5hdGlvbikge1xuICAgICAgICByZXF1ZXN0LmRlc3RpbmF0aW9uID0gZGVzdGluYXRpb247XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZmx1c2hDb21wbGV0ZWRRdWV1ZXMocmVxdWVzdCwgZGVzdGluYXRpb24pO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIChkZXN0aW5hdGlvbiA9IHt9KSxcbiAgICAgICAgICAgIGxvZ1JlY292ZXJhYmxlRXJyb3IocmVxdWVzdCwgZXJyb3IsIGRlc3RpbmF0aW9uLCBudWxsKSxcbiAgICAgICAgICAgIGZhdGFsRXJyb3IocmVxdWVzdCwgZXJyb3IsIGRlc3RpbmF0aW9uLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBhYm9ydChyZXF1ZXN0LCByZWFzb24pIHtcbiAgICAgIGlmICgxMSA9PT0gcmVxdWVzdC5zdGF0dXMgfHwgMTAgPT09IHJlcXVlc3Quc3RhdHVzKSByZXF1ZXN0LnN0YXR1cyA9IDEyO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGFib3J0YWJsZVRhc2tzID0gcmVxdWVzdC5hYm9ydGFibGVUYXNrcztcbiAgICAgICAgaWYgKDAgPCBhYm9ydGFibGVUYXNrcy5zaXplKSB7XG4gICAgICAgICAgdmFyIGVycm9yID1cbiAgICAgICAgICAgIHZvaWQgMCA9PT0gcmVhc29uXG4gICAgICAgICAgICAgID8gRXJyb3IoXCJUaGUgcmVuZGVyIHdhcyBhYm9ydGVkIGJ5IHRoZSBzZXJ2ZXIgd2l0aG91dCBhIHJlYXNvbi5cIilcbiAgICAgICAgICAgICAgOiBcIm9iamVjdFwiID09PSB0eXBlb2YgcmVhc29uICYmXG4gICAgICAgICAgICAgICAgICBudWxsICE9PSByZWFzb24gJiZcbiAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHJlYXNvbi50aGVuXG4gICAgICAgICAgICAgICAgPyBFcnJvcihcIlRoZSByZW5kZXIgd2FzIGFib3J0ZWQgYnkgdGhlIHNlcnZlciB3aXRoIGEgcHJvbWlzZS5cIilcbiAgICAgICAgICAgICAgICA6IHJlYXNvbjtcbiAgICAgICAgICByZXF1ZXN0LmZhdGFsRXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICBhYm9ydGFibGVUYXNrcy5mb3JFYWNoKGZ1bmN0aW9uICh0YXNrKSB7XG4gICAgICAgICAgICB2YXIgcHJldlRhc2tJbkRFViA9IGN1cnJlbnRUYXNrSW5ERVYsXG4gICAgICAgICAgICAgIHByZXZHZXRDdXJyZW50U3RhY2tJbXBsID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuZ2V0Q3VycmVudFN0YWNrO1xuICAgICAgICAgICAgY3VycmVudFRhc2tJbkRFViA9IHRhc2s7XG4gICAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5nZXRDdXJyZW50U3RhY2sgPSBnZXRDdXJyZW50U3RhY2tJbkRFVjtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGFib3J0VGFzayh0YXNrLCByZXF1ZXN0LCBlcnJvcik7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAoY3VycmVudFRhc2tJbkRFViA9IHByZXZUYXNrSW5ERVYpLFxuICAgICAgICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5nZXRDdXJyZW50U3RhY2sgPVxuICAgICAgICAgICAgICAgICAgcHJldkdldEN1cnJlbnRTdGFja0ltcGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGFib3J0YWJsZVRhc2tzLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgbnVsbCAhPT0gcmVxdWVzdC5kZXN0aW5hdGlvbiAmJlxuICAgICAgICAgIGZsdXNoQ29tcGxldGVkUXVldWVzKHJlcXVlc3QsIHJlcXVlc3QuZGVzdGluYXRpb24pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IkNCkge1xuICAgICAgICAocmVhc29uID0ge30pLFxuICAgICAgICAgIGxvZ1JlY292ZXJhYmxlRXJyb3IocmVxdWVzdCwgZXJyb3IkNCwgcmVhc29uLCBudWxsKSxcbiAgICAgICAgICBmYXRhbEVycm9yKHJlcXVlc3QsIGVycm9yJDQsIHJlYXNvbiwgbnVsbCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkZFRvUmVwbGF5UGFyZW50KG5vZGUsIHBhcmVudEtleVBhdGgsIHRyYWNrZWRQb3N0cG9uZXMpIHtcbiAgICAgIGlmIChudWxsID09PSBwYXJlbnRLZXlQYXRoKSB0cmFja2VkUG9zdHBvbmVzLnJvb3ROb2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciB3b3JraW5nTWFwID0gdHJhY2tlZFBvc3Rwb25lcy53b3JraW5nTWFwLFxuICAgICAgICAgIHBhcmVudE5vZGUgPSB3b3JraW5nTWFwLmdldChwYXJlbnRLZXlQYXRoKTtcbiAgICAgICAgdm9pZCAwID09PSBwYXJlbnROb2RlICYmXG4gICAgICAgICAgKChwYXJlbnROb2RlID0gW3BhcmVudEtleVBhdGhbMV0sIHBhcmVudEtleVBhdGhbMl0sIFtdLCBudWxsXSksXG4gICAgICAgICAgd29ya2luZ01hcC5zZXQocGFyZW50S2V5UGF0aCwgcGFyZW50Tm9kZSksXG4gICAgICAgICAgYWRkVG9SZXBsYXlQYXJlbnQocGFyZW50Tm9kZSwgcGFyZW50S2V5UGF0aFswXSwgdHJhY2tlZFBvc3Rwb25lcykpO1xuICAgICAgICBwYXJlbnROb2RlWzJdLnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFBvc3Rwb25lZFN0YXRlKHJlcXVlc3QpIHtcbiAgICAgIHZhciB0cmFja2VkUG9zdHBvbmVzID0gcmVxdWVzdC50cmFja2VkUG9zdHBvbmVzO1xuICAgICAgaWYgKFxuICAgICAgICBudWxsID09PSB0cmFja2VkUG9zdHBvbmVzIHx8XG4gICAgICAgICgwID09PSB0cmFja2VkUG9zdHBvbmVzLnJvb3ROb2Rlcy5sZW5ndGggJiZcbiAgICAgICAgICBudWxsID09PSB0cmFja2VkUG9zdHBvbmVzLnJvb3RTbG90cylcbiAgICAgIClcbiAgICAgICAgcmV0dXJuIChyZXF1ZXN0LnRyYWNrZWRQb3N0cG9uZXMgPSBudWxsKTtcbiAgICAgIGlmIChcbiAgICAgICAgbnVsbCA9PT0gcmVxdWVzdC5jb21wbGV0ZWRSb290U2VnbWVudCB8fFxuICAgICAgICAocmVxdWVzdC5jb21wbGV0ZWRSb290U2VnbWVudC5zdGF0dXMgIT09IFBPU1RQT05FRCAmJlxuICAgICAgICAgIG51bGwgIT09IHJlcXVlc3QuY29tcGxldGVkUHJlYW1ibGVTZWdtZW50cylcbiAgICAgICkge1xuICAgICAgICB2YXIgbmV4dFNlZ21lbnRJZCA9IHJlcXVlc3QubmV4dFNlZ21lbnRJZDtcbiAgICAgICAgdmFyIHJlcGxheVNsb3RzID0gdHJhY2tlZFBvc3Rwb25lcy5yb290U2xvdHM7XG4gICAgICAgIHZhciByZXN1bWFibGVTdGF0ZSA9IHJlcXVlc3QucmVzdW1hYmxlU3RhdGU7XG4gICAgICAgIHJlc3VtYWJsZVN0YXRlLmJvb3RzdHJhcFNjcmlwdENvbnRlbnQgPSB2b2lkIDA7XG4gICAgICAgIHJlc3VtYWJsZVN0YXRlLmJvb3RzdHJhcFNjcmlwdHMgPSB2b2lkIDA7XG4gICAgICAgIHJlc3VtYWJsZVN0YXRlLmJvb3RzdHJhcE1vZHVsZXMgPSB2b2lkIDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0U2VnbWVudElkID0gMDtcbiAgICAgICAgcmVwbGF5U2xvdHMgPSAtMTtcbiAgICAgICAgcmVzdW1hYmxlU3RhdGUgPSByZXF1ZXN0LnJlc3VtYWJsZVN0YXRlO1xuICAgICAgICB2YXIgcmVuZGVyU3RhdGUgPSByZXF1ZXN0LnJlbmRlclN0YXRlO1xuICAgICAgICByZXN1bWFibGVTdGF0ZS5uZXh0Rm9ybUlEID0gMDtcbiAgICAgICAgcmVzdW1hYmxlU3RhdGUuaGFzQm9keSA9ICExO1xuICAgICAgICByZXN1bWFibGVTdGF0ZS5oYXNIdG1sID0gITE7XG4gICAgICAgIHJlc3VtYWJsZVN0YXRlLnVua25vd25SZXNvdXJjZXMgPSB7IGZvbnQ6IHJlbmRlclN0YXRlLnJlc2V0cy5mb250IH07XG4gICAgICAgIHJlc3VtYWJsZVN0YXRlLmRuc1Jlc291cmNlcyA9IHJlbmRlclN0YXRlLnJlc2V0cy5kbnM7XG4gICAgICAgIHJlc3VtYWJsZVN0YXRlLmNvbm5lY3RSZXNvdXJjZXMgPSByZW5kZXJTdGF0ZS5yZXNldHMuY29ubmVjdDtcbiAgICAgICAgcmVzdW1hYmxlU3RhdGUuaW1hZ2VSZXNvdXJjZXMgPSByZW5kZXJTdGF0ZS5yZXNldHMuaW1hZ2U7XG4gICAgICAgIHJlc3VtYWJsZVN0YXRlLnN0eWxlUmVzb3VyY2VzID0gcmVuZGVyU3RhdGUucmVzZXRzLnN0eWxlO1xuICAgICAgICByZXN1bWFibGVTdGF0ZS5zY3JpcHRSZXNvdXJjZXMgPSB7fTtcbiAgICAgICAgcmVzdW1hYmxlU3RhdGUubW9kdWxlVW5rbm93blJlc291cmNlcyA9IHt9O1xuICAgICAgICByZXN1bWFibGVTdGF0ZS5tb2R1bGVTY3JpcHRSZXNvdXJjZXMgPSB7fTtcbiAgICAgICAgcmVzdW1hYmxlU3RhdGUuaW5zdHJ1Y3Rpb25zID0gTm90aGluZ1NlbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuZXh0U2VnbWVudElkOiBuZXh0U2VnbWVudElkLFxuICAgICAgICByb290Rm9ybWF0Q29udGV4dDogcmVxdWVzdC5yb290Rm9ybWF0Q29udGV4dCxcbiAgICAgICAgcHJvZ3Jlc3NpdmVDaHVua1NpemU6IHJlcXVlc3QucHJvZ3Jlc3NpdmVDaHVua1NpemUsXG4gICAgICAgIHJlc3VtYWJsZVN0YXRlOiByZXF1ZXN0LnJlc3VtYWJsZVN0YXRlLFxuICAgICAgICByZXBsYXlOb2RlczogdHJhY2tlZFBvc3Rwb25lcy5yb290Tm9kZXMsXG4gICAgICAgIHJlcGxheVNsb3RzOiByZXBsYXlTbG90c1xuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW5zdXJlQ29ycmVjdElzb21vcnBoaWNSZWFjdFZlcnNpb24oKSB7XG4gICAgICB2YXIgaXNvbW9ycGhpY1JlYWN0UGFja2FnZVZlcnNpb24gPSBSZWFjdC52ZXJzaW9uO1xuICAgICAgaWYgKFwiMTkuMi4wXCIgIT09IGlzb21vcnBoaWNSZWFjdFBhY2thZ2VWZXJzaW9uKVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAnSW5jb21wYXRpYmxlIFJlYWN0IHZlcnNpb25zOiBUaGUgXCJyZWFjdFwiIGFuZCBcInJlYWN0LWRvbVwiIHBhY2thZ2VzIG11c3QgaGF2ZSB0aGUgZXhhY3Qgc2FtZSB2ZXJzaW9uLiBJbnN0ZWFkIGdvdDpcXG4gIC0gcmVhY3Q6ICAgICAgJyArXG4gICAgICAgICAgICAoaXNvbW9ycGhpY1JlYWN0UGFja2FnZVZlcnNpb24gK1xuICAgICAgICAgICAgICBcIlxcbiAgLSByZWFjdC1kb206ICAxOS4yLjBcXG5MZWFybiBtb3JlOiBodHRwczovL3JlYWN0LmRldi93YXJuaW5ncy92ZXJzaW9uLW1pc21hdGNoXCIpXG4gICAgICAgICk7XG4gICAgfVxuICAgIHZhciBSZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKSxcbiAgICAgIFJlYWN0RE9NID0gcmVxdWlyZShcInJlYWN0LWRvbVwiKSxcbiAgICAgIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC50cmFuc2l0aW9uYWwuZWxlbWVudFwiKSxcbiAgICAgIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKSxcbiAgICAgIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIiksXG4gICAgICBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN0cmljdF9tb2RlXCIpLFxuICAgICAgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKSxcbiAgICAgIFJFQUNUX0NPTlNVTUVSX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29uc3VtZXJcIiksXG4gICAgICBSRUFDVF9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29udGV4dFwiKSxcbiAgICAgIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIiksXG4gICAgICBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpLFxuICAgICAgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlX2xpc3RcIiksXG4gICAgICBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb1wiKSxcbiAgICAgIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5sYXp5XCIpLFxuICAgICAgUkVBQ1RfU0NPUEVfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zY29wZVwiKSxcbiAgICAgIFJFQUNUX0FDVElWSVRZX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuYWN0aXZpdHlcIiksXG4gICAgICBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QubGVnYWN5X2hpZGRlblwiKSxcbiAgICAgIFJFQUNUX01FTU9fQ0FDSEVfU0VOVElORUwgPSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb19jYWNoZV9zZW50aW5lbFwiKSxcbiAgICAgIFJFQUNUX1ZJRVdfVFJBTlNJVElPTl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnZpZXdfdHJhbnNpdGlvblwiKSxcbiAgICAgIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcixcbiAgICAgIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheSxcbiAgICAgIGpzeFByb3BzUGFyZW50cyA9IG5ldyBXZWFrTWFwKCksXG4gICAgICBqc3hDaGlsZHJlblBhcmVudHMgPSBuZXcgV2Vha01hcCgpLFxuICAgICAgQ0xJRU5UX1JFRkVSRU5DRV9UQUcgPSBTeW1ib2wuZm9yKFwicmVhY3QuY2xpZW50LnJlZmVyZW5jZVwiKSxcbiAgICAgIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKSxcbiAgICAgIHRhc2tRdWV1ZSA9IFtdO1xuICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRhc2sgPSB0YXNrUXVldWUuc2hpZnQoKTtcbiAgICAgIHRhc2sgJiYgdGFzaygpO1xuICAgIH07XG4gICAgdmFyIExvY2FsUHJvbWlzZSA9IFByb21pc2UsXG4gICAgICBzY2hlZHVsZU1pY3JvdGFzayA9XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHF1ZXVlTWljcm90YXNrXG4gICAgICAgICAgPyBxdWV1ZU1pY3JvdGFza1xuICAgICAgICAgIDogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIExvY2FsUHJvbWlzZS5yZXNvbHZlKG51bGwpXG4gICAgICAgICAgICAgICAgLnRoZW4oY2FsbGJhY2spXG4gICAgICAgICAgICAgICAgLmNhdGNoKGhhbmRsZUVycm9ySW5OZXh0VGljayk7XG4gICAgICAgICAgICB9LFxuICAgICAgY3VycmVudFZpZXcgPSBudWxsLFxuICAgICAgd3JpdHRlbkJ5dGVzID0gMCxcbiAgICAgIHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCksXG4gICAgICBhc3NpZ24gPSBPYmplY3QuYXNzaWduLFxuICAgICAgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LFxuICAgICAgVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVggPSBSZWdFeHAoXG4gICAgICAgIFwiXls6QS1aX2EtelxcXFx1MDBDMC1cXFxcdTAwRDZcXFxcdTAwRDgtXFxcXHUwMEY2XFxcXHUwMEY4LVxcXFx1MDJGRlxcXFx1MDM3MC1cXFxcdTAzN0RcXFxcdTAzN0YtXFxcXHUxRkZGXFxcXHUyMDBDLVxcXFx1MjAwRFxcXFx1MjA3MC1cXFxcdTIxOEZcXFxcdTJDMDAtXFxcXHUyRkVGXFxcXHUzMDAxLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkZEXVs6QS1aX2EtelxcXFx1MDBDMC1cXFxcdTAwRDZcXFxcdTAwRDgtXFxcXHUwMEY2XFxcXHUwMEY4LVxcXFx1MDJGRlxcXFx1MDM3MC1cXFxcdTAzN0RcXFxcdTAzN0YtXFxcXHUxRkZGXFxcXHUyMDBDLVxcXFx1MjAwRFxcXFx1MjA3MC1cXFxcdTIxOEZcXFxcdTJDMDAtXFxcXHUyRkVGXFxcXHUzMDAxLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkZEXFxcXC0uMC05XFxcXHUwMEI3XFxcXHUwMzAwLVxcXFx1MDM2RlxcXFx1MjAzRi1cXFxcdTIwNDBdKiRcIlxuICAgICAgKSxcbiAgICAgIGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUgPSB7fSxcbiAgICAgIHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9LFxuICAgICAgdW5pdGxlc3NOdW1iZXJzID0gbmV3IFNldChcbiAgICAgICAgXCJhbmltYXRpb25JdGVyYXRpb25Db3VudCBhc3BlY3RSYXRpbyBib3JkZXJJbWFnZU91dHNldCBib3JkZXJJbWFnZVNsaWNlIGJvcmRlckltYWdlV2lkdGggYm94RmxleCBib3hGbGV4R3JvdXAgYm94T3JkaW5hbEdyb3VwIGNvbHVtbkNvdW50IGNvbHVtbnMgZmxleCBmbGV4R3JvdyBmbGV4UG9zaXRpdmUgZmxleFNocmluayBmbGV4TmVnYXRpdmUgZmxleE9yZGVyIGdyaWRBcmVhIGdyaWRSb3cgZ3JpZFJvd0VuZCBncmlkUm93U3BhbiBncmlkUm93U3RhcnQgZ3JpZENvbHVtbiBncmlkQ29sdW1uRW5kIGdyaWRDb2x1bW5TcGFuIGdyaWRDb2x1bW5TdGFydCBmb250V2VpZ2h0IGxpbmVDbGFtcCBsaW5lSGVpZ2h0IG9wYWNpdHkgb3JkZXIgb3JwaGFucyBzY2FsZSB0YWJTaXplIHdpZG93cyB6SW5kZXggem9vbSBmaWxsT3BhY2l0eSBmbG9vZE9wYWNpdHkgc3RvcE9wYWNpdHkgc3Ryb2tlRGFzaGFycmF5IHN0cm9rZURhc2hvZmZzZXQgc3Ryb2tlTWl0ZXJsaW1pdCBzdHJva2VPcGFjaXR5IHN0cm9rZVdpZHRoIE1vekFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50IE1vekJveEZsZXggTW96Qm94RmxleEdyb3VwIE1vekxpbmVDbGFtcCBtc0FuaW1hdGlvbkl0ZXJhdGlvbkNvdW50IG1zRmxleCBtc1pvb20gbXNGbGV4R3JvdyBtc0ZsZXhOZWdhdGl2ZSBtc0ZsZXhPcmRlciBtc0ZsZXhQb3NpdGl2ZSBtc0ZsZXhTaHJpbmsgbXNHcmlkQ29sdW1uIG1zR3JpZENvbHVtblNwYW4gbXNHcmlkUm93IG1zR3JpZFJvd1NwYW4gV2Via2l0QW5pbWF0aW9uSXRlcmF0aW9uQ291bnQgV2Via2l0Qm94RmxleCBXZWJLaXRCb3hGbGV4R3JvdXAgV2Via2l0Qm94T3JkaW5hbEdyb3VwIFdlYmtpdENvbHVtbkNvdW50IFdlYmtpdENvbHVtbnMgV2Via2l0RmxleCBXZWJraXRGbGV4R3JvdyBXZWJraXRGbGV4UG9zaXRpdmUgV2Via2l0RmxleFNocmluayBXZWJraXRMaW5lQ2xhbXBcIi5zcGxpdChcbiAgICAgICAgICBcIiBcIlxuICAgICAgICApXG4gICAgICApLFxuICAgICAgYWxpYXNlcyA9IG5ldyBNYXAoW1xuICAgICAgICBbXCJhY2NlcHRDaGFyc2V0XCIsIFwiYWNjZXB0LWNoYXJzZXRcIl0sXG4gICAgICAgIFtcImh0bWxGb3JcIiwgXCJmb3JcIl0sXG4gICAgICAgIFtcImh0dHBFcXVpdlwiLCBcImh0dHAtZXF1aXZcIl0sXG4gICAgICAgIFtcImNyb3NzT3JpZ2luXCIsIFwiY3Jvc3NvcmlnaW5cIl0sXG4gICAgICAgIFtcImFjY2VudEhlaWdodFwiLCBcImFjY2VudC1oZWlnaHRcIl0sXG4gICAgICAgIFtcImFsaWdubWVudEJhc2VsaW5lXCIsIFwiYWxpZ25tZW50LWJhc2VsaW5lXCJdLFxuICAgICAgICBbXCJhcmFiaWNGb3JtXCIsIFwiYXJhYmljLWZvcm1cIl0sXG4gICAgICAgIFtcImJhc2VsaW5lU2hpZnRcIiwgXCJiYXNlbGluZS1zaGlmdFwiXSxcbiAgICAgICAgW1wiY2FwSGVpZ2h0XCIsIFwiY2FwLWhlaWdodFwiXSxcbiAgICAgICAgW1wiY2xpcFBhdGhcIiwgXCJjbGlwLXBhdGhcIl0sXG4gICAgICAgIFtcImNsaXBSdWxlXCIsIFwiY2xpcC1ydWxlXCJdLFxuICAgICAgICBbXCJjb2xvckludGVycG9sYXRpb25cIiwgXCJjb2xvci1pbnRlcnBvbGF0aW9uXCJdLFxuICAgICAgICBbXCJjb2xvckludGVycG9sYXRpb25GaWx0ZXJzXCIsIFwiY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzXCJdLFxuICAgICAgICBbXCJjb2xvclByb2ZpbGVcIiwgXCJjb2xvci1wcm9maWxlXCJdLFxuICAgICAgICBbXCJjb2xvclJlbmRlcmluZ1wiLCBcImNvbG9yLXJlbmRlcmluZ1wiXSxcbiAgICAgICAgW1wiZG9taW5hbnRCYXNlbGluZVwiLCBcImRvbWluYW50LWJhc2VsaW5lXCJdLFxuICAgICAgICBbXCJlbmFibGVCYWNrZ3JvdW5kXCIsIFwiZW5hYmxlLWJhY2tncm91bmRcIl0sXG4gICAgICAgIFtcImZpbGxPcGFjaXR5XCIsIFwiZmlsbC1vcGFjaXR5XCJdLFxuICAgICAgICBbXCJmaWxsUnVsZVwiLCBcImZpbGwtcnVsZVwiXSxcbiAgICAgICAgW1wiZmxvb2RDb2xvclwiLCBcImZsb29kLWNvbG9yXCJdLFxuICAgICAgICBbXCJmbG9vZE9wYWNpdHlcIiwgXCJmbG9vZC1vcGFjaXR5XCJdLFxuICAgICAgICBbXCJmb250RmFtaWx5XCIsIFwiZm9udC1mYW1pbHlcIl0sXG4gICAgICAgIFtcImZvbnRTaXplXCIsIFwiZm9udC1zaXplXCJdLFxuICAgICAgICBbXCJmb250U2l6ZUFkanVzdFwiLCBcImZvbnQtc2l6ZS1hZGp1c3RcIl0sXG4gICAgICAgIFtcImZvbnRTdHJldGNoXCIsIFwiZm9udC1zdHJldGNoXCJdLFxuICAgICAgICBbXCJmb250U3R5bGVcIiwgXCJmb250LXN0eWxlXCJdLFxuICAgICAgICBbXCJmb250VmFyaWFudFwiLCBcImZvbnQtdmFyaWFudFwiXSxcbiAgICAgICAgW1wiZm9udFdlaWdodFwiLCBcImZvbnQtd2VpZ2h0XCJdLFxuICAgICAgICBbXCJnbHlwaE5hbWVcIiwgXCJnbHlwaC1uYW1lXCJdLFxuICAgICAgICBbXCJnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbFwiLCBcImdseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWxcIl0sXG4gICAgICAgIFtcImdseXBoT3JpZW50YXRpb25WZXJ0aWNhbFwiLCBcImdseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsXCJdLFxuICAgICAgICBbXCJob3JpekFkdlhcIiwgXCJob3Jpei1hZHYteFwiXSxcbiAgICAgICAgW1wiaG9yaXpPcmlnaW5YXCIsIFwiaG9yaXotb3JpZ2luLXhcIl0sXG4gICAgICAgIFtcImltYWdlUmVuZGVyaW5nXCIsIFwiaW1hZ2UtcmVuZGVyaW5nXCJdLFxuICAgICAgICBbXCJsZXR0ZXJTcGFjaW5nXCIsIFwibGV0dGVyLXNwYWNpbmdcIl0sXG4gICAgICAgIFtcImxpZ2h0aW5nQ29sb3JcIiwgXCJsaWdodGluZy1jb2xvclwiXSxcbiAgICAgICAgW1wibWFya2VyRW5kXCIsIFwibWFya2VyLWVuZFwiXSxcbiAgICAgICAgW1wibWFya2VyTWlkXCIsIFwibWFya2VyLW1pZFwiXSxcbiAgICAgICAgW1wibWFya2VyU3RhcnRcIiwgXCJtYXJrZXItc3RhcnRcIl0sXG4gICAgICAgIFtcIm92ZXJsaW5lUG9zaXRpb25cIiwgXCJvdmVybGluZS1wb3NpdGlvblwiXSxcbiAgICAgICAgW1wib3ZlcmxpbmVUaGlja25lc3NcIiwgXCJvdmVybGluZS10aGlja25lc3NcIl0sXG4gICAgICAgIFtcInBhaW50T3JkZXJcIiwgXCJwYWludC1vcmRlclwiXSxcbiAgICAgICAgW1wicGFub3NlLTFcIiwgXCJwYW5vc2UtMVwiXSxcbiAgICAgICAgW1wicG9pbnRlckV2ZW50c1wiLCBcInBvaW50ZXItZXZlbnRzXCJdLFxuICAgICAgICBbXCJyZW5kZXJpbmdJbnRlbnRcIiwgXCJyZW5kZXJpbmctaW50ZW50XCJdLFxuICAgICAgICBbXCJzaGFwZVJlbmRlcmluZ1wiLCBcInNoYXBlLXJlbmRlcmluZ1wiXSxcbiAgICAgICAgW1wic3RvcENvbG9yXCIsIFwic3RvcC1jb2xvclwiXSxcbiAgICAgICAgW1wic3RvcE9wYWNpdHlcIiwgXCJzdG9wLW9wYWNpdHlcIl0sXG4gICAgICAgIFtcInN0cmlrZXRocm91Z2hQb3NpdGlvblwiLCBcInN0cmlrZXRocm91Z2gtcG9zaXRpb25cIl0sXG4gICAgICAgIFtcInN0cmlrZXRocm91Z2hUaGlja25lc3NcIiwgXCJzdHJpa2V0aHJvdWdoLXRoaWNrbmVzc1wiXSxcbiAgICAgICAgW1wic3Ryb2tlRGFzaGFycmF5XCIsIFwic3Ryb2tlLWRhc2hhcnJheVwiXSxcbiAgICAgICAgW1wic3Ryb2tlRGFzaG9mZnNldFwiLCBcInN0cm9rZS1kYXNob2Zmc2V0XCJdLFxuICAgICAgICBbXCJzdHJva2VMaW5lY2FwXCIsIFwic3Ryb2tlLWxpbmVjYXBcIl0sXG4gICAgICAgIFtcInN0cm9rZUxpbmVqb2luXCIsIFwic3Ryb2tlLWxpbmVqb2luXCJdLFxuICAgICAgICBbXCJzdHJva2VNaXRlcmxpbWl0XCIsIFwic3Ryb2tlLW1pdGVybGltaXRcIl0sXG4gICAgICAgIFtcInN0cm9rZU9wYWNpdHlcIiwgXCJzdHJva2Utb3BhY2l0eVwiXSxcbiAgICAgICAgW1wic3Ryb2tlV2lkdGhcIiwgXCJzdHJva2Utd2lkdGhcIl0sXG4gICAgICAgIFtcInRleHRBbmNob3JcIiwgXCJ0ZXh0LWFuY2hvclwiXSxcbiAgICAgICAgW1widGV4dERlY29yYXRpb25cIiwgXCJ0ZXh0LWRlY29yYXRpb25cIl0sXG4gICAgICAgIFtcInRleHRSZW5kZXJpbmdcIiwgXCJ0ZXh0LXJlbmRlcmluZ1wiXSxcbiAgICAgICAgW1widHJhbnNmb3JtT3JpZ2luXCIsIFwidHJhbnNmb3JtLW9yaWdpblwiXSxcbiAgICAgICAgW1widW5kZXJsaW5lUG9zaXRpb25cIiwgXCJ1bmRlcmxpbmUtcG9zaXRpb25cIl0sXG4gICAgICAgIFtcInVuZGVybGluZVRoaWNrbmVzc1wiLCBcInVuZGVybGluZS10aGlja25lc3NcIl0sXG4gICAgICAgIFtcInVuaWNvZGVCaWRpXCIsIFwidW5pY29kZS1iaWRpXCJdLFxuICAgICAgICBbXCJ1bmljb2RlUmFuZ2VcIiwgXCJ1bmljb2RlLXJhbmdlXCJdLFxuICAgICAgICBbXCJ1bml0c1BlckVtXCIsIFwidW5pdHMtcGVyLWVtXCJdLFxuICAgICAgICBbXCJ2QWxwaGFiZXRpY1wiLCBcInYtYWxwaGFiZXRpY1wiXSxcbiAgICAgICAgW1widkhhbmdpbmdcIiwgXCJ2LWhhbmdpbmdcIl0sXG4gICAgICAgIFtcInZJZGVvZ3JhcGhpY1wiLCBcInYtaWRlb2dyYXBoaWNcIl0sXG4gICAgICAgIFtcInZNYXRoZW1hdGljYWxcIiwgXCJ2LW1hdGhlbWF0aWNhbFwiXSxcbiAgICAgICAgW1widmVjdG9yRWZmZWN0XCIsIFwidmVjdG9yLWVmZmVjdFwiXSxcbiAgICAgICAgW1widmVydEFkdllcIiwgXCJ2ZXJ0LWFkdi15XCJdLFxuICAgICAgICBbXCJ2ZXJ0T3JpZ2luWFwiLCBcInZlcnQtb3JpZ2luLXhcIl0sXG4gICAgICAgIFtcInZlcnRPcmlnaW5ZXCIsIFwidmVydC1vcmlnaW4teVwiXSxcbiAgICAgICAgW1wid29yZFNwYWNpbmdcIiwgXCJ3b3JkLXNwYWNpbmdcIl0sXG4gICAgICAgIFtcIndyaXRpbmdNb2RlXCIsIFwid3JpdGluZy1tb2RlXCJdLFxuICAgICAgICBbXCJ4bWxuc1hsaW5rXCIsIFwieG1sbnM6eGxpbmtcIl0sXG4gICAgICAgIFtcInhIZWlnaHRcIiwgXCJ4LWhlaWdodFwiXVxuICAgICAgXSksXG4gICAgICBoYXNSZWFkT25seVZhbHVlID0ge1xuICAgICAgICBidXR0b246ICEwLFxuICAgICAgICBjaGVja2JveDogITAsXG4gICAgICAgIGltYWdlOiAhMCxcbiAgICAgICAgaGlkZGVuOiAhMCxcbiAgICAgICAgcmFkaW86ICEwLFxuICAgICAgICByZXNldDogITAsXG4gICAgICAgIHN1Ym1pdDogITBcbiAgICAgIH0sXG4gICAgICBhcmlhUHJvcGVydGllcyA9IHtcbiAgICAgICAgXCJhcmlhLWN1cnJlbnRcIjogMCxcbiAgICAgICAgXCJhcmlhLWRlc2NyaXB0aW9uXCI6IDAsXG4gICAgICAgIFwiYXJpYS1kZXRhaWxzXCI6IDAsXG4gICAgICAgIFwiYXJpYS1kaXNhYmxlZFwiOiAwLFxuICAgICAgICBcImFyaWEtaGlkZGVuXCI6IDAsXG4gICAgICAgIFwiYXJpYS1pbnZhbGlkXCI6IDAsXG4gICAgICAgIFwiYXJpYS1rZXlzaG9ydGN1dHNcIjogMCxcbiAgICAgICAgXCJhcmlhLWxhYmVsXCI6IDAsXG4gICAgICAgIFwiYXJpYS1yb2xlZGVzY3JpcHRpb25cIjogMCxcbiAgICAgICAgXCJhcmlhLWF1dG9jb21wbGV0ZVwiOiAwLFxuICAgICAgICBcImFyaWEtY2hlY2tlZFwiOiAwLFxuICAgICAgICBcImFyaWEtZXhwYW5kZWRcIjogMCxcbiAgICAgICAgXCJhcmlhLWhhc3BvcHVwXCI6IDAsXG4gICAgICAgIFwiYXJpYS1sZXZlbFwiOiAwLFxuICAgICAgICBcImFyaWEtbW9kYWxcIjogMCxcbiAgICAgICAgXCJhcmlhLW11bHRpbGluZVwiOiAwLFxuICAgICAgICBcImFyaWEtbXVsdGlzZWxlY3RhYmxlXCI6IDAsXG4gICAgICAgIFwiYXJpYS1vcmllbnRhdGlvblwiOiAwLFxuICAgICAgICBcImFyaWEtcGxhY2Vob2xkZXJcIjogMCxcbiAgICAgICAgXCJhcmlhLXByZXNzZWRcIjogMCxcbiAgICAgICAgXCJhcmlhLXJlYWRvbmx5XCI6IDAsXG4gICAgICAgIFwiYXJpYS1yZXF1aXJlZFwiOiAwLFxuICAgICAgICBcImFyaWEtc2VsZWN0ZWRcIjogMCxcbiAgICAgICAgXCJhcmlhLXNvcnRcIjogMCxcbiAgICAgICAgXCJhcmlhLXZhbHVlbWF4XCI6IDAsXG4gICAgICAgIFwiYXJpYS12YWx1ZW1pblwiOiAwLFxuICAgICAgICBcImFyaWEtdmFsdWVub3dcIjogMCxcbiAgICAgICAgXCJhcmlhLXZhbHVldGV4dFwiOiAwLFxuICAgICAgICBcImFyaWEtYXRvbWljXCI6IDAsXG4gICAgICAgIFwiYXJpYS1idXN5XCI6IDAsXG4gICAgICAgIFwiYXJpYS1saXZlXCI6IDAsXG4gICAgICAgIFwiYXJpYS1yZWxldmFudFwiOiAwLFxuICAgICAgICBcImFyaWEtZHJvcGVmZmVjdFwiOiAwLFxuICAgICAgICBcImFyaWEtZ3JhYmJlZFwiOiAwLFxuICAgICAgICBcImFyaWEtYWN0aXZlZGVzY2VuZGFudFwiOiAwLFxuICAgICAgICBcImFyaWEtY29sY291bnRcIjogMCxcbiAgICAgICAgXCJhcmlhLWNvbGluZGV4XCI6IDAsXG4gICAgICAgIFwiYXJpYS1jb2xzcGFuXCI6IDAsXG4gICAgICAgIFwiYXJpYS1jb250cm9sc1wiOiAwLFxuICAgICAgICBcImFyaWEtZGVzY3JpYmVkYnlcIjogMCxcbiAgICAgICAgXCJhcmlhLWVycm9ybWVzc2FnZVwiOiAwLFxuICAgICAgICBcImFyaWEtZmxvd3RvXCI6IDAsXG4gICAgICAgIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IDAsXG4gICAgICAgIFwiYXJpYS1vd25zXCI6IDAsXG4gICAgICAgIFwiYXJpYS1wb3NpbnNldFwiOiAwLFxuICAgICAgICBcImFyaWEtcm93Y291bnRcIjogMCxcbiAgICAgICAgXCJhcmlhLXJvd2luZGV4XCI6IDAsXG4gICAgICAgIFwiYXJpYS1yb3dzcGFuXCI6IDAsXG4gICAgICAgIFwiYXJpYS1zZXRzaXplXCI6IDAsXG4gICAgICAgIFwiYXJpYS1icmFpbGxlbGFiZWxcIjogMCxcbiAgICAgICAgXCJhcmlhLWJyYWlsbGVyb2xlZGVzY3JpcHRpb25cIjogMCxcbiAgICAgICAgXCJhcmlhLWNvbGluZGV4dGV4dFwiOiAwLFxuICAgICAgICBcImFyaWEtcm93aW5kZXh0ZXh0XCI6IDBcbiAgICAgIH0sXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDEgPSB7fSxcbiAgICAgIHJBUklBJDEgPSBSZWdFeHAoXG4gICAgICAgIFwiXihhcmlhKS1bOkEtWl9hLXpcXFxcdTAwQzAtXFxcXHUwMEQ2XFxcXHUwMEQ4LVxcXFx1MDBGNlxcXFx1MDBGOC1cXFxcdTAyRkZcXFxcdTAzNzAtXFxcXHUwMzdEXFxcXHUwMzdGLVxcXFx1MUZGRlxcXFx1MjAwQy1cXFxcdTIwMERcXFxcdTIwNzAtXFxcXHUyMThGXFxcXHUyQzAwLVxcXFx1MkZFRlxcXFx1MzAwMS1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZGRFxcXFwtLjAtOVxcXFx1MDBCN1xcXFx1MDMwMC1cXFxcdTAzNkZcXFxcdTIwM0YtXFxcXHUyMDQwXSokXCJcbiAgICAgICksXG4gICAgICByQVJJQUNhbWVsJDEgPSBSZWdFeHAoXG4gICAgICAgIFwiXihhcmlhKVtBLVpdWzpBLVpfYS16XFxcXHUwMEMwLVxcXFx1MDBENlxcXFx1MDBEOC1cXFxcdTAwRjZcXFxcdTAwRjgtXFxcXHUwMkZGXFxcXHUwMzcwLVxcXFx1MDM3RFxcXFx1MDM3Ri1cXFxcdTFGRkZcXFxcdTIwMEMtXFxcXHUyMDBEXFxcXHUyMDcwLVxcXFx1MjE4RlxcXFx1MkMwMC1cXFxcdTJGRUZcXFxcdTMwMDEtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRkRcXFxcLS4wLTlcXFxcdTAwQjdcXFxcdTAzMDAtXFxcXHUwMzZGXFxcXHUyMDNGLVxcXFx1MjA0MF0qJFwiXG4gICAgICApLFxuICAgICAgZGlkV2FyblZhbHVlTnVsbCA9ICExLFxuICAgICAgcG9zc2libGVTdGFuZGFyZE5hbWVzID0ge1xuICAgICAgICBhY2NlcHQ6IFwiYWNjZXB0XCIsXG4gICAgICAgIGFjY2VwdGNoYXJzZXQ6IFwiYWNjZXB0Q2hhcnNldFwiLFxuICAgICAgICBcImFjY2VwdC1jaGFyc2V0XCI6IFwiYWNjZXB0Q2hhcnNldFwiLFxuICAgICAgICBhY2Nlc3NrZXk6IFwiYWNjZXNzS2V5XCIsXG4gICAgICAgIGFjdGlvbjogXCJhY3Rpb25cIixcbiAgICAgICAgYWxsb3dmdWxsc2NyZWVuOiBcImFsbG93RnVsbFNjcmVlblwiLFxuICAgICAgICBhbHQ6IFwiYWx0XCIsXG4gICAgICAgIGFzOiBcImFzXCIsXG4gICAgICAgIGFzeW5jOiBcImFzeW5jXCIsXG4gICAgICAgIGF1dG9jYXBpdGFsaXplOiBcImF1dG9DYXBpdGFsaXplXCIsXG4gICAgICAgIGF1dG9jb21wbGV0ZTogXCJhdXRvQ29tcGxldGVcIixcbiAgICAgICAgYXV0b2NvcnJlY3Q6IFwiYXV0b0NvcnJlY3RcIixcbiAgICAgICAgYXV0b2ZvY3VzOiBcImF1dG9Gb2N1c1wiLFxuICAgICAgICBhdXRvcGxheTogXCJhdXRvUGxheVwiLFxuICAgICAgICBhdXRvc2F2ZTogXCJhdXRvU2F2ZVwiLFxuICAgICAgICBjYXB0dXJlOiBcImNhcHR1cmVcIixcbiAgICAgICAgY2VsbHBhZGRpbmc6IFwiY2VsbFBhZGRpbmdcIixcbiAgICAgICAgY2VsbHNwYWNpbmc6IFwiY2VsbFNwYWNpbmdcIixcbiAgICAgICAgY2hhbGxlbmdlOiBcImNoYWxsZW5nZVwiLFxuICAgICAgICBjaGFyc2V0OiBcImNoYXJTZXRcIixcbiAgICAgICAgY2hlY2tlZDogXCJjaGVja2VkXCIsXG4gICAgICAgIGNoaWxkcmVuOiBcImNoaWxkcmVuXCIsXG4gICAgICAgIGNpdGU6IFwiY2l0ZVwiLFxuICAgICAgICBjbGFzczogXCJjbGFzc05hbWVcIixcbiAgICAgICAgY2xhc3NpZDogXCJjbGFzc0lEXCIsXG4gICAgICAgIGNsYXNzbmFtZTogXCJjbGFzc05hbWVcIixcbiAgICAgICAgY29sczogXCJjb2xzXCIsXG4gICAgICAgIGNvbHNwYW46IFwiY29sU3BhblwiLFxuICAgICAgICBjb250ZW50OiBcImNvbnRlbnRcIixcbiAgICAgICAgY29udGVudGVkaXRhYmxlOiBcImNvbnRlbnRFZGl0YWJsZVwiLFxuICAgICAgICBjb250ZXh0bWVudTogXCJjb250ZXh0TWVudVwiLFxuICAgICAgICBjb250cm9sczogXCJjb250cm9sc1wiLFxuICAgICAgICBjb250cm9sc2xpc3Q6IFwiY29udHJvbHNMaXN0XCIsXG4gICAgICAgIGNvb3JkczogXCJjb29yZHNcIixcbiAgICAgICAgY3Jvc3NvcmlnaW46IFwiY3Jvc3NPcmlnaW5cIixcbiAgICAgICAgZGFuZ2Vyb3VzbHlzZXRpbm5lcmh0bWw6IFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIixcbiAgICAgICAgZGF0YTogXCJkYXRhXCIsXG4gICAgICAgIGRhdGV0aW1lOiBcImRhdGVUaW1lXCIsXG4gICAgICAgIGRlZmF1bHQ6IFwiZGVmYXVsdFwiLFxuICAgICAgICBkZWZhdWx0Y2hlY2tlZDogXCJkZWZhdWx0Q2hlY2tlZFwiLFxuICAgICAgICBkZWZhdWx0dmFsdWU6IFwiZGVmYXVsdFZhbHVlXCIsXG4gICAgICAgIGRlZmVyOiBcImRlZmVyXCIsXG4gICAgICAgIGRpcjogXCJkaXJcIixcbiAgICAgICAgZGlzYWJsZWQ6IFwiZGlzYWJsZWRcIixcbiAgICAgICAgZGlzYWJsZXBpY3R1cmVpbnBpY3R1cmU6IFwiZGlzYWJsZVBpY3R1cmVJblBpY3R1cmVcIixcbiAgICAgICAgZGlzYWJsZXJlbW90ZXBsYXliYWNrOiBcImRpc2FibGVSZW1vdGVQbGF5YmFja1wiLFxuICAgICAgICBkb3dubG9hZDogXCJkb3dubG9hZFwiLFxuICAgICAgICBkcmFnZ2FibGU6IFwiZHJhZ2dhYmxlXCIsXG4gICAgICAgIGVuY3R5cGU6IFwiZW5jVHlwZVwiLFxuICAgICAgICBlbnRlcmtleWhpbnQ6IFwiZW50ZXJLZXlIaW50XCIsXG4gICAgICAgIGZldGNocHJpb3JpdHk6IFwiZmV0Y2hQcmlvcml0eVwiLFxuICAgICAgICBmb3I6IFwiaHRtbEZvclwiLFxuICAgICAgICBmb3JtOiBcImZvcm1cIixcbiAgICAgICAgZm9ybW1ldGhvZDogXCJmb3JtTWV0aG9kXCIsXG4gICAgICAgIGZvcm1hY3Rpb246IFwiZm9ybUFjdGlvblwiLFxuICAgICAgICBmb3JtZW5jdHlwZTogXCJmb3JtRW5jVHlwZVwiLFxuICAgICAgICBmb3Jtbm92YWxpZGF0ZTogXCJmb3JtTm9WYWxpZGF0ZVwiLFxuICAgICAgICBmb3JtdGFyZ2V0OiBcImZvcm1UYXJnZXRcIixcbiAgICAgICAgZnJhbWVib3JkZXI6IFwiZnJhbWVCb3JkZXJcIixcbiAgICAgICAgaGVhZGVyczogXCJoZWFkZXJzXCIsXG4gICAgICAgIGhlaWdodDogXCJoZWlnaHRcIixcbiAgICAgICAgaGlkZGVuOiBcImhpZGRlblwiLFxuICAgICAgICBoaWdoOiBcImhpZ2hcIixcbiAgICAgICAgaHJlZjogXCJocmVmXCIsXG4gICAgICAgIGhyZWZsYW5nOiBcImhyZWZMYW5nXCIsXG4gICAgICAgIGh0bWxmb3I6IFwiaHRtbEZvclwiLFxuICAgICAgICBodHRwZXF1aXY6IFwiaHR0cEVxdWl2XCIsXG4gICAgICAgIFwiaHR0cC1lcXVpdlwiOiBcImh0dHBFcXVpdlwiLFxuICAgICAgICBpY29uOiBcImljb25cIixcbiAgICAgICAgaWQ6IFwiaWRcIixcbiAgICAgICAgaW1hZ2VzaXplczogXCJpbWFnZVNpemVzXCIsXG4gICAgICAgIGltYWdlc3Jjc2V0OiBcImltYWdlU3JjU2V0XCIsXG4gICAgICAgIGluZXJ0OiBcImluZXJ0XCIsXG4gICAgICAgIGlubmVyaHRtbDogXCJpbm5lckhUTUxcIixcbiAgICAgICAgaW5wdXRtb2RlOiBcImlucHV0TW9kZVwiLFxuICAgICAgICBpbnRlZ3JpdHk6IFwiaW50ZWdyaXR5XCIsXG4gICAgICAgIGlzOiBcImlzXCIsXG4gICAgICAgIGl0ZW1pZDogXCJpdGVtSURcIixcbiAgICAgICAgaXRlbXByb3A6IFwiaXRlbVByb3BcIixcbiAgICAgICAgaXRlbXJlZjogXCJpdGVtUmVmXCIsXG4gICAgICAgIGl0ZW1zY29wZTogXCJpdGVtU2NvcGVcIixcbiAgICAgICAgaXRlbXR5cGU6IFwiaXRlbVR5cGVcIixcbiAgICAgICAga2V5cGFyYW1zOiBcImtleVBhcmFtc1wiLFxuICAgICAgICBrZXl0eXBlOiBcImtleVR5cGVcIixcbiAgICAgICAga2luZDogXCJraW5kXCIsXG4gICAgICAgIGxhYmVsOiBcImxhYmVsXCIsXG4gICAgICAgIGxhbmc6IFwibGFuZ1wiLFxuICAgICAgICBsaXN0OiBcImxpc3RcIixcbiAgICAgICAgbG9vcDogXCJsb29wXCIsXG4gICAgICAgIGxvdzogXCJsb3dcIixcbiAgICAgICAgbWFuaWZlc3Q6IFwibWFuaWZlc3RcIixcbiAgICAgICAgbWFyZ2lud2lkdGg6IFwibWFyZ2luV2lkdGhcIixcbiAgICAgICAgbWFyZ2luaGVpZ2h0OiBcIm1hcmdpbkhlaWdodFwiLFxuICAgICAgICBtYXg6IFwibWF4XCIsXG4gICAgICAgIG1heGxlbmd0aDogXCJtYXhMZW5ndGhcIixcbiAgICAgICAgbWVkaWE6IFwibWVkaWFcIixcbiAgICAgICAgbWVkaWFncm91cDogXCJtZWRpYUdyb3VwXCIsXG4gICAgICAgIG1ldGhvZDogXCJtZXRob2RcIixcbiAgICAgICAgbWluOiBcIm1pblwiLFxuICAgICAgICBtaW5sZW5ndGg6IFwibWluTGVuZ3RoXCIsXG4gICAgICAgIG11bHRpcGxlOiBcIm11bHRpcGxlXCIsXG4gICAgICAgIG11dGVkOiBcIm11dGVkXCIsXG4gICAgICAgIG5hbWU6IFwibmFtZVwiLFxuICAgICAgICBub21vZHVsZTogXCJub01vZHVsZVwiLFxuICAgICAgICBub25jZTogXCJub25jZVwiLFxuICAgICAgICBub3ZhbGlkYXRlOiBcIm5vVmFsaWRhdGVcIixcbiAgICAgICAgb3BlbjogXCJvcGVuXCIsXG4gICAgICAgIG9wdGltdW06IFwib3B0aW11bVwiLFxuICAgICAgICBwYXR0ZXJuOiBcInBhdHRlcm5cIixcbiAgICAgICAgcGxhY2Vob2xkZXI6IFwicGxhY2Vob2xkZXJcIixcbiAgICAgICAgcGxheXNpbmxpbmU6IFwicGxheXNJbmxpbmVcIixcbiAgICAgICAgcG9zdGVyOiBcInBvc3RlclwiLFxuICAgICAgICBwcmVsb2FkOiBcInByZWxvYWRcIixcbiAgICAgICAgcHJvZmlsZTogXCJwcm9maWxlXCIsXG4gICAgICAgIHJhZGlvZ3JvdXA6IFwicmFkaW9Hcm91cFwiLFxuICAgICAgICByZWFkb25seTogXCJyZWFkT25seVwiLFxuICAgICAgICByZWZlcnJlcnBvbGljeTogXCJyZWZlcnJlclBvbGljeVwiLFxuICAgICAgICByZWw6IFwicmVsXCIsXG4gICAgICAgIHJlcXVpcmVkOiBcInJlcXVpcmVkXCIsXG4gICAgICAgIHJldmVyc2VkOiBcInJldmVyc2VkXCIsXG4gICAgICAgIHJvbGU6IFwicm9sZVwiLFxuICAgICAgICByb3dzOiBcInJvd3NcIixcbiAgICAgICAgcm93c3BhbjogXCJyb3dTcGFuXCIsXG4gICAgICAgIHNhbmRib3g6IFwic2FuZGJveFwiLFxuICAgICAgICBzY29wZTogXCJzY29wZVwiLFxuICAgICAgICBzY29wZWQ6IFwic2NvcGVkXCIsXG4gICAgICAgIHNjcm9sbGluZzogXCJzY3JvbGxpbmdcIixcbiAgICAgICAgc2VhbWxlc3M6IFwic2VhbWxlc3NcIixcbiAgICAgICAgc2VsZWN0ZWQ6IFwic2VsZWN0ZWRcIixcbiAgICAgICAgc2hhcGU6IFwic2hhcGVcIixcbiAgICAgICAgc2l6ZTogXCJzaXplXCIsXG4gICAgICAgIHNpemVzOiBcInNpemVzXCIsXG4gICAgICAgIHNwYW46IFwic3BhblwiLFxuICAgICAgICBzcGVsbGNoZWNrOiBcInNwZWxsQ2hlY2tcIixcbiAgICAgICAgc3JjOiBcInNyY1wiLFxuICAgICAgICBzcmNkb2M6IFwic3JjRG9jXCIsXG4gICAgICAgIHNyY2xhbmc6IFwic3JjTGFuZ1wiLFxuICAgICAgICBzcmNzZXQ6IFwic3JjU2V0XCIsXG4gICAgICAgIHN0YXJ0OiBcInN0YXJ0XCIsXG4gICAgICAgIHN0ZXA6IFwic3RlcFwiLFxuICAgICAgICBzdHlsZTogXCJzdHlsZVwiLFxuICAgICAgICBzdW1tYXJ5OiBcInN1bW1hcnlcIixcbiAgICAgICAgdGFiaW5kZXg6IFwidGFiSW5kZXhcIixcbiAgICAgICAgdGFyZ2V0OiBcInRhcmdldFwiLFxuICAgICAgICB0aXRsZTogXCJ0aXRsZVwiLFxuICAgICAgICB0eXBlOiBcInR5cGVcIixcbiAgICAgICAgdXNlbWFwOiBcInVzZU1hcFwiLFxuICAgICAgICB2YWx1ZTogXCJ2YWx1ZVwiLFxuICAgICAgICB3aWR0aDogXCJ3aWR0aFwiLFxuICAgICAgICB3bW9kZTogXCJ3bW9kZVwiLFxuICAgICAgICB3cmFwOiBcIndyYXBcIixcbiAgICAgICAgYWJvdXQ6IFwiYWJvdXRcIixcbiAgICAgICAgYWNjZW50aGVpZ2h0OiBcImFjY2VudEhlaWdodFwiLFxuICAgICAgICBcImFjY2VudC1oZWlnaHRcIjogXCJhY2NlbnRIZWlnaHRcIixcbiAgICAgICAgYWNjdW11bGF0ZTogXCJhY2N1bXVsYXRlXCIsXG4gICAgICAgIGFkZGl0aXZlOiBcImFkZGl0aXZlXCIsXG4gICAgICAgIGFsaWdubWVudGJhc2VsaW5lOiBcImFsaWdubWVudEJhc2VsaW5lXCIsXG4gICAgICAgIFwiYWxpZ25tZW50LWJhc2VsaW5lXCI6IFwiYWxpZ25tZW50QmFzZWxpbmVcIixcbiAgICAgICAgYWxsb3dyZW9yZGVyOiBcImFsbG93UmVvcmRlclwiLFxuICAgICAgICBhbHBoYWJldGljOiBcImFscGhhYmV0aWNcIixcbiAgICAgICAgYW1wbGl0dWRlOiBcImFtcGxpdHVkZVwiLFxuICAgICAgICBhcmFiaWNmb3JtOiBcImFyYWJpY0Zvcm1cIixcbiAgICAgICAgXCJhcmFiaWMtZm9ybVwiOiBcImFyYWJpY0Zvcm1cIixcbiAgICAgICAgYXNjZW50OiBcImFzY2VudFwiLFxuICAgICAgICBhdHRyaWJ1dGVuYW1lOiBcImF0dHJpYnV0ZU5hbWVcIixcbiAgICAgICAgYXR0cmlidXRldHlwZTogXCJhdHRyaWJ1dGVUeXBlXCIsXG4gICAgICAgIGF1dG9yZXZlcnNlOiBcImF1dG9SZXZlcnNlXCIsXG4gICAgICAgIGF6aW11dGg6IFwiYXppbXV0aFwiLFxuICAgICAgICBiYXNlZnJlcXVlbmN5OiBcImJhc2VGcmVxdWVuY3lcIixcbiAgICAgICAgYmFzZWxpbmVzaGlmdDogXCJiYXNlbGluZVNoaWZ0XCIsXG4gICAgICAgIFwiYmFzZWxpbmUtc2hpZnRcIjogXCJiYXNlbGluZVNoaWZ0XCIsXG4gICAgICAgIGJhc2Vwcm9maWxlOiBcImJhc2VQcm9maWxlXCIsXG4gICAgICAgIGJib3g6IFwiYmJveFwiLFxuICAgICAgICBiZWdpbjogXCJiZWdpblwiLFxuICAgICAgICBiaWFzOiBcImJpYXNcIixcbiAgICAgICAgYnk6IFwiYnlcIixcbiAgICAgICAgY2FsY21vZGU6IFwiY2FsY01vZGVcIixcbiAgICAgICAgY2FwaGVpZ2h0OiBcImNhcEhlaWdodFwiLFxuICAgICAgICBcImNhcC1oZWlnaHRcIjogXCJjYXBIZWlnaHRcIixcbiAgICAgICAgY2xpcDogXCJjbGlwXCIsXG4gICAgICAgIGNsaXBwYXRoOiBcImNsaXBQYXRoXCIsXG4gICAgICAgIFwiY2xpcC1wYXRoXCI6IFwiY2xpcFBhdGhcIixcbiAgICAgICAgY2xpcHBhdGh1bml0czogXCJjbGlwUGF0aFVuaXRzXCIsXG4gICAgICAgIGNsaXBydWxlOiBcImNsaXBSdWxlXCIsXG4gICAgICAgIFwiY2xpcC1ydWxlXCI6IFwiY2xpcFJ1bGVcIixcbiAgICAgICAgY29sb3I6IFwiY29sb3JcIixcbiAgICAgICAgY29sb3JpbnRlcnBvbGF0aW9uOiBcImNvbG9ySW50ZXJwb2xhdGlvblwiLFxuICAgICAgICBcImNvbG9yLWludGVycG9sYXRpb25cIjogXCJjb2xvckludGVycG9sYXRpb25cIixcbiAgICAgICAgY29sb3JpbnRlcnBvbGF0aW9uZmlsdGVyczogXCJjb2xvckludGVycG9sYXRpb25GaWx0ZXJzXCIsXG4gICAgICAgIFwiY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzXCI6IFwiY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVyc1wiLFxuICAgICAgICBjb2xvcnByb2ZpbGU6IFwiY29sb3JQcm9maWxlXCIsXG4gICAgICAgIFwiY29sb3ItcHJvZmlsZVwiOiBcImNvbG9yUHJvZmlsZVwiLFxuICAgICAgICBjb2xvcnJlbmRlcmluZzogXCJjb2xvclJlbmRlcmluZ1wiLFxuICAgICAgICBcImNvbG9yLXJlbmRlcmluZ1wiOiBcImNvbG9yUmVuZGVyaW5nXCIsXG4gICAgICAgIGNvbnRlbnRzY3JpcHR0eXBlOiBcImNvbnRlbnRTY3JpcHRUeXBlXCIsXG4gICAgICAgIGNvbnRlbnRzdHlsZXR5cGU6IFwiY29udGVudFN0eWxlVHlwZVwiLFxuICAgICAgICBjdXJzb3I6IFwiY3Vyc29yXCIsXG4gICAgICAgIGN4OiBcImN4XCIsXG4gICAgICAgIGN5OiBcImN5XCIsXG4gICAgICAgIGQ6IFwiZFwiLFxuICAgICAgICBkYXRhdHlwZTogXCJkYXRhdHlwZVwiLFxuICAgICAgICBkZWNlbGVyYXRlOiBcImRlY2VsZXJhdGVcIixcbiAgICAgICAgZGVzY2VudDogXCJkZXNjZW50XCIsXG4gICAgICAgIGRpZmZ1c2Vjb25zdGFudDogXCJkaWZmdXNlQ29uc3RhbnRcIixcbiAgICAgICAgZGlyZWN0aW9uOiBcImRpcmVjdGlvblwiLFxuICAgICAgICBkaXNwbGF5OiBcImRpc3BsYXlcIixcbiAgICAgICAgZGl2aXNvcjogXCJkaXZpc29yXCIsXG4gICAgICAgIGRvbWluYW50YmFzZWxpbmU6IFwiZG9taW5hbnRCYXNlbGluZVwiLFxuICAgICAgICBcImRvbWluYW50LWJhc2VsaW5lXCI6IFwiZG9taW5hbnRCYXNlbGluZVwiLFxuICAgICAgICBkdXI6IFwiZHVyXCIsXG4gICAgICAgIGR4OiBcImR4XCIsXG4gICAgICAgIGR5OiBcImR5XCIsXG4gICAgICAgIGVkZ2Vtb2RlOiBcImVkZ2VNb2RlXCIsXG4gICAgICAgIGVsZXZhdGlvbjogXCJlbGV2YXRpb25cIixcbiAgICAgICAgZW5hYmxlYmFja2dyb3VuZDogXCJlbmFibGVCYWNrZ3JvdW5kXCIsXG4gICAgICAgIFwiZW5hYmxlLWJhY2tncm91bmRcIjogXCJlbmFibGVCYWNrZ3JvdW5kXCIsXG4gICAgICAgIGVuZDogXCJlbmRcIixcbiAgICAgICAgZXhwb25lbnQ6IFwiZXhwb25lbnRcIixcbiAgICAgICAgZXh0ZXJuYWxyZXNvdXJjZXNyZXF1aXJlZDogXCJleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkXCIsXG4gICAgICAgIGZpbGw6IFwiZmlsbFwiLFxuICAgICAgICBmaWxsb3BhY2l0eTogXCJmaWxsT3BhY2l0eVwiLFxuICAgICAgICBcImZpbGwtb3BhY2l0eVwiOiBcImZpbGxPcGFjaXR5XCIsXG4gICAgICAgIGZpbGxydWxlOiBcImZpbGxSdWxlXCIsXG4gICAgICAgIFwiZmlsbC1ydWxlXCI6IFwiZmlsbFJ1bGVcIixcbiAgICAgICAgZmlsdGVyOiBcImZpbHRlclwiLFxuICAgICAgICBmaWx0ZXJyZXM6IFwiZmlsdGVyUmVzXCIsXG4gICAgICAgIGZpbHRlcnVuaXRzOiBcImZpbHRlclVuaXRzXCIsXG4gICAgICAgIGZsb29kb3BhY2l0eTogXCJmbG9vZE9wYWNpdHlcIixcbiAgICAgICAgXCJmbG9vZC1vcGFjaXR5XCI6IFwiZmxvb2RPcGFjaXR5XCIsXG4gICAgICAgIGZsb29kY29sb3I6IFwiZmxvb2RDb2xvclwiLFxuICAgICAgICBcImZsb29kLWNvbG9yXCI6IFwiZmxvb2RDb2xvclwiLFxuICAgICAgICBmb2N1c2FibGU6IFwiZm9jdXNhYmxlXCIsXG4gICAgICAgIGZvbnRmYW1pbHk6IFwiZm9udEZhbWlseVwiLFxuICAgICAgICBcImZvbnQtZmFtaWx5XCI6IFwiZm9udEZhbWlseVwiLFxuICAgICAgICBmb250c2l6ZTogXCJmb250U2l6ZVwiLFxuICAgICAgICBcImZvbnQtc2l6ZVwiOiBcImZvbnRTaXplXCIsXG4gICAgICAgIGZvbnRzaXplYWRqdXN0OiBcImZvbnRTaXplQWRqdXN0XCIsXG4gICAgICAgIFwiZm9udC1zaXplLWFkanVzdFwiOiBcImZvbnRTaXplQWRqdXN0XCIsXG4gICAgICAgIGZvbnRzdHJldGNoOiBcImZvbnRTdHJldGNoXCIsXG4gICAgICAgIFwiZm9udC1zdHJldGNoXCI6IFwiZm9udFN0cmV0Y2hcIixcbiAgICAgICAgZm9udHN0eWxlOiBcImZvbnRTdHlsZVwiLFxuICAgICAgICBcImZvbnQtc3R5bGVcIjogXCJmb250U3R5bGVcIixcbiAgICAgICAgZm9udHZhcmlhbnQ6IFwiZm9udFZhcmlhbnRcIixcbiAgICAgICAgXCJmb250LXZhcmlhbnRcIjogXCJmb250VmFyaWFudFwiLFxuICAgICAgICBmb250d2VpZ2h0OiBcImZvbnRXZWlnaHRcIixcbiAgICAgICAgXCJmb250LXdlaWdodFwiOiBcImZvbnRXZWlnaHRcIixcbiAgICAgICAgZm9ybWF0OiBcImZvcm1hdFwiLFxuICAgICAgICBmcm9tOiBcImZyb21cIixcbiAgICAgICAgZng6IFwiZnhcIixcbiAgICAgICAgZnk6IFwiZnlcIixcbiAgICAgICAgZzE6IFwiZzFcIixcbiAgICAgICAgZzI6IFwiZzJcIixcbiAgICAgICAgZ2x5cGhuYW1lOiBcImdseXBoTmFtZVwiLFxuICAgICAgICBcImdseXBoLW5hbWVcIjogXCJnbHlwaE5hbWVcIixcbiAgICAgICAgZ2x5cGhvcmllbnRhdGlvbmhvcml6b250YWw6IFwiZ2x5cGhPcmllbnRhdGlvbkhvcml6b250YWxcIixcbiAgICAgICAgXCJnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsXCI6IFwiZ2x5cGhPcmllbnRhdGlvbkhvcml6b250YWxcIixcbiAgICAgICAgZ2x5cGhvcmllbnRhdGlvbnZlcnRpY2FsOiBcImdseXBoT3JpZW50YXRpb25WZXJ0aWNhbFwiLFxuICAgICAgICBcImdseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsXCI6IFwiZ2x5cGhPcmllbnRhdGlvblZlcnRpY2FsXCIsXG4gICAgICAgIGdseXBocmVmOiBcImdseXBoUmVmXCIsXG4gICAgICAgIGdyYWRpZW50dHJhbnNmb3JtOiBcImdyYWRpZW50VHJhbnNmb3JtXCIsXG4gICAgICAgIGdyYWRpZW50dW5pdHM6IFwiZ3JhZGllbnRVbml0c1wiLFxuICAgICAgICBoYW5naW5nOiBcImhhbmdpbmdcIixcbiAgICAgICAgaG9yaXphZHZ4OiBcImhvcml6QWR2WFwiLFxuICAgICAgICBcImhvcml6LWFkdi14XCI6IFwiaG9yaXpBZHZYXCIsXG4gICAgICAgIGhvcml6b3JpZ2lueDogXCJob3Jpek9yaWdpblhcIixcbiAgICAgICAgXCJob3Jpei1vcmlnaW4teFwiOiBcImhvcml6T3JpZ2luWFwiLFxuICAgICAgICBpZGVvZ3JhcGhpYzogXCJpZGVvZ3JhcGhpY1wiLFxuICAgICAgICBpbWFnZXJlbmRlcmluZzogXCJpbWFnZVJlbmRlcmluZ1wiLFxuICAgICAgICBcImltYWdlLXJlbmRlcmluZ1wiOiBcImltYWdlUmVuZGVyaW5nXCIsXG4gICAgICAgIGluMjogXCJpbjJcIixcbiAgICAgICAgaW46IFwiaW5cIixcbiAgICAgICAgaW5saXN0OiBcImlubGlzdFwiLFxuICAgICAgICBpbnRlcmNlcHQ6IFwiaW50ZXJjZXB0XCIsXG4gICAgICAgIGsxOiBcImsxXCIsXG4gICAgICAgIGsyOiBcImsyXCIsXG4gICAgICAgIGszOiBcImszXCIsXG4gICAgICAgIGs0OiBcIms0XCIsXG4gICAgICAgIGs6IFwia1wiLFxuICAgICAgICBrZXJuZWxtYXRyaXg6IFwia2VybmVsTWF0cml4XCIsXG4gICAgICAgIGtlcm5lbHVuaXRsZW5ndGg6IFwia2VybmVsVW5pdExlbmd0aFwiLFxuICAgICAgICBrZXJuaW5nOiBcImtlcm5pbmdcIixcbiAgICAgICAga2V5cG9pbnRzOiBcImtleVBvaW50c1wiLFxuICAgICAgICBrZXlzcGxpbmVzOiBcImtleVNwbGluZXNcIixcbiAgICAgICAga2V5dGltZXM6IFwia2V5VGltZXNcIixcbiAgICAgICAgbGVuZ3RoYWRqdXN0OiBcImxlbmd0aEFkanVzdFwiLFxuICAgICAgICBsZXR0ZXJzcGFjaW5nOiBcImxldHRlclNwYWNpbmdcIixcbiAgICAgICAgXCJsZXR0ZXItc3BhY2luZ1wiOiBcImxldHRlclNwYWNpbmdcIixcbiAgICAgICAgbGlnaHRpbmdjb2xvcjogXCJsaWdodGluZ0NvbG9yXCIsXG4gICAgICAgIFwibGlnaHRpbmctY29sb3JcIjogXCJsaWdodGluZ0NvbG9yXCIsXG4gICAgICAgIGxpbWl0aW5nY29uZWFuZ2xlOiBcImxpbWl0aW5nQ29uZUFuZ2xlXCIsXG4gICAgICAgIGxvY2FsOiBcImxvY2FsXCIsXG4gICAgICAgIG1hcmtlcmVuZDogXCJtYXJrZXJFbmRcIixcbiAgICAgICAgXCJtYXJrZXItZW5kXCI6IFwibWFya2VyRW5kXCIsXG4gICAgICAgIG1hcmtlcmhlaWdodDogXCJtYXJrZXJIZWlnaHRcIixcbiAgICAgICAgbWFya2VybWlkOiBcIm1hcmtlck1pZFwiLFxuICAgICAgICBcIm1hcmtlci1taWRcIjogXCJtYXJrZXJNaWRcIixcbiAgICAgICAgbWFya2Vyc3RhcnQ6IFwibWFya2VyU3RhcnRcIixcbiAgICAgICAgXCJtYXJrZXItc3RhcnRcIjogXCJtYXJrZXJTdGFydFwiLFxuICAgICAgICBtYXJrZXJ1bml0czogXCJtYXJrZXJVbml0c1wiLFxuICAgICAgICBtYXJrZXJ3aWR0aDogXCJtYXJrZXJXaWR0aFwiLFxuICAgICAgICBtYXNrOiBcIm1hc2tcIixcbiAgICAgICAgbWFza2NvbnRlbnR1bml0czogXCJtYXNrQ29udGVudFVuaXRzXCIsXG4gICAgICAgIG1hc2t1bml0czogXCJtYXNrVW5pdHNcIixcbiAgICAgICAgbWF0aGVtYXRpY2FsOiBcIm1hdGhlbWF0aWNhbFwiLFxuICAgICAgICBtb2RlOiBcIm1vZGVcIixcbiAgICAgICAgbnVtb2N0YXZlczogXCJudW1PY3RhdmVzXCIsXG4gICAgICAgIG9mZnNldDogXCJvZmZzZXRcIixcbiAgICAgICAgb3BhY2l0eTogXCJvcGFjaXR5XCIsXG4gICAgICAgIG9wZXJhdG9yOiBcIm9wZXJhdG9yXCIsXG4gICAgICAgIG9yZGVyOiBcIm9yZGVyXCIsXG4gICAgICAgIG9yaWVudDogXCJvcmllbnRcIixcbiAgICAgICAgb3JpZW50YXRpb246IFwib3JpZW50YXRpb25cIixcbiAgICAgICAgb3JpZ2luOiBcIm9yaWdpblwiLFxuICAgICAgICBvdmVyZmxvdzogXCJvdmVyZmxvd1wiLFxuICAgICAgICBvdmVybGluZXBvc2l0aW9uOiBcIm92ZXJsaW5lUG9zaXRpb25cIixcbiAgICAgICAgXCJvdmVybGluZS1wb3NpdGlvblwiOiBcIm92ZXJsaW5lUG9zaXRpb25cIixcbiAgICAgICAgb3ZlcmxpbmV0aGlja25lc3M6IFwib3ZlcmxpbmVUaGlja25lc3NcIixcbiAgICAgICAgXCJvdmVybGluZS10aGlja25lc3NcIjogXCJvdmVybGluZVRoaWNrbmVzc1wiLFxuICAgICAgICBwYWludG9yZGVyOiBcInBhaW50T3JkZXJcIixcbiAgICAgICAgXCJwYWludC1vcmRlclwiOiBcInBhaW50T3JkZXJcIixcbiAgICAgICAgcGFub3NlMTogXCJwYW5vc2UxXCIsXG4gICAgICAgIFwicGFub3NlLTFcIjogXCJwYW5vc2UxXCIsXG4gICAgICAgIHBhdGhsZW5ndGg6IFwicGF0aExlbmd0aFwiLFxuICAgICAgICBwYXR0ZXJuY29udGVudHVuaXRzOiBcInBhdHRlcm5Db250ZW50VW5pdHNcIixcbiAgICAgICAgcGF0dGVybnRyYW5zZm9ybTogXCJwYXR0ZXJuVHJhbnNmb3JtXCIsXG4gICAgICAgIHBhdHRlcm51bml0czogXCJwYXR0ZXJuVW5pdHNcIixcbiAgICAgICAgcG9pbnRlcmV2ZW50czogXCJwb2ludGVyRXZlbnRzXCIsXG4gICAgICAgIFwicG9pbnRlci1ldmVudHNcIjogXCJwb2ludGVyRXZlbnRzXCIsXG4gICAgICAgIHBvaW50czogXCJwb2ludHNcIixcbiAgICAgICAgcG9pbnRzYXR4OiBcInBvaW50c0F0WFwiLFxuICAgICAgICBwb2ludHNhdHk6IFwicG9pbnRzQXRZXCIsXG4gICAgICAgIHBvaW50c2F0ejogXCJwb2ludHNBdFpcIixcbiAgICAgICAgcG9wb3ZlcjogXCJwb3BvdmVyXCIsXG4gICAgICAgIHBvcG92ZXJ0YXJnZXQ6IFwicG9wb3ZlclRhcmdldFwiLFxuICAgICAgICBwb3BvdmVydGFyZ2V0YWN0aW9uOiBcInBvcG92ZXJUYXJnZXRBY3Rpb25cIixcbiAgICAgICAgcHJlZml4OiBcInByZWZpeFwiLFxuICAgICAgICBwcmVzZXJ2ZWFscGhhOiBcInByZXNlcnZlQWxwaGFcIixcbiAgICAgICAgcHJlc2VydmVhc3BlY3RyYXRpbzogXCJwcmVzZXJ2ZUFzcGVjdFJhdGlvXCIsXG4gICAgICAgIHByaW1pdGl2ZXVuaXRzOiBcInByaW1pdGl2ZVVuaXRzXCIsXG4gICAgICAgIHByb3BlcnR5OiBcInByb3BlcnR5XCIsXG4gICAgICAgIHI6IFwiclwiLFxuICAgICAgICByYWRpdXM6IFwicmFkaXVzXCIsXG4gICAgICAgIHJlZng6IFwicmVmWFwiLFxuICAgICAgICByZWZ5OiBcInJlZllcIixcbiAgICAgICAgcmVuZGVyaW5naW50ZW50OiBcInJlbmRlcmluZ0ludGVudFwiLFxuICAgICAgICBcInJlbmRlcmluZy1pbnRlbnRcIjogXCJyZW5kZXJpbmdJbnRlbnRcIixcbiAgICAgICAgcmVwZWF0Y291bnQ6IFwicmVwZWF0Q291bnRcIixcbiAgICAgICAgcmVwZWF0ZHVyOiBcInJlcGVhdER1clwiLFxuICAgICAgICByZXF1aXJlZGV4dGVuc2lvbnM6IFwicmVxdWlyZWRFeHRlbnNpb25zXCIsXG4gICAgICAgIHJlcXVpcmVkZmVhdHVyZXM6IFwicmVxdWlyZWRGZWF0dXJlc1wiLFxuICAgICAgICByZXNvdXJjZTogXCJyZXNvdXJjZVwiLFxuICAgICAgICByZXN0YXJ0OiBcInJlc3RhcnRcIixcbiAgICAgICAgcmVzdWx0OiBcInJlc3VsdFwiLFxuICAgICAgICByZXN1bHRzOiBcInJlc3VsdHNcIixcbiAgICAgICAgcm90YXRlOiBcInJvdGF0ZVwiLFxuICAgICAgICByeDogXCJyeFwiLFxuICAgICAgICByeTogXCJyeVwiLFxuICAgICAgICBzY2FsZTogXCJzY2FsZVwiLFxuICAgICAgICBzZWN1cml0eTogXCJzZWN1cml0eVwiLFxuICAgICAgICBzZWVkOiBcInNlZWRcIixcbiAgICAgICAgc2hhcGVyZW5kZXJpbmc6IFwic2hhcGVSZW5kZXJpbmdcIixcbiAgICAgICAgXCJzaGFwZS1yZW5kZXJpbmdcIjogXCJzaGFwZVJlbmRlcmluZ1wiLFxuICAgICAgICBzbG9wZTogXCJzbG9wZVwiLFxuICAgICAgICBzcGFjaW5nOiBcInNwYWNpbmdcIixcbiAgICAgICAgc3BlY3VsYXJjb25zdGFudDogXCJzcGVjdWxhckNvbnN0YW50XCIsXG4gICAgICAgIHNwZWN1bGFyZXhwb25lbnQ6IFwic3BlY3VsYXJFeHBvbmVudFwiLFxuICAgICAgICBzcGVlZDogXCJzcGVlZFwiLFxuICAgICAgICBzcHJlYWRtZXRob2Q6IFwic3ByZWFkTWV0aG9kXCIsXG4gICAgICAgIHN0YXJ0b2Zmc2V0OiBcInN0YXJ0T2Zmc2V0XCIsXG4gICAgICAgIHN0ZGRldmlhdGlvbjogXCJzdGREZXZpYXRpb25cIixcbiAgICAgICAgc3RlbWg6IFwic3RlbWhcIixcbiAgICAgICAgc3RlbXY6IFwic3RlbXZcIixcbiAgICAgICAgc3RpdGNodGlsZXM6IFwic3RpdGNoVGlsZXNcIixcbiAgICAgICAgc3RvcGNvbG9yOiBcInN0b3BDb2xvclwiLFxuICAgICAgICBcInN0b3AtY29sb3JcIjogXCJzdG9wQ29sb3JcIixcbiAgICAgICAgc3RvcG9wYWNpdHk6IFwic3RvcE9wYWNpdHlcIixcbiAgICAgICAgXCJzdG9wLW9wYWNpdHlcIjogXCJzdG9wT3BhY2l0eVwiLFxuICAgICAgICBzdHJpa2V0aHJvdWdocG9zaXRpb246IFwic3RyaWtldGhyb3VnaFBvc2l0aW9uXCIsXG4gICAgICAgIFwic3RyaWtldGhyb3VnaC1wb3NpdGlvblwiOiBcInN0cmlrZXRocm91Z2hQb3NpdGlvblwiLFxuICAgICAgICBzdHJpa2V0aHJvdWdodGhpY2tuZXNzOiBcInN0cmlrZXRocm91Z2hUaGlja25lc3NcIixcbiAgICAgICAgXCJzdHJpa2V0aHJvdWdoLXRoaWNrbmVzc1wiOiBcInN0cmlrZXRocm91Z2hUaGlja25lc3NcIixcbiAgICAgICAgc3RyaW5nOiBcInN0cmluZ1wiLFxuICAgICAgICBzdHJva2U6IFwic3Ryb2tlXCIsXG4gICAgICAgIHN0cm9rZWRhc2hhcnJheTogXCJzdHJva2VEYXNoYXJyYXlcIixcbiAgICAgICAgXCJzdHJva2UtZGFzaGFycmF5XCI6IFwic3Ryb2tlRGFzaGFycmF5XCIsXG4gICAgICAgIHN0cm9rZWRhc2hvZmZzZXQ6IFwic3Ryb2tlRGFzaG9mZnNldFwiLFxuICAgICAgICBcInN0cm9rZS1kYXNob2Zmc2V0XCI6IFwic3Ryb2tlRGFzaG9mZnNldFwiLFxuICAgICAgICBzdHJva2VsaW5lY2FwOiBcInN0cm9rZUxpbmVjYXBcIixcbiAgICAgICAgXCJzdHJva2UtbGluZWNhcFwiOiBcInN0cm9rZUxpbmVjYXBcIixcbiAgICAgICAgc3Ryb2tlbGluZWpvaW46IFwic3Ryb2tlTGluZWpvaW5cIixcbiAgICAgICAgXCJzdHJva2UtbGluZWpvaW5cIjogXCJzdHJva2VMaW5lam9pblwiLFxuICAgICAgICBzdHJva2VtaXRlcmxpbWl0OiBcInN0cm9rZU1pdGVybGltaXRcIixcbiAgICAgICAgXCJzdHJva2UtbWl0ZXJsaW1pdFwiOiBcInN0cm9rZU1pdGVybGltaXRcIixcbiAgICAgICAgc3Ryb2tld2lkdGg6IFwic3Ryb2tlV2lkdGhcIixcbiAgICAgICAgXCJzdHJva2Utd2lkdGhcIjogXCJzdHJva2VXaWR0aFwiLFxuICAgICAgICBzdHJva2VvcGFjaXR5OiBcInN0cm9rZU9wYWNpdHlcIixcbiAgICAgICAgXCJzdHJva2Utb3BhY2l0eVwiOiBcInN0cm9rZU9wYWNpdHlcIixcbiAgICAgICAgc3VwcHJlc3Njb250ZW50ZWRpdGFibGV3YXJuaW5nOiBcInN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZ1wiLFxuICAgICAgICBzdXBwcmVzc2h5ZHJhdGlvbndhcm5pbmc6IFwic3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nXCIsXG4gICAgICAgIHN1cmZhY2VzY2FsZTogXCJzdXJmYWNlU2NhbGVcIixcbiAgICAgICAgc3lzdGVtbGFuZ3VhZ2U6IFwic3lzdGVtTGFuZ3VhZ2VcIixcbiAgICAgICAgdGFibGV2YWx1ZXM6IFwidGFibGVWYWx1ZXNcIixcbiAgICAgICAgdGFyZ2V0eDogXCJ0YXJnZXRYXCIsXG4gICAgICAgIHRhcmdldHk6IFwidGFyZ2V0WVwiLFxuICAgICAgICB0ZXh0YW5jaG9yOiBcInRleHRBbmNob3JcIixcbiAgICAgICAgXCJ0ZXh0LWFuY2hvclwiOiBcInRleHRBbmNob3JcIixcbiAgICAgICAgdGV4dGRlY29yYXRpb246IFwidGV4dERlY29yYXRpb25cIixcbiAgICAgICAgXCJ0ZXh0LWRlY29yYXRpb25cIjogXCJ0ZXh0RGVjb3JhdGlvblwiLFxuICAgICAgICB0ZXh0bGVuZ3RoOiBcInRleHRMZW5ndGhcIixcbiAgICAgICAgdGV4dHJlbmRlcmluZzogXCJ0ZXh0UmVuZGVyaW5nXCIsXG4gICAgICAgIFwidGV4dC1yZW5kZXJpbmdcIjogXCJ0ZXh0UmVuZGVyaW5nXCIsXG4gICAgICAgIHRvOiBcInRvXCIsXG4gICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2Zvcm1cIixcbiAgICAgICAgdHJhbnNmb3Jtb3JpZ2luOiBcInRyYW5zZm9ybU9yaWdpblwiLFxuICAgICAgICBcInRyYW5zZm9ybS1vcmlnaW5cIjogXCJ0cmFuc2Zvcm1PcmlnaW5cIixcbiAgICAgICAgdHlwZW9mOiBcInR5cGVvZlwiLFxuICAgICAgICB1MTogXCJ1MVwiLFxuICAgICAgICB1MjogXCJ1MlwiLFxuICAgICAgICB1bmRlcmxpbmVwb3NpdGlvbjogXCJ1bmRlcmxpbmVQb3NpdGlvblwiLFxuICAgICAgICBcInVuZGVybGluZS1wb3NpdGlvblwiOiBcInVuZGVybGluZVBvc2l0aW9uXCIsXG4gICAgICAgIHVuZGVybGluZXRoaWNrbmVzczogXCJ1bmRlcmxpbmVUaGlja25lc3NcIixcbiAgICAgICAgXCJ1bmRlcmxpbmUtdGhpY2tuZXNzXCI6IFwidW5kZXJsaW5lVGhpY2tuZXNzXCIsXG4gICAgICAgIHVuaWNvZGU6IFwidW5pY29kZVwiLFxuICAgICAgICB1bmljb2RlYmlkaTogXCJ1bmljb2RlQmlkaVwiLFxuICAgICAgICBcInVuaWNvZGUtYmlkaVwiOiBcInVuaWNvZGVCaWRpXCIsXG4gICAgICAgIHVuaWNvZGVyYW5nZTogXCJ1bmljb2RlUmFuZ2VcIixcbiAgICAgICAgXCJ1bmljb2RlLXJhbmdlXCI6IFwidW5pY29kZVJhbmdlXCIsXG4gICAgICAgIHVuaXRzcGVyZW06IFwidW5pdHNQZXJFbVwiLFxuICAgICAgICBcInVuaXRzLXBlci1lbVwiOiBcInVuaXRzUGVyRW1cIixcbiAgICAgICAgdW5zZWxlY3RhYmxlOiBcInVuc2VsZWN0YWJsZVwiLFxuICAgICAgICB2YWxwaGFiZXRpYzogXCJ2QWxwaGFiZXRpY1wiLFxuICAgICAgICBcInYtYWxwaGFiZXRpY1wiOiBcInZBbHBoYWJldGljXCIsXG4gICAgICAgIHZhbHVlczogXCJ2YWx1ZXNcIixcbiAgICAgICAgdmVjdG9yZWZmZWN0OiBcInZlY3RvckVmZmVjdFwiLFxuICAgICAgICBcInZlY3Rvci1lZmZlY3RcIjogXCJ2ZWN0b3JFZmZlY3RcIixcbiAgICAgICAgdmVyc2lvbjogXCJ2ZXJzaW9uXCIsXG4gICAgICAgIHZlcnRhZHZ5OiBcInZlcnRBZHZZXCIsXG4gICAgICAgIFwidmVydC1hZHYteVwiOiBcInZlcnRBZHZZXCIsXG4gICAgICAgIHZlcnRvcmlnaW54OiBcInZlcnRPcmlnaW5YXCIsXG4gICAgICAgIFwidmVydC1vcmlnaW4teFwiOiBcInZlcnRPcmlnaW5YXCIsXG4gICAgICAgIHZlcnRvcmlnaW55OiBcInZlcnRPcmlnaW5ZXCIsXG4gICAgICAgIFwidmVydC1vcmlnaW4teVwiOiBcInZlcnRPcmlnaW5ZXCIsXG4gICAgICAgIHZoYW5naW5nOiBcInZIYW5naW5nXCIsXG4gICAgICAgIFwidi1oYW5naW5nXCI6IFwidkhhbmdpbmdcIixcbiAgICAgICAgdmlkZW9ncmFwaGljOiBcInZJZGVvZ3JhcGhpY1wiLFxuICAgICAgICBcInYtaWRlb2dyYXBoaWNcIjogXCJ2SWRlb2dyYXBoaWNcIixcbiAgICAgICAgdmlld2JveDogXCJ2aWV3Qm94XCIsXG4gICAgICAgIHZpZXd0YXJnZXQ6IFwidmlld1RhcmdldFwiLFxuICAgICAgICB2aXNpYmlsaXR5OiBcInZpc2liaWxpdHlcIixcbiAgICAgICAgdm1hdGhlbWF0aWNhbDogXCJ2TWF0aGVtYXRpY2FsXCIsXG4gICAgICAgIFwidi1tYXRoZW1hdGljYWxcIjogXCJ2TWF0aGVtYXRpY2FsXCIsXG4gICAgICAgIHZvY2FiOiBcInZvY2FiXCIsXG4gICAgICAgIHdpZHRoczogXCJ3aWR0aHNcIixcbiAgICAgICAgd29yZHNwYWNpbmc6IFwid29yZFNwYWNpbmdcIixcbiAgICAgICAgXCJ3b3JkLXNwYWNpbmdcIjogXCJ3b3JkU3BhY2luZ1wiLFxuICAgICAgICB3cml0aW5nbW9kZTogXCJ3cml0aW5nTW9kZVwiLFxuICAgICAgICBcIndyaXRpbmctbW9kZVwiOiBcIndyaXRpbmdNb2RlXCIsXG4gICAgICAgIHgxOiBcIngxXCIsXG4gICAgICAgIHgyOiBcIngyXCIsXG4gICAgICAgIHg6IFwieFwiLFxuICAgICAgICB4Y2hhbm5lbHNlbGVjdG9yOiBcInhDaGFubmVsU2VsZWN0b3JcIixcbiAgICAgICAgeGhlaWdodDogXCJ4SGVpZ2h0XCIsXG4gICAgICAgIFwieC1oZWlnaHRcIjogXCJ4SGVpZ2h0XCIsXG4gICAgICAgIHhsaW5rYWN0dWF0ZTogXCJ4bGlua0FjdHVhdGVcIixcbiAgICAgICAgXCJ4bGluazphY3R1YXRlXCI6IFwieGxpbmtBY3R1YXRlXCIsXG4gICAgICAgIHhsaW5rYXJjcm9sZTogXCJ4bGlua0FyY3JvbGVcIixcbiAgICAgICAgXCJ4bGluazphcmNyb2xlXCI6IFwieGxpbmtBcmNyb2xlXCIsXG4gICAgICAgIHhsaW5raHJlZjogXCJ4bGlua0hyZWZcIixcbiAgICAgICAgXCJ4bGluazpocmVmXCI6IFwieGxpbmtIcmVmXCIsXG4gICAgICAgIHhsaW5rcm9sZTogXCJ4bGlua1JvbGVcIixcbiAgICAgICAgXCJ4bGluazpyb2xlXCI6IFwieGxpbmtSb2xlXCIsXG4gICAgICAgIHhsaW5rc2hvdzogXCJ4bGlua1Nob3dcIixcbiAgICAgICAgXCJ4bGluazpzaG93XCI6IFwieGxpbmtTaG93XCIsXG4gICAgICAgIHhsaW5rdGl0bGU6IFwieGxpbmtUaXRsZVwiLFxuICAgICAgICBcInhsaW5rOnRpdGxlXCI6IFwieGxpbmtUaXRsZVwiLFxuICAgICAgICB4bGlua3R5cGU6IFwieGxpbmtUeXBlXCIsXG4gICAgICAgIFwieGxpbms6dHlwZVwiOiBcInhsaW5rVHlwZVwiLFxuICAgICAgICB4bWxiYXNlOiBcInhtbEJhc2VcIixcbiAgICAgICAgXCJ4bWw6YmFzZVwiOiBcInhtbEJhc2VcIixcbiAgICAgICAgeG1sbGFuZzogXCJ4bWxMYW5nXCIsXG4gICAgICAgIFwieG1sOmxhbmdcIjogXCJ4bWxMYW5nXCIsXG4gICAgICAgIHhtbG5zOiBcInhtbG5zXCIsXG4gICAgICAgIFwieG1sOnNwYWNlXCI6IFwieG1sU3BhY2VcIixcbiAgICAgICAgeG1sbnN4bGluazogXCJ4bWxuc1hsaW5rXCIsXG4gICAgICAgIFwieG1sbnM6eGxpbmtcIjogXCJ4bWxuc1hsaW5rXCIsXG4gICAgICAgIHhtbHNwYWNlOiBcInhtbFNwYWNlXCIsXG4gICAgICAgIHkxOiBcInkxXCIsXG4gICAgICAgIHkyOiBcInkyXCIsXG4gICAgICAgIHk6IFwieVwiLFxuICAgICAgICB5Y2hhbm5lbHNlbGVjdG9yOiBcInlDaGFubmVsU2VsZWN0b3JcIixcbiAgICAgICAgejogXCJ6XCIsXG4gICAgICAgIHpvb21hbmRwYW46IFwiem9vbUFuZFBhblwiXG4gICAgICB9LFxuICAgICAgd2FybmVkUHJvcGVydGllcyA9IHt9LFxuICAgICAgRVZFTlRfTkFNRV9SRUdFWCA9IC9eb24uLyxcbiAgICAgIElOVkFMSURfRVZFTlRfTkFNRV9SRUdFWCA9IC9eb25bXkEtWl0vLFxuICAgICAgckFSSUEgPSBSZWdFeHAoXG4gICAgICAgIFwiXihhcmlhKS1bOkEtWl9hLXpcXFxcdTAwQzAtXFxcXHUwMEQ2XFxcXHUwMEQ4LVxcXFx1MDBGNlxcXFx1MDBGOC1cXFxcdTAyRkZcXFxcdTAzNzAtXFxcXHUwMzdEXFxcXHUwMzdGLVxcXFx1MUZGRlxcXFx1MjAwQy1cXFxcdTIwMERcXFxcdTIwNzAtXFxcXHUyMThGXFxcXHUyQzAwLVxcXFx1MkZFRlxcXFx1MzAwMS1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZGRFxcXFwtLjAtOVxcXFx1MDBCN1xcXFx1MDMwMC1cXFxcdTAzNkZcXFxcdTIwM0YtXFxcXHUyMDQwXSokXCJcbiAgICAgICksXG4gICAgICByQVJJQUNhbWVsID0gUmVnRXhwKFxuICAgICAgICBcIl4oYXJpYSlbQS1aXVs6QS1aX2EtelxcXFx1MDBDMC1cXFxcdTAwRDZcXFxcdTAwRDgtXFxcXHUwMEY2XFxcXHUwMEY4LVxcXFx1MDJGRlxcXFx1MDM3MC1cXFxcdTAzN0RcXFxcdTAzN0YtXFxcXHUxRkZGXFxcXHUyMDBDLVxcXFx1MjAwRFxcXFx1MjA3MC1cXFxcdTIxOEZcXFxcdTJDMDAtXFxcXHUyRkVGXFxcXHUzMDAxLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkZEXFxcXC0uMC05XFxcXHUwMEI3XFxcXHUwMzAwLVxcXFx1MDM2RlxcXFx1MjAzRi1cXFxcdTIwNDBdKiRcIlxuICAgICAgKSxcbiAgICAgIGJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybiA9IC9eKD86d2Via2l0fG1venxvKVtBLVpdLyxcbiAgICAgIG1zUGF0dGVybiQxID0gL14tbXMtLyxcbiAgICAgIGh5cGhlblBhdHRlcm4gPSAvLSguKS9nLFxuICAgICAgYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuID0gLztcXHMqJC8sXG4gICAgICB3YXJuZWRTdHlsZU5hbWVzID0ge30sXG4gICAgICB3YXJuZWRTdHlsZVZhbHVlcyA9IHt9LFxuICAgICAgd2FybmVkRm9yTmFOVmFsdWUgPSAhMSxcbiAgICAgIHdhcm5lZEZvckluZmluaXR5VmFsdWUgPSAhMSxcbiAgICAgIG1hdGNoSHRtbFJlZ0V4cCA9IC9bXCInJjw+XS8sXG4gICAgICB1cHBlcmNhc2VQYXR0ZXJuID0gLyhbQS1aXSkvZyxcbiAgICAgIG1zUGF0dGVybiA9IC9ebXMtLyxcbiAgICAgIGlzSmF2YVNjcmlwdFByb3RvY29sID1cbiAgICAgICAgL15bXFx1MDAwMC1cXHUwMDFGIF0qaltcXHJcXG5cXHRdKmFbXFxyXFxuXFx0XSp2W1xcclxcblxcdF0qYVtcXHJcXG5cXHRdKnNbXFxyXFxuXFx0XSpjW1xcclxcblxcdF0qcltcXHJcXG5cXHRdKmlbXFxyXFxuXFx0XSpwW1xcclxcblxcdF0qdFtcXHJcXG5cXHRdKjovaSxcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzID1cbiAgICAgICAgUmVhY3QuX19DTElFTlRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfV0FSTl9VU0VSU19USEVZX0NBTk5PVF9VUEdSQURFLFxuICAgICAgUmVhY3RET01TaGFyZWRJbnRlcm5hbHMgPVxuICAgICAgICBSZWFjdERPTS5fX0RPTV9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREUsXG4gICAgICBOb3RQZW5kaW5nID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIHBlbmRpbmc6ICExLFxuICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICBtZXRob2Q6IG51bGwsXG4gICAgICAgIGFjdGlvbjogbnVsbFxuICAgICAgfSksXG4gICAgICBwcmV2aW91c0Rpc3BhdGNoZXIgPSBSZWFjdERPTVNoYXJlZEludGVybmFscy5kO1xuICAgIFJlYWN0RE9NU2hhcmVkSW50ZXJuYWxzLmQgPSB7XG4gICAgICBmOiBwcmV2aW91c0Rpc3BhdGNoZXIuZixcbiAgICAgIHI6IHByZXZpb3VzRGlzcGF0Y2hlci5yLFxuICAgICAgRDogZnVuY3Rpb24gKGhyZWYpIHtcbiAgICAgICAgdmFyIHJlcXVlc3QgPSBjdXJyZW50UmVxdWVzdCA/IGN1cnJlbnRSZXF1ZXN0IDogbnVsbDtcbiAgICAgICAgaWYgKHJlcXVlc3QpIHtcbiAgICAgICAgICB2YXIgcmVzdW1hYmxlU3RhdGUgPSByZXF1ZXN0LnJlc3VtYWJsZVN0YXRlLFxuICAgICAgICAgICAgcmVuZGVyU3RhdGUgPSByZXF1ZXN0LnJlbmRlclN0YXRlO1xuICAgICAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgaHJlZiAmJiBocmVmKSB7XG4gICAgICAgICAgICBpZiAoIXJlc3VtYWJsZVN0YXRlLmRuc1Jlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShocmVmKSkge1xuICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZS5kbnNSZXNvdXJjZXNbaHJlZl0gPSBFWElTVFM7XG4gICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlID0gcmVuZGVyU3RhdGUuaGVhZGVycztcbiAgICAgICAgICAgICAgdmFyIGhlYWRlciwgSlNDb21waWxlcl90ZW1wO1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKEpTQ29tcGlsZXJfdGVtcCA9XG4gICAgICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZSAmJiAwIDwgcmVzdW1hYmxlU3RhdGUucmVtYWluaW5nQ2FwYWNpdHkpXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAgPVxuICAgICAgICAgICAgICAgICAgKChoZWFkZXIgPVxuICAgICAgICAgICAgICAgICAgICBcIjxcIiArXG4gICAgICAgICAgICAgICAgICAgIGVzY2FwZUhyZWZGb3JMaW5rSGVhZGVyVVJMQ29udGV4dChocmVmKSArXG4gICAgICAgICAgICAgICAgICAgIFwiPjsgcmVsPWRucy1wcmVmZXRjaFwiKSxcbiAgICAgICAgICAgICAgICAgIDAgPD0gKHJlc3VtYWJsZVN0YXRlLnJlbWFpbmluZ0NhcGFjaXR5IC09IGhlYWRlci5sZW5ndGggKyAyKSk7XG4gICAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcFxuICAgICAgICAgICAgICAgID8gKChyZW5kZXJTdGF0ZS5yZXNldHMuZG5zW2hyZWZdID0gRVhJU1RTKSxcbiAgICAgICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLnByZWNvbm5lY3RzICYmXG4gICAgICAgICAgICAgICAgICAgIChyZXN1bWFibGVTdGF0ZS5wcmVjb25uZWN0cyArPSBcIiwgXCIpLFxuICAgICAgICAgICAgICAgICAgKHJlc3VtYWJsZVN0YXRlLnByZWNvbm5lY3RzICs9IGhlYWRlcikpXG4gICAgICAgICAgICAgICAgOiAoKGhlYWRlciA9IFtdKSxcbiAgICAgICAgICAgICAgICAgIHB1c2hMaW5rSW1wbChoZWFkZXIsIHsgaHJlZjogaHJlZiwgcmVsOiBcImRucy1wcmVmZXRjaFwiIH0pLFxuICAgICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUucHJlY29ubmVjdHMuYWRkKGhlYWRlcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW5xdWV1ZUZsdXNoKHJlcXVlc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHByZXZpb3VzRGlzcGF0Y2hlci5EKGhyZWYpO1xuICAgICAgfSxcbiAgICAgIEM6IGZ1bmN0aW9uIChocmVmLCBjcm9zc09yaWdpbikge1xuICAgICAgICB2YXIgcmVxdWVzdCA9IGN1cnJlbnRSZXF1ZXN0ID8gY3VycmVudFJlcXVlc3QgOiBudWxsO1xuICAgICAgICBpZiAocmVxdWVzdCkge1xuICAgICAgICAgIHZhciByZXN1bWFibGVTdGF0ZSA9IHJlcXVlc3QucmVzdW1hYmxlU3RhdGUsXG4gICAgICAgICAgICByZW5kZXJTdGF0ZSA9IHJlcXVlc3QucmVuZGVyU3RhdGU7XG4gICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBocmVmICYmIGhyZWYpIHtcbiAgICAgICAgICAgIHZhciBidWNrZXQgPVxuICAgICAgICAgICAgICBcInVzZS1jcmVkZW50aWFsc1wiID09PSBjcm9zc09yaWdpblxuICAgICAgICAgICAgICAgID8gXCJjcmVkZW50aWFsc1wiXG4gICAgICAgICAgICAgICAgOiBcInN0cmluZ1wiID09PSB0eXBlb2YgY3Jvc3NPcmlnaW5cbiAgICAgICAgICAgICAgICAgID8gXCJhbm9ueW1vdXNcIlxuICAgICAgICAgICAgICAgICAgOiBcImRlZmF1bHRcIjtcbiAgICAgICAgICAgIGlmICghcmVzdW1hYmxlU3RhdGUuY29ubmVjdFJlc291cmNlc1tidWNrZXRdLmhhc093blByb3BlcnR5KGhyZWYpKSB7XG4gICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLmNvbm5lY3RSZXNvdXJjZXNbYnVja2V0XVtocmVmXSA9IEVYSVNUUztcbiAgICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUgPSByZW5kZXJTdGF0ZS5oZWFkZXJzO1xuICAgICAgICAgICAgICB2YXIgaGVhZGVyLCBKU0NvbXBpbGVyX3RlbXA7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoSlNDb21waWxlcl90ZW1wID1cbiAgICAgICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlICYmIDAgPCByZXN1bWFibGVTdGF0ZS5yZW1haW5pbmdDYXBhY2l0eSlcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgSlNDb21waWxlcl90ZW1wID1cbiAgICAgICAgICAgICAgICAgIFwiPFwiICtcbiAgICAgICAgICAgICAgICAgIGVzY2FwZUhyZWZGb3JMaW5rSGVhZGVyVVJMQ29udGV4dChocmVmKSArXG4gICAgICAgICAgICAgICAgICBcIj47IHJlbD1wcmVjb25uZWN0XCI7XG4gICAgICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBjcm9zc09yaWdpbikge1xuICAgICAgICAgICAgICAgICAgdmFyIGVzY2FwZWRDcm9zc09yaWdpbiA9XG4gICAgICAgICAgICAgICAgICAgIGVzY2FwZVN0cmluZ0ZvckxpbmtIZWFkZXJRdW90ZWRQYXJhbVZhbHVlQ29udGV4dChcbiAgICAgICAgICAgICAgICAgICAgICBjcm9zc09yaWdpbixcbiAgICAgICAgICAgICAgICAgICAgICBcImNyb3NzT3JpZ2luXCJcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcCArPVxuICAgICAgICAgICAgICAgICAgICAnOyBjcm9zc29yaWdpbj1cIicgKyBlc2NhcGVkQ3Jvc3NPcmlnaW4gKyAnXCInO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAgPVxuICAgICAgICAgICAgICAgICAgKChoZWFkZXIgPSBKU0NvbXBpbGVyX3RlbXApLFxuICAgICAgICAgICAgICAgICAgMCA8PSAocmVzdW1hYmxlU3RhdGUucmVtYWluaW5nQ2FwYWNpdHkgLT0gaGVhZGVyLmxlbmd0aCArIDIpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBKU0NvbXBpbGVyX3RlbXBcbiAgICAgICAgICAgICAgICA/ICgocmVuZGVyU3RhdGUucmVzZXRzLmNvbm5lY3RbYnVja2V0XVtocmVmXSA9IEVYSVNUUyksXG4gICAgICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZS5wcmVjb25uZWN0cyAmJlxuICAgICAgICAgICAgICAgICAgICAocmVzdW1hYmxlU3RhdGUucHJlY29ubmVjdHMgKz0gXCIsIFwiKSxcbiAgICAgICAgICAgICAgICAgIChyZXN1bWFibGVTdGF0ZS5wcmVjb25uZWN0cyArPSBoZWFkZXIpKVxuICAgICAgICAgICAgICAgIDogKChidWNrZXQgPSBbXSksXG4gICAgICAgICAgICAgICAgICBwdXNoTGlua0ltcGwoYnVja2V0LCB7XG4gICAgICAgICAgICAgICAgICAgIHJlbDogXCJwcmVjb25uZWN0XCIsXG4gICAgICAgICAgICAgICAgICAgIGhyZWY6IGhyZWYsXG4gICAgICAgICAgICAgICAgICAgIGNyb3NzT3JpZ2luOiBjcm9zc09yaWdpblxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5wcmVjb25uZWN0cy5hZGQoYnVja2V0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbnF1ZXVlRmx1c2gocmVxdWVzdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgcHJldmlvdXNEaXNwYXRjaGVyLkMoaHJlZiwgY3Jvc3NPcmlnaW4pO1xuICAgICAgfSxcbiAgICAgIEw6IGZ1bmN0aW9uIChocmVmLCBhcywgb3B0aW9ucykge1xuICAgICAgICB2YXIgcmVxdWVzdCA9IGN1cnJlbnRSZXF1ZXN0ID8gY3VycmVudFJlcXVlc3QgOiBudWxsO1xuICAgICAgICBpZiAocmVxdWVzdCkge1xuICAgICAgICAgIHZhciByZXN1bWFibGVTdGF0ZSA9IHJlcXVlc3QucmVzdW1hYmxlU3RhdGUsXG4gICAgICAgICAgICByZW5kZXJTdGF0ZSA9IHJlcXVlc3QucmVuZGVyU3RhdGU7XG4gICAgICAgICAgaWYgKGFzICYmIGhyZWYpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoYXMpIHtcbiAgICAgICAgICAgICAgY2FzZSBcImltYWdlXCI6XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBpbWFnZVNyY1NldCA9IG9wdGlvbnMuaW1hZ2VTcmNTZXQ7XG4gICAgICAgICAgICAgICAgICB2YXIgaW1hZ2VTaXplcyA9IG9wdGlvbnMuaW1hZ2VTaXplcztcbiAgICAgICAgICAgICAgICAgIHZhciBmZXRjaFByaW9yaXR5ID0gb3B0aW9ucy5mZXRjaFByaW9yaXR5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gaW1hZ2VTcmNTZXRcbiAgICAgICAgICAgICAgICAgID8gaW1hZ2VTcmNTZXQgKyBcIlxcblwiICsgKGltYWdlU2l6ZXMgfHwgXCJcIilcbiAgICAgICAgICAgICAgICAgIDogaHJlZjtcbiAgICAgICAgICAgICAgICBpZiAocmVzdW1hYmxlU3RhdGUuaW1hZ2VSZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoa2V5KSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLmltYWdlUmVzb3VyY2VzW2tleV0gPSBQUkVMT0FEX05PX0NSRURTO1xuICAgICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlID0gcmVuZGVyU3RhdGUuaGVhZGVycztcbiAgICAgICAgICAgICAgICB2YXIgaGVhZGVyO1xuICAgICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlICYmXG4gICAgICAgICAgICAgICAgMCA8IHJlc3VtYWJsZVN0YXRlLnJlbWFpbmluZ0NhcGFjaXR5ICYmXG4gICAgICAgICAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIGltYWdlU3JjU2V0ICYmXG4gICAgICAgICAgICAgICAgXCJoaWdoXCIgPT09IGZldGNoUHJpb3JpdHkgJiZcbiAgICAgICAgICAgICAgICAoKGhlYWRlciA9IGdldFByZWxvYWRBc0hlYWRlcihocmVmLCBhcywgb3B0aW9ucykpLFxuICAgICAgICAgICAgICAgIDAgPD0gKHJlc3VtYWJsZVN0YXRlLnJlbWFpbmluZ0NhcGFjaXR5IC09IGhlYWRlci5sZW5ndGggKyAyKSlcbiAgICAgICAgICAgICAgICAgID8gKChyZW5kZXJTdGF0ZS5yZXNldHMuaW1hZ2Vba2V5XSA9IFBSRUxPQURfTk9fQ1JFRFMpLFxuICAgICAgICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZS5oaWdoSW1hZ2VQcmVsb2FkcyAmJlxuICAgICAgICAgICAgICAgICAgICAgIChyZXN1bWFibGVTdGF0ZS5oaWdoSW1hZ2VQcmVsb2FkcyArPSBcIiwgXCIpLFxuICAgICAgICAgICAgICAgICAgICAocmVzdW1hYmxlU3RhdGUuaGlnaEltYWdlUHJlbG9hZHMgKz0gaGVhZGVyKSlcbiAgICAgICAgICAgICAgICAgIDogKChyZXN1bWFibGVTdGF0ZSA9IFtdKSxcbiAgICAgICAgICAgICAgICAgICAgcHVzaExpbmtJbXBsKFxuICAgICAgICAgICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLFxuICAgICAgICAgICAgICAgICAgICAgIGFzc2lnbihcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVsOiBcInByZWxvYWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaHJlZjogaW1hZ2VTcmNTZXQgPyB2b2lkIDAgOiBocmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhczogYXNcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICBcImhpZ2hcIiA9PT0gZmV0Y2hQcmlvcml0eVxuICAgICAgICAgICAgICAgICAgICAgID8gcmVuZGVyU3RhdGUuaGlnaEltYWdlUHJlbG9hZHMuYWRkKHJlc3VtYWJsZVN0YXRlKVxuICAgICAgICAgICAgICAgICAgICAgIDogKHJlbmRlclN0YXRlLmJ1bGtQcmVsb2Fkcy5hZGQocmVzdW1hYmxlU3RhdGUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUucHJlbG9hZHMuaW1hZ2VzLnNldChrZXksIHJlc3VtYWJsZVN0YXRlKSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwic3R5bGVcIjpcbiAgICAgICAgICAgICAgICBpZiAocmVzdW1hYmxlU3RhdGUuc3R5bGVSZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoaHJlZikpIHJldHVybjtcbiAgICAgICAgICAgICAgICBpbWFnZVNyY1NldCA9IFtdO1xuICAgICAgICAgICAgICAgIHB1c2hMaW5rSW1wbChcbiAgICAgICAgICAgICAgICAgIGltYWdlU3JjU2V0LFxuICAgICAgICAgICAgICAgICAgYXNzaWduKHsgcmVsOiBcInByZWxvYWRcIiwgaHJlZjogaHJlZiwgYXM6IGFzIH0sIG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZS5zdHlsZVJlc291cmNlc1tocmVmXSA9XG4gICAgICAgICAgICAgICAgICAhb3B0aW9ucyB8fFxuICAgICAgICAgICAgICAgICAgKFwic3RyaW5nXCIgIT09IHR5cGVvZiBvcHRpb25zLmNyb3NzT3JpZ2luICYmXG4gICAgICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgIT09IHR5cGVvZiBvcHRpb25zLmludGVncml0eSlcbiAgICAgICAgICAgICAgICAgICAgPyBQUkVMT0FEX05PX0NSRURTXG4gICAgICAgICAgICAgICAgICAgIDogW29wdGlvbnMuY3Jvc3NPcmlnaW4sIG9wdGlvbnMuaW50ZWdyaXR5XTtcbiAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5wcmVsb2Fkcy5zdHlsZXNoZWV0cy5zZXQoaHJlZiwgaW1hZ2VTcmNTZXQpO1xuICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlLmJ1bGtQcmVsb2Fkcy5hZGQoaW1hZ2VTcmNTZXQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwic2NyaXB0XCI6XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VtYWJsZVN0YXRlLnNjcmlwdFJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShocmVmKSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGltYWdlU3JjU2V0ID0gW107XG4gICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUucHJlbG9hZHMuc2NyaXB0cy5zZXQoaHJlZiwgaW1hZ2VTcmNTZXQpO1xuICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlLmJ1bGtQcmVsb2Fkcy5hZGQoaW1hZ2VTcmNTZXQpO1xuICAgICAgICAgICAgICAgIHB1c2hMaW5rSW1wbChcbiAgICAgICAgICAgICAgICAgIGltYWdlU3JjU2V0LFxuICAgICAgICAgICAgICAgICAgYXNzaWduKHsgcmVsOiBcInByZWxvYWRcIiwgaHJlZjogaHJlZiwgYXM6IGFzIH0sIG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZS5zY3JpcHRSZXNvdXJjZXNbaHJlZl0gPVxuICAgICAgICAgICAgICAgICAgIW9wdGlvbnMgfHxcbiAgICAgICAgICAgICAgICAgIChcInN0cmluZ1wiICE9PSB0eXBlb2Ygb3B0aW9ucy5jcm9zc09yaWdpbiAmJlxuICAgICAgICAgICAgICAgICAgICBcInN0cmluZ1wiICE9PSB0eXBlb2Ygb3B0aW9ucy5pbnRlZ3JpdHkpXG4gICAgICAgICAgICAgICAgICAgID8gUFJFTE9BRF9OT19DUkVEU1xuICAgICAgICAgICAgICAgICAgICA6IFtvcHRpb25zLmNyb3NzT3JpZ2luLCBvcHRpb25zLmludGVncml0eV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VtYWJsZVN0YXRlLnVua25vd25SZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoYXMpKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICgoaW1hZ2VTcmNTZXQgPSByZXN1bWFibGVTdGF0ZS51bmtub3duUmVzb3VyY2VzW2FzXSksXG4gICAgICAgICAgICAgICAgICAgIGltYWdlU3JjU2V0Lmhhc093blByb3BlcnR5KGhyZWYpKVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAoaW1hZ2VTcmNTZXQgPSB7fSksXG4gICAgICAgICAgICAgICAgICAgIChyZXN1bWFibGVTdGF0ZS51bmtub3duUmVzb3VyY2VzW2FzXSA9IGltYWdlU3JjU2V0KTtcbiAgICAgICAgICAgICAgICBpbWFnZVNyY1NldFtocmVmXSA9IFBSRUxPQURfTk9fQ1JFRFM7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgKHJlc3VtYWJsZVN0YXRlID0gcmVuZGVyU3RhdGUuaGVhZGVycykgJiZcbiAgICAgICAgICAgICAgICAgIDAgPCByZXN1bWFibGVTdGF0ZS5yZW1haW5pbmdDYXBhY2l0eSAmJlxuICAgICAgICAgICAgICAgICAgXCJmb250XCIgPT09IGFzICYmXG4gICAgICAgICAgICAgICAgICAoKGtleSA9IGdldFByZWxvYWRBc0hlYWRlcihocmVmLCBhcywgb3B0aW9ucykpLFxuICAgICAgICAgICAgICAgICAgMCA8PSAocmVzdW1hYmxlU3RhdGUucmVtYWluaW5nQ2FwYWNpdHkgLT0ga2V5Lmxlbmd0aCArIDIpKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIChyZW5kZXJTdGF0ZS5yZXNldHMuZm9udFtocmVmXSA9IFBSRUxPQURfTk9fQ1JFRFMpLFxuICAgICAgICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZS5mb250UHJlbG9hZHMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAocmVzdW1hYmxlU3RhdGUuZm9udFByZWxvYWRzICs9IFwiLCBcIiksXG4gICAgICAgICAgICAgICAgICAgIChyZXN1bWFibGVTdGF0ZS5mb250UHJlbG9hZHMgKz0ga2V5KTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICBzd2l0Y2ggKFxuICAgICAgICAgICAgICAgICAgICAoKHJlc3VtYWJsZVN0YXRlID0gW10pLFxuICAgICAgICAgICAgICAgICAgICAoaHJlZiA9IGFzc2lnbihcbiAgICAgICAgICAgICAgICAgICAgICB7IHJlbDogXCJwcmVsb2FkXCIsIGhyZWY6IGhyZWYsIGFzOiBhcyB9LFxuICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgICAgIHB1c2hMaW5rSW1wbChyZXN1bWFibGVTdGF0ZSwgaHJlZiksXG4gICAgICAgICAgICAgICAgICAgIGFzKVxuICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmb250XCI6XG4gICAgICAgICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUuZm9udFByZWxvYWRzLmFkZChyZXN1bWFibGVTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUuYnVsa1ByZWxvYWRzLmFkZChyZXN1bWFibGVTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbnF1ZXVlRmx1c2gocmVxdWVzdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgcHJldmlvdXNEaXNwYXRjaGVyLkwoaHJlZiwgYXMsIG9wdGlvbnMpO1xuICAgICAgfSxcbiAgICAgIG06IGZ1bmN0aW9uIChocmVmLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciByZXF1ZXN0ID0gY3VycmVudFJlcXVlc3QgPyBjdXJyZW50UmVxdWVzdCA6IG51bGw7XG4gICAgICAgIGlmIChyZXF1ZXN0KSB7XG4gICAgICAgICAgdmFyIHJlc3VtYWJsZVN0YXRlID0gcmVxdWVzdC5yZXN1bWFibGVTdGF0ZSxcbiAgICAgICAgICAgIHJlbmRlclN0YXRlID0gcmVxdWVzdC5yZW5kZXJTdGF0ZTtcbiAgICAgICAgICBpZiAoaHJlZikge1xuICAgICAgICAgICAgdmFyIGFzID1cbiAgICAgICAgICAgICAgb3B0aW9ucyAmJiBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy5hcyA/IG9wdGlvbnMuYXMgOiBcInNjcmlwdFwiO1xuICAgICAgICAgICAgc3dpdGNoIChhcykge1xuICAgICAgICAgICAgICBjYXNlIFwic2NyaXB0XCI6XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VtYWJsZVN0YXRlLm1vZHVsZVNjcmlwdFJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShocmVmKSlcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBhcyA9IFtdO1xuICAgICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLm1vZHVsZVNjcmlwdFJlc291cmNlc1tocmVmXSA9XG4gICAgICAgICAgICAgICAgICAhb3B0aW9ucyB8fFxuICAgICAgICAgICAgICAgICAgKFwic3RyaW5nXCIgIT09IHR5cGVvZiBvcHRpb25zLmNyb3NzT3JpZ2luICYmXG4gICAgICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgIT09IHR5cGVvZiBvcHRpb25zLmludGVncml0eSlcbiAgICAgICAgICAgICAgICAgICAgPyBQUkVMT0FEX05PX0NSRURTXG4gICAgICAgICAgICAgICAgICAgIDogW29wdGlvbnMuY3Jvc3NPcmlnaW4sIG9wdGlvbnMuaW50ZWdyaXR5XTtcbiAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5wcmVsb2Fkcy5tb2R1bGVTY3JpcHRzLnNldChocmVmLCBhcyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VtYWJsZVN0YXRlLm1vZHVsZVVua25vd25SZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoYXMpKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcmVzb3VyY2VzID0gcmVzdW1hYmxlU3RhdGUudW5rbm93blJlc291cmNlc1thc107XG4gICAgICAgICAgICAgICAgICBpZiAocmVzb3VyY2VzLmhhc093blByb3BlcnR5KGhyZWYpKSByZXR1cm47XG4gICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAocmVzb3VyY2VzID0ge30pLFxuICAgICAgICAgICAgICAgICAgICAocmVzdW1hYmxlU3RhdGUubW9kdWxlVW5rbm93blJlc291cmNlc1thc10gPSByZXNvdXJjZXMpO1xuICAgICAgICAgICAgICAgIGFzID0gW107XG4gICAgICAgICAgICAgICAgcmVzb3VyY2VzW2hyZWZdID0gUFJFTE9BRF9OT19DUkVEUztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHB1c2hMaW5rSW1wbChcbiAgICAgICAgICAgICAgYXMsXG4gICAgICAgICAgICAgIGFzc2lnbih7IHJlbDogXCJtb2R1bGVwcmVsb2FkXCIsIGhyZWY6IGhyZWYgfSwgb3B0aW9ucylcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZS5idWxrUHJlbG9hZHMuYWRkKGFzKTtcbiAgICAgICAgICAgIGVucXVldWVGbHVzaChyZXF1ZXN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBwcmV2aW91c0Rpc3BhdGNoZXIubShocmVmLCBvcHRpb25zKTtcbiAgICAgIH0sXG4gICAgICBYOiBmdW5jdGlvbiAoc3JjLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciByZXF1ZXN0ID0gY3VycmVudFJlcXVlc3QgPyBjdXJyZW50UmVxdWVzdCA6IG51bGw7XG4gICAgICAgIGlmIChyZXF1ZXN0KSB7XG4gICAgICAgICAgdmFyIHJlc3VtYWJsZVN0YXRlID0gcmVxdWVzdC5yZXN1bWFibGVTdGF0ZSxcbiAgICAgICAgICAgIHJlbmRlclN0YXRlID0gcmVxdWVzdC5yZW5kZXJTdGF0ZTtcbiAgICAgICAgICBpZiAoc3JjKSB7XG4gICAgICAgICAgICB2YXIgcmVzb3VyY2VTdGF0ZSA9IHJlc3VtYWJsZVN0YXRlLnNjcmlwdFJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShcbiAgICAgICAgICAgICAgc3JjXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgID8gcmVzdW1hYmxlU3RhdGUuc2NyaXB0UmVzb3VyY2VzW3NyY11cbiAgICAgICAgICAgICAgOiB2b2lkIDA7XG4gICAgICAgICAgICByZXNvdXJjZVN0YXRlICE9PSBFWElTVFMgJiZcbiAgICAgICAgICAgICAgKChyZXN1bWFibGVTdGF0ZS5zY3JpcHRSZXNvdXJjZXNbc3JjXSA9IEVYSVNUUyksXG4gICAgICAgICAgICAgIChvcHRpb25zID0gYXNzaWduKHsgc3JjOiBzcmMsIGFzeW5jOiAhMCB9LCBvcHRpb25zKSksXG4gICAgICAgICAgICAgIHJlc291cmNlU3RhdGUgJiZcbiAgICAgICAgICAgICAgICAoMiA9PT0gcmVzb3VyY2VTdGF0ZS5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgIGFkb3B0UHJlbG9hZENyZWRlbnRpYWxzKG9wdGlvbnMsIHJlc291cmNlU3RhdGUpLFxuICAgICAgICAgICAgICAgIChzcmMgPSByZW5kZXJTdGF0ZS5wcmVsb2Fkcy5zY3JpcHRzLmdldChzcmMpKSkgJiZcbiAgICAgICAgICAgICAgICAoc3JjLmxlbmd0aCA9IDApLFxuICAgICAgICAgICAgICAoc3JjID0gW10pLFxuICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5zY3JpcHRzLmFkZChzcmMpLFxuICAgICAgICAgICAgICBwdXNoU2NyaXB0SW1wbChzcmMsIG9wdGlvbnMpLFxuICAgICAgICAgICAgICBlbnF1ZXVlRmx1c2gocmVxdWVzdCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHByZXZpb3VzRGlzcGF0Y2hlci5YKHNyYywgb3B0aW9ucyk7XG4gICAgICB9LFxuICAgICAgUzogZnVuY3Rpb24gKGhyZWYsIHByZWNlZGVuY2UsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHJlcXVlc3QgPSBjdXJyZW50UmVxdWVzdCA/IGN1cnJlbnRSZXF1ZXN0IDogbnVsbDtcbiAgICAgICAgaWYgKHJlcXVlc3QpIHtcbiAgICAgICAgICB2YXIgcmVzdW1hYmxlU3RhdGUgPSByZXF1ZXN0LnJlc3VtYWJsZVN0YXRlLFxuICAgICAgICAgICAgcmVuZGVyU3RhdGUgPSByZXF1ZXN0LnJlbmRlclN0YXRlO1xuICAgICAgICAgIGlmIChocmVmKSB7XG4gICAgICAgICAgICBwcmVjZWRlbmNlID0gcHJlY2VkZW5jZSB8fCBcImRlZmF1bHRcIjtcbiAgICAgICAgICAgIHZhciBzdHlsZVF1ZXVlID0gcmVuZGVyU3RhdGUuc3R5bGVzLmdldChwcmVjZWRlbmNlKSxcbiAgICAgICAgICAgICAgcmVzb3VyY2VTdGF0ZSA9IHJlc3VtYWJsZVN0YXRlLnN0eWxlUmVzb3VyY2VzLmhhc093blByb3BlcnR5KGhyZWYpXG4gICAgICAgICAgICAgICAgPyByZXN1bWFibGVTdGF0ZS5zdHlsZVJlc291cmNlc1tocmVmXVxuICAgICAgICAgICAgICAgIDogdm9pZCAwO1xuICAgICAgICAgICAgcmVzb3VyY2VTdGF0ZSAhPT0gRVhJU1RTICYmXG4gICAgICAgICAgICAgICgocmVzdW1hYmxlU3RhdGUuc3R5bGVSZXNvdXJjZXNbaHJlZl0gPSBFWElTVFMpLFxuICAgICAgICAgICAgICBzdHlsZVF1ZXVlIHx8XG4gICAgICAgICAgICAgICAgKChzdHlsZVF1ZXVlID0ge1xuICAgICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihwcmVjZWRlbmNlKSksXG4gICAgICAgICAgICAgICAgICBydWxlczogW10sXG4gICAgICAgICAgICAgICAgICBocmVmczogW10sXG4gICAgICAgICAgICAgICAgICBzaGVldHM6IG5ldyBNYXAoKVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlLnN0eWxlcy5zZXQocHJlY2VkZW5jZSwgc3R5bGVRdWV1ZSkpLFxuICAgICAgICAgICAgICAocHJlY2VkZW5jZSA9IHtcbiAgICAgICAgICAgICAgICBzdGF0ZTogUEVORElORyQxLFxuICAgICAgICAgICAgICAgIHByb3BzOiBhc3NpZ24oXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJlbDogXCJzdHlsZXNoZWV0XCIsXG4gICAgICAgICAgICAgICAgICAgIGhyZWY6IGhyZWYsXG4gICAgICAgICAgICAgICAgICAgIFwiZGF0YS1wcmVjZWRlbmNlXCI6IHByZWNlZGVuY2VcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgcmVzb3VyY2VTdGF0ZSAmJlxuICAgICAgICAgICAgICAgICgyID09PSByZXNvdXJjZVN0YXRlLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgYWRvcHRQcmVsb2FkQ3JlZGVudGlhbHMocHJlY2VkZW5jZS5wcm9wcywgcmVzb3VyY2VTdGF0ZSksXG4gICAgICAgICAgICAgICAgKHJlbmRlclN0YXRlID0gcmVuZGVyU3RhdGUucHJlbG9hZHMuc3R5bGVzaGVldHMuZ2V0KGhyZWYpKSAmJlxuICAgICAgICAgICAgICAgIDAgPCByZW5kZXJTdGF0ZS5sZW5ndGhcbiAgICAgICAgICAgICAgICAgID8gKHJlbmRlclN0YXRlLmxlbmd0aCA9IDApXG4gICAgICAgICAgICAgICAgICA6IChwcmVjZWRlbmNlLnN0YXRlID0gUFJFTE9BREVEKSksXG4gICAgICAgICAgICAgIHN0eWxlUXVldWUuc2hlZXRzLnNldChocmVmLCBwcmVjZWRlbmNlKSxcbiAgICAgICAgICAgICAgZW5xdWV1ZUZsdXNoKHJlcXVlc3QpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBwcmV2aW91c0Rpc3BhdGNoZXIuUyhocmVmLCBwcmVjZWRlbmNlLCBvcHRpb25zKTtcbiAgICAgIH0sXG4gICAgICBNOiBmdW5jdGlvbiAoc3JjLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciByZXF1ZXN0ID0gY3VycmVudFJlcXVlc3QgPyBjdXJyZW50UmVxdWVzdCA6IG51bGw7XG4gICAgICAgIGlmIChyZXF1ZXN0KSB7XG4gICAgICAgICAgdmFyIHJlc3VtYWJsZVN0YXRlID0gcmVxdWVzdC5yZXN1bWFibGVTdGF0ZSxcbiAgICAgICAgICAgIHJlbmRlclN0YXRlID0gcmVxdWVzdC5yZW5kZXJTdGF0ZTtcbiAgICAgICAgICBpZiAoc3JjKSB7XG4gICAgICAgICAgICB2YXIgcmVzb3VyY2VTdGF0ZSA9XG4gICAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLm1vZHVsZVNjcmlwdFJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShzcmMpXG4gICAgICAgICAgICAgICAgPyByZXN1bWFibGVTdGF0ZS5tb2R1bGVTY3JpcHRSZXNvdXJjZXNbc3JjXVxuICAgICAgICAgICAgICAgIDogdm9pZCAwO1xuICAgICAgICAgICAgcmVzb3VyY2VTdGF0ZSAhPT0gRVhJU1RTICYmXG4gICAgICAgICAgICAgICgocmVzdW1hYmxlU3RhdGUubW9kdWxlU2NyaXB0UmVzb3VyY2VzW3NyY10gPSBFWElTVFMpLFxuICAgICAgICAgICAgICAob3B0aW9ucyA9IGFzc2lnbihcbiAgICAgICAgICAgICAgICB7IHNyYzogc3JjLCB0eXBlOiBcIm1vZHVsZVwiLCBhc3luYzogITAgfSxcbiAgICAgICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICByZXNvdXJjZVN0YXRlICYmXG4gICAgICAgICAgICAgICAgKDIgPT09IHJlc291cmNlU3RhdGUubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICBhZG9wdFByZWxvYWRDcmVkZW50aWFscyhvcHRpb25zLCByZXNvdXJjZVN0YXRlKSxcbiAgICAgICAgICAgICAgICAoc3JjID0gcmVuZGVyU3RhdGUucHJlbG9hZHMubW9kdWxlU2NyaXB0cy5nZXQoc3JjKSkpICYmXG4gICAgICAgICAgICAgICAgKHNyYy5sZW5ndGggPSAwKSxcbiAgICAgICAgICAgICAgKHNyYyA9IFtdKSxcbiAgICAgICAgICAgICAgcmVuZGVyU3RhdGUuc2NyaXB0cy5hZGQoc3JjKSxcbiAgICAgICAgICAgICAgcHVzaFNjcmlwdEltcGwoc3JjLCBvcHRpb25zKSxcbiAgICAgICAgICAgICAgZW5xdWV1ZUZsdXNoKHJlcXVlc3QpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBwcmV2aW91c0Rpc3BhdGNoZXIuTShzcmMsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIE5vdGhpbmdTZW50ID0gMCxcbiAgICAgIFNlbnRDb21wbGV0ZVNlZ21lbnRGdW5jdGlvbiA9IDEsXG4gICAgICBTZW50Q29tcGxldGVCb3VuZGFyeUZ1bmN0aW9uID0gMixcbiAgICAgIFNlbnRDbGllbnRSZW5kZXJGdW5jdGlvbiA9IDQsXG4gICAgICBTZW50U3R5bGVJbnNlcnRpb25GdW5jdGlvbiA9IDgsXG4gICAgICBTZW50Q29tcGxldGVkU2hlbGxJZCA9IDMyLFxuICAgICAgU2VudE1hcmtTaGVsbFRpbWUgPSA2NCxcbiAgICAgIEVYSVNUUyA9IG51bGwsXG4gICAgICBQUkVMT0FEX05PX0NSRURTID0gW107XG4gICAgT2JqZWN0LmZyZWV6ZShQUkVMT0FEX05PX0NSRURTKTtcbiAgICB2YXIgY3VycmVudGx5Rmx1c2hpbmdSZW5kZXJTdGF0ZSA9IG51bGw7XG4gICAgc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIj48L3RlbXBsYXRlPicpO1xuICAgIHZhciBzdGFydElubGluZVNjcmlwdCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhcIjxzY3JpcHRcIiksXG4gICAgICBlbmRJbmxpbmVTY3JpcHQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXCJcXHgzYy9zY3JpcHQ+XCIpLFxuICAgICAgc3RhcnRTY3JpcHRTcmMgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzxzY3JpcHQgc3JjPVwiJyksXG4gICAgICBzdGFydE1vZHVsZVNyYyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHNjcmlwdCB0eXBlPVwibW9kdWxlXCIgc3JjPVwiJyksXG4gICAgICBzY3JpcHROb25jZSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnIG5vbmNlPVwiJyksXG4gICAgICBzY3JpcHRJbnRlZ2lydHkgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJyBpbnRlZ3JpdHk9XCInKSxcbiAgICAgIHNjcmlwdENyb3NzT3JpZ2luID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCcgY3Jvc3NvcmlnaW49XCInKSxcbiAgICAgIGVuZEFzeW5jU2NyaXB0ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCcgYXN5bmM9XCJcIj5cXHgzYy9zY3JpcHQ+JyksXG4gICAgICBzdGFydElubGluZVN0eWxlID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFwiPHN0eWxlXCIpLFxuICAgICAgc2NyaXB0UmVnZXggPSAvKDxcXC98PCkocykoY3JpcHQpL2dpLFxuICAgICAgaW1wb3J0TWFwU2NyaXB0U3RhcnQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXG4gICAgICAgICc8c2NyaXB0IHR5cGU9XCJpbXBvcnRtYXBcIj4nXG4gICAgICApLFxuICAgICAgaW1wb3J0TWFwU2NyaXB0RW5kID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFwiXFx4M2Mvc2NyaXB0PlwiKTtcbiAgICB2YXIgZGlkV2FybkZvck5ld0Jvb2xlYW5Qcm9wc1dpdGhFbXB0eVZhbHVlID0ge307XG4gICAgdmFyIFJPT1RfSFRNTF9NT0RFID0gMCxcbiAgICAgIEhUTUxfSFRNTF9NT0RFID0gMSxcbiAgICAgIEhUTUxfTU9ERSA9IDIsXG4gICAgICBIVE1MX0hFQURfTU9ERSA9IDMsXG4gICAgICBTVkdfTU9ERSA9IDQsXG4gICAgICBNQVRITUxfTU9ERSA9IDUsXG4gICAgICBIVE1MX1RBQkxFX01PREUgPSA2LFxuICAgICAgSFRNTF9UQUJMRV9CT0RZX01PREUgPSA3LFxuICAgICAgSFRNTF9UQUJMRV9ST1dfTU9ERSA9IDgsXG4gICAgICBIVE1MX0NPTEdST1VQX01PREUgPSA5LFxuICAgICAgdGV4dFNlcGFyYXRvciA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhcIlxceDNjIS0tIC0tXFx4M2VcIiksXG4gICAgICBzdHlsZU5hbWVDYWNoZSA9IG5ldyBNYXAoKSxcbiAgICAgIHN0eWxlQXR0cmlidXRlU3RhcnQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJyBzdHlsZT1cIicpLFxuICAgICAgc3R5bGVBc3NpZ24gPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXCI6XCIpLFxuICAgICAgc3R5bGVTZXBhcmF0b3IgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXCI7XCIpLFxuICAgICAgYXR0cmlidXRlU2VwYXJhdG9yID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFwiIFwiKSxcbiAgICAgIGF0dHJpYnV0ZUFzc2lnbiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPVwiJyksXG4gICAgICBhdHRyaWJ1dGVFbmQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiJyksXG4gICAgICBhdHRyaWJ1dGVFbXB0eVN0cmluZyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPVwiXCInKSxcbiAgICAgIGFjdGlvbkphdmFTY3JpcHRVUkwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXG4gICAgICAgIGVzY2FwZVRleHRGb3JCcm93c2VyKFxuICAgICAgICAgIFwiamF2YXNjcmlwdDp0aHJvdyBuZXcgRXJyb3IoJ1JlYWN0IGZvcm0gdW5leHBlY3RlZGx5IHN1Ym1pdHRlZC4nKVwiXG4gICAgICAgIClcbiAgICAgICksXG4gICAgICBzdGFydEhpZGRlbklucHV0Q2h1bmsgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzxpbnB1dCB0eXBlPVwiaGlkZGVuXCInKSxcbiAgICAgIGVuZE9mU3RhcnRUYWcgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXCI+XCIpLFxuICAgICAgZW5kT2ZTdGFydFRhZ1NlbGZDbG9zaW5nID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFwiLz5cIiksXG4gICAgICBkaWRXYXJuRGVmYXVsdElucHV0VmFsdWUgPSAhMSxcbiAgICAgIGRpZFdhcm5EZWZhdWx0Q2hlY2tlZCA9ICExLFxuICAgICAgZGlkV2FybkRlZmF1bHRTZWxlY3RWYWx1ZSA9ICExLFxuICAgICAgZGlkV2FybkRlZmF1bHRUZXh0YXJlYVZhbHVlID0gITEsXG4gICAgICBkaWRXYXJuSW52YWxpZE9wdGlvbkNoaWxkcmVuID0gITEsXG4gICAgICBkaWRXYXJuSW52YWxpZE9wdGlvbklubmVySFRNTCA9ICExLFxuICAgICAgZGlkV2FyblNlbGVjdGVkU2V0T25PcHRpb24gPSAhMSxcbiAgICAgIGRpZFdhcm5Gb3JtQWN0aW9uVHlwZSA9ICExLFxuICAgICAgZGlkV2FybkZvcm1BY3Rpb25OYW1lID0gITEsXG4gICAgICBkaWRXYXJuRm9ybUFjdGlvblRhcmdldCA9ICExLFxuICAgICAgZGlkV2FybkZvcm1BY3Rpb25NZXRob2QgPSAhMSxcbiAgICAgIHNlbGVjdGVkTWFya2VyQXR0cmlidXRlID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCcgc2VsZWN0ZWQ9XCJcIicpLFxuICAgICAgZm9ybVJlcGxheWluZ1J1bnRpbWVTY3JpcHQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXG4gICAgICAgICdhZGRFdmVudExpc3RlbmVyKFwic3VibWl0XCIsZnVuY3Rpb24oYSl7aWYoIWEuZGVmYXVsdFByZXZlbnRlZCl7dmFyIGM9YS50YXJnZXQsZD1hLnN1Ym1pdHRlcixlPWMuYWN0aW9uLGI9ZDtpZihkKXt2YXIgZj1kLmdldEF0dHJpYnV0ZShcImZvcm1BY3Rpb25cIik7bnVsbCE9ZiYmKGU9ZixiPW51bGwpfVwiamF2YXNjcmlwdDp0aHJvdyBuZXcgRXJyb3IoXFwnUmVhY3QgZm9ybSB1bmV4cGVjdGVkbHkgc3VibWl0dGVkLlxcJylcIj09PWUmJihhLnByZXZlbnREZWZhdWx0KCksYj8oYT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIiksYS5uYW1lPWIubmFtZSxhLnZhbHVlPWIudmFsdWUsYi5wYXJlbnROb2RlLmluc2VydEJlZm9yZShhLGIpLGI9bmV3IEZvcm1EYXRhKGMpLGEucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChhKSk6Yj1uZXcgRm9ybURhdGEoYyksYT1jLm93bmVyRG9jdW1lbnR8fGMsKGEuJCRyZWFjdEZvcm1SZXBsYXk9YS4kJHJlYWN0Rm9ybVJlcGxheXx8W10pLnB1c2goYyxkLGIpKX19KTsnXG4gICAgICApLFxuICAgICAgZm9ybVN0YXRlTWFya2VySXNNYXRjaGluZyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhcIlxceDNjIS0tRiEtLVxceDNlXCIpLFxuICAgICAgZm9ybVN0YXRlTWFya2VySXNOb3RNYXRjaGluZyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhcIlxceDNjIS0tRi0tXFx4M2VcIiksXG4gICAgICBzdHlsZVJlZ2V4ID0gLyg8XFwvfDwpKHMpKHR5bGUpL2dpLFxuICAgICAgaGVhZFByZWFtYmxlQ29udHJpYnV0aW9uQ2h1bmsgPVxuICAgICAgICBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXCJcXHgzYyEtLWhlYWQtLVxceDNlXCIpLFxuICAgICAgYm9keVByZWFtYmxlQ29udHJpYnV0aW9uQ2h1bmsgPVxuICAgICAgICBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXCJcXHgzYyEtLWJvZHktLVxceDNlXCIpLFxuICAgICAgaHRtbFByZWFtYmxlQ29udHJpYnV0aW9uQ2h1bmsgPVxuICAgICAgICBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXCJcXHgzYyEtLWh0bWwtLVxceDNlXCIpLFxuICAgICAgbGVhZGluZ05ld2xpbmUgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXCJcXG5cIiksXG4gICAgICBWQUxJRF9UQUdfUkVHRVggPSAvXlthLXpBLVpdW2EtekEtWjpfXFwuXFwtXFxkXSokLyxcbiAgICAgIHZhbGlkYXRlZFRhZ0NhY2hlID0gbmV3IE1hcCgpLFxuICAgICAgZG9jdHlwZUNodW5rID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFwiPCFET0NUWVBFIGh0bWw+XCIpLFxuICAgICAgZW5kVGFnQ2FjaGUgPSBuZXcgTWFwKCksXG4gICAgICBzaGVsbFRpbWVSdW50aW1lU2NyaXB0ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFxuICAgICAgICBcInJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpeyRSVD1wZXJmb3JtYW5jZS5ub3coKX0pO1wiXG4gICAgICApLFxuICAgICAgcGxhY2Vob2xkZXIxID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8dGVtcGxhdGUgaWQ9XCInKSxcbiAgICAgIHBsYWNlaG9sZGVyMiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCI+PC90ZW1wbGF0ZT4nKSxcbiAgICAgIHN0YXJ0QWN0aXZpdHlCb3VuZGFyeSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhcIlxceDNjIS0tJi0tXFx4M2VcIiksXG4gICAgICBlbmRBY3Rpdml0eUJvdW5kYXJ5ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFwiXFx4M2MhLS0vJi0tXFx4M2VcIiksXG4gICAgICBzdGFydENvbXBsZXRlZFN1c3BlbnNlQm91bmRhcnkgPVxuICAgICAgICBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXCJcXHgzYyEtLSQtLVxceDNlXCIpLFxuICAgICAgc3RhcnRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeTEgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXG4gICAgICAgICdcXHgzYyEtLSQ/LS1cXHgzZTx0ZW1wbGF0ZSBpZD1cIidcbiAgICAgICksXG4gICAgICBzdGFydFBlbmRpbmdTdXNwZW5zZUJvdW5kYXJ5MiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCI+PC90ZW1wbGF0ZT4nKSxcbiAgICAgIHN0YXJ0Q2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5ID1cbiAgICAgICAgc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFwiXFx4M2MhLS0kIS0tXFx4M2VcIiksXG4gICAgICBlbmRTdXNwZW5zZUJvdW5kYXJ5ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFwiXFx4M2MhLS0vJC0tXFx4M2VcIiksXG4gICAgICBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjEgPVxuICAgICAgICBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXCI8dGVtcGxhdGVcIiksXG4gICAgICBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvckF0dHJJbnRlcnN0aXRpYWwgPVxuICAgICAgICBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiJyksXG4gICAgICBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjFBID1cbiAgICAgICAgc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCcgZGF0YS1kZ3N0PVwiJyksXG4gICAgICBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjFCID1cbiAgICAgICAgc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCcgZGF0YS1tc2c9XCInKSxcbiAgICAgIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yMUMgPVxuICAgICAgICBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJyBkYXRhLXN0Y2s9XCInKSxcbiAgICAgIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yMUQgPVxuICAgICAgICBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJyBkYXRhLWNzdGNrPVwiJyksXG4gICAgICBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjIgPVxuICAgICAgICBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXCI+PC90ZW1wbGF0ZT5cIiksXG4gICAgICBzdGFydFNlZ21lbnRIVE1MID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8ZGl2IGhpZGRlbiBpZD1cIicpLFxuICAgICAgc3RhcnRTZWdtZW50SFRNTDIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiPicpLFxuICAgICAgZW5kU2VnbWVudEhUTUwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXCI8L2Rpdj5cIiksXG4gICAgICBzdGFydFNlZ21lbnRTVkcgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXG4gICAgICAgICc8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIHN0eWxlPVwiZGlzcGxheTpub25lXCIgaWQ9XCInXG4gICAgICApLFxuICAgICAgc3RhcnRTZWdtZW50U1ZHMiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCI+JyksXG4gICAgICBlbmRTZWdtZW50U1ZHID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFwiPC9zdmc+XCIpLFxuICAgICAgc3RhcnRTZWdtZW50TWF0aE1MID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFxuICAgICAgICAnPG1hdGggYXJpYS1oaWRkZW49XCJ0cnVlXCIgc3R5bGU9XCJkaXNwbGF5Om5vbmVcIiBpZD1cIidcbiAgICAgICksXG4gICAgICBzdGFydFNlZ21lbnRNYXRoTUwyID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIj4nKSxcbiAgICAgIGVuZFNlZ21lbnRNYXRoTUwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXCI8L21hdGg+XCIpLFxuICAgICAgc3RhcnRTZWdtZW50VGFibGUgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzx0YWJsZSBoaWRkZW4gaWQ9XCInKSxcbiAgICAgIHN0YXJ0U2VnbWVudFRhYmxlMiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCI+JyksXG4gICAgICBlbmRTZWdtZW50VGFibGUgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXCI8L3RhYmxlPlwiKSxcbiAgICAgIHN0YXJ0U2VnbWVudFRhYmxlQm9keSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhcbiAgICAgICAgJzx0YWJsZSBoaWRkZW4+PHRib2R5IGlkPVwiJ1xuICAgICAgKSxcbiAgICAgIHN0YXJ0U2VnbWVudFRhYmxlQm9keTIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiPicpLFxuICAgICAgZW5kU2VnbWVudFRhYmxlQm9keSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhcIjwvdGJvZHk+PC90YWJsZT5cIiksXG4gICAgICBzdGFydFNlZ21lbnRUYWJsZVJvdyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHRhYmxlIGhpZGRlbj48dHIgaWQ9XCInKSxcbiAgICAgIHN0YXJ0U2VnbWVudFRhYmxlUm93MiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCI+JyksXG4gICAgICBlbmRTZWdtZW50VGFibGVSb3cgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXCI8L3RyPjwvdGFibGU+XCIpLFxuICAgICAgc3RhcnRTZWdtZW50Q29sR3JvdXAgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXG4gICAgICAgICc8dGFibGUgaGlkZGVuPjxjb2xncm91cCBpZD1cIidcbiAgICAgICksXG4gICAgICBzdGFydFNlZ21lbnRDb2xHcm91cDIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiPicpLFxuICAgICAgZW5kU2VnbWVudENvbEdyb3VwID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFwiPC9jb2xncm91cD48L3RhYmxlPlwiKSxcbiAgICAgIGNvbXBsZXRlU2VnbWVudFNjcmlwdDFGdWxsID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFxuICAgICAgICAnJFJTPWZ1bmN0aW9uKGEsYil7YT1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChhKTtiPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGIpO2ZvcihhLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYSk7YS5maXJzdENoaWxkOyliLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGEuZmlyc3RDaGlsZCxiKTtiLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYil9OyRSUyhcIidcbiAgICAgICksXG4gICAgICBjb21wbGV0ZVNlZ21lbnRTY3JpcHQxUGFydGlhbCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnJFJTKFwiJyksXG4gICAgICBjb21wbGV0ZVNlZ21lbnRTY3JpcHQyID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIixcIicpLFxuICAgICAgY29tcGxldGVTZWdtZW50U2NyaXB0RW5kID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIilcXHgzYy9zY3JpcHQ+Jyk7XG4gICAgc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8dGVtcGxhdGUgZGF0YS1yc2k9XCJcIiBkYXRhLXNpZD1cIicpO1xuICAgIHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCIgZGF0YS1waWQ9XCInKTtcbiAgICB2YXIgY29tcGxldGVCb3VuZGFyeVNjcmlwdEZ1bmN0aW9uT25seSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhcbiAgICAgICckUkI9W107JFJWPWZ1bmN0aW9uKGEpeyRSVD1wZXJmb3JtYW5jZS5ub3coKTtmb3IodmFyIGI9MDtiPGEubGVuZ3RoO2IrPTIpe3ZhciBjPWFbYl0sZT1hW2IrMV07bnVsbCE9PWUucGFyZW50Tm9kZSYmZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGUpO3ZhciBmPWMucGFyZW50Tm9kZTtpZihmKXt2YXIgZz1jLnByZXZpb3VzU2libGluZyxoPTA7ZG97aWYoYyYmOD09PWMubm9kZVR5cGUpe3ZhciBkPWMuZGF0YTtpZihcIi8kXCI9PT1kfHxcIi8mXCI9PT1kKWlmKDA9PT1oKWJyZWFrO2Vsc2UgaC0tO2Vsc2VcIiRcIiE9PWQmJlwiJD9cIiE9PWQmJlwiJH5cIiE9PWQmJlwiJCFcIiE9PWQmJlwiJlwiIT09ZHx8aCsrfWQ9Yy5uZXh0U2libGluZztmLnJlbW92ZUNoaWxkKGMpO2M9ZH13aGlsZShjKTtmb3IoO2UuZmlyc3RDaGlsZDspZi5pbnNlcnRCZWZvcmUoZS5maXJzdENoaWxkLGMpO2cuZGF0YT1cIiRcIjtnLl9yZWFjdFJldHJ5JiZyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZy5fcmVhY3RSZXRyeSl9fWEubGVuZ3RoPTB9O1xcbiRSQz1mdW5jdGlvbihhLGIpe2lmKGI9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYikpKGE9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYSkpPyhhLnByZXZpb3VzU2libGluZy5kYXRhPVwiJH5cIiwkUkIucHVzaChhLGIpLDI9PT0kUkIubGVuZ3RoJiYoXCJudW1iZXJcIiE9PXR5cGVvZiAkUlQ/cmVxdWVzdEFuaW1hdGlvbkZyYW1lKCRSVi5iaW5kKG51bGwsJFJCKSk6KGE9cGVyZm9ybWFuY2Uubm93KCksc2V0VGltZW91dCgkUlYuYmluZChudWxsLCRSQiksMjMwMD5hJiYyRTM8YT8yMzAwLWE6JFJUKzMwMC1hKSkpKTpiLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYil9OydcbiAgICApO1xuICAgIHN0cmluZ1RvQ2h1bmsoXG4gICAgICAnJFJWPWZ1bmN0aW9uKEEsZyl7ZnVuY3Rpb24gayhhLGIpe3ZhciBlPWEuZ2V0QXR0cmlidXRlKGIpO2UmJihiPWEuc3R5bGUsbC5wdXNoKGEsYi52aWV3VHJhbnNpdGlvbk5hbWUsYi52aWV3VHJhbnNpdGlvbkNsYXNzKSxcImF1dG9cIiE9PWUmJihiLnZpZXdUcmFuc2l0aW9uQ2xhc3M9ZSksKGE9YS5nZXRBdHRyaWJ1dGUoXCJ2dC1uYW1lXCIpKXx8KGE9XCJfVF9cIitLKysgK1wiX1wiKSxiLnZpZXdUcmFuc2l0aW9uTmFtZT1hLEI9ITApfXZhciBCPSExLEs9MCxsPVtdO3RyeXt2YXIgZj1kb2N1bWVudC5fX3JlYWN0Vmlld1RyYW5zaXRpb247aWYoZil7Zi5maW5pc2hlZC5maW5hbGx5KCRSVi5iaW5kKG51bGwsZykpO3JldHVybn12YXIgbT1uZXcgTWFwO2ZvcihmPTE7ZjxnLmxlbmd0aDtmKz0yKWZvcih2YXIgaD1nW2ZdLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbdnQtc2hhcmVdXCIpLGQ9MDtkPGgubGVuZ3RoO2QrKyl7dmFyIGM9aFtkXTttLnNldChjLmdldEF0dHJpYnV0ZShcInZ0LW5hbWVcIiksYyl9dmFyIHU9W107Zm9yKGg9MDtoPGcubGVuZ3RoO2grPTIpe3ZhciBDPWdbaF0seD1DLnBhcmVudE5vZGU7aWYoeCl7dmFyIHY9eC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtpZih2LmxlZnR8fHYudG9wfHx2LndpZHRofHx2LmhlaWdodCl7Yz1DO2ZvcihmPTA7Yzspe2lmKDg9PT1jLm5vZGVUeXBlKXt2YXIgcj1jLmRhdGE7aWYoXCIvJFwiPT09cilpZigwPT09ZilicmVhaztlbHNlIGYtLTtlbHNlXCIkXCIhPT1yJiZcIiQ/XCIhPT1yJiZcIiR+XCIhPT1yJiZcIiQhXCIhPT1yfHxmKyt9ZWxzZSBpZigxPT09Yy5ub2RlVHlwZSl7ZD1jO3ZhciBEPWQuZ2V0QXR0cmlidXRlKFwidnQtbmFtZVwiKSx5PW0uZ2V0KEQpO2soZCx5P1widnQtc2hhcmVcIjpcInZ0LWV4aXRcIik7eSYmKGsoeSxcInZ0LXNoYXJlXCIpLG0uc2V0KEQsbnVsbCkpO3ZhciBFPWQucXVlcnlTZWxlY3RvckFsbChcIlt2dC1zaGFyZV1cIik7Zm9yKGQ9MDtkPEUubGVuZ3RoO2QrKyl7dmFyIEY9RVtkXSxHPUYuZ2V0QXR0cmlidXRlKFwidnQtbmFtZVwiKSxcXG5IPW0uZ2V0KEcpO0gmJihrKEYsXCJ2dC1zaGFyZVwiKSxrKEgsXCJ2dC1zaGFyZVwiKSxtLnNldChHLG51bGwpKX19Yz1jLm5leHRTaWJsaW5nfWZvcih2YXIgST1nW2grMV0sdD1JLmZpcnN0RWxlbWVudENoaWxkO3Q7KW51bGwhPT1tLmdldCh0LmdldEF0dHJpYnV0ZShcInZ0LW5hbWVcIikpJiZrKHQsXCJ2dC1lbnRlclwiKSx0PXQubmV4dEVsZW1lbnRTaWJsaW5nO2M9eDtkbyBmb3IodmFyIG49Yy5maXJzdEVsZW1lbnRDaGlsZDtuOyl7dmFyIEo9bi5nZXRBdHRyaWJ1dGUoXCJ2dC11cGRhdGVcIik7SiYmXCJub25lXCIhPT1KJiYhbC5pbmNsdWRlcyhuKSYmayhuLFwidnQtdXBkYXRlXCIpO249bi5uZXh0RWxlbWVudFNpYmxpbmd9d2hpbGUoKGM9Yy5wYXJlbnROb2RlKSYmMT09PWMubm9kZVR5cGUmJlwibm9uZVwiIT09Yy5nZXRBdHRyaWJ1dGUoXCJ2dC11cGRhdGVcIikpO3UucHVzaC5hcHBseSh1LEkucXVlcnlTZWxlY3RvckFsbChcXCdpbWdbc3JjXTpub3QoW2xvYWRpbmc9XCJsYXp5XCJdKVxcJykpfX19aWYoQil7dmFyIHo9XFxuZG9jdW1lbnQuX19yZWFjdFZpZXdUcmFuc2l0aW9uPWRvY3VtZW50LnN0YXJ0Vmlld1RyYW5zaXRpb24oe3VwZGF0ZTpmdW5jdGlvbigpe0EoZyk7Zm9yKHZhciBhPVtkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0LGRvY3VtZW50LmZvbnRzLnJlYWR5XSxiPXt9LGU9MDtlPHUubGVuZ3RoO2I9e2c6Yi5nfSxlKyspaWYoYi5nPXVbZV0sIWIuZy5jb21wbGV0ZSl7dmFyIHA9Yi5nLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOzA8cC5ib3R0b20mJjA8cC5yaWdodCYmcC50b3A8d2luZG93LmlubmVySGVpZ2h0JiZwLmxlZnQ8d2luZG93LmlubmVyV2lkdGgmJihwPW5ldyBQcm9taXNlKGZ1bmN0aW9uKHcpe3JldHVybiBmdW5jdGlvbihxKXt3LmcuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIixxKTt3LmcuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIscSl9fShiKSksYS5wdXNoKHApKX1yZXR1cm4gUHJvbWlzZS5yYWNlKFtQcm9taXNlLmFsbChhKSxuZXcgUHJvbWlzZShmdW5jdGlvbih3KXt2YXIgcT1cXG5wZXJmb3JtYW5jZS5ub3coKTtzZXRUaW1lb3V0KHcsMjMwMD5xJiYyRTM8cT8yMzAwLXE6NTAwKX0pXSl9LHR5cGVzOltdfSk7ei5yZWFkeS5maW5hbGx5KGZ1bmN0aW9uKCl7Zm9yKHZhciBhPWwubGVuZ3RoLTM7MDw9YTthLT0zKXt2YXIgYj1sW2FdLGU9Yi5zdHlsZTtlLnZpZXdUcmFuc2l0aW9uTmFtZT1sW2ErMV07ZS52aWV3VHJhbnNpdGlvbkNsYXNzPWxbYSsxXTtcIlwiPT09Yi5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKSYmYi5yZW1vdmVBdHRyaWJ1dGUoXCJzdHlsZVwiKX19KTt6LmZpbmlzaGVkLmZpbmFsbHkoZnVuY3Rpb24oKXtkb2N1bWVudC5fX3JlYWN0Vmlld1RyYW5zaXRpb249PT16JiYoZG9jdW1lbnQuX19yZWFjdFZpZXdUcmFuc2l0aW9uPW51bGwpfSk7JFJCPVtdO3JldHVybn19Y2F0Y2goYSl7fUEoZyl9LmJpbmQobnVsbCwkUlYpOydcbiAgICApO1xuICAgIHZhciBjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0MVBhcnRpYWwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJyRSQyhcIicpLFxuICAgICAgY29tcGxldGVCb3VuZGFyeVdpdGhTdHlsZXNTY3JpcHQxRnVsbFBhcnRpYWwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXG4gICAgICAgICckUk09bmV3IE1hcDskUlI9ZnVuY3Rpb24obix3LHApe2Z1bmN0aW9uIHUocSl7dGhpcy5fcD1udWxsO3EoKX1mb3IodmFyIHI9bmV3IE1hcCx0PWRvY3VtZW50LGgsYixlPXQucXVlcnlTZWxlY3RvckFsbChcImxpbmtbZGF0YS1wcmVjZWRlbmNlXSxzdHlsZVtkYXRhLXByZWNlZGVuY2VdXCIpLHY9W10saz0wO2I9ZVtrKytdOylcIm5vdCBhbGxcIj09PWIuZ2V0QXR0cmlidXRlKFwibWVkaWFcIik/di5wdXNoKGIpOihcIkxJTktcIj09PWIudGFnTmFtZSYmJFJNLnNldChiLmdldEF0dHJpYnV0ZShcImhyZWZcIiksYiksci5zZXQoYi5kYXRhc2V0LnByZWNlZGVuY2UsaD1iKSk7ZT0wO2I9W107dmFyIGwsYTtmb3Ioaz0hMDs7KXtpZihrKXt2YXIgZj1wW2UrK107aWYoIWYpe2s9ITE7ZT0wO2NvbnRpbnVlfXZhciBjPSExLG09MDt2YXIgZD1mW20rK107aWYoYT0kUk0uZ2V0KGQpKXt2YXIgZz1hLl9wO2M9ITB9ZWxzZXthPXQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7YS5ocmVmPWQ7YS5yZWw9XFxuXCJzdHlsZXNoZWV0XCI7Zm9yKGEuZGF0YXNldC5wcmVjZWRlbmNlPWw9ZlttKytdO2c9ZlttKytdOylhLnNldEF0dHJpYnV0ZShnLGZbbSsrXSk7Zz1hLl9wPW5ldyBQcm9taXNlKGZ1bmN0aW9uKHEseCl7YS5vbmxvYWQ9dS5iaW5kKGEscSk7YS5vbmVycm9yPXUuYmluZChhLHgpfSk7JFJNLnNldChkLGEpfWQ9YS5nZXRBdHRyaWJ1dGUoXCJtZWRpYVwiKTshZ3x8ZCYmIW1hdGNoTWVkaWEoZCkubWF0Y2hlc3x8Yi5wdXNoKGcpO2lmKGMpY29udGludWV9ZWxzZXthPXZbZSsrXTtpZighYSlicmVhaztsPWEuZ2V0QXR0cmlidXRlKFwiZGF0YS1wcmVjZWRlbmNlXCIpO2EucmVtb3ZlQXR0cmlidXRlKFwibWVkaWFcIil9Yz1yLmdldChsKXx8aDtjPT09aCYmKGg9YSk7ci5zZXQobCxhKTtjP2MucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoYSxjLm5leHRTaWJsaW5nKTooYz10LmhlYWQsYy5pbnNlcnRCZWZvcmUoYSxjLmZpcnN0Q2hpbGQpKX1pZihwPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG4pKXAucHJldmlvdXNTaWJsaW5nLmRhdGE9XFxuXCIkflwiO1Byb21pc2UuYWxsKGIpLnRoZW4oJFJDLmJpbmQobnVsbCxuLHcpLCRSWC5iaW5kKG51bGwsbixcIkNTUyBmYWlsZWQgdG8gbG9hZFwiKSl9OyRSUihcIidcbiAgICAgICksXG4gICAgICBjb21wbGV0ZUJvdW5kYXJ5V2l0aFN0eWxlc1NjcmlwdDFQYXJ0aWFsID1cbiAgICAgICAgc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCckUlIoXCInKSxcbiAgICAgIGNvbXBsZXRlQm91bmRhcnlTY3JpcHQyID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIixcIicpLFxuICAgICAgY29tcGxldGVCb3VuZGFyeVNjcmlwdDNhID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIiwnKSxcbiAgICAgIGNvbXBsZXRlQm91bmRhcnlTY3JpcHQzYiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCInKSxcbiAgICAgIGNvbXBsZXRlQm91bmRhcnlTY3JpcHRFbmQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXCIpXFx4M2Mvc2NyaXB0PlwiKTtcbiAgICBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzx0ZW1wbGF0ZSBkYXRhLXJjaT1cIlwiIGRhdGEtYmlkPVwiJyk7XG4gICAgc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8dGVtcGxhdGUgZGF0YS1ycmk9XCJcIiBkYXRhLWJpZD1cIicpO1xuICAgIHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCIgZGF0YS1zaWQ9XCInKTtcbiAgICBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiIGRhdGEtc3R5PVwiJyk7XG4gICAgdmFyIGNsaWVudFJlbmRlclNjcmlwdEZ1bmN0aW9uT25seSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhcbiAgICAgICAgJyRSWD1mdW5jdGlvbihiLGMsZCxlLGYpe3ZhciBhPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGIpO2EmJihiPWEucHJldmlvdXNTaWJsaW5nLGIuZGF0YT1cIiQhXCIsYT1hLmRhdGFzZXQsYyYmKGEuZGdzdD1jKSxkJiYoYS5tc2c9ZCksZSYmKGEuc3Rjaz1lKSxmJiYoYS5jc3Rjaz1mKSxiLl9yZWFjdFJldHJ5JiZiLl9yZWFjdFJldHJ5KCkpfTsnXG4gICAgICApLFxuICAgICAgY2xpZW50UmVuZGVyU2NyaXB0MUZ1bGwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXG4gICAgICAgICckUlg9ZnVuY3Rpb24oYixjLGQsZSxmKXt2YXIgYT1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChiKTthJiYoYj1hLnByZXZpb3VzU2libGluZyxiLmRhdGE9XCIkIVwiLGE9YS5kYXRhc2V0LGMmJihhLmRnc3Q9YyksZCYmKGEubXNnPWQpLGUmJihhLnN0Y2s9ZSksZiYmKGEuY3N0Y2s9ZiksYi5fcmVhY3RSZXRyeSYmYi5fcmVhY3RSZXRyeSgpKX07OyRSWChcIidcbiAgICAgICksXG4gICAgICBjbGllbnRSZW5kZXJTY3JpcHQxUGFydGlhbCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnJFJYKFwiJyksXG4gICAgICBjbGllbnRSZW5kZXJTY3JpcHQxQSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCInKSxcbiAgICAgIGNsaWVudFJlbmRlckVycm9yU2NyaXB0QXJnSW50ZXJzdGl0aWFsID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFwiLFwiKSxcbiAgICAgIGNsaWVudFJlbmRlclNjcmlwdEVuZCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhcIilcXHgzYy9zY3JpcHQ+XCIpO1xuICAgIHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHRlbXBsYXRlIGRhdGEtcnhpPVwiXCIgZGF0YS1iaWQ9XCInKTtcbiAgICBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiIGRhdGEtZGdzdD1cIicpO1xuICAgIHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCIgZGF0YS1tc2c9XCInKTtcbiAgICBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiIGRhdGEtc3Rjaz1cIicpO1xuICAgIHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCIgZGF0YS1jc3Rjaz1cIicpO1xuICAgIHZhciByZWdleEZvckpTU3RyaW5nc0luSW5zdHJ1Y3Rpb25TY3JpcHRzID0gL1s8XFx1MjAyOFxcdTIwMjldL2csXG4gICAgICByZWdleEZvckpTU3RyaW5nc0luU2NyaXB0cyA9IC9bJj48XFx1MjAyOFxcdTIwMjldL2csXG4gICAgICBsYXRlU3R5bGVUYWdSZXNvdXJjZU9wZW4xID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFxuICAgICAgICAnIG1lZGlhPVwibm90IGFsbFwiIGRhdGEtcHJlY2VkZW5jZT1cIidcbiAgICAgICksXG4gICAgICBsYXRlU3R5bGVUYWdSZXNvdXJjZU9wZW4yID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIiBkYXRhLWhyZWY9XCInKSxcbiAgICAgIGxhdGVTdHlsZVRhZ1Jlc291cmNlT3BlbjMgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiPicpLFxuICAgICAgbGF0ZVN0eWxlVGFnVGVtcGxhdGVDbG9zZSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhcIjwvc3R5bGU+XCIpLFxuICAgICAgY3VycmVudGx5UmVuZGVyaW5nQm91bmRhcnlIYXNTdHlsZXNUb0hvaXN0ID0gITEsXG4gICAgICBkZXN0aW5hdGlvbkhhc0NhcGFjaXR5ID0gITAsXG4gICAgICBzdHlsZXNoZWV0Rmx1c2hpbmdRdWV1ZSA9IFtdLFxuICAgICAgc3R5bGVUYWdSZXNvdXJjZU9wZW4xID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCcgZGF0YS1wcmVjZWRlbmNlPVwiJyksXG4gICAgICBzdHlsZVRhZ1Jlc291cmNlT3BlbjIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiIGRhdGEtaHJlZj1cIicpLFxuICAgICAgc3BhY2VTZXBhcmF0b3IgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoXCIgXCIpLFxuICAgICAgc3R5bGVUYWdSZXNvdXJjZU9wZW4zID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIj4nKSxcbiAgICAgIHN0eWxlVGFnUmVzb3VyY2VDbG9zZSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhcIjwvc3R5bGU+XCIpO1xuICAgIHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPGxpbmsgcmVsPVwiZXhwZWN0XCIgaHJlZj1cIiMnKTtcbiAgICBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiIGJsb2NraW5nPVwicmVuZGVyXCIvPicpO1xuICAgIHZhciBjb21wbGV0ZWRTaGVsbElkQXR0cmlidXRlU3RhcnQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJyBpZD1cIicpLFxuICAgICAgYXJyYXlGaXJzdE9wZW5CcmFja2V0ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFwiW1wiKSxcbiAgICAgIGFycmF5U3Vic2VxdWVudE9wZW5CcmFja2V0ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKFwiLFtcIiksXG4gICAgICBhcnJheUludGVyc3RpdGlhbCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhcIixcIiksXG4gICAgICBhcnJheUNsb3NlQnJhY2tldCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhcIl1cIiksXG4gICAgICBQRU5ESU5HJDEgPSAwLFxuICAgICAgUFJFTE9BREVEID0gMSxcbiAgICAgIFBSRUFNQkxFID0gMixcbiAgICAgIExBVEUgPSAzLFxuICAgICAgcmVnZXhGb3JIcmVmSW5MaW5rSGVhZGVyVVJMQ29udGV4dCA9IC9bPD5cXHJcXG5dL2csXG4gICAgICByZWdleEZvckxpbmtIZWFkZXJRdW90ZWRQYXJhbVZhbHVlQ29udGV4dCA9IC9bXCInOyxcXHJcXG5dL2csXG4gICAgICBiaW5kID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQsXG4gICAgICBSRUFDVF9DTElFTlRfUkVGRVJFTkNFID0gU3ltYm9sLmZvcihcInJlYWN0LmNsaWVudC5yZWZlcmVuY2VcIiksXG4gICAgICBlbXB0eUNvbnRleHRPYmplY3QgPSB7fTtcbiAgICBPYmplY3QuZnJlZXplKGVtcHR5Q29udGV4dE9iamVjdCk7XG4gICAgdmFyIHJlbmRlcmVyU2lnaWwgPSB7fTtcbiAgICB2YXIgY3VycmVudEFjdGl2ZVNuYXBzaG90ID0gbnVsbCxcbiAgICAgIGRpZFdhcm5BYm91dE5vb3BVcGRhdGVGb3JDb21wb25lbnQgPSB7fSxcbiAgICAgIGRpZFdhcm5BYm91dERlcHJlY2F0ZWRXaWxsTW91bnQgPSB7fTtcbiAgICB2YXIgZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlID0gbmV3IFNldCgpO1xuICAgIHZhciBkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGUgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlID0gbmV3IFNldCgpO1xuICAgIHZhciBkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGUgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGRpZFdhcm5BYm91dENvbnRleHRUeXBlcyQxID0gbmV3IFNldCgpO1xuICAgIHZhciBkaWRXYXJuQWJvdXRDaGlsZENvbnRleHRUeXBlcyA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlID0gbmV3IFNldCgpO1xuICAgIHZhciBkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2sgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGNsYXNzQ29tcG9uZW50VXBkYXRlciA9IHtcbiAgICAgICAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAoaW5zdCwgcGF5bG9hZCwgY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgaW50ZXJuYWxzID0gaW5zdC5fcmVhY3RJbnRlcm5hbHM7XG4gICAgICAgICAgbnVsbCA9PT0gaW50ZXJuYWxzLnF1ZXVlXG4gICAgICAgICAgICA/IHdhcm5Ob29wKGluc3QsIFwic2V0U3RhdGVcIilcbiAgICAgICAgICAgIDogKGludGVybmFscy5xdWV1ZS5wdXNoKHBheWxvYWQpLFxuICAgICAgICAgICAgICB2b2lkIDAgIT09IGNhbGxiYWNrICYmXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gY2FsbGJhY2sgJiZcbiAgICAgICAgICAgICAgICB3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2spKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKGluc3QsIHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgaW5zdCA9IGluc3QuX3JlYWN0SW50ZXJuYWxzO1xuICAgICAgICAgIGluc3QucmVwbGFjZSA9ICEwO1xuICAgICAgICAgIGluc3QucXVldWUgPSBbcGF5bG9hZF07XG4gICAgICAgICAgdm9pZCAwICE9PSBjYWxsYmFjayAmJlxuICAgICAgICAgICAgbnVsbCAhPT0gY2FsbGJhY2sgJiZcbiAgICAgICAgICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjayk7XG4gICAgICAgIH0sXG4gICAgICAgIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKGluc3QsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgbnVsbCA9PT0gaW5zdC5fcmVhY3RJbnRlcm5hbHMucXVldWVcbiAgICAgICAgICAgID8gd2Fybk5vb3AoaW5zdCwgXCJmb3JjZVVwZGF0ZVwiKVxuICAgICAgICAgICAgOiB2b2lkIDAgIT09IGNhbGxiYWNrICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IGNhbGxiYWNrICYmXG4gICAgICAgICAgICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBlbXB0eVRyZWVDb250ZXh0ID0geyBpZDogMSwgb3ZlcmZsb3c6IFwiXCIgfSxcbiAgICAgIGNsejMyID0gTWF0aC5jbHozMiA/IE1hdGguY2x6MzIgOiBjbHozMkZhbGxiYWNrLFxuICAgICAgbG9nID0gTWF0aC5sb2csXG4gICAgICBMTjIgPSBNYXRoLkxOMixcbiAgICAgIFN1c3BlbnNlRXhjZXB0aW9uID0gRXJyb3IoXG4gICAgICAgIFwiU3VzcGVuc2UgRXhjZXB0aW9uOiBUaGlzIGlzIG5vdCBhIHJlYWwgZXJyb3IhIEl0J3MgYW4gaW1wbGVtZW50YXRpb24gZGV0YWlsIG9mIGB1c2VgIHRvIGludGVycnVwdCB0aGUgY3VycmVudCByZW5kZXIuIFlvdSBtdXN0IGVpdGhlciByZXRocm93IGl0IGltbWVkaWF0ZWx5LCBvciBtb3ZlIHRoZSBgdXNlYCBjYWxsIG91dHNpZGUgb2YgdGhlIGB0cnkvY2F0Y2hgIGJsb2NrLiBDYXB0dXJpbmcgd2l0aG91dCByZXRocm93aW5nIHdpbGwgbGVhZCB0byB1bmV4cGVjdGVkIGJlaGF2aW9yLlxcblxcblRvIGhhbmRsZSBhc3luYyBlcnJvcnMsIHdyYXAgeW91ciBjb21wb25lbnQgaW4gYW4gZXJyb3IgYm91bmRhcnksIG9yIGNhbGwgdGhlIHByb21pc2UncyBgLmNhdGNoYCBtZXRob2QgYW5kIHBhc3MgdGhlIHJlc3VsdCB0byBgdXNlYC5cIlxuICAgICAgKSxcbiAgICAgIHN1c3BlbmRlZFRoZW5hYmxlID0gbnVsbCxcbiAgICAgIG9iamVjdElzID0gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgT2JqZWN0LmlzID8gT2JqZWN0LmlzIDogaXMsXG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQgPSBudWxsLFxuICAgICAgY3VycmVudGx5UmVuZGVyaW5nVGFzayA9IG51bGwsXG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdSZXF1ZXN0ID0gbnVsbCxcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0tleVBhdGggPSBudWxsLFxuICAgICAgZmlyc3RXb3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsLFxuICAgICAgd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbCxcbiAgICAgIGlzUmVSZW5kZXIgPSAhMSxcbiAgICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSAhMSxcbiAgICAgIGxvY2FsSWRDb3VudGVyID0gMCxcbiAgICAgIGFjdGlvblN0YXRlQ291bnRlciA9IDAsXG4gICAgICBhY3Rpb25TdGF0ZU1hdGNoaW5nSW5kZXggPSAtMSxcbiAgICAgIHRoZW5hYmxlSW5kZXhDb3VudGVyID0gMCxcbiAgICAgIHRoZW5hYmxlU3RhdGUgPSBudWxsLFxuICAgICAgcmVuZGVyUGhhc2VVcGRhdGVzID0gbnVsbCxcbiAgICAgIG51bWJlck9mUmVSZW5kZXJzID0gMCxcbiAgICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9ICExLFxuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYsXG4gICAgICBIb29rc0Rpc3BhdGNoZXIgPSB7XG4gICAgICAgIHJlYWRDb250ZXh0OiByZWFkQ29udGV4dCxcbiAgICAgICAgdXNlOiBmdW5jdGlvbiAodXNhYmxlKSB7XG4gICAgICAgICAgaWYgKG51bGwgIT09IHVzYWJsZSAmJiBcIm9iamVjdFwiID09PSB0eXBlb2YgdXNhYmxlKSB7XG4gICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdXNhYmxlLnRoZW4pXG4gICAgICAgICAgICAgIHJldHVybiB1bndyYXBUaGVuYWJsZSh1c2FibGUpO1xuICAgICAgICAgICAgaWYgKHVzYWJsZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFKVxuICAgICAgICAgICAgICByZXR1cm4gcmVhZENvbnRleHQodXNhYmxlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIkFuIHVuc3VwcG9ydGVkIHR5cGUgd2FzIHBhc3NlZCB0byB1c2UoKTogXCIgKyBTdHJpbmcodXNhYmxlKVxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIHVzZUNvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUNvbnRleHRcIjtcbiAgICAgICAgICByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgdXNlTWVtbzogdXNlTWVtbyxcbiAgICAgICAgdXNlUmVkdWNlcjogdXNlUmVkdWNlcixcbiAgICAgICAgdXNlUmVmOiBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgICAgY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50ID0gcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpO1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzSG9vayA9IGNyZWF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgICAgIHZhciBwcmV2aW91c1JlZiA9IHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIHJldHVybiBudWxsID09PSBwcmV2aW91c1JlZlxuICAgICAgICAgICAgPyAoKGluaXRpYWxWYWx1ZSA9IHsgY3VycmVudDogaW5pdGlhbFZhbHVlIH0pLFxuICAgICAgICAgICAgICBPYmplY3Quc2VhbChpbml0aWFsVmFsdWUpLFxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGUgPSBpbml0aWFsVmFsdWUpKVxuICAgICAgICAgICAgOiBwcmV2aW91c1JlZjtcbiAgICAgICAgfSxcbiAgICAgICAgdXNlU3RhdGU6IGZ1bmN0aW9uIChpbml0aWFsU3RhdGUpIHtcbiAgICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlU3RhdGVcIjtcbiAgICAgICAgICByZXR1cm4gdXNlUmVkdWNlcihiYXNpY1N0YXRlUmVkdWNlciwgaW5pdGlhbFN0YXRlKTtcbiAgICAgICAgfSxcbiAgICAgICAgdXNlSW5zZXJ0aW9uRWZmZWN0OiBub29wLFxuICAgICAgICB1c2VMYXlvdXRFZmZlY3Q6IG5vb3AsXG4gICAgICAgIHVzZUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAgICAgICByZXR1cm4gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2s7XG4gICAgICAgICAgfSwgZGVwcyk7XG4gICAgICAgIH0sXG4gICAgICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IG5vb3AsXG4gICAgICAgIHVzZUVmZmVjdDogbm9vcCxcbiAgICAgICAgdXNlRGVidWdWYWx1ZTogbm9vcCxcbiAgICAgICAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBpbml0aWFsVmFsdWUpIHtcbiAgICAgICAgICByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gICAgICAgICAgcmV0dXJuIHZvaWQgMCAhPT0gaW5pdGlhbFZhbHVlID8gaW5pdGlhbFZhbHVlIDogdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHVzZVRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gICAgICAgICAgcmV0dXJuIFshMSwgdW5zdXBwb3J0ZWRTdGFydFRyYW5zaXRpb25dO1xuICAgICAgICB9LFxuICAgICAgICB1c2VJZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciB0cmVlSWQgPSBjdXJyZW50bHlSZW5kZXJpbmdUYXNrLnRyZWVDb250ZXh0O1xuICAgICAgICAgIHZhciBvdmVyZmxvdyA9IHRyZWVJZC5vdmVyZmxvdztcbiAgICAgICAgICB0cmVlSWQgPSB0cmVlSWQuaWQ7XG4gICAgICAgICAgdHJlZUlkID1cbiAgICAgICAgICAgICh0cmVlSWQgJiB+KDEgPDwgKDMyIC0gY2x6MzIodHJlZUlkKSAtIDEpKSkudG9TdHJpbmcoMzIpICsgb3ZlcmZsb3c7XG4gICAgICAgICAgdmFyIHJlc3VtYWJsZVN0YXRlID0gY3VycmVudFJlc3VtYWJsZVN0YXRlO1xuICAgICAgICAgIGlmIChudWxsID09PSByZXN1bWFibGVTdGF0ZSlcbiAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICBcIkludmFsaWQgaG9vayBjYWxsLiBIb29rcyBjYW4gb25seSBiZSBjYWxsZWQgaW5zaWRlIG9mIHRoZSBib2R5IG9mIGEgZnVuY3Rpb24gY29tcG9uZW50LlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIG92ZXJmbG93ID0gbG9jYWxJZENvdW50ZXIrKztcbiAgICAgICAgICB0cmVlSWQgPSBcIl9cIiArIHJlc3VtYWJsZVN0YXRlLmlkUHJlZml4ICsgXCJSX1wiICsgdHJlZUlkO1xuICAgICAgICAgIDAgPCBvdmVyZmxvdyAmJiAodHJlZUlkICs9IFwiSFwiICsgb3ZlcmZsb3cudG9TdHJpbmcoMzIpKTtcbiAgICAgICAgICByZXR1cm4gdHJlZUlkICsgXCJfXCI7XG4gICAgICAgIH0sXG4gICAgICAgIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiBmdW5jdGlvbiAoXG4gICAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICAgIGdldFNuYXBzaG90LFxuICAgICAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgICAgICkge1xuICAgICAgICAgIGlmICh2b2lkIDAgPT09IGdldFNlcnZlclNuYXBzaG90KVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgIFwiTWlzc2luZyBnZXRTZXJ2ZXJTbmFwc2hvdCwgd2hpY2ggaXMgcmVxdWlyZWQgZm9yIHNlcnZlci1yZW5kZXJlZCBjb250ZW50LiBXaWxsIHJldmVydCB0byBjbGllbnQgcmVuZGVyaW5nLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiBnZXRTZXJ2ZXJTbmFwc2hvdCgpO1xuICAgICAgICB9LFxuICAgICAgICB1c2VPcHRpbWlzdGljOiBmdW5jdGlvbiAocGFzc3Rocm91Z2gpIHtcbiAgICAgICAgICByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gICAgICAgICAgcmV0dXJuIFtwYXNzdGhyb3VnaCwgdW5zdXBwb3J0ZWRTZXRPcHRpbWlzdGljU3RhdGVdO1xuICAgICAgICB9LFxuICAgICAgICB1c2VBY3Rpb25TdGF0ZTogdXNlQWN0aW9uU3RhdGUsXG4gICAgICAgIHVzZUZvcm1TdGF0ZTogdXNlQWN0aW9uU3RhdGUsXG4gICAgICAgIHVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpO1xuICAgICAgICAgIHJldHVybiBOb3RQZW5kaW5nO1xuICAgICAgICB9LFxuICAgICAgICB1c2VNZW1vQ2FjaGU6IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICAgICAgZm9yICh2YXIgZGF0YSA9IEFycmF5KHNpemUpLCBpID0gMDsgaSA8IHNpemU7IGkrKylcbiAgICAgICAgICAgIGRhdGFbaV0gPSBSRUFDVF9NRU1PX0NBQ0hFX1NFTlRJTkVMO1xuICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9LFxuICAgICAgICB1c2VDYWNoZVJlZnJlc2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdW5zdXBwb3J0ZWRSZWZyZXNoO1xuICAgICAgICB9LFxuICAgICAgICB1c2VFZmZlY3RFdmVudDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0aHJvd09uVXNlRWZmZWN0RXZlbnRDYWxsO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY3VycmVudFJlc3VtYWJsZVN0YXRlID0gbnVsbCxcbiAgICAgIGN1cnJlbnRUYXNrSW5ERVYgPSBudWxsLFxuICAgICAgRGVmYXVsdEFzeW5jRGlzcGF0Y2hlciA9IHtcbiAgICAgICAgZ2V0Q2FjaGVGb3JUeXBlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWQuXCIpO1xuICAgICAgICB9LFxuICAgICAgICBjYWNoZVNpZ25hbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRocm93IEVycm9yKFwiTm90IGltcGxlbWVudGVkLlwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0T3duZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbCA9PT0gY3VycmVudFRhc2tJbkRFVlxuICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICA6IGN1cnJlbnRUYXNrSW5ERVYuY29tcG9uZW50U3RhY2s7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkaXNhYmxlZERlcHRoID0gMCxcbiAgICAgIHByZXZMb2csXG4gICAgICBwcmV2SW5mbyxcbiAgICAgIHByZXZXYXJuLFxuICAgICAgcHJldkVycm9yLFxuICAgICAgcHJldkdyb3VwLFxuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkLFxuICAgICAgcHJldkdyb3VwRW5kO1xuICAgIGRpc2FibGVkTG9nLl9fcmVhY3REaXNhYmxlZExvZyA9ICEwO1xuICAgIHZhciBwcmVmaXgsXG4gICAgICBzdWZmaXgsXG4gICAgICByZWVudHJ5ID0gITE7XG4gICAgdmFyIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgKFxuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgV2Vha01hcCA/IFdlYWtNYXAgOiBNYXBcbiAgICApKCk7XG4gICAgdmFyIGNhbGxDb21wb25lbnQgPSB7XG4gICAgICAgIHJlYWN0X3N0YWNrX2JvdHRvbV9mcmFtZTogZnVuY3Rpb24gKENvbXBvbmVudCwgcHJvcHMsIHNlY29uZEFyZykge1xuICAgICAgICAgIHJldHVybiBDb21wb25lbnQocHJvcHMsIHNlY29uZEFyZyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjYWxsQ29tcG9uZW50SW5ERVYgPVxuICAgICAgICBjYWxsQ29tcG9uZW50LnJlYWN0X3N0YWNrX2JvdHRvbV9mcmFtZS5iaW5kKGNhbGxDb21wb25lbnQpLFxuICAgICAgY2FsbFJlbmRlciA9IHtcbiAgICAgICAgcmVhY3Rfc3RhY2tfYm90dG9tX2ZyYW1lOiBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICAgICAgICByZXR1cm4gaW5zdGFuY2UucmVuZGVyKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjYWxsUmVuZGVySW5ERVYgPSBjYWxsUmVuZGVyLnJlYWN0X3N0YWNrX2JvdHRvbV9mcmFtZS5iaW5kKGNhbGxSZW5kZXIpLFxuICAgICAgY2FsbExhenlJbml0ID0ge1xuICAgICAgICByZWFjdF9zdGFja19ib3R0b21fZnJhbWU6IGZ1bmN0aW9uIChsYXp5KSB7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Ll9pbml0O1xuICAgICAgICAgIHJldHVybiBpbml0KGxhenkuX3BheWxvYWQpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2FsbExhenlJbml0SW5ERVYgPVxuICAgICAgICBjYWxsTGF6eUluaXQucmVhY3Rfc3RhY2tfYm90dG9tX2ZyYW1lLmJpbmQoY2FsbExhenlJbml0KSxcbiAgICAgIGxhc3RSZXNldFRpbWUgPSAwO1xuICAgIGlmIChcbiAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBwZXJmb3JtYW5jZSAmJlxuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcGVyZm9ybWFuY2Uubm93XG4gICAgKSB7XG4gICAgICB2YXIgbG9jYWxQZXJmb3JtYW5jZSA9IHBlcmZvcm1hbmNlO1xuICAgICAgdmFyIGdldEN1cnJlbnRUaW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbG9jYWxQZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBsb2NhbERhdGUgPSBEYXRlO1xuICAgICAgZ2V0Q3VycmVudFRpbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBsb2NhbERhdGUubm93KCk7XG4gICAgICB9O1xuICAgIH1cbiAgICB2YXIgQ0xJRU5UX1JFTkRFUkVEID0gNCxcbiAgICAgIFBFTkRJTkcgPSAwLFxuICAgICAgQ09NUExFVEVEID0gMSxcbiAgICAgIEZMVVNIRUQgPSAyLFxuICAgICAgQUJPUlRFRCA9IDMsXG4gICAgICBFUlJPUkVEID0gNCxcbiAgICAgIFBPU1RQT05FRCA9IDUsXG4gICAgICBDTE9TRUQgPSAxNCxcbiAgICAgIGN1cnJlbnRSZXF1ZXN0ID0gbnVsbCxcbiAgICAgIGRpZFdhcm5BYm91dEJhZENsYXNzID0ge30sXG4gICAgICBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZXMgPSB7fSxcbiAgICAgIGRpZFdhcm5BYm91dENvbnRleHRUeXBlT25GdW5jdGlvbkNvbXBvbmVudCA9IHt9LFxuICAgICAgZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbkNvbXBvbmVudCA9IHt9LFxuICAgICAgZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcyA9ICExLFxuICAgICAgZGlkV2FybkFib3V0R2VuZXJhdG9ycyA9ICExLFxuICAgICAgZGlkV2FybkFib3V0TWFwcyA9ICExLFxuICAgICAgZmx1c2hlZEJ5dGVTaXplID0gMCxcbiAgICAgIGZsdXNoaW5nUGFydGlhbEJvdW5kYXJpZXMgPSAhMTtcbiAgICBlbnN1cmVDb3JyZWN0SXNvbW9ycGhpY1JlYWN0VmVyc2lvbigpO1xuICAgIGVuc3VyZUNvcnJlY3RJc29tb3JwaGljUmVhY3RWZXJzaW9uKCk7XG4gICAgZXhwb3J0cy5wcmVyZW5kZXIgPSBmdW5jdGlvbiAoY2hpbGRyZW4sIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciBvbkhlYWRlcnMgPSBvcHRpb25zID8gb3B0aW9ucy5vbkhlYWRlcnMgOiB2b2lkIDAsXG4gICAgICAgICAgb25IZWFkZXJzSW1wbDtcbiAgICAgICAgb25IZWFkZXJzICYmXG4gICAgICAgICAgKG9uSGVhZGVyc0ltcGwgPSBmdW5jdGlvbiAoaGVhZGVyc0Rlc2NyaXB0b3IpIHtcbiAgICAgICAgICAgIG9uSGVhZGVycyhuZXcgSGVhZGVycyhoZWFkZXJzRGVzY3JpcHRvcikpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB2YXIgcmVzb3VyY2VzID0gY3JlYXRlUmVzdW1hYmxlU3RhdGUoXG4gICAgICAgICAgICBvcHRpb25zID8gb3B0aW9ucy5pZGVudGlmaWVyUHJlZml4IDogdm9pZCAwLFxuICAgICAgICAgICAgb3B0aW9ucyA/IG9wdGlvbnMudW5zdGFibGVfZXh0ZXJuYWxSdW50aW1lU3JjIDogdm9pZCAwLFxuICAgICAgICAgICAgb3B0aW9ucyA/IG9wdGlvbnMuYm9vdHN0cmFwU2NyaXB0Q29udGVudCA6IHZvaWQgMCxcbiAgICAgICAgICAgIG9wdGlvbnMgPyBvcHRpb25zLmJvb3RzdHJhcFNjcmlwdHMgOiB2b2lkIDAsXG4gICAgICAgICAgICBvcHRpb25zID8gb3B0aW9ucy5ib290c3RyYXBNb2R1bGVzIDogdm9pZCAwXG4gICAgICAgICAgKSxcbiAgICAgICAgICByZXF1ZXN0ID0gY3JlYXRlUHJlcmVuZGVyUmVxdWVzdChcbiAgICAgICAgICAgIGNoaWxkcmVuLFxuICAgICAgICAgICAgcmVzb3VyY2VzLFxuICAgICAgICAgICAgY3JlYXRlUmVuZGVyU3RhdGUoXG4gICAgICAgICAgICAgIHJlc291cmNlcyxcbiAgICAgICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgICAgICBvcHRpb25zID8gb3B0aW9ucy51bnN0YWJsZV9leHRlcm5hbFJ1bnRpbWVTcmMgOiB2b2lkIDAsXG4gICAgICAgICAgICAgIG9wdGlvbnMgPyBvcHRpb25zLmltcG9ydE1hcCA6IHZvaWQgMCxcbiAgICAgICAgICAgICAgb25IZWFkZXJzSW1wbCxcbiAgICAgICAgICAgICAgb3B0aW9ucyA/IG9wdGlvbnMubWF4SGVhZGVyc0xlbmd0aCA6IHZvaWQgMFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGNyZWF0ZVJvb3RGb3JtYXRDb250ZXh0KG9wdGlvbnMgPyBvcHRpb25zLm5hbWVzcGFjZVVSSSA6IHZvaWQgMCksXG4gICAgICAgICAgICBvcHRpb25zID8gb3B0aW9ucy5wcm9ncmVzc2l2ZUNodW5rU2l6ZSA6IHZvaWQgMCxcbiAgICAgICAgICAgIG9wdGlvbnMgPyBvcHRpb25zLm9uRXJyb3IgOiB2b2lkIDAsXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciBzdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJieXRlc1wiLFxuICAgICAgICAgICAgICAgICAgcHVsbDogZnVuY3Rpb24gKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRGbG93aW5nKHJlcXVlc3QsIGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIGNhbmNlbDogZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmRlc3RpbmF0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgYWJvcnQocmVxdWVzdCwgcmVhc29uKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHsgaGlnaFdhdGVyTWFyazogMCB9XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHN0cmVhbSA9IHtcbiAgICAgICAgICAgICAgICBwb3N0cG9uZWQ6IGdldFBvc3Rwb25lZFN0YXRlKHJlcXVlc3QpLFxuICAgICAgICAgICAgICAgIHByZWx1ZGU6IHN0cmVhbVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICByZXNvbHZlKHN0cmVhbSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgICAgcmVqZWN0LFxuICAgICAgICAgICAgb3B0aW9ucyA/IG9wdGlvbnMub25Qb3N0cG9uZSA6IHZvaWQgMFxuICAgICAgICAgICk7XG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuc2lnbmFsKSB7XG4gICAgICAgICAgdmFyIHNpZ25hbCA9IG9wdGlvbnMuc2lnbmFsO1xuICAgICAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkgYWJvcnQocmVxdWVzdCwgc2lnbmFsLnJlYXNvbik7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgbGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGFib3J0KHJlcXVlc3QsIHNpZ25hbC5yZWFzb24pO1xuICAgICAgICAgICAgICBzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGxpc3RlbmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhcnRXb3JrKHJlcXVlc3QpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBleHBvcnRzLnJlbmRlclRvUmVhZGFibGVTdHJlYW0gPSBmdW5jdGlvbiAoY2hpbGRyZW4sIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciBvbkZhdGFsRXJyb3IsXG4gICAgICAgICAgb25BbGxSZWFkeSxcbiAgICAgICAgICBhbGxSZWFkeSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXMsIHJlaikge1xuICAgICAgICAgICAgb25BbGxSZWFkeSA9IHJlcztcbiAgICAgICAgICAgIG9uRmF0YWxFcnJvciA9IHJlajtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBvbkhlYWRlcnMgPSBvcHRpb25zID8gb3B0aW9ucy5vbkhlYWRlcnMgOiB2b2lkIDAsXG4gICAgICAgICAgb25IZWFkZXJzSW1wbDtcbiAgICAgICAgb25IZWFkZXJzICYmXG4gICAgICAgICAgKG9uSGVhZGVyc0ltcGwgPSBmdW5jdGlvbiAoaGVhZGVyc0Rlc2NyaXB0b3IpIHtcbiAgICAgICAgICAgIG9uSGVhZGVycyhuZXcgSGVhZGVycyhoZWFkZXJzRGVzY3JpcHRvcikpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB2YXIgcmVzdW1hYmxlU3RhdGUgPSBjcmVhdGVSZXN1bWFibGVTdGF0ZShcbiAgICAgICAgICAgIG9wdGlvbnMgPyBvcHRpb25zLmlkZW50aWZpZXJQcmVmaXggOiB2b2lkIDAsXG4gICAgICAgICAgICBvcHRpb25zID8gb3B0aW9ucy51bnN0YWJsZV9leHRlcm5hbFJ1bnRpbWVTcmMgOiB2b2lkIDAsXG4gICAgICAgICAgICBvcHRpb25zID8gb3B0aW9ucy5ib290c3RyYXBTY3JpcHRDb250ZW50IDogdm9pZCAwLFxuICAgICAgICAgICAgb3B0aW9ucyA/IG9wdGlvbnMuYm9vdHN0cmFwU2NyaXB0cyA6IHZvaWQgMCxcbiAgICAgICAgICAgIG9wdGlvbnMgPyBvcHRpb25zLmJvb3RzdHJhcE1vZHVsZXMgOiB2b2lkIDBcbiAgICAgICAgICApLFxuICAgICAgICAgIHJlcXVlc3QgPSBjcmVhdGVSZXF1ZXN0KFxuICAgICAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgICAgICByZXN1bWFibGVTdGF0ZSxcbiAgICAgICAgICAgIGNyZWF0ZVJlbmRlclN0YXRlKFxuICAgICAgICAgICAgICByZXN1bWFibGVTdGF0ZSxcbiAgICAgICAgICAgICAgb3B0aW9ucyA/IG9wdGlvbnMubm9uY2UgOiB2b2lkIDAsXG4gICAgICAgICAgICAgIG9wdGlvbnMgPyBvcHRpb25zLnVuc3RhYmxlX2V4dGVybmFsUnVudGltZVNyYyA6IHZvaWQgMCxcbiAgICAgICAgICAgICAgb3B0aW9ucyA/IG9wdGlvbnMuaW1wb3J0TWFwIDogdm9pZCAwLFxuICAgICAgICAgICAgICBvbkhlYWRlcnNJbXBsLFxuICAgICAgICAgICAgICBvcHRpb25zID8gb3B0aW9ucy5tYXhIZWFkZXJzTGVuZ3RoIDogdm9pZCAwXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgY3JlYXRlUm9vdEZvcm1hdENvbnRleHQob3B0aW9ucyA/IG9wdGlvbnMubmFtZXNwYWNlVVJJIDogdm9pZCAwKSxcbiAgICAgICAgICAgIG9wdGlvbnMgPyBvcHRpb25zLnByb2dyZXNzaXZlQ2h1bmtTaXplIDogdm9pZCAwLFxuICAgICAgICAgICAgb3B0aW9ucyA/IG9wdGlvbnMub25FcnJvciA6IHZvaWQgMCxcbiAgICAgICAgICAgIG9uQWxsUmVhZHksXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciBzdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJieXRlc1wiLFxuICAgICAgICAgICAgICAgICAgcHVsbDogZnVuY3Rpb24gKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRGbG93aW5nKHJlcXVlc3QsIGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIGNhbmNlbDogZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmRlc3RpbmF0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgYWJvcnQocmVxdWVzdCwgcmVhc29uKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHsgaGlnaFdhdGVyTWFyazogMCB9XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHN0cmVhbS5hbGxSZWFkeSA9IGFsbFJlYWR5O1xuICAgICAgICAgICAgICByZXNvbHZlKHN0cmVhbSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgIGFsbFJlYWR5LmNhdGNoKGZ1bmN0aW9uICgpIHt9KTtcbiAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkZhdGFsRXJyb3IsXG4gICAgICAgICAgICBvcHRpb25zID8gb3B0aW9ucy5vblBvc3Rwb25lIDogdm9pZCAwLFxuICAgICAgICAgICAgb3B0aW9ucyA/IG9wdGlvbnMuZm9ybVN0YXRlIDogdm9pZCAwXG4gICAgICAgICAgKTtcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5zaWduYWwpIHtcbiAgICAgICAgICB2YXIgc2lnbmFsID0gb3B0aW9ucy5zaWduYWw7XG4gICAgICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSBhYm9ydChyZXF1ZXN0LCBzaWduYWwucmVhc29uKTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgYWJvcnQocmVxdWVzdCwgc2lnbmFsLnJlYXNvbik7XG4gICAgICAgICAgICAgIHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgbGlzdGVuZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGFydFdvcmsocmVxdWVzdCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGV4cG9ydHMucmVzdW1lID0gZnVuY3Rpb24gKGNoaWxkcmVuLCBwb3N0cG9uZWRTdGF0ZSwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIG9uRmF0YWxFcnJvcixcbiAgICAgICAgICBvbkFsbFJlYWR5LFxuICAgICAgICAgIGFsbFJlYWR5ID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlcywgcmVqKSB7XG4gICAgICAgICAgICBvbkFsbFJlYWR5ID0gcmVzO1xuICAgICAgICAgICAgb25GYXRhbEVycm9yID0gcmVqO1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIHJlcXVlc3QgPSByZXN1bWVSZXF1ZXN0KFxuICAgICAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgICAgICBwb3N0cG9uZWRTdGF0ZSxcbiAgICAgICAgICAgIGNyZWF0ZVJlbmRlclN0YXRlKFxuICAgICAgICAgICAgICBwb3N0cG9uZWRTdGF0ZS5yZXN1bWFibGVTdGF0ZSxcbiAgICAgICAgICAgICAgb3B0aW9ucyA/IG9wdGlvbnMubm9uY2UgOiB2b2lkIDAsXG4gICAgICAgICAgICAgIHZvaWQgMCxcbiAgICAgICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgICAgICB2b2lkIDAsXG4gICAgICAgICAgICAgIHZvaWQgMFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIG9wdGlvbnMgPyBvcHRpb25zLm9uRXJyb3IgOiB2b2lkIDAsXG4gICAgICAgICAgICBvbkFsbFJlYWR5LFxuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYnl0ZXNcIixcbiAgICAgICAgICAgICAgICAgIHB1bGw6IGZ1bmN0aW9uIChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0Rmxvd2luZyhyZXF1ZXN0LCBjb250cm9sbGVyKTtcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5kZXN0aW5hdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGFib3J0KHJlcXVlc3QsIHJlYXNvbik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7IGhpZ2hXYXRlck1hcms6IDAgfVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBzdHJlYW0uYWxsUmVhZHkgPSBhbGxSZWFkeTtcbiAgICAgICAgICAgICAgcmVzb2x2ZShzdHJlYW0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICBhbGxSZWFkeS5jYXRjaChmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25GYXRhbEVycm9yLFxuICAgICAgICAgICAgb3B0aW9ucyA/IG9wdGlvbnMub25Qb3N0cG9uZSA6IHZvaWQgMFxuICAgICAgICAgICk7XG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuc2lnbmFsKSB7XG4gICAgICAgICAgdmFyIHNpZ25hbCA9IG9wdGlvbnMuc2lnbmFsO1xuICAgICAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkgYWJvcnQocmVxdWVzdCwgc2lnbmFsLnJlYXNvbik7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgbGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGFib3J0KHJlcXVlc3QsIHNpZ25hbC5yZWFzb24pO1xuICAgICAgICAgICAgICBzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGxpc3RlbmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhcnRXb3JrKHJlcXVlc3QpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBleHBvcnRzLnJlc3VtZUFuZFByZXJlbmRlciA9IGZ1bmN0aW9uIChjaGlsZHJlbiwgcG9zdHBvbmVkU3RhdGUsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciByZXF1ZXN0ID0gcmVzdW1lQW5kUHJlcmVuZGVyUmVxdWVzdChcbiAgICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgICBwb3N0cG9uZWRTdGF0ZSxcbiAgICAgICAgICBjcmVhdGVSZW5kZXJTdGF0ZShcbiAgICAgICAgICAgIHBvc3Rwb25lZFN0YXRlLnJlc3VtYWJsZVN0YXRlLFxuICAgICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgICAgdm9pZCAwXG4gICAgICAgICAgKSxcbiAgICAgICAgICBvcHRpb25zID8gb3B0aW9ucy5vbkVycm9yIDogdm9pZCAwLFxuICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImJ5dGVzXCIsXG4gICAgICAgICAgICAgICAgcHVsbDogZnVuY3Rpb24gKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICAgIHN0YXJ0Rmxvd2luZyhyZXF1ZXN0LCBjb250cm9sbGVyKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNhbmNlbDogZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgICAgICAgICAgcmVxdWVzdC5kZXN0aW5hdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICBhYm9ydChyZXF1ZXN0LCByZWFzb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgeyBoaWdoV2F0ZXJNYXJrOiAwIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBzdHJlYW0gPSB7IHBvc3Rwb25lZDogZ2V0UG9zdHBvbmVkU3RhdGUocmVxdWVzdCksIHByZWx1ZGU6IHN0cmVhbSB9O1xuICAgICAgICAgICAgcmVzb2x2ZShzdHJlYW0pO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgIHZvaWQgMCxcbiAgICAgICAgICByZWplY3QsXG4gICAgICAgICAgb3B0aW9ucyA/IG9wdGlvbnMub25Qb3N0cG9uZSA6IHZvaWQgMFxuICAgICAgICApO1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnNpZ25hbCkge1xuICAgICAgICAgIHZhciBzaWduYWwgPSBvcHRpb25zLnNpZ25hbDtcbiAgICAgICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIGFib3J0KHJlcXVlc3QsIHNpZ25hbC5yZWFzb24pO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBhYm9ydChyZXF1ZXN0LCBzaWduYWwucmVhc29uKTtcbiAgICAgICAgICAgICAgc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBsaXN0ZW5lcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXJ0V29yayhyZXF1ZXN0KTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgZXhwb3J0cy52ZXJzaW9uID0gXCIxOS4yLjBcIjtcbiAgfSkoKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-dom/cjs/react-dom-server.browser.development.js\n\n}");

/***/ }),

/***/ "./node_modules/react-dom/cjs/react-dom.development.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-dom/cjs/react-dom.development.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{/**\n * @license React\n * react-dom.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  (function () {\n    function noop() {}\n    function testStringCoercion(value) {\n      return \"\" + value;\n    }\n    function createPortal$1(children, containerInfo, implementation) {\n      var key =\n        3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;\n      try {\n        testStringCoercion(key);\n        var JSCompiler_inline_result = !1;\n      } catch (e) {\n        JSCompiler_inline_result = !0;\n      }\n      JSCompiler_inline_result &&\n        (console.error(\n          \"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\",\n          (\"function\" === typeof Symbol &&\n            Symbol.toStringTag &&\n            key[Symbol.toStringTag]) ||\n            key.constructor.name ||\n            \"Object\"\n        ),\n        testStringCoercion(key));\n      return {\n        $$typeof: REACT_PORTAL_TYPE,\n        key: null == key ? null : \"\" + key,\n        children: children,\n        containerInfo: containerInfo,\n        implementation: implementation\n      };\n    }\n    function getCrossOriginStringAs(as, input) {\n      if (\"font\" === as) return \"\";\n      if (\"string\" === typeof input)\n        return \"use-credentials\" === input ? input : \"\";\n    }\n    function getValueDescriptorExpectingObjectForWarning(thing) {\n      return null === thing\n        ? \"`null`\"\n        : void 0 === thing\n          ? \"`undefined`\"\n          : \"\" === thing\n            ? \"an empty string\"\n            : 'something with type \"' + typeof thing + '\"';\n    }\n    function getValueDescriptorExpectingEnumForWarning(thing) {\n      return null === thing\n        ? \"`null`\"\n        : void 0 === thing\n          ? \"`undefined`\"\n          : \"\" === thing\n            ? \"an empty string\"\n            : \"string\" === typeof thing\n              ? JSON.stringify(thing)\n              : \"number\" === typeof thing\n                ? \"`\" + thing + \"`\"\n                : 'something with type \"' + typeof thing + '\"';\n    }\n    function resolveDispatcher() {\n      var dispatcher = ReactSharedInternals.H;\n      null === dispatcher &&\n        console.error(\n          \"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\\n1. You might have mismatching versions of React and the renderer (such as React DOM)\\n2. You might be breaking the Rules of Hooks\\n3. You might have more than one copy of React in the same app\\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.\"\n        );\n      return dispatcher;\n    }\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());\n    var React = __webpack_require__(/*! react */ \"./node_modules/react/index.js\"),\n      Internals = {\n        d: {\n          f: noop,\n          r: function () {\n            throw Error(\n              \"Invalid form element. requestFormReset must be passed a form that was rendered by React.\"\n            );\n          },\n          D: noop,\n          C: noop,\n          L: noop,\n          m: noop,\n          X: noop,\n          S: noop,\n          M: noop\n        },\n        p: 0,\n        findDOMNode: null\n      },\n      REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n      ReactSharedInternals =\n        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;\n    (\"function\" === typeof Map &&\n      null != Map.prototype &&\n      \"function\" === typeof Map.prototype.forEach &&\n      \"function\" === typeof Set &&\n      null != Set.prototype &&\n      \"function\" === typeof Set.prototype.clear &&\n      \"function\" === typeof Set.prototype.forEach) ||\n      console.error(\n        \"React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills\"\n      );\n    exports.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE =\n      Internals;\n    exports.createPortal = function (children, container) {\n      var key =\n        2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;\n      if (\n        !container ||\n        (1 !== container.nodeType &&\n          9 !== container.nodeType &&\n          11 !== container.nodeType)\n      )\n        throw Error(\"Target container is not a DOM element.\");\n      return createPortal$1(children, container, null, key);\n    };\n    exports.flushSync = function (fn) {\n      var previousTransition = ReactSharedInternals.T,\n        previousUpdatePriority = Internals.p;\n      try {\n        if (((ReactSharedInternals.T = null), (Internals.p = 2), fn))\n          return fn();\n      } finally {\n        (ReactSharedInternals.T = previousTransition),\n          (Internals.p = previousUpdatePriority),\n          Internals.d.f() &&\n            console.error(\n              \"flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task.\"\n            );\n      }\n    };\n    exports.preconnect = function (href, options) {\n      \"string\" === typeof href && href\n        ? null != options && \"object\" !== typeof options\n          ? console.error(\n              \"ReactDOM.preconnect(): Expected the `options` argument (second) to be an object but encountered %s instead. The only supported option at this time is `crossOrigin` which accepts a string.\",\n              getValueDescriptorExpectingEnumForWarning(options)\n            )\n          : null != options &&\n            \"string\" !== typeof options.crossOrigin &&\n            console.error(\n              \"ReactDOM.preconnect(): Expected the `crossOrigin` option (second argument) to be a string but encountered %s instead. Try removing this option or passing a string value instead.\",\n              getValueDescriptorExpectingObjectForWarning(options.crossOrigin)\n            )\n        : console.error(\n            \"ReactDOM.preconnect(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.\",\n            getValueDescriptorExpectingObjectForWarning(href)\n          );\n      \"string\" === typeof href &&\n        (options\n          ? ((options = options.crossOrigin),\n            (options =\n              \"string\" === typeof options\n                ? \"use-credentials\" === options\n                  ? options\n                  : \"\"\n                : void 0))\n          : (options = null),\n        Internals.d.C(href, options));\n    };\n    exports.prefetchDNS = function (href) {\n      if (\"string\" !== typeof href || !href)\n        console.error(\n          \"ReactDOM.prefetchDNS(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.\",\n          getValueDescriptorExpectingObjectForWarning(href)\n        );\n      else if (1 < arguments.length) {\n        var options = arguments[1];\n        \"object\" === typeof options && options.hasOwnProperty(\"crossOrigin\")\n          ? console.error(\n              \"ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. It looks like the you are attempting to set a crossOrigin property for this DNS lookup hint. Browsers do not perform DNS queries using CORS and setting this attribute on the resource hint has no effect. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.\",\n              getValueDescriptorExpectingEnumForWarning(options)\n            )\n          : console.error(\n              \"ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.\",\n              getValueDescriptorExpectingEnumForWarning(options)\n            );\n      }\n      \"string\" === typeof href && Internals.d.D(href);\n    };\n    exports.preinit = function (href, options) {\n      \"string\" === typeof href && href\n        ? null == options || \"object\" !== typeof options\n          ? console.error(\n              \"ReactDOM.preinit(): Expected the `options` argument (second) to be an object with an `as` property describing the type of resource to be preinitialized but encountered %s instead.\",\n              getValueDescriptorExpectingEnumForWarning(options)\n            )\n          : \"style\" !== options.as &&\n            \"script\" !== options.as &&\n            console.error(\n              'ReactDOM.preinit(): Expected the `as` property in the `options` argument (second) to contain a valid value describing the type of resource to be preinitialized but encountered %s instead. Valid values for `as` are \"style\" and \"script\".',\n              getValueDescriptorExpectingEnumForWarning(options.as)\n            )\n        : console.error(\n            \"ReactDOM.preinit(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.\",\n            getValueDescriptorExpectingObjectForWarning(href)\n          );\n      if (\n        \"string\" === typeof href &&\n        options &&\n        \"string\" === typeof options.as\n      ) {\n        var as = options.as,\n          crossOrigin = getCrossOriginStringAs(as, options.crossOrigin),\n          integrity =\n            \"string\" === typeof options.integrity ? options.integrity : void 0,\n          fetchPriority =\n            \"string\" === typeof options.fetchPriority\n              ? options.fetchPriority\n              : void 0;\n        \"style\" === as\n          ? Internals.d.S(\n              href,\n              \"string\" === typeof options.precedence\n                ? options.precedence\n                : void 0,\n              {\n                crossOrigin: crossOrigin,\n                integrity: integrity,\n                fetchPriority: fetchPriority\n              }\n            )\n          : \"script\" === as &&\n            Internals.d.X(href, {\n              crossOrigin: crossOrigin,\n              integrity: integrity,\n              fetchPriority: fetchPriority,\n              nonce: \"string\" === typeof options.nonce ? options.nonce : void 0\n            });\n      }\n    };\n    exports.preinitModule = function (href, options) {\n      var encountered = \"\";\n      (\"string\" === typeof href && href) ||\n        (encountered +=\n          \" The `href` argument encountered was \" +\n          getValueDescriptorExpectingObjectForWarning(href) +\n          \".\");\n      void 0 !== options && \"object\" !== typeof options\n        ? (encountered +=\n            \" The `options` argument encountered was \" +\n            getValueDescriptorExpectingObjectForWarning(options) +\n            \".\")\n        : options &&\n          \"as\" in options &&\n          \"script\" !== options.as &&\n          (encountered +=\n            \" The `as` option encountered was \" +\n            getValueDescriptorExpectingEnumForWarning(options.as) +\n            \".\");\n      if (encountered)\n        console.error(\n          \"ReactDOM.preinitModule(): Expected up to two arguments, a non-empty `href` string and, optionally, an `options` object with a valid `as` property.%s\",\n          encountered\n        );\n      else\n        switch (\n          ((encountered =\n            options && \"string\" === typeof options.as ? options.as : \"script\"),\n          encountered)\n        ) {\n          case \"script\":\n            break;\n          default:\n            (encountered =\n              getValueDescriptorExpectingEnumForWarning(encountered)),\n              console.error(\n                'ReactDOM.preinitModule(): Currently the only supported \"as\" type for this function is \"script\" but received \"%s\" instead. This warning was generated for `href` \"%s\". In the future other module types will be supported, aligning with the import-attributes proposal. Learn more here: (https://github.com/tc39/proposal-import-attributes)',\n                encountered,\n                href\n              );\n        }\n      if (\"string\" === typeof href)\n        if (\"object\" === typeof options && null !== options) {\n          if (null == options.as || \"script\" === options.as)\n            (encountered = getCrossOriginStringAs(\n              options.as,\n              options.crossOrigin\n            )),\n              Internals.d.M(href, {\n                crossOrigin: encountered,\n                integrity:\n                  \"string\" === typeof options.integrity\n                    ? options.integrity\n                    : void 0,\n                nonce:\n                  \"string\" === typeof options.nonce ? options.nonce : void 0\n              });\n        } else null == options && Internals.d.M(href);\n    };\n    exports.preload = function (href, options) {\n      var encountered = \"\";\n      (\"string\" === typeof href && href) ||\n        (encountered +=\n          \" The `href` argument encountered was \" +\n          getValueDescriptorExpectingObjectForWarning(href) +\n          \".\");\n      null == options || \"object\" !== typeof options\n        ? (encountered +=\n            \" The `options` argument encountered was \" +\n            getValueDescriptorExpectingObjectForWarning(options) +\n            \".\")\n        : (\"string\" === typeof options.as && options.as) ||\n          (encountered +=\n            \" The `as` option encountered was \" +\n            getValueDescriptorExpectingObjectForWarning(options.as) +\n            \".\");\n      encountered &&\n        console.error(\n          'ReactDOM.preload(): Expected two arguments, a non-empty `href` string and an `options` object with an `as` property valid for a `<link rel=\"preload\" as=\"...\" />` tag.%s',\n          encountered\n        );\n      if (\n        \"string\" === typeof href &&\n        \"object\" === typeof options &&\n        null !== options &&\n        \"string\" === typeof options.as\n      ) {\n        encountered = options.as;\n        var crossOrigin = getCrossOriginStringAs(\n          encountered,\n          options.crossOrigin\n        );\n        Internals.d.L(href, encountered, {\n          crossOrigin: crossOrigin,\n          integrity:\n            \"string\" === typeof options.integrity ? options.integrity : void 0,\n          nonce: \"string\" === typeof options.nonce ? options.nonce : void 0,\n          type: \"string\" === typeof options.type ? options.type : void 0,\n          fetchPriority:\n            \"string\" === typeof options.fetchPriority\n              ? options.fetchPriority\n              : void 0,\n          referrerPolicy:\n            \"string\" === typeof options.referrerPolicy\n              ? options.referrerPolicy\n              : void 0,\n          imageSrcSet:\n            \"string\" === typeof options.imageSrcSet\n              ? options.imageSrcSet\n              : void 0,\n          imageSizes:\n            \"string\" === typeof options.imageSizes\n              ? options.imageSizes\n              : void 0,\n          media: \"string\" === typeof options.media ? options.media : void 0\n        });\n      }\n    };\n    exports.preloadModule = function (href, options) {\n      var encountered = \"\";\n      (\"string\" === typeof href && href) ||\n        (encountered +=\n          \" The `href` argument encountered was \" +\n          getValueDescriptorExpectingObjectForWarning(href) +\n          \".\");\n      void 0 !== options && \"object\" !== typeof options\n        ? (encountered +=\n            \" The `options` argument encountered was \" +\n            getValueDescriptorExpectingObjectForWarning(options) +\n            \".\")\n        : options &&\n          \"as\" in options &&\n          \"string\" !== typeof options.as &&\n          (encountered +=\n            \" The `as` option encountered was \" +\n            getValueDescriptorExpectingObjectForWarning(options.as) +\n            \".\");\n      encountered &&\n        console.error(\n          'ReactDOM.preloadModule(): Expected two arguments, a non-empty `href` string and, optionally, an `options` object with an `as` property valid for a `<link rel=\"modulepreload\" as=\"...\" />` tag.%s',\n          encountered\n        );\n      \"string\" === typeof href &&\n        (options\n          ? ((encountered = getCrossOriginStringAs(\n              options.as,\n              options.crossOrigin\n            )),\n            Internals.d.m(href, {\n              as:\n                \"string\" === typeof options.as && \"script\" !== options.as\n                  ? options.as\n                  : void 0,\n              crossOrigin: encountered,\n              integrity:\n                \"string\" === typeof options.integrity\n                  ? options.integrity\n                  : void 0\n            }))\n          : Internals.d.m(href));\n    };\n    exports.requestFormReset = function (form) {\n      Internals.d.r(form);\n    };\n    exports.unstable_batchedUpdates = function (fn, a) {\n      return fn(a);\n    };\n    exports.useFormState = function (action, initialState, permalink) {\n      return resolveDispatcher().useFormState(action, initialState, permalink);\n    };\n    exports.useFormStatus = function () {\n      return resolveDispatcher().useHostTransitionStatus();\n    };\n    exports.version = \"19.2.0\";\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2Nqcy9yZWFjdC1kb20uZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhO0FBQ2IsS0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsNENBQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksb0VBQW9FO0FBQ3hFO0FBQ0EsSUFBSSxvQkFBb0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksaUJBQWlCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksa0JBQWtCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxtQkFBbUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGVBQWU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsSUFBSSxxQkFBcUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsVUFBVTtBQUNWO0FBQ0EsSUFBSSxlQUFlO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxJQUFJLHFCQUFxQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLElBQUksd0JBQXdCO0FBQzVCO0FBQ0E7QUFDQSxJQUFJLCtCQUErQjtBQUNuQztBQUNBO0FBQ0EsSUFBSSxvQkFBb0I7QUFDeEI7QUFDQTtBQUNBLElBQUkscUJBQXFCO0FBQ3pCO0FBQ0E7QUFDQSxJQUFJLGVBQWU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vU1NSLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9janMvcmVhY3QtZG9tLmRldmVsb3BtZW50LmpzPzYxYmIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtZG9tLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViAmJlxuICAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIG5vb3AoKSB7fVxuICAgIGZ1bmN0aW9uIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIFwiXCIgKyB2YWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlUG9ydGFsJDEoY2hpbGRyZW4sIGNvbnRhaW5lckluZm8sIGltcGxlbWVudGF0aW9uKSB7XG4gICAgICB2YXIga2V5ID1cbiAgICAgICAgMyA8IGFyZ3VtZW50cy5sZW5ndGggJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbM10gPyBhcmd1bWVudHNbM10gOiBudWxsO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKGtleSk7XG4gICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAhMTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITA7XG4gICAgICB9XG4gICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgJiZcbiAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJUaGUgcHJvdmlkZWQga2V5IGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSB1c2luZyBpdCBoZXJlLlwiLFxuICAgICAgICAgIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBTeW1ib2wgJiZcbiAgICAgICAgICAgIFN5bWJvbC50b1N0cmluZ1RhZyAmJlxuICAgICAgICAgICAga2V5W1N5bWJvbC50b1N0cmluZ1RhZ10pIHx8XG4gICAgICAgICAgICBrZXkuY29uc3RydWN0b3IubmFtZSB8fFxuICAgICAgICAgICAgXCJPYmplY3RcIlxuICAgICAgICApLFxuICAgICAgICB0ZXN0U3RyaW5nQ29lcmNpb24oa2V5KSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAkJHR5cGVvZjogUkVBQ1RfUE9SVEFMX1RZUEUsXG4gICAgICAgIGtleTogbnVsbCA9PSBrZXkgPyBudWxsIDogXCJcIiArIGtleSxcbiAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgICAgICBjb250YWluZXJJbmZvOiBjb250YWluZXJJbmZvLFxuICAgICAgICBpbXBsZW1lbnRhdGlvbjogaW1wbGVtZW50YXRpb25cbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldENyb3NzT3JpZ2luU3RyaW5nQXMoYXMsIGlucHV0KSB7XG4gICAgICBpZiAoXCJmb250XCIgPT09IGFzKSByZXR1cm4gXCJcIjtcbiAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgaW5wdXQpXG4gICAgICAgIHJldHVybiBcInVzZS1jcmVkZW50aWFsc1wiID09PSBpbnB1dCA/IGlucHV0IDogXCJcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nT2JqZWN0Rm9yV2FybmluZyh0aGluZykge1xuICAgICAgcmV0dXJuIG51bGwgPT09IHRoaW5nXG4gICAgICAgID8gXCJgbnVsbGBcIlxuICAgICAgICA6IHZvaWQgMCA9PT0gdGhpbmdcbiAgICAgICAgICA/IFwiYHVuZGVmaW5lZGBcIlxuICAgICAgICAgIDogXCJcIiA9PT0gdGhpbmdcbiAgICAgICAgICAgID8gXCJhbiBlbXB0eSBzdHJpbmdcIlxuICAgICAgICAgICAgOiAnc29tZXRoaW5nIHdpdGggdHlwZSBcIicgKyB0eXBlb2YgdGhpbmcgKyAnXCInO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdFbnVtRm9yV2FybmluZyh0aGluZykge1xuICAgICAgcmV0dXJuIG51bGwgPT09IHRoaW5nXG4gICAgICAgID8gXCJgbnVsbGBcIlxuICAgICAgICA6IHZvaWQgMCA9PT0gdGhpbmdcbiAgICAgICAgICA/IFwiYHVuZGVmaW5lZGBcIlxuICAgICAgICAgIDogXCJcIiA9PT0gdGhpbmdcbiAgICAgICAgICAgID8gXCJhbiBlbXB0eSBzdHJpbmdcIlxuICAgICAgICAgICAgOiBcInN0cmluZ1wiID09PSB0eXBlb2YgdGhpbmdcbiAgICAgICAgICAgICAgPyBKU09OLnN0cmluZ2lmeSh0aGluZylcbiAgICAgICAgICAgICAgOiBcIm51bWJlclwiID09PSB0eXBlb2YgdGhpbmdcbiAgICAgICAgICAgICAgICA/IFwiYFwiICsgdGhpbmcgKyBcImBcIlxuICAgICAgICAgICAgICAgIDogJ3NvbWV0aGluZyB3aXRoIHR5cGUgXCInICsgdHlwZW9mIHRoaW5nICsgJ1wiJztcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzb2x2ZURpc3BhdGNoZXIoKSB7XG4gICAgICB2YXIgZGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICBudWxsID09PSBkaXNwYXRjaGVyICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJJbnZhbGlkIGhvb2sgY2FsbC4gSG9va3MgY2FuIG9ubHkgYmUgY2FsbGVkIGluc2lkZSBvZiB0aGUgYm9keSBvZiBhIGZ1bmN0aW9uIGNvbXBvbmVudC4gVGhpcyBjb3VsZCBoYXBwZW4gZm9yIG9uZSBvZiB0aGUgZm9sbG93aW5nIHJlYXNvbnM6XFxuMS4gWW91IG1pZ2h0IGhhdmUgbWlzbWF0Y2hpbmcgdmVyc2lvbnMgb2YgUmVhY3QgYW5kIHRoZSByZW5kZXJlciAoc3VjaCBhcyBSZWFjdCBET00pXFxuMi4gWW91IG1pZ2h0IGJlIGJyZWFraW5nIHRoZSBSdWxlcyBvZiBIb29rc1xcbjMuIFlvdSBtaWdodCBoYXZlIG1vcmUgdGhhbiBvbmUgY29weSBvZiBSZWFjdCBpbiB0aGUgc2FtZSBhcHBcXG5TZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9pbnZhbGlkLWhvb2stY2FsbCBmb3IgdGlwcyBhYm91dCBob3cgdG8gZGVidWcgYW5kIGZpeCB0aGlzIHByb2JsZW0uXCJcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiBkaXNwYXRjaGVyO1xuICAgIH1cbiAgICBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICYmXG4gICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0ICYmXG4gICAgICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0KEVycm9yKCkpO1xuICAgIHZhciBSZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKSxcbiAgICAgIEludGVybmFscyA9IHtcbiAgICAgICAgZDoge1xuICAgICAgICAgIGY6IG5vb3AsXG4gICAgICAgICAgcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgIFwiSW52YWxpZCBmb3JtIGVsZW1lbnQuIHJlcXVlc3RGb3JtUmVzZXQgbXVzdCBiZSBwYXNzZWQgYSBmb3JtIHRoYXQgd2FzIHJlbmRlcmVkIGJ5IFJlYWN0LlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgRDogbm9vcCxcbiAgICAgICAgICBDOiBub29wLFxuICAgICAgICAgIEw6IG5vb3AsXG4gICAgICAgICAgbTogbm9vcCxcbiAgICAgICAgICBYOiBub29wLFxuICAgICAgICAgIFM6IG5vb3AsXG4gICAgICAgICAgTTogbm9vcFxuICAgICAgICB9LFxuICAgICAgICBwOiAwLFxuICAgICAgICBmaW5kRE9NTm9kZTogbnVsbFxuICAgICAgfSxcbiAgICAgIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKSxcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzID1cbiAgICAgICAgUmVhY3QuX19DTElFTlRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfV0FSTl9VU0VSU19USEVZX0NBTk5PVF9VUEdSQURFO1xuICAgIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBNYXAgJiZcbiAgICAgIG51bGwgIT0gTWFwLnByb3RvdHlwZSAmJlxuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgTWFwLnByb3RvdHlwZS5mb3JFYWNoICYmXG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBTZXQgJiZcbiAgICAgIG51bGwgIT0gU2V0LnByb3RvdHlwZSAmJlxuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgU2V0LnByb3RvdHlwZS5jbGVhciAmJlxuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgU2V0LnByb3RvdHlwZS5mb3JFYWNoKSB8fFxuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgXCJSZWFjdCBkZXBlbmRzIG9uIE1hcCBhbmQgU2V0IGJ1aWx0LWluIHR5cGVzLiBNYWtlIHN1cmUgdGhhdCB5b3UgbG9hZCBhIHBvbHlmaWxsIGluIG9sZGVyIGJyb3dzZXJzLiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvcmVhY3QtcG9seWZpbGxzXCJcbiAgICAgICk7XG4gICAgZXhwb3J0cy5fX0RPTV9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREUgPVxuICAgICAgSW50ZXJuYWxzO1xuICAgIGV4cG9ydHMuY3JlYXRlUG9ydGFsID0gZnVuY3Rpb24gKGNoaWxkcmVuLCBjb250YWluZXIpIHtcbiAgICAgIHZhciBrZXkgPVxuICAgICAgICAyIDwgYXJndW1lbnRzLmxlbmd0aCAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1syXSA/IGFyZ3VtZW50c1syXSA6IG51bGw7XG4gICAgICBpZiAoXG4gICAgICAgICFjb250YWluZXIgfHxcbiAgICAgICAgKDEgIT09IGNvbnRhaW5lci5ub2RlVHlwZSAmJlxuICAgICAgICAgIDkgIT09IGNvbnRhaW5lci5ub2RlVHlwZSAmJlxuICAgICAgICAgIDExICE9PSBjb250YWluZXIubm9kZVR5cGUpXG4gICAgICApXG4gICAgICAgIHRocm93IEVycm9yKFwiVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgYSBET00gZWxlbWVudC5cIik7XG4gICAgICByZXR1cm4gY3JlYXRlUG9ydGFsJDEoY2hpbGRyZW4sIGNvbnRhaW5lciwgbnVsbCwga2V5KTtcbiAgICB9O1xuICAgIGV4cG9ydHMuZmx1c2hTeW5jID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICB2YXIgcHJldmlvdXNUcmFuc2l0aW9uID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCxcbiAgICAgICAgcHJldmlvdXNVcGRhdGVQcmlvcml0eSA9IEludGVybmFscy5wO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCgoUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IG51bGwpLCAoSW50ZXJuYWxzLnAgPSAyKSwgZm4pKVxuICAgICAgICAgIHJldHVybiBmbigpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBwcmV2aW91c1RyYW5zaXRpb24pLFxuICAgICAgICAgIChJbnRlcm5hbHMucCA9IHByZXZpb3VzVXBkYXRlUHJpb3JpdHkpLFxuICAgICAgICAgIEludGVybmFscy5kLmYoKSAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJmbHVzaFN5bmMgd2FzIGNhbGxlZCBmcm9tIGluc2lkZSBhIGxpZmVjeWNsZSBtZXRob2QuIFJlYWN0IGNhbm5vdCBmbHVzaCB3aGVuIFJlYWN0IGlzIGFscmVhZHkgcmVuZGVyaW5nLiBDb25zaWRlciBtb3ZpbmcgdGhpcyBjYWxsIHRvIGEgc2NoZWR1bGVyIHRhc2sgb3IgbWljcm8gdGFzay5cIlxuICAgICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGV4cG9ydHMucHJlY29ubmVjdCA9IGZ1bmN0aW9uIChocmVmLCBvcHRpb25zKSB7XG4gICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgaHJlZiAmJiBocmVmXG4gICAgICAgID8gbnVsbCAhPSBvcHRpb25zICYmIFwib2JqZWN0XCIgIT09IHR5cGVvZiBvcHRpb25zXG4gICAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlJlYWN0RE9NLnByZWNvbm5lY3QoKTogRXhwZWN0ZWQgdGhlIGBvcHRpb25zYCBhcmd1bWVudCAoc2Vjb25kKSB0byBiZSBhbiBvYmplY3QgYnV0IGVuY291bnRlcmVkICVzIGluc3RlYWQuIFRoZSBvbmx5IHN1cHBvcnRlZCBvcHRpb24gYXQgdGhpcyB0aW1lIGlzIGBjcm9zc09yaWdpbmAgd2hpY2ggYWNjZXB0cyBhIHN0cmluZy5cIixcbiAgICAgICAgICAgICAgZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nRW51bUZvcldhcm5pbmcob3B0aW9ucylcbiAgICAgICAgICAgIClcbiAgICAgICAgICA6IG51bGwgIT0gb3B0aW9ucyAmJlxuICAgICAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIG9wdGlvbnMuY3Jvc3NPcmlnaW4gJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVhY3RET00ucHJlY29ubmVjdCgpOiBFeHBlY3RlZCB0aGUgYGNyb3NzT3JpZ2luYCBvcHRpb24gKHNlY29uZCBhcmd1bWVudCkgdG8gYmUgYSBzdHJpbmcgYnV0IGVuY291bnRlcmVkICVzIGluc3RlYWQuIFRyeSByZW1vdmluZyB0aGlzIG9wdGlvbiBvciBwYXNzaW5nIGEgc3RyaW5nIHZhbHVlIGluc3RlYWQuXCIsXG4gICAgICAgICAgICAgIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ09iamVjdEZvcldhcm5pbmcob3B0aW9ucy5jcm9zc09yaWdpbilcbiAgICAgICAgICAgIClcbiAgICAgICAgOiBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJSZWFjdERPTS5wcmVjb25uZWN0KCk6IEV4cGVjdGVkIHRoZSBgaHJlZmAgYXJndW1lbnQgKGZpcnN0KSB0byBiZSBhIG5vbi1lbXB0eSBzdHJpbmcgYnV0IGVuY291bnRlcmVkICVzIGluc3RlYWQuXCIsXG4gICAgICAgICAgICBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdPYmplY3RGb3JXYXJuaW5nKGhyZWYpXG4gICAgICAgICAgKTtcbiAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBocmVmICYmXG4gICAgICAgIChvcHRpb25zXG4gICAgICAgICAgPyAoKG9wdGlvbnMgPSBvcHRpb25zLmNyb3NzT3JpZ2luKSxcbiAgICAgICAgICAgIChvcHRpb25zID1cbiAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnNcbiAgICAgICAgICAgICAgICA/IFwidXNlLWNyZWRlbnRpYWxzXCIgPT09IG9wdGlvbnNcbiAgICAgICAgICAgICAgICAgID8gb3B0aW9uc1xuICAgICAgICAgICAgICAgICAgOiBcIlwiXG4gICAgICAgICAgICAgICAgOiB2b2lkIDApKVxuICAgICAgICAgIDogKG9wdGlvbnMgPSBudWxsKSxcbiAgICAgICAgSW50ZXJuYWxzLmQuQyhocmVmLCBvcHRpb25zKSk7XG4gICAgfTtcbiAgICBleHBvcnRzLnByZWZldGNoRE5TID0gZnVuY3Rpb24gKGhyZWYpIHtcbiAgICAgIGlmIChcInN0cmluZ1wiICE9PSB0eXBlb2YgaHJlZiB8fCAhaHJlZilcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlJlYWN0RE9NLnByZWZldGNoRE5TKCk6IEV4cGVjdGVkIHRoZSBgaHJlZmAgYXJndW1lbnQgKGZpcnN0KSB0byBiZSBhIG5vbi1lbXB0eSBzdHJpbmcgYnV0IGVuY291bnRlcmVkICVzIGluc3RlYWQuXCIsXG4gICAgICAgICAgZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nT2JqZWN0Rm9yV2FybmluZyhocmVmKVxuICAgICAgICApO1xuICAgICAgZWxzZSBpZiAoMSA8IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBvcHRpb25zICYmIG9wdGlvbnMuaGFzT3duUHJvcGVydHkoXCJjcm9zc09yaWdpblwiKVxuICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJSZWFjdERPTS5wcmVmZXRjaEROUygpOiBFeHBlY3RlZCBvbmx5IG9uZSBhcmd1bWVudCwgYGhyZWZgLCBidXQgZW5jb3VudGVyZWQgJXMgYXMgYSBzZWNvbmQgYXJndW1lbnQgaW5zdGVhZC4gVGhpcyBhcmd1bWVudCBpcyByZXNlcnZlZCBmb3IgZnV0dXJlIG9wdGlvbnMgYW5kIGlzIGN1cnJlbnRseSBkaXNhbGxvd2VkLiBJdCBsb29rcyBsaWtlIHRoZSB5b3UgYXJlIGF0dGVtcHRpbmcgdG8gc2V0IGEgY3Jvc3NPcmlnaW4gcHJvcGVydHkgZm9yIHRoaXMgRE5TIGxvb2t1cCBoaW50LiBCcm93c2VycyBkbyBub3QgcGVyZm9ybSBETlMgcXVlcmllcyB1c2luZyBDT1JTIGFuZCBzZXR0aW5nIHRoaXMgYXR0cmlidXRlIG9uIHRoZSByZXNvdXJjZSBoaW50IGhhcyBubyBlZmZlY3QuIFRyeSBjYWxsaW5nIFJlYWN0RE9NLnByZWZldGNoRE5TKCkgd2l0aCBqdXN0IGEgc2luZ2xlIHN0cmluZyBhcmd1bWVudCwgYGhyZWZgLlwiLFxuICAgICAgICAgICAgICBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdFbnVtRm9yV2FybmluZyhvcHRpb25zKVxuICAgICAgICAgICAgKVxuICAgICAgICAgIDogY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJSZWFjdERPTS5wcmVmZXRjaEROUygpOiBFeHBlY3RlZCBvbmx5IG9uZSBhcmd1bWVudCwgYGhyZWZgLCBidXQgZW5jb3VudGVyZWQgJXMgYXMgYSBzZWNvbmQgYXJndW1lbnQgaW5zdGVhZC4gVGhpcyBhcmd1bWVudCBpcyByZXNlcnZlZCBmb3IgZnV0dXJlIG9wdGlvbnMgYW5kIGlzIGN1cnJlbnRseSBkaXNhbGxvd2VkLiBUcnkgY2FsbGluZyBSZWFjdERPTS5wcmVmZXRjaEROUygpIHdpdGgganVzdCBhIHNpbmdsZSBzdHJpbmcgYXJndW1lbnQsIGBocmVmYC5cIixcbiAgICAgICAgICAgICAgZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nRW51bUZvcldhcm5pbmcob3B0aW9ucylcbiAgICAgICAgICAgICk7XG4gICAgICB9XG4gICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgaHJlZiAmJiBJbnRlcm5hbHMuZC5EKGhyZWYpO1xuICAgIH07XG4gICAgZXhwb3J0cy5wcmVpbml0ID0gZnVuY3Rpb24gKGhyZWYsIG9wdGlvbnMpIHtcbiAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBocmVmICYmIGhyZWZcbiAgICAgICAgPyBudWxsID09IG9wdGlvbnMgfHwgXCJvYmplY3RcIiAhPT0gdHlwZW9mIG9wdGlvbnNcbiAgICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVhY3RET00ucHJlaW5pdCgpOiBFeHBlY3RlZCB0aGUgYG9wdGlvbnNgIGFyZ3VtZW50IChzZWNvbmQpIHRvIGJlIGFuIG9iamVjdCB3aXRoIGFuIGBhc2AgcHJvcGVydHkgZGVzY3JpYmluZyB0aGUgdHlwZSBvZiByZXNvdXJjZSB0byBiZSBwcmVpbml0aWFsaXplZCBidXQgZW5jb3VudGVyZWQgJXMgaW5zdGVhZC5cIixcbiAgICAgICAgICAgICAgZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nRW51bUZvcldhcm5pbmcob3B0aW9ucylcbiAgICAgICAgICAgIClcbiAgICAgICAgICA6IFwic3R5bGVcIiAhPT0gb3B0aW9ucy5hcyAmJlxuICAgICAgICAgICAgXCJzY3JpcHRcIiAhPT0gb3B0aW9ucy5hcyAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgJ1JlYWN0RE9NLnByZWluaXQoKTogRXhwZWN0ZWQgdGhlIGBhc2AgcHJvcGVydHkgaW4gdGhlIGBvcHRpb25zYCBhcmd1bWVudCAoc2Vjb25kKSB0byBjb250YWluIGEgdmFsaWQgdmFsdWUgZGVzY3JpYmluZyB0aGUgdHlwZSBvZiByZXNvdXJjZSB0byBiZSBwcmVpbml0aWFsaXplZCBidXQgZW5jb3VudGVyZWQgJXMgaW5zdGVhZC4gVmFsaWQgdmFsdWVzIGZvciBgYXNgIGFyZSBcInN0eWxlXCIgYW5kIFwic2NyaXB0XCIuJyxcbiAgICAgICAgICAgICAgZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nRW51bUZvcldhcm5pbmcob3B0aW9ucy5hcylcbiAgICAgICAgICAgIClcbiAgICAgICAgOiBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJSZWFjdERPTS5wcmVpbml0KCk6IEV4cGVjdGVkIHRoZSBgaHJlZmAgYXJndW1lbnQgKGZpcnN0KSB0byBiZSBhIG5vbi1lbXB0eSBzdHJpbmcgYnV0IGVuY291bnRlcmVkICVzIGluc3RlYWQuXCIsXG4gICAgICAgICAgICBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdPYmplY3RGb3JXYXJuaW5nKGhyZWYpXG4gICAgICAgICAgKTtcbiAgICAgIGlmIChcbiAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGhyZWYgJiZcbiAgICAgICAgb3B0aW9ucyAmJlxuICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy5hc1xuICAgICAgKSB7XG4gICAgICAgIHZhciBhcyA9IG9wdGlvbnMuYXMsXG4gICAgICAgICAgY3Jvc3NPcmlnaW4gPSBnZXRDcm9zc09yaWdpblN0cmluZ0FzKGFzLCBvcHRpb25zLmNyb3NzT3JpZ2luKSxcbiAgICAgICAgICBpbnRlZ3JpdHkgPVxuICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMuaW50ZWdyaXR5ID8gb3B0aW9ucy5pbnRlZ3JpdHkgOiB2b2lkIDAsXG4gICAgICAgICAgZmV0Y2hQcmlvcml0eSA9XG4gICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy5mZXRjaFByaW9yaXR5XG4gICAgICAgICAgICAgID8gb3B0aW9ucy5mZXRjaFByaW9yaXR5XG4gICAgICAgICAgICAgIDogdm9pZCAwO1xuICAgICAgICBcInN0eWxlXCIgPT09IGFzXG4gICAgICAgICAgPyBJbnRlcm5hbHMuZC5TKFxuICAgICAgICAgICAgICBocmVmLFxuICAgICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy5wcmVjZWRlbmNlXG4gICAgICAgICAgICAgICAgPyBvcHRpb25zLnByZWNlZGVuY2VcbiAgICAgICAgICAgICAgICA6IHZvaWQgMCxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNyb3NzT3JpZ2luOiBjcm9zc09yaWdpbixcbiAgICAgICAgICAgICAgICBpbnRlZ3JpdHk6IGludGVncml0eSxcbiAgICAgICAgICAgICAgICBmZXRjaFByaW9yaXR5OiBmZXRjaFByaW9yaXR5XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIClcbiAgICAgICAgICA6IFwic2NyaXB0XCIgPT09IGFzICYmXG4gICAgICAgICAgICBJbnRlcm5hbHMuZC5YKGhyZWYsIHtcbiAgICAgICAgICAgICAgY3Jvc3NPcmlnaW46IGNyb3NzT3JpZ2luLFxuICAgICAgICAgICAgICBpbnRlZ3JpdHk6IGludGVncml0eSxcbiAgICAgICAgICAgICAgZmV0Y2hQcmlvcml0eTogZmV0Y2hQcmlvcml0eSxcbiAgICAgICAgICAgICAgbm9uY2U6IFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLm5vbmNlID8gb3B0aW9ucy5ub25jZSA6IHZvaWQgMFxuICAgICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBleHBvcnRzLnByZWluaXRNb2R1bGUgPSBmdW5jdGlvbiAoaHJlZiwgb3B0aW9ucykge1xuICAgICAgdmFyIGVuY291bnRlcmVkID0gXCJcIjtcbiAgICAgIChcInN0cmluZ1wiID09PSB0eXBlb2YgaHJlZiAmJiBocmVmKSB8fFxuICAgICAgICAoZW5jb3VudGVyZWQgKz1cbiAgICAgICAgICBcIiBUaGUgYGhyZWZgIGFyZ3VtZW50IGVuY291bnRlcmVkIHdhcyBcIiArXG4gICAgICAgICAgZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nT2JqZWN0Rm9yV2FybmluZyhocmVmKSArXG4gICAgICAgICAgXCIuXCIpO1xuICAgICAgdm9pZCAwICE9PSBvcHRpb25zICYmIFwib2JqZWN0XCIgIT09IHR5cGVvZiBvcHRpb25zXG4gICAgICAgID8gKGVuY291bnRlcmVkICs9XG4gICAgICAgICAgICBcIiBUaGUgYG9wdGlvbnNgIGFyZ3VtZW50IGVuY291bnRlcmVkIHdhcyBcIiArXG4gICAgICAgICAgICBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdPYmplY3RGb3JXYXJuaW5nKG9wdGlvbnMpICtcbiAgICAgICAgICAgIFwiLlwiKVxuICAgICAgICA6IG9wdGlvbnMgJiZcbiAgICAgICAgICBcImFzXCIgaW4gb3B0aW9ucyAmJlxuICAgICAgICAgIFwic2NyaXB0XCIgIT09IG9wdGlvbnMuYXMgJiZcbiAgICAgICAgICAoZW5jb3VudGVyZWQgKz1cbiAgICAgICAgICAgIFwiIFRoZSBgYXNgIG9wdGlvbiBlbmNvdW50ZXJlZCB3YXMgXCIgK1xuICAgICAgICAgICAgZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nRW51bUZvcldhcm5pbmcob3B0aW9ucy5hcykgK1xuICAgICAgICAgICAgXCIuXCIpO1xuICAgICAgaWYgKGVuY291bnRlcmVkKVxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiUmVhY3RET00ucHJlaW5pdE1vZHVsZSgpOiBFeHBlY3RlZCB1cCB0byB0d28gYXJndW1lbnRzLCBhIG5vbi1lbXB0eSBgaHJlZmAgc3RyaW5nIGFuZCwgb3B0aW9uYWxseSwgYW4gYG9wdGlvbnNgIG9iamVjdCB3aXRoIGEgdmFsaWQgYGFzYCBwcm9wZXJ0eS4lc1wiLFxuICAgICAgICAgIGVuY291bnRlcmVkXG4gICAgICAgICk7XG4gICAgICBlbHNlXG4gICAgICAgIHN3aXRjaCAoXG4gICAgICAgICAgKChlbmNvdW50ZXJlZCA9XG4gICAgICAgICAgICBvcHRpb25zICYmIFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLmFzID8gb3B0aW9ucy5hcyA6IFwic2NyaXB0XCIpLFxuICAgICAgICAgIGVuY291bnRlcmVkKVxuICAgICAgICApIHtcbiAgICAgICAgICBjYXNlIFwic2NyaXB0XCI6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgKGVuY291bnRlcmVkID1cbiAgICAgICAgICAgICAgZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nRW51bUZvcldhcm5pbmcoZW5jb3VudGVyZWQpKSxcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAnUmVhY3RET00ucHJlaW5pdE1vZHVsZSgpOiBDdXJyZW50bHkgdGhlIG9ubHkgc3VwcG9ydGVkIFwiYXNcIiB0eXBlIGZvciB0aGlzIGZ1bmN0aW9uIGlzIFwic2NyaXB0XCIgYnV0IHJlY2VpdmVkIFwiJXNcIiBpbnN0ZWFkLiBUaGlzIHdhcm5pbmcgd2FzIGdlbmVyYXRlZCBmb3IgYGhyZWZgIFwiJXNcIi4gSW4gdGhlIGZ1dHVyZSBvdGhlciBtb2R1bGUgdHlwZXMgd2lsbCBiZSBzdXBwb3J0ZWQsIGFsaWduaW5nIHdpdGggdGhlIGltcG9ydC1hdHRyaWJ1dGVzIHByb3Bvc2FsLiBMZWFybiBtb3JlIGhlcmU6IChodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1pbXBvcnQtYXR0cmlidXRlcyknLFxuICAgICAgICAgICAgICAgIGVuY291bnRlcmVkLFxuICAgICAgICAgICAgICAgIGhyZWZcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBocmVmKVxuICAgICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIG9wdGlvbnMgJiYgbnVsbCAhPT0gb3B0aW9ucykge1xuICAgICAgICAgIGlmIChudWxsID09IG9wdGlvbnMuYXMgfHwgXCJzY3JpcHRcIiA9PT0gb3B0aW9ucy5hcylcbiAgICAgICAgICAgIChlbmNvdW50ZXJlZCA9IGdldENyb3NzT3JpZ2luU3RyaW5nQXMoXG4gICAgICAgICAgICAgIG9wdGlvbnMuYXMsXG4gICAgICAgICAgICAgIG9wdGlvbnMuY3Jvc3NPcmlnaW5cbiAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICBJbnRlcm5hbHMuZC5NKGhyZWYsIHtcbiAgICAgICAgICAgICAgICBjcm9zc09yaWdpbjogZW5jb3VudGVyZWQsXG4gICAgICAgICAgICAgICAgaW50ZWdyaXR5OlxuICAgICAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMuaW50ZWdyaXR5XG4gICAgICAgICAgICAgICAgICAgID8gb3B0aW9ucy5pbnRlZ3JpdHlcbiAgICAgICAgICAgICAgICAgICAgOiB2b2lkIDAsXG4gICAgICAgICAgICAgICAgbm9uY2U6XG4gICAgICAgICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy5ub25jZSA/IG9wdGlvbnMubm9uY2UgOiB2b2lkIDBcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBudWxsID09IG9wdGlvbnMgJiYgSW50ZXJuYWxzLmQuTShocmVmKTtcbiAgICB9O1xuICAgIGV4cG9ydHMucHJlbG9hZCA9IGZ1bmN0aW9uIChocmVmLCBvcHRpb25zKSB7XG4gICAgICB2YXIgZW5jb3VudGVyZWQgPSBcIlwiO1xuICAgICAgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBocmVmICYmIGhyZWYpIHx8XG4gICAgICAgIChlbmNvdW50ZXJlZCArPVxuICAgICAgICAgIFwiIFRoZSBgaHJlZmAgYXJndW1lbnQgZW5jb3VudGVyZWQgd2FzIFwiICtcbiAgICAgICAgICBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdPYmplY3RGb3JXYXJuaW5nKGhyZWYpICtcbiAgICAgICAgICBcIi5cIik7XG4gICAgICBudWxsID09IG9wdGlvbnMgfHwgXCJvYmplY3RcIiAhPT0gdHlwZW9mIG9wdGlvbnNcbiAgICAgICAgPyAoZW5jb3VudGVyZWQgKz1cbiAgICAgICAgICAgIFwiIFRoZSBgb3B0aW9uc2AgYXJndW1lbnQgZW5jb3VudGVyZWQgd2FzIFwiICtcbiAgICAgICAgICAgIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ09iamVjdEZvcldhcm5pbmcob3B0aW9ucykgK1xuICAgICAgICAgICAgXCIuXCIpXG4gICAgICAgIDogKFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLmFzICYmIG9wdGlvbnMuYXMpIHx8XG4gICAgICAgICAgKGVuY291bnRlcmVkICs9XG4gICAgICAgICAgICBcIiBUaGUgYGFzYCBvcHRpb24gZW5jb3VudGVyZWQgd2FzIFwiICtcbiAgICAgICAgICAgIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ09iamVjdEZvcldhcm5pbmcob3B0aW9ucy5hcykgK1xuICAgICAgICAgICAgXCIuXCIpO1xuICAgICAgZW5jb3VudGVyZWQgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAnUmVhY3RET00ucHJlbG9hZCgpOiBFeHBlY3RlZCB0d28gYXJndW1lbnRzLCBhIG5vbi1lbXB0eSBgaHJlZmAgc3RyaW5nIGFuZCBhbiBgb3B0aW9uc2Agb2JqZWN0IHdpdGggYW4gYGFzYCBwcm9wZXJ0eSB2YWxpZCBmb3IgYSBgPGxpbmsgcmVsPVwicHJlbG9hZFwiIGFzPVwiLi4uXCIgLz5gIHRhZy4lcycsXG4gICAgICAgICAgZW5jb3VudGVyZWRcbiAgICAgICAgKTtcbiAgICAgIGlmIChcbiAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGhyZWYgJiZcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIG9wdGlvbnMgJiZcbiAgICAgICAgbnVsbCAhPT0gb3B0aW9ucyAmJlxuICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy5hc1xuICAgICAgKSB7XG4gICAgICAgIGVuY291bnRlcmVkID0gb3B0aW9ucy5hcztcbiAgICAgICAgdmFyIGNyb3NzT3JpZ2luID0gZ2V0Q3Jvc3NPcmlnaW5TdHJpbmdBcyhcbiAgICAgICAgICBlbmNvdW50ZXJlZCxcbiAgICAgICAgICBvcHRpb25zLmNyb3NzT3JpZ2luXG4gICAgICAgICk7XG4gICAgICAgIEludGVybmFscy5kLkwoaHJlZiwgZW5jb3VudGVyZWQsIHtcbiAgICAgICAgICBjcm9zc09yaWdpbjogY3Jvc3NPcmlnaW4sXG4gICAgICAgICAgaW50ZWdyaXR5OlxuICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMuaW50ZWdyaXR5ID8gb3B0aW9ucy5pbnRlZ3JpdHkgOiB2b2lkIDAsXG4gICAgICAgICAgbm9uY2U6IFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLm5vbmNlID8gb3B0aW9ucy5ub25jZSA6IHZvaWQgMCxcbiAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy50eXBlID8gb3B0aW9ucy50eXBlIDogdm9pZCAwLFxuICAgICAgICAgIGZldGNoUHJpb3JpdHk6XG4gICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy5mZXRjaFByaW9yaXR5XG4gICAgICAgICAgICAgID8gb3B0aW9ucy5mZXRjaFByaW9yaXR5XG4gICAgICAgICAgICAgIDogdm9pZCAwLFxuICAgICAgICAgIHJlZmVycmVyUG9saWN5OlxuICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMucmVmZXJyZXJQb2xpY3lcbiAgICAgICAgICAgICAgPyBvcHRpb25zLnJlZmVycmVyUG9saWN5XG4gICAgICAgICAgICAgIDogdm9pZCAwLFxuICAgICAgICAgIGltYWdlU3JjU2V0OlxuICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMuaW1hZ2VTcmNTZXRcbiAgICAgICAgICAgICAgPyBvcHRpb25zLmltYWdlU3JjU2V0XG4gICAgICAgICAgICAgIDogdm9pZCAwLFxuICAgICAgICAgIGltYWdlU2l6ZXM6XG4gICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy5pbWFnZVNpemVzXG4gICAgICAgICAgICAgID8gb3B0aW9ucy5pbWFnZVNpemVzXG4gICAgICAgICAgICAgIDogdm9pZCAwLFxuICAgICAgICAgIG1lZGlhOiBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy5tZWRpYSA/IG9wdGlvbnMubWVkaWEgOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBleHBvcnRzLnByZWxvYWRNb2R1bGUgPSBmdW5jdGlvbiAoaHJlZiwgb3B0aW9ucykge1xuICAgICAgdmFyIGVuY291bnRlcmVkID0gXCJcIjtcbiAgICAgIChcInN0cmluZ1wiID09PSB0eXBlb2YgaHJlZiAmJiBocmVmKSB8fFxuICAgICAgICAoZW5jb3VudGVyZWQgKz1cbiAgICAgICAgICBcIiBUaGUgYGhyZWZgIGFyZ3VtZW50IGVuY291bnRlcmVkIHdhcyBcIiArXG4gICAgICAgICAgZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nT2JqZWN0Rm9yV2FybmluZyhocmVmKSArXG4gICAgICAgICAgXCIuXCIpO1xuICAgICAgdm9pZCAwICE9PSBvcHRpb25zICYmIFwib2JqZWN0XCIgIT09IHR5cGVvZiBvcHRpb25zXG4gICAgICAgID8gKGVuY291bnRlcmVkICs9XG4gICAgICAgICAgICBcIiBUaGUgYG9wdGlvbnNgIGFyZ3VtZW50IGVuY291bnRlcmVkIHdhcyBcIiArXG4gICAgICAgICAgICBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdPYmplY3RGb3JXYXJuaW5nKG9wdGlvbnMpICtcbiAgICAgICAgICAgIFwiLlwiKVxuICAgICAgICA6IG9wdGlvbnMgJiZcbiAgICAgICAgICBcImFzXCIgaW4gb3B0aW9ucyAmJlxuICAgICAgICAgIFwic3RyaW5nXCIgIT09IHR5cGVvZiBvcHRpb25zLmFzICYmXG4gICAgICAgICAgKGVuY291bnRlcmVkICs9XG4gICAgICAgICAgICBcIiBUaGUgYGFzYCBvcHRpb24gZW5jb3VudGVyZWQgd2FzIFwiICtcbiAgICAgICAgICAgIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ09iamVjdEZvcldhcm5pbmcob3B0aW9ucy5hcykgK1xuICAgICAgICAgICAgXCIuXCIpO1xuICAgICAgZW5jb3VudGVyZWQgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAnUmVhY3RET00ucHJlbG9hZE1vZHVsZSgpOiBFeHBlY3RlZCB0d28gYXJndW1lbnRzLCBhIG5vbi1lbXB0eSBgaHJlZmAgc3RyaW5nIGFuZCwgb3B0aW9uYWxseSwgYW4gYG9wdGlvbnNgIG9iamVjdCB3aXRoIGFuIGBhc2AgcHJvcGVydHkgdmFsaWQgZm9yIGEgYDxsaW5rIHJlbD1cIm1vZHVsZXByZWxvYWRcIiBhcz1cIi4uLlwiIC8+YCB0YWcuJXMnLFxuICAgICAgICAgIGVuY291bnRlcmVkXG4gICAgICAgICk7XG4gICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgaHJlZiAmJlxuICAgICAgICAob3B0aW9uc1xuICAgICAgICAgID8gKChlbmNvdW50ZXJlZCA9IGdldENyb3NzT3JpZ2luU3RyaW5nQXMoXG4gICAgICAgICAgICAgIG9wdGlvbnMuYXMsXG4gICAgICAgICAgICAgIG9wdGlvbnMuY3Jvc3NPcmlnaW5cbiAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgSW50ZXJuYWxzLmQubShocmVmLCB7XG4gICAgICAgICAgICAgIGFzOlxuICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLmFzICYmIFwic2NyaXB0XCIgIT09IG9wdGlvbnMuYXNcbiAgICAgICAgICAgICAgICAgID8gb3B0aW9ucy5hc1xuICAgICAgICAgICAgICAgICAgOiB2b2lkIDAsXG4gICAgICAgICAgICAgIGNyb3NzT3JpZ2luOiBlbmNvdW50ZXJlZCxcbiAgICAgICAgICAgICAgaW50ZWdyaXR5OlxuICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLmludGVncml0eVxuICAgICAgICAgICAgICAgICAgPyBvcHRpb25zLmludGVncml0eVxuICAgICAgICAgICAgICAgICAgOiB2b2lkIDBcbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgIDogSW50ZXJuYWxzLmQubShocmVmKSk7XG4gICAgfTtcbiAgICBleHBvcnRzLnJlcXVlc3RGb3JtUmVzZXQgPSBmdW5jdGlvbiAoZm9ybSkge1xuICAgICAgSW50ZXJuYWxzLmQucihmb3JtKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMgPSBmdW5jdGlvbiAoZm4sIGEpIHtcbiAgICAgIHJldHVybiBmbihhKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXNlRm9ybVN0YXRlID0gZnVuY3Rpb24gKGFjdGlvbiwgaW5pdGlhbFN0YXRlLCBwZXJtYWxpbmspIHtcbiAgICAgIHJldHVybiByZXNvbHZlRGlzcGF0Y2hlcigpLnVzZUZvcm1TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZSwgcGVybWFsaW5rKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXNlRm9ybVN0YXR1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiByZXNvbHZlRGlzcGF0Y2hlcigpLnVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzKCk7XG4gICAgfTtcbiAgICBleHBvcnRzLnZlcnNpb24gPSBcIjE5LjIuMFwiO1xuICAgIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gJiZcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RvcCAmJlxuICAgICAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wKEVycm9yKCkpO1xuICB9KSgpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-dom/cjs/react-dom.development.js\n\n}");

/***/ }),

/***/ "./node_modules/react-dom/index.js":
/*!*****************************************!*\
  !*** ./node_modules/react-dom/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("{\n\nfunction checkDCE() {\n  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n  if (\n    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||\n    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'\n  ) {\n    return;\n  }\n  if (true) {\n    // This branch is unreachable because this function is only called\n    // in production, but the condition is true only in development.\n    // Therefore if the branch is still here, dead code elimination wasn't\n    // properly applied.\n    // Don't change the message. React DevTools relies on it. Also make sure\n    // this message doesn't occur elsewhere in this function, or it will cause\n    // a false positive.\n    throw new Error('^_^');\n  }\n  // removed by dead control flow\n\n}\n\nif (false) // removed by dead control flow\n{} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-dom.development.js */ \"./node_modules/react-dom/cjs/react-dom.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFPQztBQUNIOztBQUVBLElBQUksS0FBcUMsRUFBRTtBQUFBLEVBSzFDLENBQUM7QUFDRixFQUFFLG1JQUEwRDtBQUM1RCIsInNvdXJjZXMiOlsid2VicGFjazovL1NTUi8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vaW5kZXguanM/OGJjOCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGNoZWNrRENFKCkge1xuICAvKiBnbG9iYWwgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICovXG4gIGlmIChcbiAgICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fID09PSAndW5kZWZpbmVkJyB8fFxuICAgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uY2hlY2tEQ0UgIT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gVGhpcyBicmFuY2ggaXMgdW5yZWFjaGFibGUgYmVjYXVzZSB0aGlzIGZ1bmN0aW9uIGlzIG9ubHkgY2FsbGVkXG4gICAgLy8gaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBjb25kaXRpb24gaXMgdHJ1ZSBvbmx5IGluIGRldmVsb3BtZW50LlxuICAgIC8vIFRoZXJlZm9yZSBpZiB0aGUgYnJhbmNoIGlzIHN0aWxsIGhlcmUsIGRlYWQgY29kZSBlbGltaW5hdGlvbiB3YXNuJ3RcbiAgICAvLyBwcm9wZXJseSBhcHBsaWVkLlxuICAgIC8vIERvbid0IGNoYW5nZSB0aGUgbWVzc2FnZS4gUmVhY3QgRGV2VG9vbHMgcmVsaWVzIG9uIGl0LiBBbHNvIG1ha2Ugc3VyZVxuICAgIC8vIHRoaXMgbWVzc2FnZSBkb2Vzbid0IG9jY3VyIGVsc2V3aGVyZSBpbiB0aGlzIGZ1bmN0aW9uLCBvciBpdCB3aWxsIGNhdXNlXG4gICAgLy8gYSBmYWxzZSBwb3NpdGl2ZS5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ15fXicpO1xuICB9XG4gIHRyeSB7XG4gICAgLy8gVmVyaWZ5IHRoYXQgdGhlIGNvZGUgYWJvdmUgaGFzIGJlZW4gZGVhZCBjb2RlIGVsaW1pbmF0ZWQgKERDRSdkKS5cbiAgICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uY2hlY2tEQ0UoY2hlY2tEQ0UpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBEZXZUb29scyBzaG91bGRuJ3QgY3Jhc2ggUmVhY3QsIG5vIG1hdHRlciB3aGF0LlxuICAgIC8vIFdlIHNob3VsZCBzdGlsbCByZXBvcnQgaW4gY2FzZSB3ZSBicmVhayB0aGlzIGNvZGUuXG4gICAgY29uc29sZS5lcnJvcihlcnIpO1xuICB9XG59XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIC8vIERDRSBjaGVjayBzaG91bGQgaGFwcGVuIGJlZm9yZSBSZWFjdERPTSBidW5kbGUgZXhlY3V0ZXMgc28gdGhhdFxuICAvLyBEZXZUb29scyBjYW4gcmVwb3J0IGJhZCBtaW5pZmljYXRpb24gZHVyaW5nIGluamVjdGlvbi5cbiAgY2hlY2tEQ0UoKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1kb20ucHJvZHVjdGlvbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1kb20uZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-dom/index.js\n\n}");

/***/ }),

/***/ "./node_modules/react-dom/server.browser.js":
/*!**************************************************!*\
  !*** ./node_modules/react-dom/server.browser.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\n\nvar l, s;\nif (false) // removed by dead control flow\n{} else {\n  l = __webpack_require__(/*! ./cjs/react-dom-server-legacy.browser.development.js */ \"./node_modules/react-dom/cjs/react-dom-server-legacy.browser.development.js\");\n  s = __webpack_require__(/*! ./cjs/react-dom-server.browser.development.js */ \"./node_modules/react-dom/cjs/react-dom-server.browser.development.js\");\n}\n\nexports.version = l.version;\nexports.renderToString = l.renderToString;\nexports.renderToStaticMarkup = l.renderToStaticMarkup;\nexports.renderToReadableStream = s.renderToReadableStream;\nexports.resume = s.resume;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL3NlcnZlci5icm93c2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0EsSUFBSSxLQUFxQyxFQUFFO0FBQUEsRUFHMUMsQ0FBQztBQUNGLE1BQU0sbUJBQU8sQ0FBQyx5SUFBc0Q7QUFDcEUsTUFBTSxtQkFBTyxDQUFDLDJIQUErQztBQUM3RDs7QUFFQSxlQUFlO0FBQ2Ysc0JBQXNCO0FBQ3RCLDRCQUE0QjtBQUM1Qiw4QkFBOEI7QUFDOUIsY0FBYyIsInNvdXJjZXMiOlsid2VicGFjazovL1NTUi8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vc2VydmVyLmJyb3dzZXIuanM/MjgwYyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBsLCBzO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbCA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWRvbS1zZXJ2ZXItbGVnYWN5LmJyb3dzZXIucHJvZHVjdGlvbi5qcycpO1xuICBzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtZG9tLXNlcnZlci5icm93c2VyLnByb2R1Y3Rpb24uanMnKTtcbn0gZWxzZSB7XG4gIGwgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1kb20tc2VydmVyLWxlZ2FjeS5icm93c2VyLmRldmVsb3BtZW50LmpzJyk7XG4gIHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1kb20tc2VydmVyLmJyb3dzZXIuZGV2ZWxvcG1lbnQuanMnKTtcbn1cblxuZXhwb3J0cy52ZXJzaW9uID0gbC52ZXJzaW9uO1xuZXhwb3J0cy5yZW5kZXJUb1N0cmluZyA9IGwucmVuZGVyVG9TdHJpbmc7XG5leHBvcnRzLnJlbmRlclRvU3RhdGljTWFya3VwID0gbC5yZW5kZXJUb1N0YXRpY01hcmt1cDtcbmV4cG9ydHMucmVuZGVyVG9SZWFkYWJsZVN0cmVhbSA9IHMucmVuZGVyVG9SZWFkYWJsZVN0cmVhbTtcbmV4cG9ydHMucmVzdW1lID0gcy5yZXN1bWU7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-dom/server.browser.js\n\n}");

/***/ }),

/***/ "./node_modules/react/cjs/react-jsx-runtime.development.js":
/*!*****************************************************************!*\
  !*** ./node_modules/react/cjs/react-jsx-runtime.development.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{/**\n * @license React\n * react-jsx-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  (function () {\n    function getComponentNameFromType(type) {\n      if (null == type) return null;\n      if (\"function\" === typeof type)\n        return type.$$typeof === REACT_CLIENT_REFERENCE\n          ? null\n          : type.displayName || type.name || null;\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return \"Fragment\";\n        case REACT_PROFILER_TYPE:\n          return \"Profiler\";\n        case REACT_STRICT_MODE_TYPE:\n          return \"StrictMode\";\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n        case REACT_ACTIVITY_TYPE:\n          return \"Activity\";\n      }\n      if (\"object\" === typeof type)\n        switch (\n          (\"number\" === typeof type.tag &&\n            console.error(\n              \"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"\n            ),\n          type.$$typeof)\n        ) {\n          case REACT_PORTAL_TYPE:\n            return \"Portal\";\n          case REACT_CONTEXT_TYPE:\n            return type.displayName || \"Context\";\n          case REACT_CONSUMER_TYPE:\n            return (type._context.displayName || \"Context\") + \".Consumer\";\n          case REACT_FORWARD_REF_TYPE:\n            var innerType = type.render;\n            type = type.displayName;\n            type ||\n              ((type = innerType.displayName || innerType.name || \"\"),\n              (type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\"));\n            return type;\n          case REACT_MEMO_TYPE:\n            return (\n              (innerType = type.displayName || null),\n              null !== innerType\n                ? innerType\n                : getComponentNameFromType(type.type) || \"Memo\"\n            );\n          case REACT_LAZY_TYPE:\n            innerType = type._payload;\n            type = type._init;\n            try {\n              return getComponentNameFromType(type(innerType));\n            } catch (x) {}\n        }\n      return null;\n    }\n    function testStringCoercion(value) {\n      return \"\" + value;\n    }\n    function checkKeyStringCoercion(value) {\n      try {\n        testStringCoercion(value);\n        var JSCompiler_inline_result = !1;\n      } catch (e) {\n        JSCompiler_inline_result = !0;\n      }\n      if (JSCompiler_inline_result) {\n        JSCompiler_inline_result = console;\n        var JSCompiler_temp_const = JSCompiler_inline_result.error;\n        var JSCompiler_inline_result$jscomp$0 =\n          (\"function\" === typeof Symbol &&\n            Symbol.toStringTag &&\n            value[Symbol.toStringTag]) ||\n          value.constructor.name ||\n          \"Object\";\n        JSCompiler_temp_const.call(\n          JSCompiler_inline_result,\n          \"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\",\n          JSCompiler_inline_result$jscomp$0\n        );\n        return testStringCoercion(value);\n      }\n    }\n    function getTaskName(type) {\n      if (type === REACT_FRAGMENT_TYPE) return \"<>\";\n      if (\n        \"object\" === typeof type &&\n        null !== type &&\n        type.$$typeof === REACT_LAZY_TYPE\n      )\n        return \"<...>\";\n      try {\n        var name = getComponentNameFromType(type);\n        return name ? \"<\" + name + \">\" : \"<...>\";\n      } catch (x) {\n        return \"<...>\";\n      }\n    }\n    function getOwner() {\n      var dispatcher = ReactSharedInternals.A;\n      return null === dispatcher ? null : dispatcher.getOwner();\n    }\n    function UnknownOwner() {\n      return Error(\"react-stack-top-frame\");\n    }\n    function hasValidKey(config) {\n      if (hasOwnProperty.call(config, \"key\")) {\n        var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n        if (getter && getter.isReactWarning) return !1;\n      }\n      return void 0 !== config.key;\n    }\n    function defineKeyPropWarningGetter(props, displayName) {\n      function warnAboutAccessingKey() {\n        specialPropKeyWarningShown ||\n          ((specialPropKeyWarningShown = !0),\n          console.error(\n            \"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)\",\n            displayName\n          ));\n      }\n      warnAboutAccessingKey.isReactWarning = !0;\n      Object.defineProperty(props, \"key\", {\n        get: warnAboutAccessingKey,\n        configurable: !0\n      });\n    }\n    function elementRefGetterWithDeprecationWarning() {\n      var componentName = getComponentNameFromType(this.type);\n      didWarnAboutElementRef[componentName] ||\n        ((didWarnAboutElementRef[componentName] = !0),\n        console.error(\n          \"Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release.\"\n        ));\n      componentName = this.props.ref;\n      return void 0 !== componentName ? componentName : null;\n    }\n    function ReactElement(type, key, props, owner, debugStack, debugTask) {\n      var refProp = props.ref;\n      type = {\n        $$typeof: REACT_ELEMENT_TYPE,\n        type: type,\n        key: key,\n        props: props,\n        _owner: owner\n      };\n      null !== (void 0 !== refProp ? refProp : null)\n        ? Object.defineProperty(type, \"ref\", {\n            enumerable: !1,\n            get: elementRefGetterWithDeprecationWarning\n          })\n        : Object.defineProperty(type, \"ref\", { enumerable: !1, value: null });\n      type._store = {};\n      Object.defineProperty(type._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: 0\n      });\n      Object.defineProperty(type, \"_debugInfo\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: null\n      });\n      Object.defineProperty(type, \"_debugStack\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugStack\n      });\n      Object.defineProperty(type, \"_debugTask\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugTask\n      });\n      Object.freeze && (Object.freeze(type.props), Object.freeze(type));\n      return type;\n    }\n    function jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      debugStack,\n      debugTask\n    ) {\n      var children = config.children;\n      if (void 0 !== children)\n        if (isStaticChildren)\n          if (isArrayImpl(children)) {\n            for (\n              isStaticChildren = 0;\n              isStaticChildren < children.length;\n              isStaticChildren++\n            )\n              validateChildKeys(children[isStaticChildren]);\n            Object.freeze && Object.freeze(children);\n          } else\n            console.error(\n              \"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\"\n            );\n        else validateChildKeys(children);\n      if (hasOwnProperty.call(config, \"key\")) {\n        children = getComponentNameFromType(type);\n        var keys = Object.keys(config).filter(function (k) {\n          return \"key\" !== k;\n        });\n        isStaticChildren =\n          0 < keys.length\n            ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\"\n            : \"{key: someKey}\";\n        didWarnAboutKeySpread[children + isStaticChildren] ||\n          ((keys =\n            0 < keys.length ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\"),\n          console.error(\n            'A props object containing a \"key\" prop is being spread into JSX:\\n  let props = %s;\\n  <%s {...props} />\\nReact keys must be passed directly to JSX without using spread:\\n  let props = %s;\\n  <%s key={someKey} {...props} />',\n            isStaticChildren,\n            children,\n            keys,\n            children\n          ),\n          (didWarnAboutKeySpread[children + isStaticChildren] = !0));\n      }\n      children = null;\n      void 0 !== maybeKey &&\n        (checkKeyStringCoercion(maybeKey), (children = \"\" + maybeKey));\n      hasValidKey(config) &&\n        (checkKeyStringCoercion(config.key), (children = \"\" + config.key));\n      if (\"key\" in config) {\n        maybeKey = {};\n        for (var propName in config)\n          \"key\" !== propName && (maybeKey[propName] = config[propName]);\n      } else maybeKey = config;\n      children &&\n        defineKeyPropWarningGetter(\n          maybeKey,\n          \"function\" === typeof type\n            ? type.displayName || type.name || \"Unknown\"\n            : type\n        );\n      return ReactElement(\n        type,\n        children,\n        maybeKey,\n        getOwner(),\n        debugStack,\n        debugTask\n      );\n    }\n    function validateChildKeys(node) {\n      isValidElement(node)\n        ? node._store && (node._store.validated = 1)\n        : \"object\" === typeof node &&\n          null !== node &&\n          node.$$typeof === REACT_LAZY_TYPE &&\n          (\"fulfilled\" === node._payload.status\n            ? isValidElement(node._payload.value) &&\n              node._payload.value._store &&\n              (node._payload.value._store.validated = 1)\n            : node._store && (node._store.validated = 1));\n    }\n    function isValidElement(object) {\n      return (\n        \"object\" === typeof object &&\n        null !== object &&\n        object.$$typeof === REACT_ELEMENT_TYPE\n      );\n    }\n    var React = __webpack_require__(/*! react */ \"./node_modules/react/index.js\"),\n      REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n      REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n      REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\n      REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\n      REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\"),\n      REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\n      REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\n      REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\n      REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\n      REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"),\n      REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\n      REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\n      REACT_ACTIVITY_TYPE = Symbol.for(\"react.activity\"),\n      REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n      ReactSharedInternals =\n        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      isArrayImpl = Array.isArray,\n      createTask = console.createTask\n        ? console.createTask\n        : function () {\n            return null;\n          };\n    React = {\n      react_stack_bottom_frame: function (callStackForError) {\n        return callStackForError();\n      }\n    };\n    var specialPropKeyWarningShown;\n    var didWarnAboutElementRef = {};\n    var unknownOwnerDebugStack = React.react_stack_bottom_frame.bind(\n      React,\n      UnknownOwner\n    )();\n    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));\n    var didWarnAboutKeySpread = {};\n    exports.Fragment = REACT_FRAGMENT_TYPE;\n    exports.jsx = function (type, config, maybeKey) {\n      var trackActualOwner =\n        1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;\n      return jsxDEVImpl(\n        type,\n        config,\n        maybeKey,\n        !1,\n        trackActualOwner\n          ? Error(\"react-stack-top-frame\")\n          : unknownOwnerDebugStack,\n        trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask\n      );\n    };\n    exports.jsxs = function (type, config, maybeKey) {\n      var trackActualOwner =\n        1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;\n      return jsxDEVImpl(\n        type,\n        config,\n        maybeKey,\n        !0,\n        trackActualOwner\n          ? Error(\"react-stack-top-frame\")\n          : unknownOwnerDebugStack,\n        trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask\n      );\n    };\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LWpzeC1ydW50aW1lLmRldmVsb3BtZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTtBQUNiLEtBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLCtDQUErQyw2QkFBNkI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGdCQUFnQixnREFBZ0Q7QUFDaEUsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBLGdDQUFnQyxrQ0FBa0MsT0FBTztBQUN6RTtBQUNBLGdHQUFnRyxTQUFTLFVBQVUsc0ZBQXNGLGFBQWEsVUFBVSxVQUFVO0FBQzFPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyw0Q0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdCQUFnQjtBQUNwQixJQUFJLFdBQVc7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksWUFBWTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TU1IvLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LWpzeC1ydW50aW1lLmRldmVsb3BtZW50LmpzP2JiMTkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtanN4LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgICAgIGlmIChudWxsID09IHR5cGUpIHJldHVybiBudWxsO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHJldHVybiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFXG4gICAgICAgICAgPyBudWxsXG4gICAgICAgICAgOiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlKSByZXR1cm4gdHlwZTtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiRnJhZ21lbnRcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlByb2ZpbGVyXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdHJpY3RNb2RlXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZVwiO1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZUxpc3RcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9BQ1RJVklUWV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIkFjdGl2aXR5XCI7XG4gICAgICB9XG4gICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHN3aXRjaCAoXG4gICAgICAgICAgKFwibnVtYmVyXCIgPT09IHR5cGVvZiB0eXBlLnRhZyAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoKS4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgICApLFxuICAgICAgICAgIHR5cGUuJCR0eXBlb2YpXG4gICAgICAgICkge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gXCJQb3J0YWxcIjtcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IFwiQ29udGV4dFwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OU1VNRVJfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZS5fY29udGV4dC5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Db25zdW1lclwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgIHZhciBpbm5lclR5cGUgPSB0eXBlLnJlbmRlcjtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lO1xuICAgICAgICAgICAgdHlwZSB8fFxuICAgICAgICAgICAgICAoKHR5cGUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgXCJcIiksXG4gICAgICAgICAgICAgICh0eXBlID0gXCJcIiAhPT0gdHlwZSA/IFwiRm9yd2FyZFJlZihcIiArIHR5cGUgKyBcIilcIiA6IFwiRm9yd2FyZFJlZlwiKSk7XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChpbm5lclR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGwpLFxuICAgICAgICAgICAgICBudWxsICE9PSBpbm5lclR5cGVcbiAgICAgICAgICAgICAgICA/IGlubmVyVHlwZVxuICAgICAgICAgICAgICAgIDogZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgXCJNZW1vXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICBpbm5lclR5cGUgPSB0eXBlLl9wYXlsb2FkO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUoaW5uZXJUeXBlKSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gXCJcIiArIHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITE7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICEwO1xuICAgICAgfVxuICAgICAgaWYgKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCkge1xuICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSBjb25zb2xlO1xuICAgICAgICB2YXIgSlNDb21waWxlcl90ZW1wX2NvbnN0ID0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LmVycm9yO1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwID1cbiAgICAgICAgICAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgU3ltYm9sICYmXG4gICAgICAgICAgICBTeW1ib2wudG9TdHJpbmdUYWcgJiZcbiAgICAgICAgICAgIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10pIHx8XG4gICAgICAgICAgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fFxuICAgICAgICAgIFwiT2JqZWN0XCI7XG4gICAgICAgIEpTQ29tcGlsZXJfdGVtcF9jb25zdC5jYWxsKFxuICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCxcbiAgICAgICAgICBcIlRoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4gVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIHVzaW5nIGl0IGhlcmUuXCIsXG4gICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRUYXNrTmFtZSh0eXBlKSB7XG4gICAgICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkgcmV0dXJuIFwiPD5cIjtcbiAgICAgIGlmIChcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUgJiZcbiAgICAgICAgbnVsbCAhPT0gdHlwZSAmJlxuICAgICAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEVcbiAgICAgIClcbiAgICAgICAgcmV0dXJuIFwiPC4uLj5cIjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgICByZXR1cm4gbmFtZSA/IFwiPFwiICsgbmFtZSArIFwiPlwiIDogXCI8Li4uPlwiO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICByZXR1cm4gXCI8Li4uPlwiO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRPd25lcigpIHtcbiAgICAgIHZhciBkaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuQTtcbiAgICAgIHJldHVybiBudWxsID09PSBkaXNwYXRjaGVyID8gbnVsbCA6IGRpc3BhdGNoZXIuZ2V0T3duZXIoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVW5rbm93bk93bmVyKCkge1xuICAgICAgcmV0dXJuIEVycm9yKFwicmVhY3Qtc3RhY2stdG9wLWZyYW1lXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgXCJrZXlcIikpIHtcbiAgICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCBcImtleVwiKS5nZXQ7XG4gICAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm9pZCAwICE9PSBjb25maWcua2V5O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgICAgIGZ1bmN0aW9uIHdhcm5BYm91dEFjY2Vzc2luZ0tleSgpIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gfHxcbiAgICAgICAgICAoKHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gITApLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgdmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCBwcm9wLiAoaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9zcGVjaWFsLXByb3BzKVwiLFxuICAgICAgICAgICAgZGlzcGxheU5hbWVcbiAgICAgICAgICApKTtcbiAgICAgIH1cbiAgICAgIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9ICEwO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCBcImtleVwiLCB7XG4gICAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZWxlbWVudFJlZkdldHRlcldpdGhEZXByZWNhdGlvbldhcm5pbmcoKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0aGlzLnR5cGUpO1xuICAgICAgZGlkV2FybkFib3V0RWxlbWVudFJlZltjb21wb25lbnROYW1lXSB8fFxuICAgICAgICAoKGRpZFdhcm5BYm91dEVsZW1lbnRSZWZbY29tcG9uZW50TmFtZV0gPSAhMCksXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJBY2Nlc3NpbmcgZWxlbWVudC5yZWYgd2FzIHJlbW92ZWQgaW4gUmVhY3QgMTkuIHJlZiBpcyBub3cgYSByZWd1bGFyIHByb3AuIEl0IHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBKU1ggRWxlbWVudCB0eXBlIGluIGEgZnV0dXJlIHJlbGVhc2UuXCJcbiAgICAgICAgKSk7XG4gICAgICBjb21wb25lbnROYW1lID0gdGhpcy5wcm9wcy5yZWY7XG4gICAgICByZXR1cm4gdm9pZCAwICE9PSBjb21wb25lbnROYW1lID8gY29tcG9uZW50TmFtZSA6IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHByb3BzLCBvd25lciwgZGVidWdTdGFjaywgZGVidWdUYXNrKSB7XG4gICAgICB2YXIgcmVmUHJvcCA9IHByb3BzLnJlZjtcbiAgICAgIHR5cGUgPSB7XG4gICAgICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIGtleToga2V5LFxuICAgICAgICBwcm9wczogcHJvcHMsXG4gICAgICAgIF9vd25lcjogb3duZXJcbiAgICAgIH07XG4gICAgICBudWxsICE9PSAodm9pZCAwICE9PSByZWZQcm9wID8gcmVmUHJvcCA6IG51bGwpXG4gICAgICAgID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwicmVmXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICAgICAgZ2V0OiBlbGVtZW50UmVmR2V0dGVyV2l0aERlcHJlY2F0aW9uV2FybmluZ1xuICAgICAgICAgIH0pXG4gICAgICAgIDogT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwicmVmXCIsIHsgZW51bWVyYWJsZTogITEsIHZhbHVlOiBudWxsIH0pO1xuICAgICAgdHlwZS5fc3RvcmUgPSB7fTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLl9zdG9yZSwgXCJ2YWxpZGF0ZWRcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICB2YWx1ZTogMFxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJfZGVidWdJbmZvXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwiX2RlYnVnU3RhY2tcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICB2YWx1ZTogZGVidWdTdGFja1xuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJfZGVidWdUYXNrXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6IGRlYnVnVGFza1xuICAgICAgfSk7XG4gICAgICBPYmplY3QuZnJlZXplICYmIChPYmplY3QuZnJlZXplKHR5cGUucHJvcHMpLCBPYmplY3QuZnJlZXplKHR5cGUpKTtcbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBqc3hERVZJbXBsKFxuICAgICAgdHlwZSxcbiAgICAgIGNvbmZpZyxcbiAgICAgIG1heWJlS2V5LFxuICAgICAgaXNTdGF0aWNDaGlsZHJlbixcbiAgICAgIGRlYnVnU3RhY2ssXG4gICAgICBkZWJ1Z1Rhc2tcbiAgICApIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IGNvbmZpZy5jaGlsZHJlbjtcbiAgICAgIGlmICh2b2lkIDAgIT09IGNoaWxkcmVuKVxuICAgICAgICBpZiAoaXNTdGF0aWNDaGlsZHJlbilcbiAgICAgICAgICBpZiAoaXNBcnJheUltcGwoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuID0gMDtcbiAgICAgICAgICAgICAgaXNTdGF0aWNDaGlsZHJlbiA8IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgICAgaXNTdGF0aWNDaGlsZHJlbisrXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuW2lzU3RhdGljQ2hpbGRyZW5dKTtcbiAgICAgICAgICAgIE9iamVjdC5mcmVlemUgJiYgT2JqZWN0LmZyZWV6ZShjaGlsZHJlbik7XG4gICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlJlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuIFlvdSBhcmUgbGlrZWx5IGV4cGxpY2l0bHkgY2FsbGluZyBSZWFjdC5qc3hzIG9yIFJlYWN0LmpzeERFVi4gVXNlIHRoZSBCYWJlbCB0cmFuc2Zvcm0gaW5zdGVhZC5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgZWxzZSB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbik7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIFwia2V5XCIpKSB7XG4gICAgICAgIGNoaWxkcmVuID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGNvbmZpZykuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgcmV0dXJuIFwia2V5XCIgIT09IGs7XG4gICAgICAgIH0pO1xuICAgICAgICBpc1N0YXRpY0NoaWxkcmVuID1cbiAgICAgICAgICAwIDwga2V5cy5sZW5ndGhcbiAgICAgICAgICAgID8gXCJ7a2V5OiBzb21lS2V5LCBcIiArIGtleXMuam9pbihcIjogLi4uLCBcIikgKyBcIjogLi4ufVwiXG4gICAgICAgICAgICA6IFwie2tleTogc29tZUtleX1cIjtcbiAgICAgICAgZGlkV2FybkFib3V0S2V5U3ByZWFkW2NoaWxkcmVuICsgaXNTdGF0aWNDaGlsZHJlbl0gfHxcbiAgICAgICAgICAoKGtleXMgPVxuICAgICAgICAgICAgMCA8IGtleXMubGVuZ3RoID8gXCJ7XCIgKyBrZXlzLmpvaW4oXCI6IC4uLiwgXCIpICsgXCI6IC4uLn1cIiA6IFwie31cIiksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICdBIHByb3BzIG9iamVjdCBjb250YWluaW5nIGEgXCJrZXlcIiBwcm9wIGlzIGJlaW5nIHNwcmVhZCBpbnRvIEpTWDpcXG4gIGxldCBwcm9wcyA9ICVzO1xcbiAgPCVzIHsuLi5wcm9wc30gLz5cXG5SZWFjdCBrZXlzIG11c3QgYmUgcGFzc2VkIGRpcmVjdGx5IHRvIEpTWCB3aXRob3V0IHVzaW5nIHNwcmVhZDpcXG4gIGxldCBwcm9wcyA9ICVzO1xcbiAgPCVzIGtleT17c29tZUtleX0gey4uLnByb3BzfSAvPicsXG4gICAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuLFxuICAgICAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgICAgICBrZXlzLFxuICAgICAgICAgICAgY2hpbGRyZW5cbiAgICAgICAgICApLFxuICAgICAgICAgIChkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY2hpbGRyZW4gKyBpc1N0YXRpY0NoaWxkcmVuXSA9ICEwKSk7XG4gICAgICB9XG4gICAgICBjaGlsZHJlbiA9IG51bGw7XG4gICAgICB2b2lkIDAgIT09IG1heWJlS2V5ICYmXG4gICAgICAgIChjaGVja0tleVN0cmluZ0NvZXJjaW9uKG1heWJlS2V5KSwgKGNoaWxkcmVuID0gXCJcIiArIG1heWJlS2V5KSk7XG4gICAgICBoYXNWYWxpZEtleShjb25maWcpICYmXG4gICAgICAgIChjaGVja0tleVN0cmluZ0NvZXJjaW9uKGNvbmZpZy5rZXkpLCAoY2hpbGRyZW4gPSBcIlwiICsgY29uZmlnLmtleSkpO1xuICAgICAgaWYgKFwia2V5XCIgaW4gY29uZmlnKSB7XG4gICAgICAgIG1heWJlS2V5ID0ge307XG4gICAgICAgIGZvciAodmFyIHByb3BOYW1lIGluIGNvbmZpZylcbiAgICAgICAgICBcImtleVwiICE9PSBwcm9wTmFtZSAmJiAobWF5YmVLZXlbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXSk7XG4gICAgICB9IGVsc2UgbWF5YmVLZXkgPSBjb25maWc7XG4gICAgICBjaGlsZHJlbiAmJlxuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihcbiAgICAgICAgICBtYXliZUtleSxcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlXG4gICAgICAgICAgICA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IFwiVW5rbm93blwiXG4gICAgICAgICAgICA6IHR5cGVcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiBSZWFjdEVsZW1lbnQoXG4gICAgICAgIHR5cGUsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICBtYXliZUtleSxcbiAgICAgICAgZ2V0T3duZXIoKSxcbiAgICAgICAgZGVidWdTdGFjayxcbiAgICAgICAgZGVidWdUYXNrXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlKSB7XG4gICAgICBpc1ZhbGlkRWxlbWVudChub2RlKVxuICAgICAgICA/IG5vZGUuX3N0b3JlICYmIChub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSAxKVxuICAgICAgICA6IFwib2JqZWN0XCIgPT09IHR5cGVvZiBub2RlICYmXG4gICAgICAgICAgbnVsbCAhPT0gbm9kZSAmJlxuICAgICAgICAgIG5vZGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSAmJlxuICAgICAgICAgIChcImZ1bGZpbGxlZFwiID09PSBub2RlLl9wYXlsb2FkLnN0YXR1c1xuICAgICAgICAgICAgPyBpc1ZhbGlkRWxlbWVudChub2RlLl9wYXlsb2FkLnZhbHVlKSAmJlxuICAgICAgICAgICAgICBub2RlLl9wYXlsb2FkLnZhbHVlLl9zdG9yZSAmJlxuICAgICAgICAgICAgICAobm9kZS5fcGF5bG9hZC52YWx1ZS5fc3RvcmUudmFsaWRhdGVkID0gMSlcbiAgICAgICAgICAgIDogbm9kZS5fc3RvcmUgJiYgKG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IDEpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2Ygb2JqZWN0ICYmXG4gICAgICAgIG51bGwgIT09IG9iamVjdCAmJlxuICAgICAgICBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRVxuICAgICAgKTtcbiAgICB9XG4gICAgdmFyIFJlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpLFxuICAgICAgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnRyYW5zaXRpb25hbC5lbGVtZW50XCIpLFxuICAgICAgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpLFxuICAgICAgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSxcbiAgICAgIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIiksXG4gICAgICBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnByb2ZpbGVyXCIpLFxuICAgICAgUkVBQ1RfQ09OU1VNRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb25zdW1lclwiKSxcbiAgICAgIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpLFxuICAgICAgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKSxcbiAgICAgIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIiksXG4gICAgICBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VfbGlzdFwiKSxcbiAgICAgIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vXCIpLFxuICAgICAgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmxhenlcIiksXG4gICAgICBSRUFDVF9BQ1RJVklUWV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmFjdGl2aXR5XCIpLFxuICAgICAgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jbGllbnQucmVmZXJlbmNlXCIpLFxuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPVxuICAgICAgICBSZWFjdC5fX0NMSUVOVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREUsXG4gICAgICBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksXG4gICAgICBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXksXG4gICAgICBjcmVhdGVUYXNrID0gY29uc29sZS5jcmVhdGVUYXNrXG4gICAgICAgID8gY29uc29sZS5jcmVhdGVUYXNrXG4gICAgICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfTtcbiAgICBSZWFjdCA9IHtcbiAgICAgIHJlYWN0X3N0YWNrX2JvdHRvbV9mcmFtZTogZnVuY3Rpb24gKGNhbGxTdGFja0ZvckVycm9yKSB7XG4gICAgICAgIHJldHVybiBjYWxsU3RhY2tGb3JFcnJvcigpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xuICAgIHZhciBkaWRXYXJuQWJvdXRFbGVtZW50UmVmID0ge307XG4gICAgdmFyIHVua25vd25Pd25lckRlYnVnU3RhY2sgPSBSZWFjdC5yZWFjdF9zdGFja19ib3R0b21fZnJhbWUuYmluZChcbiAgICAgIFJlYWN0LFxuICAgICAgVW5rbm93bk93bmVyXG4gICAgKSgpO1xuICAgIHZhciB1bmtub3duT3duZXJEZWJ1Z1Rhc2sgPSBjcmVhdGVUYXNrKGdldFRhc2tOYW1lKFVua25vd25Pd25lcikpO1xuICAgIHZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbiAgICBleHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbiAgICBleHBvcnRzLmpzeCA9IGZ1bmN0aW9uICh0eXBlLCBjb25maWcsIG1heWJlS2V5KSB7XG4gICAgICB2YXIgdHJhY2tBY3R1YWxPd25lciA9XG4gICAgICAgIDFlNCA+IFJlYWN0U2hhcmVkSW50ZXJuYWxzLnJlY2VudGx5Q3JlYXRlZE93bmVyU3RhY2tzKys7XG4gICAgICByZXR1cm4ganN4REVWSW1wbChcbiAgICAgICAgdHlwZSxcbiAgICAgICAgY29uZmlnLFxuICAgICAgICBtYXliZUtleSxcbiAgICAgICAgITEsXG4gICAgICAgIHRyYWNrQWN0dWFsT3duZXJcbiAgICAgICAgICA/IEVycm9yKFwicmVhY3Qtc3RhY2stdG9wLWZyYW1lXCIpXG4gICAgICAgICAgOiB1bmtub3duT3duZXJEZWJ1Z1N0YWNrLFxuICAgICAgICB0cmFja0FjdHVhbE93bmVyID8gY3JlYXRlVGFzayhnZXRUYXNrTmFtZSh0eXBlKSkgOiB1bmtub3duT3duZXJEZWJ1Z1Rhc2tcbiAgICAgICk7XG4gICAgfTtcbiAgICBleHBvcnRzLmpzeHMgPSBmdW5jdGlvbiAodHlwZSwgY29uZmlnLCBtYXliZUtleSkge1xuICAgICAgdmFyIHRyYWNrQWN0dWFsT3duZXIgPVxuICAgICAgICAxZTQgPiBSZWFjdFNoYXJlZEludGVybmFscy5yZWNlbnRseUNyZWF0ZWRPd25lclN0YWNrcysrO1xuICAgICAgcmV0dXJuIGpzeERFVkltcGwoXG4gICAgICAgIHR5cGUsXG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgbWF5YmVLZXksXG4gICAgICAgICEwLFxuICAgICAgICB0cmFja0FjdHVhbE93bmVyXG4gICAgICAgICAgPyBFcnJvcihcInJlYWN0LXN0YWNrLXRvcC1mcmFtZVwiKVxuICAgICAgICAgIDogdW5rbm93bk93bmVyRGVidWdTdGFjayxcbiAgICAgICAgdHJhY2tBY3R1YWxPd25lciA/IGNyZWF0ZVRhc2soZ2V0VGFza05hbWUodHlwZSkpIDogdW5rbm93bk93bmVyRGVidWdUYXNrXG4gICAgICApO1xuICAgIH07XG4gIH0pKCk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react/cjs/react-jsx-runtime.development.js\n\n}");

/***/ }),

/***/ "./node_modules/react/cjs/react.development.js":
/*!*****************************************************!*\
  !*** ./node_modules/react/cjs/react.development.js ***!
  \*****************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("{/* module decorator */ module = __webpack_require__.nmd(module);\n/**\n * @license React\n * react.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  (function () {\n    function defineDeprecationWarning(methodName, info) {\n      Object.defineProperty(Component.prototype, methodName, {\n        get: function () {\n          console.warn(\n            \"%s(...) is deprecated in plain JavaScript React classes. %s\",\n            info[0],\n            info[1]\n          );\n        }\n      });\n    }\n    function getIteratorFn(maybeIterable) {\n      if (null === maybeIterable || \"object\" !== typeof maybeIterable)\n        return null;\n      maybeIterable =\n        (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||\n        maybeIterable[\"@@iterator\"];\n      return \"function\" === typeof maybeIterable ? maybeIterable : null;\n    }\n    function warnNoop(publicInstance, callerName) {\n      publicInstance =\n        ((publicInstance = publicInstance.constructor) &&\n          (publicInstance.displayName || publicInstance.name)) ||\n        \"ReactClass\";\n      var warningKey = publicInstance + \".\" + callerName;\n      didWarnStateUpdateForUnmountedComponent[warningKey] ||\n        (console.error(\n          \"Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.\",\n          callerName,\n          publicInstance\n        ),\n        (didWarnStateUpdateForUnmountedComponent[warningKey] = !0));\n    }\n    function Component(props, context, updater) {\n      this.props = props;\n      this.context = context;\n      this.refs = emptyObject;\n      this.updater = updater || ReactNoopUpdateQueue;\n    }\n    function ComponentDummy() {}\n    function PureComponent(props, context, updater) {\n      this.props = props;\n      this.context = context;\n      this.refs = emptyObject;\n      this.updater = updater || ReactNoopUpdateQueue;\n    }\n    function noop() {}\n    function testStringCoercion(value) {\n      return \"\" + value;\n    }\n    function checkKeyStringCoercion(value) {\n      try {\n        testStringCoercion(value);\n        var JSCompiler_inline_result = !1;\n      } catch (e) {\n        JSCompiler_inline_result = !0;\n      }\n      if (JSCompiler_inline_result) {\n        JSCompiler_inline_result = console;\n        var JSCompiler_temp_const = JSCompiler_inline_result.error;\n        var JSCompiler_inline_result$jscomp$0 =\n          (\"function\" === typeof Symbol &&\n            Symbol.toStringTag &&\n            value[Symbol.toStringTag]) ||\n          value.constructor.name ||\n          \"Object\";\n        JSCompiler_temp_const.call(\n          JSCompiler_inline_result,\n          \"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\",\n          JSCompiler_inline_result$jscomp$0\n        );\n        return testStringCoercion(value);\n      }\n    }\n    function getComponentNameFromType(type) {\n      if (null == type) return null;\n      if (\"function\" === typeof type)\n        return type.$$typeof === REACT_CLIENT_REFERENCE\n          ? null\n          : type.displayName || type.name || null;\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return \"Fragment\";\n        case REACT_PROFILER_TYPE:\n          return \"Profiler\";\n        case REACT_STRICT_MODE_TYPE:\n          return \"StrictMode\";\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n        case REACT_ACTIVITY_TYPE:\n          return \"Activity\";\n      }\n      if (\"object\" === typeof type)\n        switch (\n          (\"number\" === typeof type.tag &&\n            console.error(\n              \"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"\n            ),\n          type.$$typeof)\n        ) {\n          case REACT_PORTAL_TYPE:\n            return \"Portal\";\n          case REACT_CONTEXT_TYPE:\n            return type.displayName || \"Context\";\n          case REACT_CONSUMER_TYPE:\n            return (type._context.displayName || \"Context\") + \".Consumer\";\n          case REACT_FORWARD_REF_TYPE:\n            var innerType = type.render;\n            type = type.displayName;\n            type ||\n              ((type = innerType.displayName || innerType.name || \"\"),\n              (type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\"));\n            return type;\n          case REACT_MEMO_TYPE:\n            return (\n              (innerType = type.displayName || null),\n              null !== innerType\n                ? innerType\n                : getComponentNameFromType(type.type) || \"Memo\"\n            );\n          case REACT_LAZY_TYPE:\n            innerType = type._payload;\n            type = type._init;\n            try {\n              return getComponentNameFromType(type(innerType));\n            } catch (x) {}\n        }\n      return null;\n    }\n    function getTaskName(type) {\n      if (type === REACT_FRAGMENT_TYPE) return \"<>\";\n      if (\n        \"object\" === typeof type &&\n        null !== type &&\n        type.$$typeof === REACT_LAZY_TYPE\n      )\n        return \"<...>\";\n      try {\n        var name = getComponentNameFromType(type);\n        return name ? \"<\" + name + \">\" : \"<...>\";\n      } catch (x) {\n        return \"<...>\";\n      }\n    }\n    function getOwner() {\n      var dispatcher = ReactSharedInternals.A;\n      return null === dispatcher ? null : dispatcher.getOwner();\n    }\n    function UnknownOwner() {\n      return Error(\"react-stack-top-frame\");\n    }\n    function hasValidKey(config) {\n      if (hasOwnProperty.call(config, \"key\")) {\n        var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n        if (getter && getter.isReactWarning) return !1;\n      }\n      return void 0 !== config.key;\n    }\n    function defineKeyPropWarningGetter(props, displayName) {\n      function warnAboutAccessingKey() {\n        specialPropKeyWarningShown ||\n          ((specialPropKeyWarningShown = !0),\n          console.error(\n            \"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)\",\n            displayName\n          ));\n      }\n      warnAboutAccessingKey.isReactWarning = !0;\n      Object.defineProperty(props, \"key\", {\n        get: warnAboutAccessingKey,\n        configurable: !0\n      });\n    }\n    function elementRefGetterWithDeprecationWarning() {\n      var componentName = getComponentNameFromType(this.type);\n      didWarnAboutElementRef[componentName] ||\n        ((didWarnAboutElementRef[componentName] = !0),\n        console.error(\n          \"Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release.\"\n        ));\n      componentName = this.props.ref;\n      return void 0 !== componentName ? componentName : null;\n    }\n    function ReactElement(type, key, props, owner, debugStack, debugTask) {\n      var refProp = props.ref;\n      type = {\n        $$typeof: REACT_ELEMENT_TYPE,\n        type: type,\n        key: key,\n        props: props,\n        _owner: owner\n      };\n      null !== (void 0 !== refProp ? refProp : null)\n        ? Object.defineProperty(type, \"ref\", {\n            enumerable: !1,\n            get: elementRefGetterWithDeprecationWarning\n          })\n        : Object.defineProperty(type, \"ref\", { enumerable: !1, value: null });\n      type._store = {};\n      Object.defineProperty(type._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: 0\n      });\n      Object.defineProperty(type, \"_debugInfo\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: null\n      });\n      Object.defineProperty(type, \"_debugStack\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugStack\n      });\n      Object.defineProperty(type, \"_debugTask\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugTask\n      });\n      Object.freeze && (Object.freeze(type.props), Object.freeze(type));\n      return type;\n    }\n    function cloneAndReplaceKey(oldElement, newKey) {\n      newKey = ReactElement(\n        oldElement.type,\n        newKey,\n        oldElement.props,\n        oldElement._owner,\n        oldElement._debugStack,\n        oldElement._debugTask\n      );\n      oldElement._store &&\n        (newKey._store.validated = oldElement._store.validated);\n      return newKey;\n    }\n    function validateChildKeys(node) {\n      isValidElement(node)\n        ? node._store && (node._store.validated = 1)\n        : \"object\" === typeof node &&\n          null !== node &&\n          node.$$typeof === REACT_LAZY_TYPE &&\n          (\"fulfilled\" === node._payload.status\n            ? isValidElement(node._payload.value) &&\n              node._payload.value._store &&\n              (node._payload.value._store.validated = 1)\n            : node._store && (node._store.validated = 1));\n    }\n    function isValidElement(object) {\n      return (\n        \"object\" === typeof object &&\n        null !== object &&\n        object.$$typeof === REACT_ELEMENT_TYPE\n      );\n    }\n    function escape(key) {\n      var escaperLookup = { \"=\": \"=0\", \":\": \"=2\" };\n      return (\n        \"$\" +\n        key.replace(/[=:]/g, function (match) {\n          return escaperLookup[match];\n        })\n      );\n    }\n    function getElementKey(element, index) {\n      return \"object\" === typeof element &&\n        null !== element &&\n        null != element.key\n        ? (checkKeyStringCoercion(element.key), escape(\"\" + element.key))\n        : index.toString(36);\n    }\n    function resolveThenable(thenable) {\n      switch (thenable.status) {\n        case \"fulfilled\":\n          return thenable.value;\n        case \"rejected\":\n          throw thenable.reason;\n        default:\n          switch (\n            (\"string\" === typeof thenable.status\n              ? thenable.then(noop, noop)\n              : ((thenable.status = \"pending\"),\n                thenable.then(\n                  function (fulfilledValue) {\n                    \"pending\" === thenable.status &&\n                      ((thenable.status = \"fulfilled\"),\n                      (thenable.value = fulfilledValue));\n                  },\n                  function (error) {\n                    \"pending\" === thenable.status &&\n                      ((thenable.status = \"rejected\"),\n                      (thenable.reason = error));\n                  }\n                )),\n            thenable.status)\n          ) {\n            case \"fulfilled\":\n              return thenable.value;\n            case \"rejected\":\n              throw thenable.reason;\n          }\n      }\n      throw thenable;\n    }\n    function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {\n      var type = typeof children;\n      if (\"undefined\" === type || \"boolean\" === type) children = null;\n      var invokeCallback = !1;\n      if (null === children) invokeCallback = !0;\n      else\n        switch (type) {\n          case \"bigint\":\n          case \"string\":\n          case \"number\":\n            invokeCallback = !0;\n            break;\n          case \"object\":\n            switch (children.$$typeof) {\n              case REACT_ELEMENT_TYPE:\n              case REACT_PORTAL_TYPE:\n                invokeCallback = !0;\n                break;\n              case REACT_LAZY_TYPE:\n                return (\n                  (invokeCallback = children._init),\n                  mapIntoArray(\n                    invokeCallback(children._payload),\n                    array,\n                    escapedPrefix,\n                    nameSoFar,\n                    callback\n                  )\n                );\n            }\n        }\n      if (invokeCallback) {\n        invokeCallback = children;\n        callback = callback(invokeCallback);\n        var childKey =\n          \"\" === nameSoFar ? \".\" + getElementKey(invokeCallback, 0) : nameSoFar;\n        isArrayImpl(callback)\n          ? ((escapedPrefix = \"\"),\n            null != childKey &&\n              (escapedPrefix =\n                childKey.replace(userProvidedKeyEscapeRegex, \"$&/\") + \"/\"),\n            mapIntoArray(callback, array, escapedPrefix, \"\", function (c) {\n              return c;\n            }))\n          : null != callback &&\n            (isValidElement(callback) &&\n              (null != callback.key &&\n                ((invokeCallback && invokeCallback.key === callback.key) ||\n                  checkKeyStringCoercion(callback.key)),\n              (escapedPrefix = cloneAndReplaceKey(\n                callback,\n                escapedPrefix +\n                  (null == callback.key ||\n                  (invokeCallback && invokeCallback.key === callback.key)\n                    ? \"\"\n                    : (\"\" + callback.key).replace(\n                        userProvidedKeyEscapeRegex,\n                        \"$&/\"\n                      ) + \"/\") +\n                  childKey\n              )),\n              \"\" !== nameSoFar &&\n                null != invokeCallback &&\n                isValidElement(invokeCallback) &&\n                null == invokeCallback.key &&\n                invokeCallback._store &&\n                !invokeCallback._store.validated &&\n                (escapedPrefix._store.validated = 2),\n              (callback = escapedPrefix)),\n            array.push(callback));\n        return 1;\n      }\n      invokeCallback = 0;\n      childKey = \"\" === nameSoFar ? \".\" : nameSoFar + \":\";\n      if (isArrayImpl(children))\n        for (var i = 0; i < children.length; i++)\n          (nameSoFar = children[i]),\n            (type = childKey + getElementKey(nameSoFar, i)),\n            (invokeCallback += mapIntoArray(\n              nameSoFar,\n              array,\n              escapedPrefix,\n              type,\n              callback\n            ));\n      else if (((i = getIteratorFn(children)), \"function\" === typeof i))\n        for (\n          i === children.entries &&\n            (didWarnAboutMaps ||\n              console.warn(\n                \"Using Maps as children is not supported. Use an array of keyed ReactElements instead.\"\n              ),\n            (didWarnAboutMaps = !0)),\n            children = i.call(children),\n            i = 0;\n          !(nameSoFar = children.next()).done;\n\n        )\n          (nameSoFar = nameSoFar.value),\n            (type = childKey + getElementKey(nameSoFar, i++)),\n            (invokeCallback += mapIntoArray(\n              nameSoFar,\n              array,\n              escapedPrefix,\n              type,\n              callback\n            ));\n      else if (\"object\" === type) {\n        if (\"function\" === typeof children.then)\n          return mapIntoArray(\n            resolveThenable(children),\n            array,\n            escapedPrefix,\n            nameSoFar,\n            callback\n          );\n        array = String(children);\n        throw Error(\n          \"Objects are not valid as a React child (found: \" +\n            (\"[object Object]\" === array\n              ? \"object with keys {\" + Object.keys(children).join(\", \") + \"}\"\n              : array) +\n            \"). If you meant to render a collection of children, use an array instead.\"\n        );\n      }\n      return invokeCallback;\n    }\n    function mapChildren(children, func, context) {\n      if (null == children) return children;\n      var result = [],\n        count = 0;\n      mapIntoArray(children, result, \"\", \"\", function (child) {\n        return func.call(context, child, count++);\n      });\n      return result;\n    }\n    function lazyInitializer(payload) {\n      if (-1 === payload._status) {\n        var ioInfo = payload._ioInfo;\n        null != ioInfo && (ioInfo.start = ioInfo.end = performance.now());\n        ioInfo = payload._result;\n        var thenable = ioInfo();\n        thenable.then(\n          function (moduleObject) {\n            if (0 === payload._status || -1 === payload._status) {\n              payload._status = 1;\n              payload._result = moduleObject;\n              var _ioInfo = payload._ioInfo;\n              null != _ioInfo && (_ioInfo.end = performance.now());\n              void 0 === thenable.status &&\n                ((thenable.status = \"fulfilled\"),\n                (thenable.value = moduleObject));\n            }\n          },\n          function (error) {\n            if (0 === payload._status || -1 === payload._status) {\n              payload._status = 2;\n              payload._result = error;\n              var _ioInfo2 = payload._ioInfo;\n              null != _ioInfo2 && (_ioInfo2.end = performance.now());\n              void 0 === thenable.status &&\n                ((thenable.status = \"rejected\"), (thenable.reason = error));\n            }\n          }\n        );\n        ioInfo = payload._ioInfo;\n        if (null != ioInfo) {\n          ioInfo.value = thenable;\n          var displayName = thenable.displayName;\n          \"string\" === typeof displayName && (ioInfo.name = displayName);\n        }\n        -1 === payload._status &&\n          ((payload._status = 0), (payload._result = thenable));\n      }\n      if (1 === payload._status)\n        return (\n          (ioInfo = payload._result),\n          void 0 === ioInfo &&\n            console.error(\n              \"lazy: Expected the result of a dynamic import() call. Instead received: %s\\n\\nYour code should look like: \\n  const MyComponent = lazy(() => import('./MyComponent'))\\n\\nDid you accidentally put curly braces around the import?\",\n              ioInfo\n            ),\n          \"default\" in ioInfo ||\n            console.error(\n              \"lazy: Expected the result of a dynamic import() call. Instead received: %s\\n\\nYour code should look like: \\n  const MyComponent = lazy(() => import('./MyComponent'))\",\n              ioInfo\n            ),\n          ioInfo.default\n        );\n      throw payload._result;\n    }\n    function resolveDispatcher() {\n      var dispatcher = ReactSharedInternals.H;\n      null === dispatcher &&\n        console.error(\n          \"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\\n1. You might have mismatching versions of React and the renderer (such as React DOM)\\n2. You might be breaking the Rules of Hooks\\n3. You might have more than one copy of React in the same app\\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.\"\n        );\n      return dispatcher;\n    }\n    function releaseAsyncTransition() {\n      ReactSharedInternals.asyncTransitions--;\n    }\n    function enqueueTask(task) {\n      if (null === enqueueTaskImpl)\n        try {\n          var requireString = (\"require\" + Math.random()).slice(0, 7);\n          enqueueTaskImpl = (module && module[requireString]).call(\n            module,\n            \"timers\"\n          ).setImmediate;\n        } catch (_err) {\n          enqueueTaskImpl = function (callback) {\n            !1 === didWarnAboutMessageChannel &&\n              ((didWarnAboutMessageChannel = !0),\n              \"undefined\" === typeof MessageChannel &&\n                console.error(\n                  \"This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning.\"\n                ));\n            var channel = new MessageChannel();\n            channel.port1.onmessage = callback;\n            channel.port2.postMessage(void 0);\n          };\n        }\n      return enqueueTaskImpl(task);\n    }\n    function aggregateErrors(errors) {\n      return 1 < errors.length && \"function\" === typeof AggregateError\n        ? new AggregateError(errors)\n        : errors[0];\n    }\n    function popActScope(prevActQueue, prevActScopeDepth) {\n      prevActScopeDepth !== actScopeDepth - 1 &&\n        console.error(\n          \"You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. \"\n        );\n      actScopeDepth = prevActScopeDepth;\n    }\n    function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {\n      var queue = ReactSharedInternals.actQueue;\n      if (null !== queue)\n        if (0 !== queue.length)\n          try {\n            flushActQueue(queue);\n            enqueueTask(function () {\n              return recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n            });\n            return;\n          } catch (error) {\n            ReactSharedInternals.thrownErrors.push(error);\n          }\n        else ReactSharedInternals.actQueue = null;\n      0 < ReactSharedInternals.thrownErrors.length\n        ? ((queue = aggregateErrors(ReactSharedInternals.thrownErrors)),\n          (ReactSharedInternals.thrownErrors.length = 0),\n          reject(queue))\n        : resolve(returnValue);\n    }\n    function flushActQueue(queue) {\n      if (!isFlushing) {\n        isFlushing = !0;\n        var i = 0;\n        try {\n          for (; i < queue.length; i++) {\n            var callback = queue[i];\n            do {\n              ReactSharedInternals.didUsePromise = !1;\n              var continuation = callback(!1);\n              if (null !== continuation) {\n                if (ReactSharedInternals.didUsePromise) {\n                  queue[i] = callback;\n                  queue.splice(0, i);\n                  return;\n                }\n                callback = continuation;\n              } else break;\n            } while (1);\n          }\n          queue.length = 0;\n        } catch (error) {\n          queue.splice(0, i + 1), ReactSharedInternals.thrownErrors.push(error);\n        } finally {\n          isFlushing = !1;\n        }\n      }\n    }\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());\n    var REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n      REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n      REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\n      REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\n      REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\"),\n      REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\n      REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\n      REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\n      REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\n      REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"),\n      REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\n      REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\n      REACT_ACTIVITY_TYPE = Symbol.for(\"react.activity\"),\n      MAYBE_ITERATOR_SYMBOL = Symbol.iterator,\n      didWarnStateUpdateForUnmountedComponent = {},\n      ReactNoopUpdateQueue = {\n        isMounted: function () {\n          return !1;\n        },\n        enqueueForceUpdate: function (publicInstance) {\n          warnNoop(publicInstance, \"forceUpdate\");\n        },\n        enqueueReplaceState: function (publicInstance) {\n          warnNoop(publicInstance, \"replaceState\");\n        },\n        enqueueSetState: function (publicInstance) {\n          warnNoop(publicInstance, \"setState\");\n        }\n      },\n      assign = Object.assign,\n      emptyObject = {};\n    Object.freeze(emptyObject);\n    Component.prototype.isReactComponent = {};\n    Component.prototype.setState = function (partialState, callback) {\n      if (\n        \"object\" !== typeof partialState &&\n        \"function\" !== typeof partialState &&\n        null != partialState\n      )\n        throw Error(\n          \"takes an object of state variables to update or a function which returns an object of state variables.\"\n        );\n      this.updater.enqueueSetState(this, partialState, callback, \"setState\");\n    };\n    Component.prototype.forceUpdate = function (callback) {\n      this.updater.enqueueForceUpdate(this, callback, \"forceUpdate\");\n    };\n    var deprecatedAPIs = {\n      isMounted: [\n        \"isMounted\",\n        \"Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks.\"\n      ],\n      replaceState: [\n        \"replaceState\",\n        \"Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236).\"\n      ]\n    };\n    for (fnName in deprecatedAPIs)\n      deprecatedAPIs.hasOwnProperty(fnName) &&\n        defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);\n    ComponentDummy.prototype = Component.prototype;\n    deprecatedAPIs = PureComponent.prototype = new ComponentDummy();\n    deprecatedAPIs.constructor = PureComponent;\n    assign(deprecatedAPIs, Component.prototype);\n    deprecatedAPIs.isPureReactComponent = !0;\n    var isArrayImpl = Array.isArray,\n      REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n      ReactSharedInternals = {\n        H: null,\n        A: null,\n        T: null,\n        S: null,\n        actQueue: null,\n        asyncTransitions: 0,\n        isBatchingLegacy: !1,\n        didScheduleLegacyUpdate: !1,\n        didUsePromise: !1,\n        thrownErrors: [],\n        getCurrentStack: null,\n        recentlyCreatedOwnerStacks: 0\n      },\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      createTask = console.createTask\n        ? console.createTask\n        : function () {\n            return null;\n          };\n    deprecatedAPIs = {\n      react_stack_bottom_frame: function (callStackForError) {\n        return callStackForError();\n      }\n    };\n    var specialPropKeyWarningShown, didWarnAboutOldJSXRuntime;\n    var didWarnAboutElementRef = {};\n    var unknownOwnerDebugStack = deprecatedAPIs.react_stack_bottom_frame.bind(\n      deprecatedAPIs,\n      UnknownOwner\n    )();\n    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));\n    var didWarnAboutMaps = !1,\n      userProvidedKeyEscapeRegex = /\\/+/g,\n      reportGlobalError =\n        \"function\" === typeof reportError\n          ? reportError\n          : function (error) {\n              if (\n                \"object\" === typeof window &&\n                \"function\" === typeof window.ErrorEvent\n              ) {\n                var event = new window.ErrorEvent(\"error\", {\n                  bubbles: !0,\n                  cancelable: !0,\n                  message:\n                    \"object\" === typeof error &&\n                    null !== error &&\n                    \"string\" === typeof error.message\n                      ? String(error.message)\n                      : String(error),\n                  error: error\n                });\n                if (!window.dispatchEvent(event)) return;\n              } else if (\n                \"object\" === typeof process &&\n                \"function\" === typeof process.emit\n              ) {\n                process.emit(\"uncaughtException\", error);\n                return;\n              }\n              console.error(error);\n            },\n      didWarnAboutMessageChannel = !1,\n      enqueueTaskImpl = null,\n      actScopeDepth = 0,\n      didWarnNoAwaitAct = !1,\n      isFlushing = !1,\n      queueSeveralMicrotasks =\n        \"function\" === typeof queueMicrotask\n          ? function (callback) {\n              queueMicrotask(function () {\n                return queueMicrotask(callback);\n              });\n            }\n          : enqueueTask;\n    deprecatedAPIs = Object.freeze({\n      __proto__: null,\n      c: function (size) {\n        return resolveDispatcher().useMemoCache(size);\n      }\n    });\n    var fnName = {\n      map: mapChildren,\n      forEach: function (children, forEachFunc, forEachContext) {\n        mapChildren(\n          children,\n          function () {\n            forEachFunc.apply(this, arguments);\n          },\n          forEachContext\n        );\n      },\n      count: function (children) {\n        var n = 0;\n        mapChildren(children, function () {\n          n++;\n        });\n        return n;\n      },\n      toArray: function (children) {\n        return (\n          mapChildren(children, function (child) {\n            return child;\n          }) || []\n        );\n      },\n      only: function (children) {\n        if (!isValidElement(children))\n          throw Error(\n            \"React.Children.only expected to receive a single React element child.\"\n          );\n        return children;\n      }\n    };\n    exports.Activity = REACT_ACTIVITY_TYPE;\n    exports.Children = fnName;\n    exports.Component = Component;\n    exports.Fragment = REACT_FRAGMENT_TYPE;\n    exports.Profiler = REACT_PROFILER_TYPE;\n    exports.PureComponent = PureComponent;\n    exports.StrictMode = REACT_STRICT_MODE_TYPE;\n    exports.Suspense = REACT_SUSPENSE_TYPE;\n    exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE =\n      ReactSharedInternals;\n    exports.__COMPILER_RUNTIME = deprecatedAPIs;\n    exports.act = function (callback) {\n      var prevActQueue = ReactSharedInternals.actQueue,\n        prevActScopeDepth = actScopeDepth;\n      actScopeDepth++;\n      var queue = (ReactSharedInternals.actQueue =\n          null !== prevActQueue ? prevActQueue : []),\n        didAwaitActCall = !1;\n      try {\n        var result = callback();\n      } catch (error) {\n        ReactSharedInternals.thrownErrors.push(error);\n      }\n      if (0 < ReactSharedInternals.thrownErrors.length)\n        throw (\n          (popActScope(prevActQueue, prevActScopeDepth),\n          (callback = aggregateErrors(ReactSharedInternals.thrownErrors)),\n          (ReactSharedInternals.thrownErrors.length = 0),\n          callback)\n        );\n      if (\n        null !== result &&\n        \"object\" === typeof result &&\n        \"function\" === typeof result.then\n      ) {\n        var thenable = result;\n        queueSeveralMicrotasks(function () {\n          didAwaitActCall ||\n            didWarnNoAwaitAct ||\n            ((didWarnNoAwaitAct = !0),\n            console.error(\n              \"You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);\"\n            ));\n        });\n        return {\n          then: function (resolve, reject) {\n            didAwaitActCall = !0;\n            thenable.then(\n              function (returnValue) {\n                popActScope(prevActQueue, prevActScopeDepth);\n                if (0 === prevActScopeDepth) {\n                  try {\n                    flushActQueue(queue),\n                      enqueueTask(function () {\n                        return recursivelyFlushAsyncActWork(\n                          returnValue,\n                          resolve,\n                          reject\n                        );\n                      });\n                  } catch (error$0) {\n                    ReactSharedInternals.thrownErrors.push(error$0);\n                  }\n                  if (0 < ReactSharedInternals.thrownErrors.length) {\n                    var _thrownError = aggregateErrors(\n                      ReactSharedInternals.thrownErrors\n                    );\n                    ReactSharedInternals.thrownErrors.length = 0;\n                    reject(_thrownError);\n                  }\n                } else resolve(returnValue);\n              },\n              function (error) {\n                popActScope(prevActQueue, prevActScopeDepth);\n                0 < ReactSharedInternals.thrownErrors.length\n                  ? ((error = aggregateErrors(\n                      ReactSharedInternals.thrownErrors\n                    )),\n                    (ReactSharedInternals.thrownErrors.length = 0),\n                    reject(error))\n                  : reject(error);\n              }\n            );\n          }\n        };\n      }\n      var returnValue$jscomp$0 = result;\n      popActScope(prevActQueue, prevActScopeDepth);\n      0 === prevActScopeDepth &&\n        (flushActQueue(queue),\n        0 !== queue.length &&\n          queueSeveralMicrotasks(function () {\n            didAwaitActCall ||\n              didWarnNoAwaitAct ||\n              ((didWarnNoAwaitAct = !0),\n              console.error(\n                \"A component suspended inside an `act` scope, but the `act` call was not awaited. When testing React components that depend on asynchronous data, you must await the result:\\n\\nawait act(() => ...)\"\n              ));\n          }),\n        (ReactSharedInternals.actQueue = null));\n      if (0 < ReactSharedInternals.thrownErrors.length)\n        throw (\n          ((callback = aggregateErrors(ReactSharedInternals.thrownErrors)),\n          (ReactSharedInternals.thrownErrors.length = 0),\n          callback)\n        );\n      return {\n        then: function (resolve, reject) {\n          didAwaitActCall = !0;\n          0 === prevActScopeDepth\n            ? ((ReactSharedInternals.actQueue = queue),\n              enqueueTask(function () {\n                return recursivelyFlushAsyncActWork(\n                  returnValue$jscomp$0,\n                  resolve,\n                  reject\n                );\n              }))\n            : resolve(returnValue$jscomp$0);\n        }\n      };\n    };\n    exports.cache = function (fn) {\n      return function () {\n        return fn.apply(null, arguments);\n      };\n    };\n    exports.cacheSignal = function () {\n      return null;\n    };\n    exports.captureOwnerStack = function () {\n      var getCurrentStack = ReactSharedInternals.getCurrentStack;\n      return null === getCurrentStack ? null : getCurrentStack();\n    };\n    exports.cloneElement = function (element, config, children) {\n      if (null === element || void 0 === element)\n        throw Error(\n          \"The argument must be a React element, but you passed \" +\n            element +\n            \".\"\n        );\n      var props = assign({}, element.props),\n        key = element.key,\n        owner = element._owner;\n      if (null != config) {\n        var JSCompiler_inline_result;\n        a: {\n          if (\n            hasOwnProperty.call(config, \"ref\") &&\n            (JSCompiler_inline_result = Object.getOwnPropertyDescriptor(\n              config,\n              \"ref\"\n            ).get) &&\n            JSCompiler_inline_result.isReactWarning\n          ) {\n            JSCompiler_inline_result = !1;\n            break a;\n          }\n          JSCompiler_inline_result = void 0 !== config.ref;\n        }\n        JSCompiler_inline_result && (owner = getOwner());\n        hasValidKey(config) &&\n          (checkKeyStringCoercion(config.key), (key = \"\" + config.key));\n        for (propName in config)\n          !hasOwnProperty.call(config, propName) ||\n            \"key\" === propName ||\n            \"__self\" === propName ||\n            \"__source\" === propName ||\n            (\"ref\" === propName && void 0 === config.ref) ||\n            (props[propName] = config[propName]);\n      }\n      var propName = arguments.length - 2;\n      if (1 === propName) props.children = children;\n      else if (1 < propName) {\n        JSCompiler_inline_result = Array(propName);\n        for (var i = 0; i < propName; i++)\n          JSCompiler_inline_result[i] = arguments[i + 2];\n        props.children = JSCompiler_inline_result;\n      }\n      props = ReactElement(\n        element.type,\n        key,\n        props,\n        owner,\n        element._debugStack,\n        element._debugTask\n      );\n      for (key = 2; key < arguments.length; key++)\n        validateChildKeys(arguments[key]);\n      return props;\n    };\n    exports.createContext = function (defaultValue) {\n      defaultValue = {\n        $$typeof: REACT_CONTEXT_TYPE,\n        _currentValue: defaultValue,\n        _currentValue2: defaultValue,\n        _threadCount: 0,\n        Provider: null,\n        Consumer: null\n      };\n      defaultValue.Provider = defaultValue;\n      defaultValue.Consumer = {\n        $$typeof: REACT_CONSUMER_TYPE,\n        _context: defaultValue\n      };\n      defaultValue._currentRenderer = null;\n      defaultValue._currentRenderer2 = null;\n      return defaultValue;\n    };\n    exports.createElement = function (type, config, children) {\n      for (var i = 2; i < arguments.length; i++)\n        validateChildKeys(arguments[i]);\n      i = {};\n      var key = null;\n      if (null != config)\n        for (propName in (didWarnAboutOldJSXRuntime ||\n          !(\"__self\" in config) ||\n          \"key\" in config ||\n          ((didWarnAboutOldJSXRuntime = !0),\n          console.warn(\n            \"Your app (or one of its dependencies) is using an outdated JSX transform. Update to the modern JSX transform for faster performance: https://react.dev/link/new-jsx-transform\"\n          )),\n        hasValidKey(config) &&\n          (checkKeyStringCoercion(config.key), (key = \"\" + config.key)),\n        config))\n          hasOwnProperty.call(config, propName) &&\n            \"key\" !== propName &&\n            \"__self\" !== propName &&\n            \"__source\" !== propName &&\n            (i[propName] = config[propName]);\n      var childrenLength = arguments.length - 2;\n      if (1 === childrenLength) i.children = children;\n      else if (1 < childrenLength) {\n        for (\n          var childArray = Array(childrenLength), _i = 0;\n          _i < childrenLength;\n          _i++\n        )\n          childArray[_i] = arguments[_i + 2];\n        Object.freeze && Object.freeze(childArray);\n        i.children = childArray;\n      }\n      if (type && type.defaultProps)\n        for (propName in ((childrenLength = type.defaultProps), childrenLength))\n          void 0 === i[propName] && (i[propName] = childrenLength[propName]);\n      key &&\n        defineKeyPropWarningGetter(\n          i,\n          \"function\" === typeof type\n            ? type.displayName || type.name || \"Unknown\"\n            : type\n        );\n      var propName = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;\n      return ReactElement(\n        type,\n        key,\n        i,\n        getOwner(),\n        propName ? Error(\"react-stack-top-frame\") : unknownOwnerDebugStack,\n        propName ? createTask(getTaskName(type)) : unknownOwnerDebugTask\n      );\n    };\n    exports.createRef = function () {\n      var refObject = { current: null };\n      Object.seal(refObject);\n      return refObject;\n    };\n    exports.forwardRef = function (render) {\n      null != render && render.$$typeof === REACT_MEMO_TYPE\n        ? console.error(\n            \"forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).\"\n          )\n        : \"function\" !== typeof render\n          ? console.error(\n              \"forwardRef requires a render function but was given %s.\",\n              null === render ? \"null\" : typeof render\n            )\n          : 0 !== render.length &&\n            2 !== render.length &&\n            console.error(\n              \"forwardRef render functions accept exactly two parameters: props and ref. %s\",\n              1 === render.length\n                ? \"Did you forget to use the ref parameter?\"\n                : \"Any additional parameter will be undefined.\"\n            );\n      null != render &&\n        null != render.defaultProps &&\n        console.error(\n          \"forwardRef render functions do not support defaultProps. Did you accidentally pass a React component?\"\n        );\n      var elementType = { $$typeof: REACT_FORWARD_REF_TYPE, render: render },\n        ownName;\n      Object.defineProperty(elementType, \"displayName\", {\n        enumerable: !1,\n        configurable: !0,\n        get: function () {\n          return ownName;\n        },\n        set: function (name) {\n          ownName = name;\n          render.name ||\n            render.displayName ||\n            (Object.defineProperty(render, \"name\", { value: name }),\n            (render.displayName = name));\n        }\n      });\n      return elementType;\n    };\n    exports.isValidElement = isValidElement;\n    exports.lazy = function (ctor) {\n      ctor = { _status: -1, _result: ctor };\n      var lazyType = {\n          $$typeof: REACT_LAZY_TYPE,\n          _payload: ctor,\n          _init: lazyInitializer\n        },\n        ioInfo = {\n          name: \"lazy\",\n          start: -1,\n          end: -1,\n          value: null,\n          owner: null,\n          debugStack: Error(\"react-stack-top-frame\"),\n          debugTask: console.createTask ? console.createTask(\"lazy()\") : null\n        };\n      ctor._ioInfo = ioInfo;\n      lazyType._debugInfo = [{ awaited: ioInfo }];\n      return lazyType;\n    };\n    exports.memo = function (type, compare) {\n      null == type &&\n        console.error(\n          \"memo: The first argument must be a component. Instead received: %s\",\n          null === type ? \"null\" : typeof type\n        );\n      compare = {\n        $$typeof: REACT_MEMO_TYPE,\n        type: type,\n        compare: void 0 === compare ? null : compare\n      };\n      var ownName;\n      Object.defineProperty(compare, \"displayName\", {\n        enumerable: !1,\n        configurable: !0,\n        get: function () {\n          return ownName;\n        },\n        set: function (name) {\n          ownName = name;\n          type.name ||\n            type.displayName ||\n            (Object.defineProperty(type, \"name\", { value: name }),\n            (type.displayName = name));\n        }\n      });\n      return compare;\n    };\n    exports.startTransition = function (scope) {\n      var prevTransition = ReactSharedInternals.T,\n        currentTransition = {};\n      currentTransition._updatedFibers = new Set();\n      ReactSharedInternals.T = currentTransition;\n      try {\n        var returnValue = scope(),\n          onStartTransitionFinish = ReactSharedInternals.S;\n        null !== onStartTransitionFinish &&\n          onStartTransitionFinish(currentTransition, returnValue);\n        \"object\" === typeof returnValue &&\n          null !== returnValue &&\n          \"function\" === typeof returnValue.then &&\n          (ReactSharedInternals.asyncTransitions++,\n          returnValue.then(releaseAsyncTransition, releaseAsyncTransition),\n          returnValue.then(noop, reportGlobalError));\n      } catch (error) {\n        reportGlobalError(error);\n      } finally {\n        null === prevTransition &&\n          currentTransition._updatedFibers &&\n          ((scope = currentTransition._updatedFibers.size),\n          currentTransition._updatedFibers.clear(),\n          10 < scope &&\n            console.warn(\n              \"Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.\"\n            )),\n          null !== prevTransition &&\n            null !== currentTransition.types &&\n            (null !== prevTransition.types &&\n              prevTransition.types !== currentTransition.types &&\n              console.error(\n                \"We expected inner Transitions to have transferred the outer types set and that you cannot add to the outer Transition while inside the inner.This is a bug in React.\"\n              ),\n            (prevTransition.types = currentTransition.types)),\n          (ReactSharedInternals.T = prevTransition);\n      }\n    };\n    exports.unstable_useCacheRefresh = function () {\n      return resolveDispatcher().useCacheRefresh();\n    };\n    exports.use = function (usable) {\n      return resolveDispatcher().use(usable);\n    };\n    exports.useActionState = function (action, initialState, permalink) {\n      return resolveDispatcher().useActionState(\n        action,\n        initialState,\n        permalink\n      );\n    };\n    exports.useCallback = function (callback, deps) {\n      return resolveDispatcher().useCallback(callback, deps);\n    };\n    exports.useContext = function (Context) {\n      var dispatcher = resolveDispatcher();\n      Context.$$typeof === REACT_CONSUMER_TYPE &&\n        console.error(\n          \"Calling useContext(Context.Consumer) is not supported and will cause bugs. Did you mean to call useContext(Context) instead?\"\n        );\n      return dispatcher.useContext(Context);\n    };\n    exports.useDebugValue = function (value, formatterFn) {\n      return resolveDispatcher().useDebugValue(value, formatterFn);\n    };\n    exports.useDeferredValue = function (value, initialValue) {\n      return resolveDispatcher().useDeferredValue(value, initialValue);\n    };\n    exports.useEffect = function (create, deps) {\n      null == create &&\n        console.warn(\n          \"React Hook useEffect requires an effect callback. Did you forget to pass a callback to the hook?\"\n        );\n      return resolveDispatcher().useEffect(create, deps);\n    };\n    exports.useEffectEvent = function (callback) {\n      return resolveDispatcher().useEffectEvent(callback);\n    };\n    exports.useId = function () {\n      return resolveDispatcher().useId();\n    };\n    exports.useImperativeHandle = function (ref, create, deps) {\n      return resolveDispatcher().useImperativeHandle(ref, create, deps);\n    };\n    exports.useInsertionEffect = function (create, deps) {\n      null == create &&\n        console.warn(\n          \"React Hook useInsertionEffect requires an effect callback. Did you forget to pass a callback to the hook?\"\n        );\n      return resolveDispatcher().useInsertionEffect(create, deps);\n    };\n    exports.useLayoutEffect = function (create, deps) {\n      null == create &&\n        console.warn(\n          \"React Hook useLayoutEffect requires an effect callback. Did you forget to pass a callback to the hook?\"\n        );\n      return resolveDispatcher().useLayoutEffect(create, deps);\n    };\n    exports.useMemo = function (create, deps) {\n      return resolveDispatcher().useMemo(create, deps);\n    };\n    exports.useOptimistic = function (passthrough, reducer) {\n      return resolveDispatcher().useOptimistic(passthrough, reducer);\n    };\n    exports.useReducer = function (reducer, initialArg, init) {\n      return resolveDispatcher().useReducer(reducer, initialArg, init);\n    };\n    exports.useRef = function (initialValue) {\n      return resolveDispatcher().useRef(initialValue);\n    };\n    exports.useState = function (initialState) {\n      return resolveDispatcher().useState(initialState);\n    };\n    exports.useSyncExternalStore = function (\n      subscribe,\n      getSnapshot,\n      getServerSnapshot\n    ) {\n      return resolveDispatcher().useSyncExternalStore(\n        subscribe,\n        getSnapshot,\n        getServerSnapshot\n      );\n    };\n    exports.useTransition = function () {\n      return resolveDispatcher().useTransition();\n    };\n    exports.version = \"19.2.0\";\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LmRldmVsb3BtZW50LmpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7QUFDYixLQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb01BQW9NO0FBQ3BNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLCtDQUErQyw2QkFBNkI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMseUNBQXlDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsY0FBYztBQUNkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnQkFBZ0I7QUFDcEIsSUFBSSxnQkFBZ0I7QUFDcEIsSUFBSSxpQkFBaUI7QUFDckIsSUFBSSxnQkFBZ0I7QUFDcEIsSUFBSSxnQkFBZ0I7QUFDcEIsSUFBSSxxQkFBcUI7QUFDekIsSUFBSSxrQkFBa0I7QUFDdEIsSUFBSSxnQkFBZ0I7QUFDcEIsSUFBSSx1RUFBdUU7QUFDM0U7QUFDQSxJQUFJLDBCQUEwQjtBQUM5QixJQUFJLFdBQVc7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnTkFBZ047QUFDaE47QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxhQUFhO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxtQkFBbUI7QUFDdkI7QUFDQTtBQUNBLElBQUkseUJBQXlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLElBQUksb0JBQW9CO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsY0FBYztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBO0FBQ0E7QUFDQSxJQUFJLHFCQUFxQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxxQkFBcUI7QUFDekIsc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGlCQUFpQjtBQUNyQix3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsSUFBSSxrQkFBa0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsa0RBQWtEO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxhQUFhO0FBQ2xFO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLElBQUksc0JBQXNCO0FBQzFCLElBQUksWUFBWTtBQUNoQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsaUJBQWlCO0FBQ2hEO0FBQ0E7QUFDQSxJQUFJLFlBQVk7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsYUFBYTtBQUNoRTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxJQUFJLHVCQUF1QjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdDQUFnQztBQUNwQztBQUNBO0FBQ0EsSUFBSSxXQUFXO0FBQ2Y7QUFDQTtBQUNBLElBQUksc0JBQXNCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksbUJBQW1CO0FBQ3ZCO0FBQ0E7QUFDQSxJQUFJLGtCQUFrQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUkscUJBQXFCO0FBQ3pCO0FBQ0E7QUFDQSxJQUFJLHdCQUF3QjtBQUM1QjtBQUNBO0FBQ0EsSUFBSSxpQkFBaUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxzQkFBc0I7QUFDMUI7QUFDQTtBQUNBLElBQUksYUFBYTtBQUNqQjtBQUNBO0FBQ0EsSUFBSSwyQkFBMkI7QUFDL0I7QUFDQTtBQUNBLElBQUksMEJBQTBCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksdUJBQXVCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZUFBZTtBQUNuQjtBQUNBO0FBQ0EsSUFBSSxxQkFBcUI7QUFDekI7QUFDQTtBQUNBLElBQUksa0JBQWtCO0FBQ3RCO0FBQ0E7QUFDQSxJQUFJLGNBQWM7QUFDbEI7QUFDQTtBQUNBLElBQUksZ0JBQWdCO0FBQ3BCO0FBQ0E7QUFDQSxJQUFJLDRCQUE0QjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUkscUJBQXFCO0FBQ3pCO0FBQ0E7QUFDQSxJQUFJLGVBQWU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vU1NSLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2Nqcy9yZWFjdC5kZXZlbG9wbWVudC5qcz83MmQwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViAmJlxuICAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyhtZXRob2ROYW1lLCBpbmZvKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50LnByb3RvdHlwZSwgbWV0aG9kTmFtZSwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICBcIiVzKC4uLikgaXMgZGVwcmVjYXRlZCBpbiBwbGFpbiBKYXZhU2NyaXB0IFJlYWN0IGNsYXNzZXMuICVzXCIsXG4gICAgICAgICAgICBpbmZvWzBdLFxuICAgICAgICAgICAgaW5mb1sxXVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgICAgIGlmIChudWxsID09PSBtYXliZUl0ZXJhYmxlIHx8IFwib2JqZWN0XCIgIT09IHR5cGVvZiBtYXliZUl0ZXJhYmxlKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIG1heWJlSXRlcmFibGUgPVxuICAgICAgICAoTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSkgfHxcbiAgICAgICAgbWF5YmVJdGVyYWJsZVtcIkBAaXRlcmF0b3JcIl07XG4gICAgICByZXR1cm4gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbWF5YmVJdGVyYWJsZSA/IG1heWJlSXRlcmFibGUgOiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgY2FsbGVyTmFtZSkge1xuICAgICAgcHVibGljSW5zdGFuY2UgPVxuICAgICAgICAoKHB1YmxpY0luc3RhbmNlID0gcHVibGljSW5zdGFuY2UuY29uc3RydWN0b3IpICYmXG4gICAgICAgICAgKHB1YmxpY0luc3RhbmNlLmRpc3BsYXlOYW1lIHx8IHB1YmxpY0luc3RhbmNlLm5hbWUpKSB8fFxuICAgICAgICBcIlJlYWN0Q2xhc3NcIjtcbiAgICAgIHZhciB3YXJuaW5nS2V5ID0gcHVibGljSW5zdGFuY2UgKyBcIi5cIiArIGNhbGxlck5hbWU7XG4gICAgICBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnRbd2FybmluZ0tleV0gfHxcbiAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJDYW4ndCBjYWxsICVzIG9uIGEgY29tcG9uZW50IHRoYXQgaXMgbm90IHlldCBtb3VudGVkLiBUaGlzIGlzIGEgbm8tb3AsIGJ1dCBpdCBtaWdodCBpbmRpY2F0ZSBhIGJ1ZyBpbiB5b3VyIGFwcGxpY2F0aW9uLiBJbnN0ZWFkLCBhc3NpZ24gdG8gYHRoaXMuc3RhdGVgIGRpcmVjdGx5IG9yIGRlZmluZSBhIGBzdGF0ZSA9IHt9O2AgY2xhc3MgcHJvcGVydHkgd2l0aCB0aGUgZGVzaXJlZCBzdGF0ZSBpbiB0aGUgJXMgY29tcG9uZW50LlwiLFxuICAgICAgICAgIGNhbGxlck5hbWUsXG4gICAgICAgICAgcHVibGljSW5zdGFuY2VcbiAgICAgICAgKSxcbiAgICAgICAgKGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudFt3YXJuaW5nS2V5XSA9ICEwKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIENvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICAgICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICAgICAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gQ29tcG9uZW50RHVtbXkoKSB7fVxuICAgIGZ1bmN0aW9uIFB1cmVDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgICAgIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vb3AoKSB7fVxuICAgIGZ1bmN0aW9uIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIFwiXCIgKyB2YWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tLZXlTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICExO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAhMDtcbiAgICAgIH1cbiAgICAgIGlmIChKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQpIHtcbiAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gY29uc29sZTtcbiAgICAgICAgdmFyIEpTQ29tcGlsZXJfdGVtcF9jb25zdCA9IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdC5lcnJvcjtcbiAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMCA9XG4gICAgICAgICAgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIFN5bWJvbCAmJlxuICAgICAgICAgICAgU3ltYm9sLnRvU3RyaW5nVGFnICYmXG4gICAgICAgICAgICB2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddKSB8fFxuICAgICAgICAgIHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgfHxcbiAgICAgICAgICBcIk9iamVjdFwiO1xuICAgICAgICBKU0NvbXBpbGVyX3RlbXBfY29uc3QuY2FsbChcbiAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQsXG4gICAgICAgICAgXCJUaGUgcHJvdmlkZWQga2V5IGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSB1c2luZyBpdCBoZXJlLlwiLFxuICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgICAgIGlmIChudWxsID09IHR5cGUpIHJldHVybiBudWxsO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHJldHVybiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFXG4gICAgICAgICAgPyBudWxsXG4gICAgICAgICAgOiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlKSByZXR1cm4gdHlwZTtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiRnJhZ21lbnRcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlByb2ZpbGVyXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdHJpY3RNb2RlXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZVwiO1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZUxpc3RcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9BQ1RJVklUWV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIkFjdGl2aXR5XCI7XG4gICAgICB9XG4gICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHN3aXRjaCAoXG4gICAgICAgICAgKFwibnVtYmVyXCIgPT09IHR5cGVvZiB0eXBlLnRhZyAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoKS4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgICApLFxuICAgICAgICAgIHR5cGUuJCR0eXBlb2YpXG4gICAgICAgICkge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gXCJQb3J0YWxcIjtcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IFwiQ29udGV4dFwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OU1VNRVJfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZS5fY29udGV4dC5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Db25zdW1lclwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgIHZhciBpbm5lclR5cGUgPSB0eXBlLnJlbmRlcjtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lO1xuICAgICAgICAgICAgdHlwZSB8fFxuICAgICAgICAgICAgICAoKHR5cGUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgXCJcIiksXG4gICAgICAgICAgICAgICh0eXBlID0gXCJcIiAhPT0gdHlwZSA/IFwiRm9yd2FyZFJlZihcIiArIHR5cGUgKyBcIilcIiA6IFwiRm9yd2FyZFJlZlwiKSk7XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChpbm5lclR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGwpLFxuICAgICAgICAgICAgICBudWxsICE9PSBpbm5lclR5cGVcbiAgICAgICAgICAgICAgICA/IGlubmVyVHlwZVxuICAgICAgICAgICAgICAgIDogZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgXCJNZW1vXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICBpbm5lclR5cGUgPSB0eXBlLl9wYXlsb2FkO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUoaW5uZXJUeXBlKSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0VGFza05hbWUodHlwZSkge1xuICAgICAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHJldHVybiBcIjw+XCI7XG4gICAgICBpZiAoXG4gICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiB0eXBlICYmXG4gICAgICAgIG51bGwgIT09IHR5cGUgJiZcbiAgICAgICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFXG4gICAgICApXG4gICAgICAgIHJldHVybiBcIjwuLi4+XCI7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcbiAgICAgICAgcmV0dXJuIG5hbWUgPyBcIjxcIiArIG5hbWUgKyBcIj5cIiA6IFwiPC4uLj5cIjtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgcmV0dXJuIFwiPC4uLj5cIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0T3duZXIoKSB7XG4gICAgICB2YXIgZGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkE7XG4gICAgICByZXR1cm4gbnVsbCA9PT0gZGlzcGF0Y2hlciA/IG51bGwgOiBkaXNwYXRjaGVyLmdldE93bmVyKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFVua25vd25Pd25lcigpIHtcbiAgICAgIHJldHVybiBFcnJvcihcInJlYWN0LXN0YWNrLXRvcC1mcmFtZVwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIFwia2V5XCIpKSB7XG4gICAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgXCJrZXlcIikuZ2V0O1xuICAgICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykgcmV0dXJuICExO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZvaWQgMCAhPT0gY29uZmlnLmtleTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gICAgICBmdW5jdGlvbiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkoKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duIHx8XG4gICAgICAgICAgKChzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9ICEwKSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lIHZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgcHJvcC4gKGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvc3BlY2lhbC1wcm9wcylcIixcbiAgICAgICAgICAgIGRpc3BsYXlOYW1lXG4gICAgICAgICAgKSk7XG4gICAgICB9XG4gICAgICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSAhMDtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgXCJrZXlcIiwge1xuICAgICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVsZW1lbnRSZWZHZXR0ZXJXaXRoRGVwcmVjYXRpb25XYXJuaW5nKCkge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodGhpcy50eXBlKTtcbiAgICAgIGRpZFdhcm5BYm91dEVsZW1lbnRSZWZbY29tcG9uZW50TmFtZV0gfHxcbiAgICAgICAgKChkaWRXYXJuQWJvdXRFbGVtZW50UmVmW2NvbXBvbmVudE5hbWVdID0gITApLFxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiQWNjZXNzaW5nIGVsZW1lbnQucmVmIHdhcyByZW1vdmVkIGluIFJlYWN0IDE5LiByZWYgaXMgbm93IGEgcmVndWxhciBwcm9wLiBJdCB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgSlNYIEVsZW1lbnQgdHlwZSBpbiBhIGZ1dHVyZSByZWxlYXNlLlwiXG4gICAgICAgICkpO1xuICAgICAgY29tcG9uZW50TmFtZSA9IHRoaXMucHJvcHMucmVmO1xuICAgICAgcmV0dXJuIHZvaWQgMCAhPT0gY29tcG9uZW50TmFtZSA/IGNvbXBvbmVudE5hbWUgOiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCBwcm9wcywgb3duZXIsIGRlYnVnU3RhY2ssIGRlYnVnVGFzaykge1xuICAgICAgdmFyIHJlZlByb3AgPSBwcm9wcy5yZWY7XG4gICAgICB0eXBlID0ge1xuICAgICAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICBfb3duZXI6IG93bmVyXG4gICAgICB9O1xuICAgICAgbnVsbCAhPT0gKHZvaWQgMCAhPT0gcmVmUHJvcCA/IHJlZlByb3AgOiBudWxsKVxuICAgICAgICA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcInJlZlwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgICAgIGdldDogZWxlbWVudFJlZkdldHRlcldpdGhEZXByZWNhdGlvbldhcm5pbmdcbiAgICAgICAgICB9KVxuICAgICAgICA6IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcInJlZlwiLCB7IGVudW1lcmFibGU6ICExLCB2YWx1ZTogbnVsbCB9KTtcbiAgICAgIHR5cGUuX3N0b3JlID0ge307XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZS5fc3RvcmUsIFwidmFsaWRhdGVkXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6IDBcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwiX2RlYnVnSW5mb1wiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiBudWxsXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcIl9kZWJ1Z1N0YWNrXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6IGRlYnVnU3RhY2tcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwiX2RlYnVnVGFza1wiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiBkZWJ1Z1Rhc2tcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmZyZWV6ZSAmJiAoT2JqZWN0LmZyZWV6ZSh0eXBlLnByb3BzKSwgT2JqZWN0LmZyZWV6ZSh0eXBlKSk7XG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xvbmVBbmRSZXBsYWNlS2V5KG9sZEVsZW1lbnQsIG5ld0tleSkge1xuICAgICAgbmV3S2V5ID0gUmVhY3RFbGVtZW50KFxuICAgICAgICBvbGRFbGVtZW50LnR5cGUsXG4gICAgICAgIG5ld0tleSxcbiAgICAgICAgb2xkRWxlbWVudC5wcm9wcyxcbiAgICAgICAgb2xkRWxlbWVudC5fb3duZXIsXG4gICAgICAgIG9sZEVsZW1lbnQuX2RlYnVnU3RhY2ssXG4gICAgICAgIG9sZEVsZW1lbnQuX2RlYnVnVGFza1xuICAgICAgKTtcbiAgICAgIG9sZEVsZW1lbnQuX3N0b3JlICYmXG4gICAgICAgIChuZXdLZXkuX3N0b3JlLnZhbGlkYXRlZCA9IG9sZEVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCk7XG4gICAgICByZXR1cm4gbmV3S2V5O1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlKSB7XG4gICAgICBpc1ZhbGlkRWxlbWVudChub2RlKVxuICAgICAgICA/IG5vZGUuX3N0b3JlICYmIChub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSAxKVxuICAgICAgICA6IFwib2JqZWN0XCIgPT09IHR5cGVvZiBub2RlICYmXG4gICAgICAgICAgbnVsbCAhPT0gbm9kZSAmJlxuICAgICAgICAgIG5vZGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSAmJlxuICAgICAgICAgIChcImZ1bGZpbGxlZFwiID09PSBub2RlLl9wYXlsb2FkLnN0YXR1c1xuICAgICAgICAgICAgPyBpc1ZhbGlkRWxlbWVudChub2RlLl9wYXlsb2FkLnZhbHVlKSAmJlxuICAgICAgICAgICAgICBub2RlLl9wYXlsb2FkLnZhbHVlLl9zdG9yZSAmJlxuICAgICAgICAgICAgICAobm9kZS5fcGF5bG9hZC52YWx1ZS5fc3RvcmUudmFsaWRhdGVkID0gMSlcbiAgICAgICAgICAgIDogbm9kZS5fc3RvcmUgJiYgKG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IDEpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2Ygb2JqZWN0ICYmXG4gICAgICAgIG51bGwgIT09IG9iamVjdCAmJlxuICAgICAgICBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRVxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZXNjYXBlKGtleSkge1xuICAgICAgdmFyIGVzY2FwZXJMb29rdXAgPSB7IFwiPVwiOiBcIj0wXCIsIFwiOlwiOiBcIj0yXCIgfTtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIFwiJFwiICtcbiAgICAgICAga2V5LnJlcGxhY2UoL1s9Ol0vZywgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgcmV0dXJuIGVzY2FwZXJMb29rdXBbbWF0Y2hdO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0RWxlbWVudEtleShlbGVtZW50LCBpbmRleCkge1xuICAgICAgcmV0dXJuIFwib2JqZWN0XCIgPT09IHR5cGVvZiBlbGVtZW50ICYmXG4gICAgICAgIG51bGwgIT09IGVsZW1lbnQgJiZcbiAgICAgICAgbnVsbCAhPSBlbGVtZW50LmtleVxuICAgICAgICA/IChjaGVja0tleVN0cmluZ0NvZXJjaW9uKGVsZW1lbnQua2V5KSwgZXNjYXBlKFwiXCIgKyBlbGVtZW50LmtleSkpXG4gICAgICAgIDogaW5kZXgudG9TdHJpbmcoMzYpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNvbHZlVGhlbmFibGUodGhlbmFibGUpIHtcbiAgICAgIHN3aXRjaCAodGhlbmFibGUuc3RhdHVzKSB7XG4gICAgICAgIGNhc2UgXCJmdWxmaWxsZWRcIjpcbiAgICAgICAgICByZXR1cm4gdGhlbmFibGUudmFsdWU7XG4gICAgICAgIGNhc2UgXCJyZWplY3RlZFwiOlxuICAgICAgICAgIHRocm93IHRoZW5hYmxlLnJlYXNvbjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBzd2l0Y2ggKFxuICAgICAgICAgICAgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0aGVuYWJsZS5zdGF0dXNcbiAgICAgICAgICAgICAgPyB0aGVuYWJsZS50aGVuKG5vb3AsIG5vb3ApXG4gICAgICAgICAgICAgIDogKCh0aGVuYWJsZS5zdGF0dXMgPSBcInBlbmRpbmdcIiksXG4gICAgICAgICAgICAgICAgdGhlbmFibGUudGhlbihcbiAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChmdWxmaWxsZWRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBcInBlbmRpbmdcIiA9PT0gdGhlbmFibGUuc3RhdHVzICYmXG4gICAgICAgICAgICAgICAgICAgICAgKCh0aGVuYWJsZS5zdGF0dXMgPSBcImZ1bGZpbGxlZFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAodGhlbmFibGUudmFsdWUgPSBmdWxmaWxsZWRWYWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBcInBlbmRpbmdcIiA9PT0gdGhlbmFibGUuc3RhdHVzICYmXG4gICAgICAgICAgICAgICAgICAgICAgKCh0aGVuYWJsZS5zdGF0dXMgPSBcInJlamVjdGVkXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICh0aGVuYWJsZS5yZWFzb24gPSBlcnJvcikpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgdGhlbmFibGUuc3RhdHVzKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgY2FzZSBcImZ1bGZpbGxlZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gdGhlbmFibGUudmFsdWU7XG4gICAgICAgICAgICBjYXNlIFwicmVqZWN0ZWRcIjpcbiAgICAgICAgICAgICAgdGhyb3cgdGhlbmFibGUucmVhc29uO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRocm93IHRoZW5hYmxlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXBJbnRvQXJyYXkoY2hpbGRyZW4sIGFycmF5LCBlc2NhcGVkUHJlZml4LCBuYW1lU29GYXIsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiBjaGlsZHJlbjtcbiAgICAgIGlmIChcInVuZGVmaW5lZFwiID09PSB0eXBlIHx8IFwiYm9vbGVhblwiID09PSB0eXBlKSBjaGlsZHJlbiA9IG51bGw7XG4gICAgICB2YXIgaW52b2tlQ2FsbGJhY2sgPSAhMTtcbiAgICAgIGlmIChudWxsID09PSBjaGlsZHJlbikgaW52b2tlQ2FsbGJhY2sgPSAhMDtcbiAgICAgIGVsc2VcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBcImJpZ2ludFwiOlxuICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICBpbnZva2VDYWxsYmFjayA9ICEwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgc3dpdGNoIChjaGlsZHJlbi4kJHR5cGVvZikge1xuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICAgICAgICBpbnZva2VDYWxsYmFjayA9ICEwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgKGludm9rZUNhbGxiYWNrID0gY2hpbGRyZW4uX2luaXQpLFxuICAgICAgICAgICAgICAgICAgbWFwSW50b0FycmF5KFxuICAgICAgICAgICAgICAgICAgICBpbnZva2VDYWxsYmFjayhjaGlsZHJlbi5fcGF5bG9hZCksXG4gICAgICAgICAgICAgICAgICAgIGFycmF5LFxuICAgICAgICAgICAgICAgICAgICBlc2NhcGVkUHJlZml4LFxuICAgICAgICAgICAgICAgICAgICBuYW1lU29GYXIsXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgaWYgKGludm9rZUNhbGxiYWNrKSB7XG4gICAgICAgIGludm9rZUNhbGxiYWNrID0gY2hpbGRyZW47XG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2soaW52b2tlQ2FsbGJhY2spO1xuICAgICAgICB2YXIgY2hpbGRLZXkgPVxuICAgICAgICAgIFwiXCIgPT09IG5hbWVTb0ZhciA/IFwiLlwiICsgZ2V0RWxlbWVudEtleShpbnZva2VDYWxsYmFjaywgMCkgOiBuYW1lU29GYXI7XG4gICAgICAgIGlzQXJyYXlJbXBsKGNhbGxiYWNrKVxuICAgICAgICAgID8gKChlc2NhcGVkUHJlZml4ID0gXCJcIiksXG4gICAgICAgICAgICBudWxsICE9IGNoaWxkS2V5ICYmXG4gICAgICAgICAgICAgIChlc2NhcGVkUHJlZml4ID1cbiAgICAgICAgICAgICAgICBjaGlsZEtleS5yZXBsYWNlKHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4LCBcIiQmL1wiKSArIFwiL1wiKSxcbiAgICAgICAgICAgIG1hcEludG9BcnJheShjYWxsYmFjaywgYXJyYXksIGVzY2FwZWRQcmVmaXgsIFwiXCIsIGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgOiBudWxsICE9IGNhbGxiYWNrICYmXG4gICAgICAgICAgICAoaXNWYWxpZEVsZW1lbnQoY2FsbGJhY2spICYmXG4gICAgICAgICAgICAgIChudWxsICE9IGNhbGxiYWNrLmtleSAmJlxuICAgICAgICAgICAgICAgICgoaW52b2tlQ2FsbGJhY2sgJiYgaW52b2tlQ2FsbGJhY2sua2V5ID09PSBjYWxsYmFjay5rZXkpIHx8XG4gICAgICAgICAgICAgICAgICBjaGVja0tleVN0cmluZ0NvZXJjaW9uKGNhbGxiYWNrLmtleSkpLFxuICAgICAgICAgICAgICAoZXNjYXBlZFByZWZpeCA9IGNsb25lQW5kUmVwbGFjZUtleShcbiAgICAgICAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgICAgICAgICBlc2NhcGVkUHJlZml4ICtcbiAgICAgICAgICAgICAgICAgIChudWxsID09IGNhbGxiYWNrLmtleSB8fFxuICAgICAgICAgICAgICAgICAgKGludm9rZUNhbGxiYWNrICYmIGludm9rZUNhbGxiYWNrLmtleSA9PT0gY2FsbGJhY2sua2V5KVxuICAgICAgICAgICAgICAgICAgICA/IFwiXCJcbiAgICAgICAgICAgICAgICAgICAgOiAoXCJcIiArIGNhbGxiYWNrLmtleSkucmVwbGFjZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4LFxuICAgICAgICAgICAgICAgICAgICAgICAgXCIkJi9cIlxuICAgICAgICAgICAgICAgICAgICAgICkgKyBcIi9cIikgK1xuICAgICAgICAgICAgICAgICAgY2hpbGRLZXlcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIFwiXCIgIT09IG5hbWVTb0ZhciAmJlxuICAgICAgICAgICAgICAgIG51bGwgIT0gaW52b2tlQ2FsbGJhY2sgJiZcbiAgICAgICAgICAgICAgICBpc1ZhbGlkRWxlbWVudChpbnZva2VDYWxsYmFjaykgJiZcbiAgICAgICAgICAgICAgICBudWxsID09IGludm9rZUNhbGxiYWNrLmtleSAmJlxuICAgICAgICAgICAgICAgIGludm9rZUNhbGxiYWNrLl9zdG9yZSAmJlxuICAgICAgICAgICAgICAgICFpbnZva2VDYWxsYmFjay5fc3RvcmUudmFsaWRhdGVkICYmXG4gICAgICAgICAgICAgICAgKGVzY2FwZWRQcmVmaXguX3N0b3JlLnZhbGlkYXRlZCA9IDIpLFxuICAgICAgICAgICAgICAoY2FsbGJhY2sgPSBlc2NhcGVkUHJlZml4KSksXG4gICAgICAgICAgICBhcnJheS5wdXNoKGNhbGxiYWNrKSk7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgICAgaW52b2tlQ2FsbGJhY2sgPSAwO1xuICAgICAgY2hpbGRLZXkgPSBcIlwiID09PSBuYW1lU29GYXIgPyBcIi5cIiA6IG5hbWVTb0ZhciArIFwiOlwiO1xuICAgICAgaWYgKGlzQXJyYXlJbXBsKGNoaWxkcmVuKSlcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKylcbiAgICAgICAgICAobmFtZVNvRmFyID0gY2hpbGRyZW5baV0pLFxuICAgICAgICAgICAgKHR5cGUgPSBjaGlsZEtleSArIGdldEVsZW1lbnRLZXkobmFtZVNvRmFyLCBpKSksXG4gICAgICAgICAgICAoaW52b2tlQ2FsbGJhY2sgKz0gbWFwSW50b0FycmF5KFxuICAgICAgICAgICAgICBuYW1lU29GYXIsXG4gICAgICAgICAgICAgIGFycmF5LFxuICAgICAgICAgICAgICBlc2NhcGVkUHJlZml4LFxuICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICBjYWxsYmFja1xuICAgICAgICAgICAgKSk7XG4gICAgICBlbHNlIGlmICgoKGkgPSBnZXRJdGVyYXRvckZuKGNoaWxkcmVuKSksIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGkpKVxuICAgICAgICBmb3IgKFxuICAgICAgICAgIGkgPT09IGNoaWxkcmVuLmVudHJpZXMgJiZcbiAgICAgICAgICAgIChkaWRXYXJuQWJvdXRNYXBzIHx8XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICBcIlVzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgbm90IHN1cHBvcnRlZC4gVXNlIGFuIGFycmF5IG9mIGtleWVkIFJlYWN0RWxlbWVudHMgaW5zdGVhZC5cIlxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgKGRpZFdhcm5BYm91dE1hcHMgPSAhMCkpLFxuICAgICAgICAgICAgY2hpbGRyZW4gPSBpLmNhbGwoY2hpbGRyZW4pLFxuICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgIShuYW1lU29GYXIgPSBjaGlsZHJlbi5uZXh0KCkpLmRvbmU7XG5cbiAgICAgICAgKVxuICAgICAgICAgIChuYW1lU29GYXIgPSBuYW1lU29GYXIudmFsdWUpLFxuICAgICAgICAgICAgKHR5cGUgPSBjaGlsZEtleSArIGdldEVsZW1lbnRLZXkobmFtZVNvRmFyLCBpKyspKSxcbiAgICAgICAgICAgIChpbnZva2VDYWxsYmFjayArPSBtYXBJbnRvQXJyYXkoXG4gICAgICAgICAgICAgIG5hbWVTb0ZhcixcbiAgICAgICAgICAgICAgYXJyYXksXG4gICAgICAgICAgICAgIGVzY2FwZWRQcmVmaXgsXG4gICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgIGNhbGxiYWNrXG4gICAgICAgICAgICApKTtcbiAgICAgIGVsc2UgaWYgKFwib2JqZWN0XCIgPT09IHR5cGUpIHtcbiAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGNoaWxkcmVuLnRoZW4pXG4gICAgICAgICAgcmV0dXJuIG1hcEludG9BcnJheShcbiAgICAgICAgICAgIHJlc29sdmVUaGVuYWJsZShjaGlsZHJlbiksXG4gICAgICAgICAgICBhcnJheSxcbiAgICAgICAgICAgIGVzY2FwZWRQcmVmaXgsXG4gICAgICAgICAgICBuYW1lU29GYXIsXG4gICAgICAgICAgICBjYWxsYmFja1xuICAgICAgICAgICk7XG4gICAgICAgIGFycmF5ID0gU3RyaW5nKGNoaWxkcmVuKTtcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6IFwiICtcbiAgICAgICAgICAgIChcIltvYmplY3QgT2JqZWN0XVwiID09PSBhcnJheVxuICAgICAgICAgICAgICA/IFwib2JqZWN0IHdpdGgga2V5cyB7XCIgKyBPYmplY3Qua2V5cyhjaGlsZHJlbikuam9pbihcIiwgXCIpICsgXCJ9XCJcbiAgICAgICAgICAgICAgOiBhcnJheSkgK1xuICAgICAgICAgICAgXCIpLiBJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5IGluc3RlYWQuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbnZva2VDYWxsYmFjaztcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmMsIGNvbnRleHQpIHtcbiAgICAgIGlmIChudWxsID09IGNoaWxkcmVuKSByZXR1cm4gY2hpbGRyZW47XG4gICAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgIGNvdW50ID0gMDtcbiAgICAgIG1hcEludG9BcnJheShjaGlsZHJlbiwgcmVzdWx0LCBcIlwiLCBcIlwiLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCBjaGlsZCwgY291bnQrKyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxhenlJbml0aWFsaXplcihwYXlsb2FkKSB7XG4gICAgICBpZiAoLTEgPT09IHBheWxvYWQuX3N0YXR1cykge1xuICAgICAgICB2YXIgaW9JbmZvID0gcGF5bG9hZC5faW9JbmZvO1xuICAgICAgICBudWxsICE9IGlvSW5mbyAmJiAoaW9JbmZvLnN0YXJ0ID0gaW9JbmZvLmVuZCA9IHBlcmZvcm1hbmNlLm5vdygpKTtcbiAgICAgICAgaW9JbmZvID0gcGF5bG9hZC5fcmVzdWx0O1xuICAgICAgICB2YXIgdGhlbmFibGUgPSBpb0luZm8oKTtcbiAgICAgICAgdGhlbmFibGUudGhlbihcbiAgICAgICAgICBmdW5jdGlvbiAobW9kdWxlT2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAoMCA9PT0gcGF5bG9hZC5fc3RhdHVzIHx8IC0xID09PSBwYXlsb2FkLl9zdGF0dXMpIHtcbiAgICAgICAgICAgICAgcGF5bG9hZC5fc3RhdHVzID0gMTtcbiAgICAgICAgICAgICAgcGF5bG9hZC5fcmVzdWx0ID0gbW9kdWxlT2JqZWN0O1xuICAgICAgICAgICAgICB2YXIgX2lvSW5mbyA9IHBheWxvYWQuX2lvSW5mbztcbiAgICAgICAgICAgICAgbnVsbCAhPSBfaW9JbmZvICYmIChfaW9JbmZvLmVuZCA9IHBlcmZvcm1hbmNlLm5vdygpKTtcbiAgICAgICAgICAgICAgdm9pZCAwID09PSB0aGVuYWJsZS5zdGF0dXMgJiZcbiAgICAgICAgICAgICAgICAoKHRoZW5hYmxlLnN0YXR1cyA9IFwiZnVsZmlsbGVkXCIpLFxuICAgICAgICAgICAgICAgICh0aGVuYWJsZS52YWx1ZSA9IG1vZHVsZU9iamVjdCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoMCA9PT0gcGF5bG9hZC5fc3RhdHVzIHx8IC0xID09PSBwYXlsb2FkLl9zdGF0dXMpIHtcbiAgICAgICAgICAgICAgcGF5bG9hZC5fc3RhdHVzID0gMjtcbiAgICAgICAgICAgICAgcGF5bG9hZC5fcmVzdWx0ID0gZXJyb3I7XG4gICAgICAgICAgICAgIHZhciBfaW9JbmZvMiA9IHBheWxvYWQuX2lvSW5mbztcbiAgICAgICAgICAgICAgbnVsbCAhPSBfaW9JbmZvMiAmJiAoX2lvSW5mbzIuZW5kID0gcGVyZm9ybWFuY2Uubm93KCkpO1xuICAgICAgICAgICAgICB2b2lkIDAgPT09IHRoZW5hYmxlLnN0YXR1cyAmJlxuICAgICAgICAgICAgICAgICgodGhlbmFibGUuc3RhdHVzID0gXCJyZWplY3RlZFwiKSwgKHRoZW5hYmxlLnJlYXNvbiA9IGVycm9yKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgICBpb0luZm8gPSBwYXlsb2FkLl9pb0luZm87XG4gICAgICAgIGlmIChudWxsICE9IGlvSW5mbykge1xuICAgICAgICAgIGlvSW5mby52YWx1ZSA9IHRoZW5hYmxlO1xuICAgICAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHRoZW5hYmxlLmRpc3BsYXlOYW1lO1xuICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBkaXNwbGF5TmFtZSAmJiAoaW9JbmZvLm5hbWUgPSBkaXNwbGF5TmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgLTEgPT09IHBheWxvYWQuX3N0YXR1cyAmJlxuICAgICAgICAgICgocGF5bG9hZC5fc3RhdHVzID0gMCksIChwYXlsb2FkLl9yZXN1bHQgPSB0aGVuYWJsZSkpO1xuICAgICAgfVxuICAgICAgaWYgKDEgPT09IHBheWxvYWQuX3N0YXR1cylcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAoaW9JbmZvID0gcGF5bG9hZC5fcmVzdWx0KSxcbiAgICAgICAgICB2b2lkIDAgPT09IGlvSW5mbyAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJsYXp5OiBFeHBlY3RlZCB0aGUgcmVzdWx0IG9mIGEgZHluYW1pYyBpbXBvcnQoKSBjYWxsLiBJbnN0ZWFkIHJlY2VpdmVkOiAlc1xcblxcbllvdXIgY29kZSBzaG91bGQgbG9vayBsaWtlOiBcXG4gIGNvbnN0IE15Q29tcG9uZW50ID0gbGF6eSgoKSA9PiBpbXBvcnQoJy4vTXlDb21wb25lbnQnKSlcXG5cXG5EaWQgeW91IGFjY2lkZW50YWxseSBwdXQgY3VybHkgYnJhY2VzIGFyb3VuZCB0aGUgaW1wb3J0P1wiLFxuICAgICAgICAgICAgICBpb0luZm9cbiAgICAgICAgICAgICksXG4gICAgICAgICAgXCJkZWZhdWx0XCIgaW4gaW9JbmZvIHx8XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcImxhenk6IEV4cGVjdGVkIHRoZSByZXN1bHQgb2YgYSBkeW5hbWljIGltcG9ydCgpIGNhbGwuIEluc3RlYWQgcmVjZWl2ZWQ6ICVzXFxuXFxuWW91ciBjb2RlIHNob3VsZCBsb29rIGxpa2U6IFxcbiAgY29uc3QgTXlDb21wb25lbnQgPSBsYXp5KCgpID0+IGltcG9ydCgnLi9NeUNvbXBvbmVudCcpKVwiLFxuICAgICAgICAgICAgICBpb0luZm9cbiAgICAgICAgICAgICksXG4gICAgICAgICAgaW9JbmZvLmRlZmF1bHRcbiAgICAgICAgKTtcbiAgICAgIHRocm93IHBheWxvYWQuX3Jlc3VsdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzb2x2ZURpc3BhdGNoZXIoKSB7XG4gICAgICB2YXIgZGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICBudWxsID09PSBkaXNwYXRjaGVyICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJJbnZhbGlkIGhvb2sgY2FsbC4gSG9va3MgY2FuIG9ubHkgYmUgY2FsbGVkIGluc2lkZSBvZiB0aGUgYm9keSBvZiBhIGZ1bmN0aW9uIGNvbXBvbmVudC4gVGhpcyBjb3VsZCBoYXBwZW4gZm9yIG9uZSBvZiB0aGUgZm9sbG93aW5nIHJlYXNvbnM6XFxuMS4gWW91IG1pZ2h0IGhhdmUgbWlzbWF0Y2hpbmcgdmVyc2lvbnMgb2YgUmVhY3QgYW5kIHRoZSByZW5kZXJlciAoc3VjaCBhcyBSZWFjdCBET00pXFxuMi4gWW91IG1pZ2h0IGJlIGJyZWFraW5nIHRoZSBSdWxlcyBvZiBIb29rc1xcbjMuIFlvdSBtaWdodCBoYXZlIG1vcmUgdGhhbiBvbmUgY29weSBvZiBSZWFjdCBpbiB0aGUgc2FtZSBhcHBcXG5TZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9pbnZhbGlkLWhvb2stY2FsbCBmb3IgdGlwcyBhYm91dCBob3cgdG8gZGVidWcgYW5kIGZpeCB0aGlzIHByb2JsZW0uXCJcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiBkaXNwYXRjaGVyO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWxlYXNlQXN5bmNUcmFuc2l0aW9uKCkge1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuYXN5bmNUcmFuc2l0aW9ucy0tO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbnF1ZXVlVGFzayh0YXNrKSB7XG4gICAgICBpZiAobnVsbCA9PT0gZW5xdWV1ZVRhc2tJbXBsKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciByZXF1aXJlU3RyaW5nID0gKFwicmVxdWlyZVwiICsgTWF0aC5yYW5kb20oKSkuc2xpY2UoMCwgNyk7XG4gICAgICAgICAgZW5xdWV1ZVRhc2tJbXBsID0gKG1vZHVsZSAmJiBtb2R1bGVbcmVxdWlyZVN0cmluZ10pLmNhbGwoXG4gICAgICAgICAgICBtb2R1bGUsXG4gICAgICAgICAgICBcInRpbWVyc1wiXG4gICAgICAgICAgKS5zZXRJbW1lZGlhdGU7XG4gICAgICAgIH0gY2F0Y2ggKF9lcnIpIHtcbiAgICAgICAgICBlbnF1ZXVlVGFza0ltcGwgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICExID09PSBkaWRXYXJuQWJvdXRNZXNzYWdlQ2hhbm5lbCAmJlxuICAgICAgICAgICAgICAoKGRpZFdhcm5BYm91dE1lc3NhZ2VDaGFubmVsID0gITApLFxuICAgICAgICAgICAgICBcInVuZGVmaW5lZFwiID09PSB0eXBlb2YgTWVzc2FnZUNoYW5uZWwgJiZcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJUaGlzIGJyb3dzZXIgZG9lcyBub3QgaGF2ZSBhIE1lc3NhZ2VDaGFubmVsIGltcGxlbWVudGF0aW9uLCBzbyBlbnF1ZXVpbmcgdGFza3MgdmlhIGF3YWl0IGFjdChhc3luYyAoKSA9PiAuLi4pIHdpbGwgZmFpbC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUgYXQgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3VlcyBpZiB5b3UgZW5jb3VudGVyIHRoaXMgd2FybmluZy5cIlxuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gY2FsbGJhY2s7XG4gICAgICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKHZvaWQgMCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgcmV0dXJuIGVucXVldWVUYXNrSW1wbCh0YXNrKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWdncmVnYXRlRXJyb3JzKGVycm9ycykge1xuICAgICAgcmV0dXJuIDEgPCBlcnJvcnMubGVuZ3RoICYmIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIEFnZ3JlZ2F0ZUVycm9yXG4gICAgICAgID8gbmV3IEFnZ3JlZ2F0ZUVycm9yKGVycm9ycylcbiAgICAgICAgOiBlcnJvcnNbMF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvcEFjdFNjb3BlKHByZXZBY3RRdWV1ZSwgcHJldkFjdFNjb3BlRGVwdGgpIHtcbiAgICAgIHByZXZBY3RTY29wZURlcHRoICE9PSBhY3RTY29wZURlcHRoIC0gMSAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiWW91IHNlZW0gdG8gaGF2ZSBvdmVybGFwcGluZyBhY3QoKSBjYWxscywgdGhpcyBpcyBub3Qgc3VwcG9ydGVkLiBCZSBzdXJlIHRvIGF3YWl0IHByZXZpb3VzIGFjdCgpIGNhbGxzIGJlZm9yZSBtYWtpbmcgYSBuZXcgb25lLiBcIlxuICAgICAgICApO1xuICAgICAgYWN0U2NvcGVEZXB0aCA9IHByZXZBY3RTY29wZURlcHRoO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWN1cnNpdmVseUZsdXNoQXN5bmNBY3RXb3JrKHJldHVyblZhbHVlLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBxdWV1ZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlO1xuICAgICAgaWYgKG51bGwgIT09IHF1ZXVlKVxuICAgICAgICBpZiAoMCAhPT0gcXVldWUubGVuZ3RoKVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmbHVzaEFjdFF1ZXVlKHF1ZXVlKTtcbiAgICAgICAgICAgIGVucXVldWVUYXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlY3Vyc2l2ZWx5Rmx1c2hBc3luY0FjdFdvcmsocmV0dXJuVmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMudGhyb3duRXJyb3JzLnB1c2goZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgZWxzZSBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZSA9IG51bGw7XG4gICAgICAwIDwgUmVhY3RTaGFyZWRJbnRlcm5hbHMudGhyb3duRXJyb3JzLmxlbmd0aFxuICAgICAgICA/ICgocXVldWUgPSBhZ2dyZWdhdGVFcnJvcnMoUmVhY3RTaGFyZWRJbnRlcm5hbHMudGhyb3duRXJyb3JzKSksXG4gICAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLnRocm93bkVycm9ycy5sZW5ndGggPSAwKSxcbiAgICAgICAgICByZWplY3QocXVldWUpKVxuICAgICAgICA6IHJlc29sdmUocmV0dXJuVmFsdWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmbHVzaEFjdFF1ZXVlKHF1ZXVlKSB7XG4gICAgICBpZiAoIWlzRmx1c2hpbmcpIHtcbiAgICAgICAgaXNGbHVzaGluZyA9ICEwO1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yICg7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gcXVldWVbaV07XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmRpZFVzZVByb21pc2UgPSAhMTtcbiAgICAgICAgICAgICAgdmFyIGNvbnRpbnVhdGlvbiA9IGNhbGxiYWNrKCExKTtcbiAgICAgICAgICAgICAgaWYgKG51bGwgIT09IGNvbnRpbnVhdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChSZWFjdFNoYXJlZEludGVybmFscy5kaWRVc2VQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICBxdWV1ZVtpXSA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgICAgICAgcXVldWUuc3BsaWNlKDAsIGkpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGNvbnRpbnVhdGlvbjtcbiAgICAgICAgICAgICAgfSBlbHNlIGJyZWFrO1xuICAgICAgICAgICAgfSB3aGlsZSAoMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgcXVldWUuc3BsaWNlKDAsIGkgKyAxKSwgUmVhY3RTaGFyZWRJbnRlcm5hbHMudGhyb3duRXJyb3JzLnB1c2goZXJyb3IpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlzRmx1c2hpbmcgPSAhMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICYmXG4gICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0ICYmXG4gICAgICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0KEVycm9yKCkpO1xuICAgIHZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QudHJhbnNpdGlvbmFsLmVsZW1lbnRcIiksXG4gICAgICBSRUFDVF9QT1JUQUxfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wb3J0YWxcIiksXG4gICAgICBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpLFxuICAgICAgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKSxcbiAgICAgIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucHJvZmlsZXJcIiksXG4gICAgICBSRUFDVF9DT05TVU1FUl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnN1bWVyXCIpLFxuICAgICAgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnRleHRcIiksXG4gICAgICBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmZvcndhcmRfcmVmXCIpLFxuICAgICAgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZVwiKSxcbiAgICAgIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZV9saXN0XCIpLFxuICAgICAgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9cIiksXG4gICAgICBSRUFDVF9MQVpZX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QubGF6eVwiKSxcbiAgICAgIFJFQUNUX0FDVElWSVRZX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuYWN0aXZpdHlcIiksXG4gICAgICBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSBTeW1ib2wuaXRlcmF0b3IsXG4gICAgICBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQgPSB7fSxcbiAgICAgIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0ge1xuICAgICAgICBpc01vdW50ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgIH0sXG4gICAgICAgIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgICAgICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsIFwiZm9yY2VVcGRhdGVcIik7XG4gICAgICAgIH0sXG4gICAgICAgIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgICAgICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCBcInJlcGxhY2VTdGF0ZVwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICAgICAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgXCJzZXRTdGF0ZVwiKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGFzc2lnbiA9IE9iamVjdC5hc3NpZ24sXG4gICAgICBlbXB0eU9iamVjdCA9IHt9O1xuICAgIE9iamVjdC5mcmVlemUoZW1wdHlPYmplY3QpO1xuICAgIENvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IHt9O1xuICAgIENvbXBvbmVudC5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAocGFydGlhbFN0YXRlLCBjYWxsYmFjaykge1xuICAgICAgaWYgKFxuICAgICAgICBcIm9iamVjdFwiICE9PSB0eXBlb2YgcGFydGlhbFN0YXRlICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHBhcnRpYWxTdGF0ZSAmJlxuICAgICAgICBudWxsICE9IHBhcnRpYWxTdGF0ZVxuICAgICAgKVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcInRha2VzIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMgdG8gdXBkYXRlIG9yIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzLlwiXG4gICAgICAgICk7XG4gICAgICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZVNldFN0YXRlKHRoaXMsIHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2ssIFwic2V0U3RhdGVcIik7XG4gICAgfTtcbiAgICBDb21wb25lbnQucHJvdG90eXBlLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUZvcmNlVXBkYXRlKHRoaXMsIGNhbGxiYWNrLCBcImZvcmNlVXBkYXRlXCIpO1xuICAgIH07XG4gICAgdmFyIGRlcHJlY2F0ZWRBUElzID0ge1xuICAgICAgaXNNb3VudGVkOiBbXG4gICAgICAgIFwiaXNNb3VudGVkXCIsXG4gICAgICAgIFwiSW5zdGVhZCwgbWFrZSBzdXJlIHRvIGNsZWFuIHVwIHN1YnNjcmlwdGlvbnMgYW5kIHBlbmRpbmcgcmVxdWVzdHMgaW4gY29tcG9uZW50V2lsbFVubW91bnQgdG8gcHJldmVudCBtZW1vcnkgbGVha3MuXCJcbiAgICAgIF0sXG4gICAgICByZXBsYWNlU3RhdGU6IFtcbiAgICAgICAgXCJyZXBsYWNlU3RhdGVcIixcbiAgICAgICAgXCJSZWZhY3RvciB5b3VyIGNvZGUgdG8gdXNlIHNldFN0YXRlIGluc3RlYWQgKHNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzMyMzYpLlwiXG4gICAgICBdXG4gICAgfTtcbiAgICBmb3IgKGZuTmFtZSBpbiBkZXByZWNhdGVkQVBJcylcbiAgICAgIGRlcHJlY2F0ZWRBUElzLmhhc093blByb3BlcnR5KGZuTmFtZSkgJiZcbiAgICAgICAgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nKGZuTmFtZSwgZGVwcmVjYXRlZEFQSXNbZm5OYW1lXSk7XG4gICAgQ29tcG9uZW50RHVtbXkucHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgICBkZXByZWNhdGVkQVBJcyA9IFB1cmVDb21wb25lbnQucHJvdG90eXBlID0gbmV3IENvbXBvbmVudER1bW15KCk7XG4gICAgZGVwcmVjYXRlZEFQSXMuY29uc3RydWN0b3IgPSBQdXJlQ29tcG9uZW50O1xuICAgIGFzc2lnbihkZXByZWNhdGVkQVBJcywgQ29tcG9uZW50LnByb3RvdHlwZSk7XG4gICAgZGVwcmVjYXRlZEFQSXMuaXNQdXJlUmVhY3RDb21wb25lbnQgPSAhMDtcbiAgICB2YXIgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5LFxuICAgICAgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jbGllbnQucmVmZXJlbmNlXCIpLFxuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSB7XG4gICAgICAgIEg6IG51bGwsXG4gICAgICAgIEE6IG51bGwsXG4gICAgICAgIFQ6IG51bGwsXG4gICAgICAgIFM6IG51bGwsXG4gICAgICAgIGFjdFF1ZXVlOiBudWxsLFxuICAgICAgICBhc3luY1RyYW5zaXRpb25zOiAwLFxuICAgICAgICBpc0JhdGNoaW5nTGVnYWN5OiAhMSxcbiAgICAgICAgZGlkU2NoZWR1bGVMZWdhY3lVcGRhdGU6ICExLFxuICAgICAgICBkaWRVc2VQcm9taXNlOiAhMSxcbiAgICAgICAgdGhyb3duRXJyb3JzOiBbXSxcbiAgICAgICAgZ2V0Q3VycmVudFN0YWNrOiBudWxsLFxuICAgICAgICByZWNlbnRseUNyZWF0ZWRPd25lclN0YWNrczogMFxuICAgICAgfSxcbiAgICAgIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxcbiAgICAgIGNyZWF0ZVRhc2sgPSBjb25zb2xlLmNyZWF0ZVRhc2tcbiAgICAgICAgPyBjb25zb2xlLmNyZWF0ZVRhc2tcbiAgICAgICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9O1xuICAgIGRlcHJlY2F0ZWRBUElzID0ge1xuICAgICAgcmVhY3Rfc3RhY2tfYm90dG9tX2ZyYW1lOiBmdW5jdGlvbiAoY2FsbFN0YWNrRm9yRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxTdGFja0ZvckVycm9yKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24sIGRpZFdhcm5BYm91dE9sZEpTWFJ1bnRpbWU7XG4gICAgdmFyIGRpZFdhcm5BYm91dEVsZW1lbnRSZWYgPSB7fTtcbiAgICB2YXIgdW5rbm93bk93bmVyRGVidWdTdGFjayA9IGRlcHJlY2F0ZWRBUElzLnJlYWN0X3N0YWNrX2JvdHRvbV9mcmFtZS5iaW5kKFxuICAgICAgZGVwcmVjYXRlZEFQSXMsXG4gICAgICBVbmtub3duT3duZXJcbiAgICApKCk7XG4gICAgdmFyIHVua25vd25Pd25lckRlYnVnVGFzayA9IGNyZWF0ZVRhc2soZ2V0VGFza05hbWUoVW5rbm93bk93bmVyKSk7XG4gICAgdmFyIGRpZFdhcm5BYm91dE1hcHMgPSAhMSxcbiAgICAgIHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4ID0gL1xcLysvZyxcbiAgICAgIHJlcG9ydEdsb2JhbEVycm9yID1cbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcmVwb3J0RXJyb3JcbiAgICAgICAgICA/IHJlcG9ydEVycm9yXG4gICAgICAgICAgOiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiB3aW5kb3cgJiZcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB3aW5kb3cuRXJyb3JFdmVudFxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnQgPSBuZXcgd2luZG93LkVycm9yRXZlbnQoXCJlcnJvclwiLCB7XG4gICAgICAgICAgICAgICAgICBidWJibGVzOiAhMCxcbiAgICAgICAgICAgICAgICAgIGNhbmNlbGFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZTpcbiAgICAgICAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGVycm9yICYmXG4gICAgICAgICAgICAgICAgICAgIG51bGwgIT09IGVycm9yICYmXG4gICAgICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBlcnJvci5tZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgPyBTdHJpbmcoZXJyb3IubWVzc2FnZSlcbiAgICAgICAgICAgICAgICAgICAgICA6IFN0cmluZyhlcnJvciksXG4gICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3JcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIXdpbmRvdy5kaXNwYXRjaEV2ZW50KGV2ZW50KSkgcmV0dXJuO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBwcm9jZXNzICYmXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcHJvY2Vzcy5lbWl0XG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHByb2Nlc3MuZW1pdChcInVuY2F1Z2h0RXhjZXB0aW9uXCIsIGVycm9yKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9LFxuICAgICAgZGlkV2FybkFib3V0TWVzc2FnZUNoYW5uZWwgPSAhMSxcbiAgICAgIGVucXVldWVUYXNrSW1wbCA9IG51bGwsXG4gICAgICBhY3RTY29wZURlcHRoID0gMCxcbiAgICAgIGRpZFdhcm5Ob0F3YWl0QWN0ID0gITEsXG4gICAgICBpc0ZsdXNoaW5nID0gITEsXG4gICAgICBxdWV1ZVNldmVyYWxNaWNyb3Rhc2tzID1cbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcXVldWVNaWNyb3Rhc2tcbiAgICAgICAgICA/IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICBxdWV1ZU1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHF1ZXVlTWljcm90YXNrKGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgOiBlbnF1ZXVlVGFzaztcbiAgICBkZXByZWNhdGVkQVBJcyA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgX19wcm90b19fOiBudWxsLFxuICAgICAgYzogZnVuY3Rpb24gKHNpemUpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVEaXNwYXRjaGVyKCkudXNlTWVtb0NhY2hlKHNpemUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBmbk5hbWUgPSB7XG4gICAgICBtYXA6IG1hcENoaWxkcmVuLFxuICAgICAgZm9yRWFjaDogZnVuY3Rpb24gKGNoaWxkcmVuLCBmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpIHtcbiAgICAgICAgbWFwQ2hpbGRyZW4oXG4gICAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZm9yRWFjaEZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZvckVhY2hDb250ZXh0XG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgY291bnQ6IGZ1bmN0aW9uIChjaGlsZHJlbikge1xuICAgICAgICB2YXIgbiA9IDA7XG4gICAgICAgIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgbisrO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG47XG4gICAgICB9LFxuICAgICAgdG9BcnJheTogZnVuY3Rpb24gKGNoaWxkcmVuKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgICAgIH0pIHx8IFtdXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgb25seTogZnVuY3Rpb24gKGNoaWxkcmVuKSB7XG4gICAgICAgIGlmICghaXNWYWxpZEVsZW1lbnQoY2hpbGRyZW4pKVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJSZWFjdC5DaGlsZHJlbi5vbmx5IGV4cGVjdGVkIHRvIHJlY2VpdmUgYSBzaW5nbGUgUmVhY3QgZWxlbWVudCBjaGlsZC5cIlxuICAgICAgICAgICk7XG4gICAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICAgIH1cbiAgICB9O1xuICAgIGV4cG9ydHMuQWN0aXZpdHkgPSBSRUFDVF9BQ1RJVklUWV9UWVBFO1xuICAgIGV4cG9ydHMuQ2hpbGRyZW4gPSBmbk5hbWU7XG4gICAgZXhwb3J0cy5Db21wb25lbnQgPSBDb21wb25lbnQ7XG4gICAgZXhwb3J0cy5GcmFnbWVudCA9IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG4gICAgZXhwb3J0cy5Qcm9maWxlciA9IFJFQUNUX1BST0ZJTEVSX1RZUEU7XG4gICAgZXhwb3J0cy5QdXJlQ29tcG9uZW50ID0gUHVyZUNvbXBvbmVudDtcbiAgICBleHBvcnRzLlN0cmljdE1vZGUgPSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xuICAgIGV4cG9ydHMuU3VzcGVuc2UgPSBSRUFDVF9TVVNQRU5TRV9UWVBFO1xuICAgIGV4cG9ydHMuX19DTElFTlRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfV0FSTl9VU0VSU19USEVZX0NBTk5PVF9VUEdSQURFID1cbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzO1xuICAgIGV4cG9ydHMuX19DT01QSUxFUl9SVU5USU1FID0gZGVwcmVjYXRlZEFQSXM7XG4gICAgZXhwb3J0cy5hY3QgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgIHZhciBwcmV2QWN0UXVldWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZSxcbiAgICAgICAgcHJldkFjdFNjb3BlRGVwdGggPSBhY3RTY29wZURlcHRoO1xuICAgICAgYWN0U2NvcGVEZXB0aCsrO1xuICAgICAgdmFyIHF1ZXVlID0gKFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlID1cbiAgICAgICAgICBudWxsICE9PSBwcmV2QWN0UXVldWUgPyBwcmV2QWN0UXVldWUgOiBbXSksXG4gICAgICAgIGRpZEF3YWl0QWN0Q2FsbCA9ICExO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGNhbGxiYWNrKCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy50aHJvd25FcnJvcnMucHVzaChlcnJvcik7XG4gICAgICB9XG4gICAgICBpZiAoMCA8IFJlYWN0U2hhcmVkSW50ZXJuYWxzLnRocm93bkVycm9ycy5sZW5ndGgpXG4gICAgICAgIHRocm93IChcbiAgICAgICAgICAocG9wQWN0U2NvcGUocHJldkFjdFF1ZXVlLCBwcmV2QWN0U2NvcGVEZXB0aCksXG4gICAgICAgICAgKGNhbGxiYWNrID0gYWdncmVnYXRlRXJyb3JzKFJlYWN0U2hhcmVkSW50ZXJuYWxzLnRocm93bkVycm9ycykpLFxuICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy50aHJvd25FcnJvcnMubGVuZ3RoID0gMCksXG4gICAgICAgICAgY2FsbGJhY2spXG4gICAgICAgICk7XG4gICAgICBpZiAoXG4gICAgICAgIG51bGwgIT09IHJlc3VsdCAmJlxuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgcmVzdWx0ICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHJlc3VsdC50aGVuXG4gICAgICApIHtcbiAgICAgICAgdmFyIHRoZW5hYmxlID0gcmVzdWx0O1xuICAgICAgICBxdWV1ZVNldmVyYWxNaWNyb3Rhc2tzKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBkaWRBd2FpdEFjdENhbGwgfHxcbiAgICAgICAgICAgIGRpZFdhcm5Ob0F3YWl0QWN0IHx8XG4gICAgICAgICAgICAoKGRpZFdhcm5Ob0F3YWl0QWN0ID0gITApLFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJZb3UgY2FsbGVkIGFjdChhc3luYyAoKSA9PiAuLi4pIHdpdGhvdXQgYXdhaXQuIFRoaXMgY291bGQgbGVhZCB0byB1bmV4cGVjdGVkIHRlc3RpbmcgYmVoYXZpb3VyLCBpbnRlcmxlYXZpbmcgbXVsdGlwbGUgYWN0IGNhbGxzIGFuZCBtaXhpbmcgdGhlaXIgc2NvcGVzLiBZb3Ugc2hvdWxkIC0gYXdhaXQgYWN0KGFzeW5jICgpID0+IC4uLik7XCJcbiAgICAgICAgICAgICkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0aGVuOiBmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBkaWRBd2FpdEFjdENhbGwgPSAhMDtcbiAgICAgICAgICAgIHRoZW5hYmxlLnRoZW4oXG4gICAgICAgICAgICAgIGZ1bmN0aW9uIChyZXR1cm5WYWx1ZSkge1xuICAgICAgICAgICAgICAgIHBvcEFjdFNjb3BlKHByZXZBY3RRdWV1ZSwgcHJldkFjdFNjb3BlRGVwdGgpO1xuICAgICAgICAgICAgICAgIGlmICgwID09PSBwcmV2QWN0U2NvcGVEZXB0aCkge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZmx1c2hBY3RRdWV1ZShxdWV1ZSksXG4gICAgICAgICAgICAgICAgICAgICAgZW5xdWV1ZVRhc2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlY3Vyc2l2ZWx5Rmx1c2hBc3luY0FjdFdvcmsoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3RcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvciQwKSB7XG4gICAgICAgICAgICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLnRocm93bkVycm9ycy5wdXNoKGVycm9yJDApO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKDAgPCBSZWFjdFNoYXJlZEludGVybmFscy50aHJvd25FcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhyb3duRXJyb3IgPSBhZ2dyZWdhdGVFcnJvcnMoXG4gICAgICAgICAgICAgICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMudGhyb3duRXJyb3JzXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLnRocm93bkVycm9ycy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoX3Rocm93bkVycm9yKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgcmVzb2x2ZShyZXR1cm5WYWx1ZSk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHBvcEFjdFNjb3BlKHByZXZBY3RRdWV1ZSwgcHJldkFjdFNjb3BlRGVwdGgpO1xuICAgICAgICAgICAgICAgIDAgPCBSZWFjdFNoYXJlZEludGVybmFscy50aHJvd25FcnJvcnMubGVuZ3RoXG4gICAgICAgICAgICAgICAgICA/ICgoZXJyb3IgPSBhZ2dyZWdhdGVFcnJvcnMoXG4gICAgICAgICAgICAgICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMudGhyb3duRXJyb3JzXG4gICAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMudGhyb3duRXJyb3JzLmxlbmd0aCA9IDApLFxuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpKVxuICAgICAgICAgICAgICAgICAgOiByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHZhciByZXR1cm5WYWx1ZSRqc2NvbXAkMCA9IHJlc3VsdDtcbiAgICAgIHBvcEFjdFNjb3BlKHByZXZBY3RRdWV1ZSwgcHJldkFjdFNjb3BlRGVwdGgpO1xuICAgICAgMCA9PT0gcHJldkFjdFNjb3BlRGVwdGggJiZcbiAgICAgICAgKGZsdXNoQWN0UXVldWUocXVldWUpLFxuICAgICAgICAwICE9PSBxdWV1ZS5sZW5ndGggJiZcbiAgICAgICAgICBxdWV1ZVNldmVyYWxNaWNyb3Rhc2tzKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGRpZEF3YWl0QWN0Q2FsbCB8fFxuICAgICAgICAgICAgICBkaWRXYXJuTm9Bd2FpdEFjdCB8fFxuICAgICAgICAgICAgICAoKGRpZFdhcm5Ob0F3YWl0QWN0ID0gITApLFxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiQSBjb21wb25lbnQgc3VzcGVuZGVkIGluc2lkZSBhbiBgYWN0YCBzY29wZSwgYnV0IHRoZSBgYWN0YCBjYWxsIHdhcyBub3QgYXdhaXRlZC4gV2hlbiB0ZXN0aW5nIFJlYWN0IGNvbXBvbmVudHMgdGhhdCBkZXBlbmQgb24gYXN5bmNocm9ub3VzIGRhdGEsIHlvdSBtdXN0IGF3YWl0IHRoZSByZXN1bHQ6XFxuXFxuYXdhaXQgYWN0KCgpID0+IC4uLilcIlxuICAgICAgICAgICAgICApKTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlID0gbnVsbCkpO1xuICAgICAgaWYgKDAgPCBSZWFjdFNoYXJlZEludGVybmFscy50aHJvd25FcnJvcnMubGVuZ3RoKVxuICAgICAgICB0aHJvdyAoXG4gICAgICAgICAgKChjYWxsYmFjayA9IGFnZ3JlZ2F0ZUVycm9ycyhSZWFjdFNoYXJlZEludGVybmFscy50aHJvd25FcnJvcnMpKSxcbiAgICAgICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMudGhyb3duRXJyb3JzLmxlbmd0aCA9IDApLFxuICAgICAgICAgIGNhbGxiYWNrKVxuICAgICAgICApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGhlbjogZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGRpZEF3YWl0QWN0Q2FsbCA9ICEwO1xuICAgICAgICAgIDAgPT09IHByZXZBY3RTY29wZURlcHRoXG4gICAgICAgICAgICA/ICgoUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWUgPSBxdWV1ZSksXG4gICAgICAgICAgICAgIGVucXVldWVUYXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjdXJzaXZlbHlGbHVzaEFzeW5jQWN0V29yayhcbiAgICAgICAgICAgICAgICAgIHJldHVyblZhbHVlJGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgcmVzb2x2ZSxcbiAgICAgICAgICAgICAgICAgIHJlamVjdFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgOiByZXNvbHZlKHJldHVyblZhbHVlJGpzY29tcCQwKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuICAgIGV4cG9ydHMuY2FjaGUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9O1xuICAgIGV4cG9ydHMuY2FjaGVTaWduYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIGV4cG9ydHMuY2FwdHVyZU93bmVyU3RhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZ2V0Q3VycmVudFN0YWNrID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuZ2V0Q3VycmVudFN0YWNrO1xuICAgICAgcmV0dXJuIG51bGwgPT09IGdldEN1cnJlbnRTdGFjayA/IG51bGwgOiBnZXRDdXJyZW50U3RhY2soKTtcbiAgICB9O1xuICAgIGV4cG9ydHMuY2xvbmVFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgICAgIGlmIChudWxsID09PSBlbGVtZW50IHx8IHZvaWQgMCA9PT0gZWxlbWVudClcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJUaGUgYXJndW1lbnQgbXVzdCBiZSBhIFJlYWN0IGVsZW1lbnQsIGJ1dCB5b3UgcGFzc2VkIFwiICtcbiAgICAgICAgICAgIGVsZW1lbnQgK1xuICAgICAgICAgICAgXCIuXCJcbiAgICAgICAgKTtcbiAgICAgIHZhciBwcm9wcyA9IGFzc2lnbih7fSwgZWxlbWVudC5wcm9wcyksXG4gICAgICAgIGtleSA9IGVsZW1lbnQua2V5LFxuICAgICAgICBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgaWYgKG51bGwgIT0gY29uZmlnKSB7XG4gICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQ7XG4gICAgICAgIGE6IHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgXCJyZWZcIikgJiZcbiAgICAgICAgICAgIChKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFxuICAgICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICAgIFwicmVmXCJcbiAgICAgICAgICAgICkuZ2V0KSAmJlxuICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LmlzUmVhY3RXYXJuaW5nXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAhMTtcbiAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgfVxuICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IHZvaWQgMCAhPT0gY29uZmlnLnJlZjtcbiAgICAgICAgfVxuICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgJiYgKG93bmVyID0gZ2V0T3duZXIoKSk7XG4gICAgICAgIGhhc1ZhbGlkS2V5KGNvbmZpZykgJiZcbiAgICAgICAgICAoY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KSwgKGtleSA9IFwiXCIgKyBjb25maWcua2V5KSk7XG4gICAgICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKVxuICAgICAgICAgICFoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpIHx8XG4gICAgICAgICAgICBcImtleVwiID09PSBwcm9wTmFtZSB8fFxuICAgICAgICAgICAgXCJfX3NlbGZcIiA9PT0gcHJvcE5hbWUgfHxcbiAgICAgICAgICAgIFwiX19zb3VyY2VcIiA9PT0gcHJvcE5hbWUgfHxcbiAgICAgICAgICAgIChcInJlZlwiID09PSBwcm9wTmFtZSAmJiB2b2lkIDAgPT09IGNvbmZpZy5yZWYpIHx8XG4gICAgICAgICAgICAocHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXSk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcE5hbWUgPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgICAgIGlmICgxID09PSBwcm9wTmFtZSkgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgIGVsc2UgaWYgKDEgPCBwcm9wTmFtZSkge1xuICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSBBcnJheShwcm9wTmFtZSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcE5hbWU7IGkrKylcbiAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHRbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgICAgICBwcm9wcy5jaGlsZHJlbiA9IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdDtcbiAgICAgIH1cbiAgICAgIHByb3BzID0gUmVhY3RFbGVtZW50KFxuICAgICAgICBlbGVtZW50LnR5cGUsXG4gICAgICAgIGtleSxcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIG93bmVyLFxuICAgICAgICBlbGVtZW50Ll9kZWJ1Z1N0YWNrLFxuICAgICAgICBlbGVtZW50Ll9kZWJ1Z1Rhc2tcbiAgICAgICk7XG4gICAgICBmb3IgKGtleSA9IDI7IGtleSA8IGFyZ3VtZW50cy5sZW5ndGg7IGtleSsrKVxuICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNba2V5XSk7XG4gICAgICByZXR1cm4gcHJvcHM7XG4gICAgfTtcbiAgICBleHBvcnRzLmNyZWF0ZUNvbnRleHQgPSBmdW5jdGlvbiAoZGVmYXVsdFZhbHVlKSB7XG4gICAgICBkZWZhdWx0VmFsdWUgPSB7XG4gICAgICAgICQkdHlwZW9mOiBSRUFDVF9DT05URVhUX1RZUEUsXG4gICAgICAgIF9jdXJyZW50VmFsdWU6IGRlZmF1bHRWYWx1ZSxcbiAgICAgICAgX2N1cnJlbnRWYWx1ZTI6IGRlZmF1bHRWYWx1ZSxcbiAgICAgICAgX3RocmVhZENvdW50OiAwLFxuICAgICAgICBQcm92aWRlcjogbnVsbCxcbiAgICAgICAgQ29uc3VtZXI6IG51bGxcbiAgICAgIH07XG4gICAgICBkZWZhdWx0VmFsdWUuUHJvdmlkZXIgPSBkZWZhdWx0VmFsdWU7XG4gICAgICBkZWZhdWx0VmFsdWUuQ29uc3VtZXIgPSB7XG4gICAgICAgICQkdHlwZW9mOiBSRUFDVF9DT05TVU1FUl9UWVBFLFxuICAgICAgICBfY29udGV4dDogZGVmYXVsdFZhbHVlXG4gICAgICB9O1xuICAgICAgZGVmYXVsdFZhbHVlLl9jdXJyZW50UmVuZGVyZXIgPSBudWxsO1xuICAgICAgZGVmYXVsdFZhbHVlLl9jdXJyZW50UmVuZGVyZXIyID0gbnVsbDtcbiAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgfTtcbiAgICBleHBvcnRzLmNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwgY29uZmlnLCBjaGlsZHJlbikge1xuICAgICAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXG4gICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSk7XG4gICAgICBpID0ge307XG4gICAgICB2YXIga2V5ID0gbnVsbDtcbiAgICAgIGlmIChudWxsICE9IGNvbmZpZylcbiAgICAgICAgZm9yIChwcm9wTmFtZSBpbiAoZGlkV2FybkFib3V0T2xkSlNYUnVudGltZSB8fFxuICAgICAgICAgICEoXCJfX3NlbGZcIiBpbiBjb25maWcpIHx8XG4gICAgICAgICAgXCJrZXlcIiBpbiBjb25maWcgfHxcbiAgICAgICAgICAoKGRpZFdhcm5BYm91dE9sZEpTWFJ1bnRpbWUgPSAhMCksXG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgXCJZb3VyIGFwcCAob3Igb25lIG9mIGl0cyBkZXBlbmRlbmNpZXMpIGlzIHVzaW5nIGFuIG91dGRhdGVkIEpTWCB0cmFuc2Zvcm0uIFVwZGF0ZSB0byB0aGUgbW9kZXJuIEpTWCB0cmFuc2Zvcm0gZm9yIGZhc3RlciBwZXJmb3JtYW5jZTogaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9uZXctanN4LXRyYW5zZm9ybVwiXG4gICAgICAgICAgKSksXG4gICAgICAgIGhhc1ZhbGlkS2V5KGNvbmZpZykgJiZcbiAgICAgICAgICAoY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KSwgKGtleSA9IFwiXCIgKyBjb25maWcua2V5KSksXG4gICAgICAgIGNvbmZpZykpXG4gICAgICAgICAgaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJlxuICAgICAgICAgICAgXCJrZXlcIiAhPT0gcHJvcE5hbWUgJiZcbiAgICAgICAgICAgIFwiX19zZWxmXCIgIT09IHByb3BOYW1lICYmXG4gICAgICAgICAgICBcIl9fc291cmNlXCIgIT09IHByb3BOYW1lICYmXG4gICAgICAgICAgICAoaVtwcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdKTtcbiAgICAgIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICAgICAgaWYgKDEgPT09IGNoaWxkcmVuTGVuZ3RoKSBpLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICBlbHNlIGlmICgxIDwgY2hpbGRyZW5MZW5ndGgpIHtcbiAgICAgICAgZm9yIChcbiAgICAgICAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKSwgX2kgPSAwO1xuICAgICAgICAgIF9pIDwgY2hpbGRyZW5MZW5ndGg7XG4gICAgICAgICAgX2krK1xuICAgICAgICApXG4gICAgICAgICAgY2hpbGRBcnJheVtfaV0gPSBhcmd1bWVudHNbX2kgKyAyXTtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZSAmJiBPYmplY3QuZnJlZXplKGNoaWxkQXJyYXkpO1xuICAgICAgICBpLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKVxuICAgICAgICBmb3IgKHByb3BOYW1lIGluICgoY2hpbGRyZW5MZW5ndGggPSB0eXBlLmRlZmF1bHRQcm9wcyksIGNoaWxkcmVuTGVuZ3RoKSlcbiAgICAgICAgICB2b2lkIDAgPT09IGlbcHJvcE5hbWVdICYmIChpW3Byb3BOYW1lXSA9IGNoaWxkcmVuTGVuZ3RoW3Byb3BOYW1lXSk7XG4gICAgICBrZXkgJiZcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIoXG4gICAgICAgICAgaSxcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlXG4gICAgICAgICAgICA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IFwiVW5rbm93blwiXG4gICAgICAgICAgICA6IHR5cGVcbiAgICAgICAgKTtcbiAgICAgIHZhciBwcm9wTmFtZSA9IDFlNCA+IFJlYWN0U2hhcmVkSW50ZXJuYWxzLnJlY2VudGx5Q3JlYXRlZE93bmVyU3RhY2tzKys7XG4gICAgICByZXR1cm4gUmVhY3RFbGVtZW50KFxuICAgICAgICB0eXBlLFxuICAgICAgICBrZXksXG4gICAgICAgIGksXG4gICAgICAgIGdldE93bmVyKCksXG4gICAgICAgIHByb3BOYW1lID8gRXJyb3IoXCJyZWFjdC1zdGFjay10b3AtZnJhbWVcIikgOiB1bmtub3duT3duZXJEZWJ1Z1N0YWNrLFxuICAgICAgICBwcm9wTmFtZSA/IGNyZWF0ZVRhc2soZ2V0VGFza05hbWUodHlwZSkpIDogdW5rbm93bk93bmVyRGVidWdUYXNrXG4gICAgICApO1xuICAgIH07XG4gICAgZXhwb3J0cy5jcmVhdGVSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcmVmT2JqZWN0ID0geyBjdXJyZW50OiBudWxsIH07XG4gICAgICBPYmplY3Quc2VhbChyZWZPYmplY3QpO1xuICAgICAgcmV0dXJuIHJlZk9iamVjdDtcbiAgICB9O1xuICAgIGV4cG9ydHMuZm9yd2FyZFJlZiA9IGZ1bmN0aW9uIChyZW5kZXIpIHtcbiAgICAgIG51bGwgIT0gcmVuZGVyICYmIHJlbmRlci4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFXG4gICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiZm9yd2FyZFJlZiByZXF1aXJlcyBhIHJlbmRlciBmdW5jdGlvbiBidXQgcmVjZWl2ZWQgYSBgbWVtb2AgY29tcG9uZW50LiBJbnN0ZWFkIG9mIGZvcndhcmRSZWYobWVtbyguLi4pKSwgdXNlIG1lbW8oZm9yd2FyZFJlZiguLi4pKS5cIlxuICAgICAgICAgIClcbiAgICAgICAgOiBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiByZW5kZXJcbiAgICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiZm9yd2FyZFJlZiByZXF1aXJlcyBhIHJlbmRlciBmdW5jdGlvbiBidXQgd2FzIGdpdmVuICVzLlwiLFxuICAgICAgICAgICAgICBudWxsID09PSByZW5kZXIgPyBcIm51bGxcIiA6IHR5cGVvZiByZW5kZXJcbiAgICAgICAgICAgIClcbiAgICAgICAgICA6IDAgIT09IHJlbmRlci5sZW5ndGggJiZcbiAgICAgICAgICAgIDIgIT09IHJlbmRlci5sZW5ndGggJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiZm9yd2FyZFJlZiByZW5kZXIgZnVuY3Rpb25zIGFjY2VwdCBleGFjdGx5IHR3byBwYXJhbWV0ZXJzOiBwcm9wcyBhbmQgcmVmLiAlc1wiLFxuICAgICAgICAgICAgICAxID09PSByZW5kZXIubGVuZ3RoXG4gICAgICAgICAgICAgICAgPyBcIkRpZCB5b3UgZm9yZ2V0IHRvIHVzZSB0aGUgcmVmIHBhcmFtZXRlcj9cIlxuICAgICAgICAgICAgICAgIDogXCJBbnkgYWRkaXRpb25hbCBwYXJhbWV0ZXIgd2lsbCBiZSB1bmRlZmluZWQuXCJcbiAgICAgICAgICAgICk7XG4gICAgICBudWxsICE9IHJlbmRlciAmJlxuICAgICAgICBudWxsICE9IHJlbmRlci5kZWZhdWx0UHJvcHMgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcImZvcndhcmRSZWYgcmVuZGVyIGZ1bmN0aW9ucyBkbyBub3Qgc3VwcG9ydCBkZWZhdWx0UHJvcHMuIERpZCB5b3UgYWNjaWRlbnRhbGx5IHBhc3MgYSBSZWFjdCBjb21wb25lbnQ/XCJcbiAgICAgICAgKTtcbiAgICAgIHZhciBlbGVtZW50VHlwZSA9IHsgJCR0eXBlb2Y6IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUsIHJlbmRlcjogcmVuZGVyIH0sXG4gICAgICAgIG93bk5hbWU7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudFR5cGUsIFwiZGlzcGxheU5hbWVcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIG93bk5hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICBvd25OYW1lID0gbmFtZTtcbiAgICAgICAgICByZW5kZXIubmFtZSB8fFxuICAgICAgICAgICAgcmVuZGVyLmRpc3BsYXlOYW1lIHx8XG4gICAgICAgICAgICAoT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlbmRlciwgXCJuYW1lXCIsIHsgdmFsdWU6IG5hbWUgfSksXG4gICAgICAgICAgICAocmVuZGVyLmRpc3BsYXlOYW1lID0gbmFtZSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBlbGVtZW50VHlwZTtcbiAgICB9O1xuICAgIGV4cG9ydHMuaXNWYWxpZEVsZW1lbnQgPSBpc1ZhbGlkRWxlbWVudDtcbiAgICBleHBvcnRzLmxhenkgPSBmdW5jdGlvbiAoY3Rvcikge1xuICAgICAgY3RvciA9IHsgX3N0YXR1czogLTEsIF9yZXN1bHQ6IGN0b3IgfTtcbiAgICAgIHZhciBsYXp5VHlwZSA9IHtcbiAgICAgICAgICAkJHR5cGVvZjogUkVBQ1RfTEFaWV9UWVBFLFxuICAgICAgICAgIF9wYXlsb2FkOiBjdG9yLFxuICAgICAgICAgIF9pbml0OiBsYXp5SW5pdGlhbGl6ZXJcbiAgICAgICAgfSxcbiAgICAgICAgaW9JbmZvID0ge1xuICAgICAgICAgIG5hbWU6IFwibGF6eVwiLFxuICAgICAgICAgIHN0YXJ0OiAtMSxcbiAgICAgICAgICBlbmQ6IC0xLFxuICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgIG93bmVyOiBudWxsLFxuICAgICAgICAgIGRlYnVnU3RhY2s6IEVycm9yKFwicmVhY3Qtc3RhY2stdG9wLWZyYW1lXCIpLFxuICAgICAgICAgIGRlYnVnVGFzazogY29uc29sZS5jcmVhdGVUYXNrID8gY29uc29sZS5jcmVhdGVUYXNrKFwibGF6eSgpXCIpIDogbnVsbFxuICAgICAgICB9O1xuICAgICAgY3Rvci5faW9JbmZvID0gaW9JbmZvO1xuICAgICAgbGF6eVR5cGUuX2RlYnVnSW5mbyA9IFt7IGF3YWl0ZWQ6IGlvSW5mbyB9XTtcbiAgICAgIHJldHVybiBsYXp5VHlwZTtcbiAgICB9O1xuICAgIGV4cG9ydHMubWVtbyA9IGZ1bmN0aW9uICh0eXBlLCBjb21wYXJlKSB7XG4gICAgICBudWxsID09IHR5cGUgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIm1lbW86IFRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgY29tcG9uZW50LiBJbnN0ZWFkIHJlY2VpdmVkOiAlc1wiLFxuICAgICAgICAgIG51bGwgPT09IHR5cGUgPyBcIm51bGxcIiA6IHR5cGVvZiB0eXBlXG4gICAgICAgICk7XG4gICAgICBjb21wYXJlID0ge1xuICAgICAgICAkJHR5cGVvZjogUkVBQ1RfTUVNT19UWVBFLFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBjb21wYXJlOiB2b2lkIDAgPT09IGNvbXBhcmUgPyBudWxsIDogY29tcGFyZVxuICAgICAgfTtcbiAgICAgIHZhciBvd25OYW1lO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbXBhcmUsIFwiZGlzcGxheU5hbWVcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIG93bk5hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICBvd25OYW1lID0gbmFtZTtcbiAgICAgICAgICB0eXBlLm5hbWUgfHxcbiAgICAgICAgICAgIHR5cGUuZGlzcGxheU5hbWUgfHxcbiAgICAgICAgICAgIChPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJuYW1lXCIsIHsgdmFsdWU6IG5hbWUgfSksXG4gICAgICAgICAgICAodHlwZS5kaXNwbGF5TmFtZSA9IG5hbWUpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gY29tcGFyZTtcbiAgICB9O1xuICAgIGV4cG9ydHMuc3RhcnRUcmFuc2l0aW9uID0gZnVuY3Rpb24gKHNjb3BlKSB7XG4gICAgICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdFNoYXJlZEludGVybmFscy5ULFxuICAgICAgICBjdXJyZW50VHJhbnNpdGlvbiA9IHt9O1xuICAgICAgY3VycmVudFRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMgPSBuZXcgU2V0KCk7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5UID0gY3VycmVudFRyYW5zaXRpb247XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcmV0dXJuVmFsdWUgPSBzY29wZSgpLFxuICAgICAgICAgIG9uU3RhcnRUcmFuc2l0aW9uRmluaXNoID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUztcbiAgICAgICAgbnVsbCAhPT0gb25TdGFydFRyYW5zaXRpb25GaW5pc2ggJiZcbiAgICAgICAgICBvblN0YXJ0VHJhbnNpdGlvbkZpbmlzaChjdXJyZW50VHJhbnNpdGlvbiwgcmV0dXJuVmFsdWUpO1xuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgcmV0dXJuVmFsdWUgJiZcbiAgICAgICAgICBudWxsICE9PSByZXR1cm5WYWx1ZSAmJlxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHJldHVyblZhbHVlLnRoZW4gJiZcbiAgICAgICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuYXN5bmNUcmFuc2l0aW9ucysrLFxuICAgICAgICAgIHJldHVyblZhbHVlLnRoZW4ocmVsZWFzZUFzeW5jVHJhbnNpdGlvbiwgcmVsZWFzZUFzeW5jVHJhbnNpdGlvbiksXG4gICAgICAgICAgcmV0dXJuVmFsdWUudGhlbihub29wLCByZXBvcnRHbG9iYWxFcnJvcikpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmVwb3J0R2xvYmFsRXJyb3IoZXJyb3IpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgbnVsbCA9PT0gcHJldlRyYW5zaXRpb24gJiZcbiAgICAgICAgICBjdXJyZW50VHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycyAmJlxuICAgICAgICAgICgoc2NvcGUgPSBjdXJyZW50VHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycy5zaXplKSxcbiAgICAgICAgICBjdXJyZW50VHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycy5jbGVhcigpLFxuICAgICAgICAgIDEwIDwgc2NvcGUgJiZcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgXCJEZXRlY3RlZCBhIGxhcmdlIG51bWJlciBvZiB1cGRhdGVzIGluc2lkZSBzdGFydFRyYW5zaXRpb24uIElmIHRoaXMgaXMgZHVlIHRvIGEgc3Vic2NyaXB0aW9uIHBsZWFzZSByZS13cml0ZSBpdCB0byB1c2UgUmVhY3QgcHJvdmlkZWQgaG9va3MuIE90aGVyd2lzZSBjb25jdXJyZW50IG1vZGUgZ3VhcmFudGVlcyBhcmUgb2ZmIHRoZSB0YWJsZS5cIlxuICAgICAgICAgICAgKSksXG4gICAgICAgICAgbnVsbCAhPT0gcHJldlRyYW5zaXRpb24gJiZcbiAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnRUcmFuc2l0aW9uLnR5cGVzICYmXG4gICAgICAgICAgICAobnVsbCAhPT0gcHJldlRyYW5zaXRpb24udHlwZXMgJiZcbiAgICAgICAgICAgICAgcHJldlRyYW5zaXRpb24udHlwZXMgIT09IGN1cnJlbnRUcmFuc2l0aW9uLnR5cGVzICYmXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJXZSBleHBlY3RlZCBpbm5lciBUcmFuc2l0aW9ucyB0byBoYXZlIHRyYW5zZmVycmVkIHRoZSBvdXRlciB0eXBlcyBzZXQgYW5kIHRoYXQgeW91IGNhbm5vdCBhZGQgdG8gdGhlIG91dGVyIFRyYW5zaXRpb24gd2hpbGUgaW5zaWRlIHRoZSBpbm5lci5UaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAocHJldlRyYW5zaXRpb24udHlwZXMgPSBjdXJyZW50VHJhbnNpdGlvbi50eXBlcykpLFxuICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5UID0gcHJldlRyYW5zaXRpb24pO1xuICAgICAgfVxuICAgIH07XG4gICAgZXhwb3J0cy51bnN0YWJsZV91c2VDYWNoZVJlZnJlc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZURpc3BhdGNoZXIoKS51c2VDYWNoZVJlZnJlc2goKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXNlID0gZnVuY3Rpb24gKHVzYWJsZSkge1xuICAgICAgcmV0dXJuIHJlc29sdmVEaXNwYXRjaGVyKCkudXNlKHVzYWJsZSk7XG4gICAgfTtcbiAgICBleHBvcnRzLnVzZUFjdGlvblN0YXRlID0gZnVuY3Rpb24gKGFjdGlvbiwgaW5pdGlhbFN0YXRlLCBwZXJtYWxpbmspIHtcbiAgICAgIHJldHVybiByZXNvbHZlRGlzcGF0Y2hlcigpLnVzZUFjdGlvblN0YXRlKFxuICAgICAgICBhY3Rpb24sXG4gICAgICAgIGluaXRpYWxTdGF0ZSxcbiAgICAgICAgcGVybWFsaW5rXG4gICAgICApO1xuICAgIH07XG4gICAgZXhwb3J0cy51c2VDYWxsYmFjayA9IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICAgICAgcmV0dXJuIHJlc29sdmVEaXNwYXRjaGVyKCkudXNlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgIH07XG4gICAgZXhwb3J0cy51c2VDb250ZXh0ID0gZnVuY3Rpb24gKENvbnRleHQpIHtcbiAgICAgIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgICAgIENvbnRleHQuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlNVTUVSX1RZUEUgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkNhbGxpbmcgdXNlQ29udGV4dChDb250ZXh0LkNvbnN1bWVyKSBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIGNhdXNlIGJ1Z3MuIERpZCB5b3UgbWVhbiB0byBjYWxsIHVzZUNvbnRleHQoQ29udGV4dCkgaW5zdGVhZD9cIlxuICAgICAgICApO1xuICAgICAgcmV0dXJuIGRpc3BhdGNoZXIudXNlQ29udGV4dChDb250ZXh0KTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXNlRGVidWdWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgZm9ybWF0dGVyRm4pIHtcbiAgICAgIHJldHVybiByZXNvbHZlRGlzcGF0Y2hlcigpLnVzZURlYnVnVmFsdWUodmFsdWUsIGZvcm1hdHRlckZuKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXNlRGVmZXJyZWRWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZURpc3BhdGNoZXIoKS51c2VEZWZlcnJlZFZhbHVlKHZhbHVlLCBpbml0aWFsVmFsdWUpO1xuICAgIH07XG4gICAgZXhwb3J0cy51c2VFZmZlY3QgPSBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBudWxsID09IGNyZWF0ZSAmJlxuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgXCJSZWFjdCBIb29rIHVzZUVmZmVjdCByZXF1aXJlcyBhbiBlZmZlY3QgY2FsbGJhY2suIERpZCB5b3UgZm9yZ2V0IHRvIHBhc3MgYSBjYWxsYmFjayB0byB0aGUgaG9vaz9cIlxuICAgICAgICApO1xuICAgICAgcmV0dXJuIHJlc29sdmVEaXNwYXRjaGVyKCkudXNlRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfTtcbiAgICBleHBvcnRzLnVzZUVmZmVjdEV2ZW50ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZURpc3BhdGNoZXIoKS51c2VFZmZlY3RFdmVudChjYWxsYmFjayk7XG4gICAgfTtcbiAgICBleHBvcnRzLnVzZUlkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHJlc29sdmVEaXNwYXRjaGVyKCkudXNlSWQoKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXNlSW1wZXJhdGl2ZUhhbmRsZSA9IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgcmV0dXJuIHJlc29sdmVEaXNwYXRjaGVyKCkudXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG4gICAgfTtcbiAgICBleHBvcnRzLnVzZUluc2VydGlvbkVmZmVjdCA9IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIG51bGwgPT0gY3JlYXRlICYmXG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBcIlJlYWN0IEhvb2sgdXNlSW5zZXJ0aW9uRWZmZWN0IHJlcXVpcmVzIGFuIGVmZmVjdCBjYWxsYmFjay4gRGlkIHlvdSBmb3JnZXQgdG8gcGFzcyBhIGNhbGxiYWNrIHRvIHRoZSBob29rP1wiXG4gICAgICAgICk7XG4gICAgICByZXR1cm4gcmVzb2x2ZURpc3BhdGNoZXIoKS51c2VJbnNlcnRpb25FZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXNlTGF5b3V0RWZmZWN0ID0gZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgbnVsbCA9PSBjcmVhdGUgJiZcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIFwiUmVhY3QgSG9vayB1c2VMYXlvdXRFZmZlY3QgcmVxdWlyZXMgYW4gZWZmZWN0IGNhbGxiYWNrLiBEaWQgeW91IGZvcmdldCB0byBwYXNzIGEgY2FsbGJhY2sgdG8gdGhlIGhvb2s/XCJcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiByZXNvbHZlRGlzcGF0Y2hlcigpLnVzZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH07XG4gICAgZXhwb3J0cy51c2VNZW1vID0gZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgcmV0dXJuIHJlc29sdmVEaXNwYXRjaGVyKCkudXNlTWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgIH07XG4gICAgZXhwb3J0cy51c2VPcHRpbWlzdGljID0gZnVuY3Rpb24gKHBhc3N0aHJvdWdoLCByZWR1Y2VyKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZURpc3BhdGNoZXIoKS51c2VPcHRpbWlzdGljKHBhc3N0aHJvdWdoLCByZWR1Y2VyKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXNlUmVkdWNlciA9IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZURpc3BhdGNoZXIoKS51c2VSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgIH07XG4gICAgZXhwb3J0cy51c2VSZWYgPSBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZURpc3BhdGNoZXIoKS51c2VSZWYoaW5pdGlhbFZhbHVlKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXNlU3RhdGUgPSBmdW5jdGlvbiAoaW5pdGlhbFN0YXRlKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZURpc3BhdGNoZXIoKS51c2VTdGF0ZShpbml0aWFsU3RhdGUpO1xuICAgIH07XG4gICAgZXhwb3J0cy51c2VTeW5jRXh0ZXJuYWxTdG9yZSA9IGZ1bmN0aW9uIChcbiAgICAgIHN1YnNjcmliZSxcbiAgICAgIGdldFNuYXBzaG90LFxuICAgICAgZ2V0U2VydmVyU25hcHNob3RcbiAgICApIHtcbiAgICAgIHJldHVybiByZXNvbHZlRGlzcGF0Y2hlcigpLnVzZVN5bmNFeHRlcm5hbFN0b3JlKFxuICAgICAgICBzdWJzY3JpYmUsXG4gICAgICAgIGdldFNuYXBzaG90LFxuICAgICAgICBnZXRTZXJ2ZXJTbmFwc2hvdFxuICAgICAgKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXNlVHJhbnNpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiByZXNvbHZlRGlzcGF0Y2hlcigpLnVzZVRyYW5zaXRpb24oKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudmVyc2lvbiA9IFwiMTkuMi4wXCI7XG4gICAgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAmJlxuICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wICYmXG4gICAgICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AoRXJyb3IoKSk7XG4gIH0pKCk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react/cjs/react.development.js\n\n}");

/***/ }),

/***/ "./node_modules/react/index.js":
/*!*************************************!*\
  !*** ./node_modules/react/index.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("{\n\nif (false) // removed by dead control flow\n{} else {\n  module.exports = __webpack_require__(/*! ./cjs/react.development.js */ \"./node_modules/react/cjs/react.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsSUFBSSxLQUFxQyxFQUFFO0FBQUEsRUFFMUMsQ0FBQztBQUNGLEVBQUUsdUhBQXNEO0FBQ3hEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vU1NSLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2luZGV4LmpzP2FiNWIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LnByb2R1Y3Rpb24uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react/index.js\n\n}");

/***/ }),

/***/ "./node_modules/react/jsx-runtime.js":
/*!*******************************************!*\
  !*** ./node_modules/react/jsx-runtime.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("{\n\nif (false) // removed by dead control flow\n{} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-runtime.development.js */ \"./node_modules/react/cjs/react-jsx-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QvanN4LXJ1bnRpbWUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsSUFBSSxLQUFxQyxFQUFFO0FBQUEsRUFFMUMsQ0FBQztBQUNGLEVBQUUsK0lBQWtFO0FBQ3BFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vU1NSLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2pzeC1ydW50aW1lLmpzPzljYTUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1ydW50aW1lLnByb2R1Y3Rpb24uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react/jsx-runtime.js\n\n}");

/***/ }),

/***/ "./src/server/index.tsx":
/*!******************************!*\
  !*** ./src/server/index.tsx ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   render: () => (/* binding */ render)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"./node_modules/react/jsx-runtime.js\");\n/* harmony import */ var react_dom_server__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom/server */ \"./node_modules/react-dom/server.browser.js\");\n/* harmony import */ var _shared_App__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/App */ \"./src/shared/App.tsx\");\n\n\n\n// this function is called from Kotlin\nfunction render(jsonData) {\n    return react_dom_server__WEBPACK_IMPORTED_MODULE_1__.renderToString((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_shared_App__WEBPACK_IMPORTED_MODULE_2__.App, { data: jsonData }));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2VydmVyL2luZGV4LnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWdEO0FBQ0Y7QUFDVjtBQUNwQztBQUNPO0FBQ1AsV0FBVyw0REFBNkIsQ0FBQyxzREFBSSxDQUFDLDRDQUFHLElBQUksZ0JBQWdCO0FBQ3JFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vU1NSLy4vc3JjL3NlcnZlci9pbmRleC50c3g/OWJlYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBqc3ggYXMgX2pzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuaW1wb3J0IFJlYWN0RE9NU2VydmVyIGZyb20gJ3JlYWN0LWRvbS9zZXJ2ZXInO1xuaW1wb3J0IHsgQXBwIH0gZnJvbSAnLi4vc2hhcmVkL0FwcCc7XG4vLyB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBmcm9tIEtvdGxpblxuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcihqc29uRGF0YSkge1xuICAgIHJldHVybiBSZWFjdERPTVNlcnZlci5yZW5kZXJUb1N0cmluZyhfanN4KEFwcCwgeyBkYXRhOiBqc29uRGF0YSB9KSk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/server/index.tsx\n\n}");

/***/ }),

/***/ "./src/server/polyfills.ts":
/*!*********************************!*\
  !*** ./src/server/polyfills.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var fast_text_encoding__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fast-text-encoding */ \"./node_modules/fast-text-encoding/text.min.js\");\n/* harmony import */ var fast_text_encoding__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fast_text_encoding__WEBPACK_IMPORTED_MODULE_0__);\n/*\n * Copyright 2014-2025 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license.\n */\n\n// Basic global objects for the GraalJS environment\n__webpack_require__.g.self = __webpack_require__.g;\n__webpack_require__.g.window = __webpack_require__.g;\nif (typeof __webpack_require__.g.TextEncoder === 'undefined') {\n    __webpack_require__.g.TextEncoder = fast_text_encoding__WEBPACK_IMPORTED_MODULE_0__.TextEncoder;\n}\nif (typeof __webpack_require__.g.TextDecoder === 'undefined') {\n    __webpack_require__.g.TextDecoder = fast_text_encoding__WEBPACK_IMPORTED_MODULE_0__.TextDecoder;\n}\n// Polyfill setTimeout/clearTimeout for React SSR\nif (typeof setTimeout === 'undefined') {\n    __webpack_require__.g.setTimeout = function (func, delay) {\n        return func(); // In synchronous SSR just call the function\n    };\n    __webpack_require__.g.clearTimeout = function (id) { };\n}\n// Polyfill MessageChannel for React 19 Scheduler\nif (typeof MessageChannel === 'undefined') {\n    __webpack_require__.g.MessageChannel = /** @class */ (function () {\n        function MessageChannel() {\n            var _this = this;\n            this.port1 = { onmessage: null };\n            this.port2 = { onmessage: null };\n            this.port1.postMessage = function (msg) {\n                if (_this.port2.onmessage)\n                    _this.port2.onmessage({ data: msg });\n            };\n            this.port2.postMessage = function (msg) {\n                if (_this.port1.onmessage)\n                    _this.port1.onmessage({ data: msg });\n            };\n        }\n        return MessageChannel;\n    }());\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2VydmVyL3BvbHlmaWxscy50cyIsIm1hcHBpbmdzIjoiOzs7QUFBQTtBQUNBO0FBQ0E7QUFDOEQ7QUFDOUQ7QUFDQSxxQkFBTSxRQUFRLHFCQUFNO0FBQ3BCLHFCQUFNLFVBQVUscUJBQU07QUFDdEIsV0FBVyxxQkFBTTtBQUNqQixJQUFJLHFCQUFNLGVBQWUsMkRBQVc7QUFDcEM7QUFDQSxXQUFXLHFCQUFNO0FBQ2pCLElBQUkscUJBQU0sZUFBZSwyREFBVztBQUNwQztBQUNBO0FBQ0E7QUFDQSxJQUFJLHFCQUFNO0FBQ1YsdUJBQXVCO0FBQ3ZCO0FBQ0EsSUFBSSxxQkFBTTtBQUNWO0FBQ0E7QUFDQTtBQUNBLElBQUkscUJBQU07QUFDVjtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsNENBQTRDLFdBQVc7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFdBQVc7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vU1NSLy4vc3JjL3NlcnZlci9wb2x5ZmlsbHMudHM/NThjYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IDIwMTQtMjAyNSBKZXRCcmFpbnMgcy5yLm8uIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IHRoZSBBcGFjaGUgMi4wIGxpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IFRleHRFbmNvZGVyLCBUZXh0RGVjb2RlciB9IGZyb20gJ2Zhc3QtdGV4dC1lbmNvZGluZyc7XG4vLyBCYXNpYyBnbG9iYWwgb2JqZWN0cyBmb3IgdGhlIEdyYWFsSlMgZW52aXJvbm1lbnRcbmdsb2JhbC5zZWxmID0gZ2xvYmFsO1xuZ2xvYmFsLndpbmRvdyA9IGdsb2JhbDtcbmlmICh0eXBlb2YgZ2xvYmFsLlRleHRFbmNvZGVyID09PSAndW5kZWZpbmVkJykge1xuICAgIGdsb2JhbC5UZXh0RW5jb2RlciA9IFRleHRFbmNvZGVyO1xufVxuaWYgKHR5cGVvZiBnbG9iYWwuVGV4dERlY29kZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgZ2xvYmFsLlRleHREZWNvZGVyID0gVGV4dERlY29kZXI7XG59XG4vLyBQb2x5ZmlsbCBzZXRUaW1lb3V0L2NsZWFyVGltZW91dCBmb3IgUmVhY3QgU1NSXG5pZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgZ2xvYmFsLnNldFRpbWVvdXQgPSBmdW5jdGlvbiAoZnVuYywgZGVsYXkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMoKTsgLy8gSW4gc3luY2hyb25vdXMgU1NSIGp1c3QgY2FsbCB0aGUgZnVuY3Rpb25cbiAgICB9O1xuICAgIGdsb2JhbC5jbGVhclRpbWVvdXQgPSBmdW5jdGlvbiAoaWQpIHsgfTtcbn1cbi8vIFBvbHlmaWxsIE1lc3NhZ2VDaGFubmVsIGZvciBSZWFjdCAxOSBTY2hlZHVsZXJcbmlmICh0eXBlb2YgTWVzc2FnZUNoYW5uZWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgZ2xvYmFsLk1lc3NhZ2VDaGFubmVsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBNZXNzYWdlQ2hhbm5lbCgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLnBvcnQxID0geyBvbm1lc3NhZ2U6IG51bGwgfTtcbiAgICAgICAgICAgIHRoaXMucG9ydDIgPSB7IG9ubWVzc2FnZTogbnVsbCB9O1xuICAgICAgICAgICAgdGhpcy5wb3J0MS5wb3N0TWVzc2FnZSA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMucG9ydDIub25tZXNzYWdlKVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5wb3J0Mi5vbm1lc3NhZ2UoeyBkYXRhOiBtc2cgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5wb3J0Mi5wb3N0TWVzc2FnZSA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMucG9ydDEub25tZXNzYWdlKVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5wb3J0MS5vbm1lc3NhZ2UoeyBkYXRhOiBtc2cgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNZXNzYWdlQ2hhbm5lbDtcbiAgICB9KCkpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/server/polyfills.ts\n\n}");

/***/ }),

/***/ "./src/shared/App.tsx":
/*!****************************!*\
  !*** ./src/shared/App.tsx ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   App: () => (/* binding */ App)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"./node_modules/react/jsx-runtime.js\");\n\nvar App = function (_a) {\n    var data = _a.data;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", { className: \"dokka-page\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h1\", { children: data.title }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"ul\", { children: data.items.map(function (item, idx) { return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"li\", { children: item }, idx)); }) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"footer\", { children: \"Generated by GraalJS\" })] }));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2hhcmVkL0FwcC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBK0Q7QUFDeEQ7QUFDUDtBQUNBLFlBQVksdURBQUssVUFBVSxvQ0FBb0Msc0RBQUksU0FBUyxzQkFBc0IsR0FBRyxzREFBSSxTQUFTLGdEQUFnRCxRQUFRLHNEQUFJLFNBQVMsZ0JBQWdCLFVBQVUsR0FBRyxHQUFHLHNEQUFJLGFBQWEsa0NBQWtDLElBQUk7QUFDOVEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TU1IvLi9zcmMvc2hhcmVkL0FwcC50c3g/YWQ5MiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBqc3ggYXMgX2pzeCwganN4cyBhcyBfanN4cyB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuZXhwb3J0IHZhciBBcHAgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgZGF0YSA9IF9hLmRhdGE7XG4gICAgcmV0dXJuIChfanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJkb2trYS1wYWdlXCIsIGNoaWxkcmVuOiBbX2pzeChcImgxXCIsIHsgY2hpbGRyZW46IGRhdGEudGl0bGUgfSksIF9qc3goXCJ1bFwiLCB7IGNoaWxkcmVuOiBkYXRhLml0ZW1zLm1hcChmdW5jdGlvbiAoaXRlbSwgaWR4KSB7IHJldHVybiAoX2pzeChcImxpXCIsIHsgY2hpbGRyZW46IGl0ZW0gfSwgaWR4KSk7IH0pIH0pLCBfanN4KFwiZm9vdGVyXCIsIHsgY2hpbGRyZW46IFwiR2VuZXJhdGVkIGJ5IEdyYWFsSlNcIiB9KV0gfSkpO1xufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/shared/App.tsx\n\n}");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	__webpack_require__("./src/server/polyfills.ts");
/******/ 	var __webpack_exports__ = __webpack_require__("./src/server/index.tsx");
/******/ 	SSR = __webpack_exports__;
/******/ 	
/******/ })()
;