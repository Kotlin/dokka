{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Dokka","text":"<p>Dokka is an API documentation engine for Kotlin.</p> <p>If you want to learn how to use Dokka, see  documentation on kotlinlang.org.</p> <p>If you want to learn more about Dokka's internals and/or how to write Dokka plugins, see Developer guides.</p>"},{"location":"developer_guide/introduction/","title":"Developer guides","text":"<p>The purpose of the Developer guides documentation is to get you acquainted with Dokka's internals so that you can  start developing your own plugins or contributing features and fixes to Dokka itself.</p> <p>If you want to start hacking on Dokka right away, the only thing you need to be aware of is the general workflow: it will teach you how to build, debug and test Dokka locally.</p> <p>CONTRIBUTING.md contains information that can be useful  if you want to contribute to Dokka.</p> <p>If you want to get into plugin development quick, see Introduction to plugin development.</p> <p>If you have time to spare and want to know more about Dokka's internals, its architecture and capabilities, follow Architecture overview and subsequent sections inside <code>Internals</code>.</p> <p>Having read through all the developer guides, you'll have a pretty good understanding of Dokka and how to develop for it. </p> <p>If you have any questions, feel free to get in touch with maintainers via Slack or  GitHub.</p>"},{"location":"developer_guide/workflow/","title":"Workflow","text":"<p>Whether you're contributing a feature/fix to Dokka itself or developing a Dokka plugin, there are 3 essential things you need to know how to do:</p> <ol> <li>How to build Dokka or a plugin</li> <li>How to use/test locally built Dokka in a project</li> <li>How to debug Dokka or a plugin in IntelliJ IDEA</li> </ol> <p>We'll go over each step individually in this section.</p> <p>Examples below will be specific to Gradle and Gradle\u2019s Kotlin DSL, but you can apply the same principles and run/test/debug with CLI/Maven runners and build configurations if you wish.</p>"},{"location":"developer_guide/workflow/#build-dokka","title":"Build Dokka","text":"<p>Building Dokka is pretty straightforward:</p> <pre><code>./gradlew build\n</code></pre> <p>This will build all subprojects and trigger <code>build</code> in all composite builds. If you are working on a runner, you can build it independently.</p> <p>Checks that are performed as part of <code>build</code> do not require any special configuration or environment, and should not take much time (~2-5 minutes), so please make sure they pass before submitting a pull request.</p>"},{"location":"developer_guide/workflow/#troubleshooting-build","title":"Troubleshooting build","text":""},{"location":"developer_guide/workflow/#api-check-failed-for-project","title":"API check failed for project ..","text":"<p>If you see a message like <code>API check failed for project ..</code> during the <code>build</code> phase, it indicates that the binary compatibility check has failed, meaning you've  changed/added/removed some public API.</p> <p>If the change was intentional, run <code>./gradlew apiDump</code> - it will re-generate <code>.api</code> files with signatures, and you should be able to <code>build</code> Dokka with no errors. These updated files need to be committed as well. Maintainers will review API changes thoroughly, so please make sure it's intentional and rational.</p>"},{"location":"developer_guide/workflow/#use-test-locally-built-dokka","title":"Use / test locally built Dokka","text":"<p>Having built Dokka locally, you can publish it to <code>mavenLocal()</code>. This will allow you to test your changes in another project as well as debug code remotely.</p> <ol> <li>Publish a custom version of Dokka to Maven Local: <code>./gradlew publishToMavenLocal -Pversion=2.1.0-my-fix-SNAPSHOT</code>.     This version will be propagated to plugins that reside inside Dokka's project (<code>mathjax</code>, <code>kotlin-as-java</code>, etc),    and its artifacts should appear in <code>~/.m2</code></li> <li>In the project you want to generate documentation for or debug on, add maven local as a plugin/dependency    repository: <pre><code>repositories {\n   mavenLocal()\n}\n</code></pre></li> <li>Update your Dokka dependency to the version you've just published: <pre><code>plugins {\n    id(\"org.jetbrains.dokka\") version \"2.1.0-my-fix-SNAPSHOT\"\n}\n</code></pre></li> </ol> <p>After completing these steps, you should be able to build documentation using your own version of Dokka.</p>"},{"location":"developer_guide/workflow/#debugging-dokka","title":"Debugging Dokka","text":"<p>Dokka is essentially a Gradle plugin, so you can debug it the same way you would any other Gradle plugin. </p> <p>Below you'll find instructions on how to debug Dokka's internal logic, but you can apply the same principles if you wish to debug a Dokka plugin.</p> <ol> <li>Choose a project to debug on, it needs to have some code for which documentation will be generated.    Prefer using smaller projects that reproduce the exact problem or behaviour you want    since the less code you have, the easier it will be to understand what's going on. You can use example projects    found in dokka/examples/gradle, there's both simple     single-module and more complex multi-module / multiplatform examples.</li> <li> <p>For the debug project, set <code>org.gradle.debug</code> to <code>true</code> in one of the following ways:</p> <ul> <li>In your <code>gradle.properties</code> add <code>org.gradle.debug=true</code></li> <li>When running Dokka tasks:<code>./gradlew dokkaHtml -Dorg.gradle.debug=true --no-daemon</code></li> </ul> </li> <li> <p>Run the desired Dokka task with <code>--no-daemon</code>. Gradle should wait until you attach with debugger before proceeding    with the task, so no need to hurry here.    Example: <code>./gradlew dokkaHtml -Dorg.gradle.debug=true --no-daemon</code>.</p> </li> <li> <p>Open Dokka in IntelliJ IDEA, set a breakpoint and, using remote debug in IntelliJ IDEA,    Attach to process    running on the default port 5005. You can do that either by creating a <code>Remote JVM Debug</code> Run/Debug configuration    or by attaching to the process via <code>Run</code> -&gt; <code>Attach to process</code></p> </li> </ol> <p>Note</p> <p>The reason for <code>--no-daemon</code> is that Gradle daemons continue to exist even after the task has completed execution, so you might hang in debug or experience issues with <code>port was already in use</code> if you try to run it again.</p> <p>If you previously ran Dokka with daemons and you are already encountering problems with it, try killing gradle daemons. For instance, via <code>pkill -f gradle.*daemon</code></p> <p>In case you need to debug some other part of the build - consult the official Gradle tutorials on Troubleshooting Builds.</p>"},{"location":"developer_guide/workflow/#run-integration-tests","title":"Run integration tests","text":"<p>Dokka's integration tests help check  compatibility with various versions of Kotlin, Android, Gradle and Java. They apply Dokka to real user-like projects  and invoke Gradle / Maven / CLI tasks to generate the documentation.</p> <p>Integration tests require a significant amount of available RAM (~20-30GB), take 1+ hour and may require additional environment configuration to run. For these reasons, it's not expected that you run all integration tests locally as part of the everyday development process, they will be run on CI once you submit a PR.</p> <p>Integration tests are executed by default when running <code>check</code>, <code>test</code> or <code>build</code> tasks. It's possible to skip those by passing <code>-Porg.jetbrains.dokka.integration_test.skip=true</code> to the Gradle command, like:</p> <pre><code>./gradlew check -Porg.jetbrains.dokka.integration_test.skip=true\n</code></pre> <p>Integration tests can be run explicitly by running <code>check</code> task in <code>:dokka-integration-tests</code> composite build:</p> <pre><code>./gradlew :dokka-integration-tests:check\n</code></pre> <p>If you need to run a specific test locally, you can run it from your IDE or by calling the corresponding Gradle task (for example, <code>:dokka-integration-tests:gradle:testExternalProjectKotlinxCoroutines</code>).</p>"},{"location":"developer_guide/architecture/architecture_overview/","title":"Architecture overview","text":"<p>Normally, you would think that a tool like Dokka simply parses some programming language sources and generates HTML pages for whatever it sees along the way, with little to no abstractions. That would be the simplest and the most straightforward way to implement an API documentation engine.</p> <p>However, it was clear that Dokka may need to generate documentation from various sources (not only Kotlin), that users might request additional output formats (like Markdown), that users might need additional features like supporting custom KDoc tags or rendering mermaid.js diagrams - all these things would require changing  a lot of code inside Dokka itself if all solutions were hardcoded.</p> <p>For this reason, Dokka was built from the ground up to be easily extensible and customizable by adding several layers of abstractions to the data model, and by providing pluggable extension points, giving you the ability to introduce selective changes on a given level.</p>"},{"location":"developer_guide/architecture/architecture_overview/#overview-of-data-model","title":"Overview of data model","text":"<p>Generating API documentation begins with input source files (<code>.kt</code>, <code>.java</code>, etc) and ends with some output files (<code>.html</code>/<code>.md</code>, etc). However, to allow for extensibility and customization, several input and output independent abstractions have been added to the data model.</p> <p>Below you can find the general pipeline of processing data gathered from sources and the explanation for each stage.</p> <pre><code>flowchart TD\n    Input --&gt; Documentables --&gt; Pages --&gt; Output</code></pre> <ul> <li><code>Input</code> - generalization of sources, by default Kotlin / Java sources, but could be virtually anything</li> <li><code>Documentables</code> - unified data model that represents any parsed sources as a    tree, independent of the source language. Examples of a <code>Documentable</code>: class, function, package, property, etc</li> <li><code>Pages</code> - universal model that represents output pages (e.g a function/property page)    and the content it's composed of (lists, text, code blocks) that the users needs to see. Not to be confused with    <code>.html</code> pages. Goes hand in hand with the so-called Content model.</li> <li><code>Output</code> - specific output formats like HTML / Markdown / Javadoc and so on. This is a mapping of the pages/content    model to a human-readable and visual representation. For instance:<ul> <li><code>PageNode</code> is mapped as <ul> <li><code>.html</code> file for the HTML format</li> <li><code>.md</code> file for the Markdown format</li> </ul> </li> <li><code>ContentList</code> is mapped as<ul> <li><code>&lt;li&gt;</code> / <code>&lt;ul&gt;</code> for the HTML format</li> <li><code>1.</code> / <code>*</code> for the Markdown format</li> </ul> </li> <li><code>ContentCodeBlock</code> is mapped as<ul> <li><code>&lt;code&gt;</code> or <code>&lt;pre&gt;</code> with some CSS styles in the HTML format</li> <li>Text wrapped in triple backticks for the Markdown format</li> </ul> </li> </ul> </li> </ul> <p>You, as a Dokka developer or a plugin writer, can use extension points to introduce selective changes to the model on one particular level without altering everything else. </p> <p>For instance, if you wanted to make an annotation / function / class invisible in the final documentation, you would only need to modify the <code>Documentables</code> level by filtering undesirable declarations out. If you wanted to display all overloaded methods on the same page instead of on separate ones, you would only need to modify the <code>Pages</code> layer by merging multiple pages into one, and so on.</p> <p>For a deeper dive into Dokka's model with more examples and details, see sections about Documentables and Page/Content</p> <p>For an overview of existing extension points that let you transform Dokka's models, see  Core extension points and Base extensions.</p>"},{"location":"developer_guide/architecture/architecture_overview/#overview-of-extension-points","title":"Overview of extension points","text":"<p>An extension point usually represents a pluggable interface that performs an action during one of the stages of generating documentation. An extension is, therefore, an implementation of the interface which is extending the extension point.</p> <p>You can create extension points, provide your own implementations (extensions) and configure them. All of this is possible with Dokka's plugin / extension point API.</p> <p>Here's a sneak peek of the DSL:</p> <pre><code>// declare your own plugin\nclass MyPlugin : DokkaPlugin() {\n    // create an extension point for developers to use\n    val signatureProvider by extensionPoint&lt;SignatureProvider&gt;()\n\n    // provide a default implementation\n    val defaultSignatureProvider by extending {\n        signatureProvider with KotlinSignatureProvider()\n    }\n\n    // register our own extension in Dokka's Base plugin by overriding its default implementation\n    val dokkaBasePlugin by lazy { plugin&lt;DokkaBase&gt;() }\n    val multimoduleLocationProvider by extending {\n        (dokkaBasePlugin.locationProviderFactory\n                providing MultimoduleLocationProvider::Factory\n                override dokkaBasePlugin.locationProvider)\n    }\n}\n\nclass MyExtension(val context: DokkaContext) {\n\n    // use an existing extension\n    val signatureProvider: SignatureProvider = context.plugin&lt;MyPlugin&gt;().querySingle { signatureProvider }\n\n    fun doSomething() {\n        signatureProvider.signature(..)\n    }\n}\n\ninterface SignatureProvider {\n    fun signature(documentable: Documentable): List&lt;ContentNode&gt;\n}\n\nclass KotlinSignatureProvider : SignatureProvider {\n    override fun signature(documentable: Documentable): List&lt;ContentNode&gt; = listOf()\n}\n</code></pre> <p>For a deeper dive into extensions and extension points, see Introduction to Extensions.</p> <p>For an overview of existing extension points, see Core extension points and Base extensions.</p>"},{"location":"developer_guide/architecture/architecture_overview/#historical-context","title":"Historical context","text":"<p>This is a second iteration of Dokka that was built from scratch.</p> <p>If you want to learn more about why Dokka was redesigned this way, watch this great talk by Pawe\u0142 Marks: New Dokka - Designed for Fearless Creativity. The general principles  and general architecture are the same, although it may be outdated in some areas, so please double-check.</p>"},{"location":"developer_guide/architecture/data_model/documentable_model/","title":"Documentable Model","text":"<p>The Documentable model represents the data that is parsed from some programming language sources. Think of this data as  of something that could be seen or produced by a compiler frontend, it's not far off from the truth.</p> <p>By default, the documentables are created from:</p> <ul> <li>Descriptors (Kotlin's K1 compiler)</li> <li>Symbols (Kotlin's K2 compiler)</li> <li>PSI (Java's model). </li> </ul> <p>Code-wise, you can have a look at following classes:</p> <ul> <li><code>DefaultDescriptorToDocumentableTranslator</code> - responsible for Kotlin's K1 -&gt; <code>Documentable</code> mapping</li> <li><code>DefaultSymbolToDocumentableTranslator</code> - responsible for Kotlin's K2 -&gt; <code>Documentable</code> mapping</li> <li><code>DefaultPsiToDocumentableTranslator</code> - responsible for Java -&gt; <code>Documentable</code> mapping</li> </ul> <p>Upon creation, the documentable model represents a collection of trees, each with <code>DModule</code> as root.</p> <p>Take some arbitrary Kotlin source code that is located within the same module:</p> <pre><code>// Package 1\nclass Clazz(val property: String) {\n    fun function(parameter: String) {}\n}\n\nfun topLevelFunction() {}\n\n// Package 2\nenum class Enum { }\n\nval topLevelProperty: String\n</code></pre> <p>This would be represented roughly as the following Documentable tree:</p> <pre><code>flowchart TD\n    DModule --&gt; firstPackage[DPackage]\n    firstPackage --&gt; DClass\n    firstPackage --&gt; toplevelfunction[DFunction] \n    DClass --&gt; DProperty\n    DClass --&gt; DFunction\n    DFunction --&gt; DParameter\n    DModule --&gt; secondPackage[DPackage]\n    secondPackage --&gt; DEnum\n    secondPackage --&gt; secondPackageProperty[DProperty]</code></pre> <p>At later stages of transformation, all trees are folded into one by  DocumentableMerger.</p>"},{"location":"developer_guide/architecture/data_model/documentable_model/#documentable","title":"Documentable","text":"<p>The main building block of the documentable model is the <code>Documentable</code> class. It is the base class for all more specific  types. All implementations represent elements of source code with mostly self-explanatory names: <code>DFunction</code>,  <code>DPackage</code>, <code>DProperty</code>, and so on.</p> <p><code>DClasslike</code> is the base class for all class-like documentables, such as <code>DClass</code>, <code>DEnum</code>, <code>DAnnotation</code> and others.</p> <p>The contents of each documentable normally represent what you would see in the source code. </p> <p>For example, if you open <code>DClass</code>, you should find that it contains references to functions, properties, companion objects, constructors and so on. <code>DEnum</code> should have references to its entries, and <code>DPackage</code> can have references to both classlikes and top-level functions and properties (Kotlin-specific).</p> <p>Here's an example of a documentable:</p> <pre><code>data class DClass(\n    val dri: DRI,\n    val name: String,\n    val constructors: List&lt;DFunction&gt;,\n    val functions: List&lt;DFunction&gt;,\n    val properties: List&lt;DProperty&gt;,\n    val classlikes: List&lt;DClasslike&gt;,\n    val sources: SourceSetDependent&lt;DocumentableSource&gt;,\n    val visibility: SourceSetDependent&lt;Visibility&gt;,\n    val companion: DObject?,\n    val generics: List&lt;DTypeParameter&gt;,\n    val supertypes: SourceSetDependent&lt;List&lt;TypeConstructorWithKind&gt;&gt;,\n    val documentation: SourceSetDependent&lt;DocumentationNode&gt;,\n    val expectPresentInSet: DokkaSourceSet?,\n    val modifier: SourceSetDependent&lt;Modifier&gt;,\n    val sourceSets: Set&lt;DokkaSourceSet&gt;,\n    val isExpectActual: Boolean,\n    val extra: PropertyContainer&lt;DClass&gt; = PropertyContainer.empty()\n) : DClasslike(), WithAbstraction, WithCompanion, WithConstructors,\n    WithGenerics, WithSupertypes, WithExtraProperties&lt;DClass&gt;\n</code></pre> <p>There are three non-documentable classes that are important for this model:</p> <ul> <li><code>DRI</code></li> <li><code>SourceSetDependent</code></li> <li><code>ExtraProperty</code>.</li> </ul>"},{"location":"developer_guide/architecture/data_model/documentable_model/#dri","title":"DRI","text":"<p><code>DRI</code> stans for Dokka Resource Identifier - a unique value that identifies a specific <code>Documentable</code>. All references and relations between the documentables (other than direct ownership) are described using <code>DRI</code>.</p> <p>For example, <code>DFunction</code> with a parameter of type <code>Foo</code> only has <code>Foo</code>'s <code>DRI</code>, but not the actual reference to <code>Foo</code>'s <code>Documentable</code> object.</p>"},{"location":"developer_guide/architecture/data_model/documentable_model/#example","title":"Example","text":"<p>For an example of how a <code>DRI</code> can look like, let's take the <code>limitedParallelism</code> function from <code>kotlinx.coroutines</code>:</p> <pre><code>package kotlinx.coroutines\n\nimport ...\n\npublic abstract class MainCoroutineDispatcher : CoroutineDispatcher() {\n\n    override fun limitedParallelism(parallelism: Int): CoroutineDispatcher {\n        ...\n    }\n}\n</code></pre> <p>If we were to re-create the DRI of this function in code, it would look something like this:</p> <pre><code>DRI(\n    packageName = \"kotlinx.coroutines\",\n    classNames = \"MainCoroutineDispatcher\",\n    callable = Callable(\n        name = \"limitedParallelism\",\n        receiver = null,\n        params = listOf(\n            TypeConstructor(\n                fullyQualifiedName = \"kotlin.Int\",\n                params = emptyList()\n            )\n        )\n    ),\n    target = PointingToDeclaration,\n    extra = null\n)\n</code></pre> <p>If you format it as <code>String</code>, it would look like this:</p> <pre><code>kotlinx.coroutines/MainCoroutineDispatcher/limitedParallelism/#kotlin.Int/PointingToDeclaration/\n</code></pre>"},{"location":"developer_guide/architecture/data_model/documentable_model/#sourcesetdependent","title":"SourceSetDependent","text":"<p><code>SourceSetDependent</code> helps handling multiplatform data by associating platform-specific data (declared with either <code>expect</code> or <code>actual</code> modifiers) with particular  source sets.</p> <p>This comes in handy if the <code>expect</code> / <code>actual</code> declarations differ. For example, the default value for <code>actual</code> might  differ from that declared in <code>expect</code>, or code comments written for <code>expect</code> might be different from what's written for <code>actual</code>.</p> <p>Under the hood, it's a <code>typealias</code> to a <code>Map</code>:</p> <pre><code>typealias SourceSetDependent&lt;T&gt; = Map&lt;DokkaSourceSet, T&gt;\n</code></pre>"},{"location":"developer_guide/architecture/data_model/documentable_model/#extraproperty","title":"ExtraProperty","text":"<p><code>ExtraProperty</code> is used to store any additional information that falls outside of the regular model. It is highly recommended to use extras to provide any additional information when creating custom Dokka plugins.</p> <p>This element is a bit more complex, so you can read more about how to use it in a separate section.</p>"},{"location":"developer_guide/architecture/data_model/documentable_model/#documentation-model","title":"Documentation model","text":"<p>The Documentation model is used alongside documentables to store data obtained by parsing code comments (such as KDocs / Javadocs).</p>"},{"location":"developer_guide/architecture/data_model/documentable_model/#doctag","title":"DocTag","text":"<p><code>DocTag</code> describes a specific documentation syntax element.</p> <p>It's universal across language sources. For example, the DocTag <code>B</code> is the same for <code>**bold**</code> in Kotlin and <code>&lt;b&gt;bold&lt;/b&gt;</code> in Java.</p> <p>However, some DocTag elements are specific to one language. There are many such examples for Java, because it allows  HTML tags inside the Javadoc comments, some of which are simply not possible to reproduce with Markdown that KDocs use.</p> <p><code>DocTag</code> elements can be deeply nested with other <code>DocTag</code> children elements.</p> <p>Examples:</p> <pre><code>data class H1(\n    override val children: List&lt;DocTag&gt; = emptyList(),\n    override val params: Map&lt;String, String&gt; = emptyMap()\n) : DocTag()\n\ndata class H2(\n    override val children: List&lt;DocTag&gt; = emptyList(),\n    override val params: Map&lt;String, String&gt; = emptyMap()\n) : DocTag()\n\ndata class Strikethrough(\n    override val children: List&lt;DocTag&gt; = emptyList(),\n    override val params: Map&lt;String, String&gt; = emptyMap()\n) : DocTag()\n\ndata class Strong(\n    override val children: List&lt;DocTag&gt; = emptyList(),\n    override val params: Map&lt;String, String&gt; = emptyMap()\n) : DocTag()\n\ndata class CodeBlock(\n    override val children: List&lt;DocTag&gt; = emptyList(),\n    override val params: Map&lt;String, String&gt; = emptyMap()\n) : Code()\n</code></pre>"},{"location":"developer_guide/architecture/data_model/documentable_model/#tagwrapper","title":"TagWrapper","text":"<p><code>TagWrapper</code> describes the whole comment description or a specific comment tag. For example: <code>@see</code> / <code>@author</code> / <code>@return</code>.</p> <p>Since each such section may contain formatted text inside it, each <code>TagWrapper</code> has <code>DocTag</code> children.</p> <pre><code>/**\n * @author **Ben Affleck*\n * @return nothing, except _sometimes_ it may throw an [Error]\n */\nfun foo() {}\n</code></pre>"},{"location":"developer_guide/architecture/data_model/documentable_model/#documentationnode","title":"DocumentationNode","text":"<p><code>DocumentationNode</code> acts as a container for multiple <code>TagWrapper</code> elements for a specific <code>Documentable</code>, usually used like this:</p> <pre><code>data class DFunction(\n    ...\n    val documentation: SourceSetDependent&lt;DocumentationNode&gt;,\n    ...\n)\n</code></pre>"},{"location":"developer_guide/architecture/data_model/extra/","title":"Extra","text":""},{"location":"developer_guide/architecture/data_model/extra/#introduction","title":"Introduction","text":"<p><code>ExtraProperty</code> is used to store any additional information that falls outside of the regular model. It is highly  recommended to use extras to provide any additional information when creating custom Dokka plugins.</p> <p><code>ExtraProperty</code> classes are available both in the Documentable and the Content models.</p> <p>To create a new extra, you need to implement the <code>ExtraProperty</code> interface. It is advised to use the following pattern when declaring new extras:</p> <pre><code>data class CustomExtra(\n    [any data relevant to your extra], \n    [any data relevant to your extra] \n): ExtraProperty&lt;Documentable&gt; {\n    override val key: CustomExtra.Key&lt;Documentable, *&gt; = CustomExtra\n    companion object : CustomExtra.Key&lt;Documentable, CustomExtra&gt;\n}\n</code></pre> <p>Merge strategy (the <code>mergeStrategyFor</code> method) for extras is invoked during the merging of the documentables from different  source sets, when the documentables being merged have their own <code>Extra</code> of the same type. </p>"},{"location":"developer_guide/architecture/data_model/extra/#propertycontainer","title":"PropertyContainer","text":"<p>All extras for <code>ContentNode</code> and <code>Documentable</code> classes are stored in the <code>PropertyContainer&lt;C : Any&gt;</code> class instances.</p> <pre><code>data class DFunction(\n    ...\n    override val extra: PropertyContainer&lt;DFunction&gt; = PropertyContainer.empty()\n    ...\n) : WithExtraProperties&lt;DFunction&gt;\n</code></pre> <p><code>PropertyContainer</code> has a number of convenient functions for handling extras in a collection-like manner.</p> <p>The generic class parameter <code>C</code> limits the types of properties that can be stored in the container - it must match the generic <code>C</code> class parameter from the <code>ExtraProperty</code> interface. This allows creating extra properties which can only be stored in a specific <code>Documentable</code>.</p>"},{"location":"developer_guide/architecture/data_model/extra/#usage-example","title":"Usage example","text":"<p>In following example we will create a <code>DFunction</code>-only extra property, store it and then retrieve its value:</p> <pre><code>// Extra that is applicable only to DFunction\ndata class CustomExtra(val customExtraValue: String) : ExtraProperty&lt;DFunction&gt; {\n    override val key: ExtraProperty.Key&lt;Documentable, *&gt; = CustomExtra\n    companion object: ExtraProperty.Key&lt;Documentable, CustomExtra&gt;\n}\n\n// Storing it inside the documentable\nfun DFunction.withCustomExtraProperty(data: String): DFunction {\n    return this.copy(\n        extra = extra + CustomExtra(data)\n    )\n}\n\n// Retrieveing it from the documentable\nfun DFunction.getCustomExtraPropertyValue(): String? {\n    return this.extra[CustomExtra]?.customExtraValue\n}\n</code></pre> <p>You can also use extras as markers, without storing any data in them:</p> <pre><code>object MarkerExtra : ExtraProperty&lt;Any&gt;, ExtraProperty.Key&lt;Any, MarkerExtra&gt; {\n    override val key: ExtraProperty.Key&lt;Any, *&gt; = this\n}\n\nfun Documentable.markIfFunction(): Documentable {\n    return when(this) {\n        is DFunction -&gt; this.copy(extra = extra + MarkerExtra)\n        else -&gt; this\n    }\n}\n\nfun WithExtraProperties&lt;Documentable&gt;.isMarked(): Boolean {\n    return this.extra[MarkerExtra] != null\n}\n</code></pre>"},{"location":"developer_guide/architecture/data_model/page_content/","title":"Page / Content Model","text":"<p>Even though the <code>Page</code> and <code>Content</code> models reside on the same level (under <code>Page</code>), it is easier to view them as two  different models altogether, even though <code>Content</code> is only used in conjunction with and inside the <code>Page</code> model only.</p>"},{"location":"developer_guide/architecture/data_model/page_content/#page","title":"Page","text":"<p>The Page model represents the structure of documentation pages to be generated. During rendering, each page is processed separately, so one page corresponds to exactly one output file.</p> <p>The Page model is independent of the final output format. In other words, it's universal. Which file extension the pages should be created as (<code>.html</code>, <code>.md</code>, etc), and how, is up to the  Renderer extension.</p> <p>Subclasses of the <code>PageNode</code> class represent the different kinds of pages, such as <code>ModulePage</code>, <code>PackagePage</code>, <code>ClasslikePage</code>, <code>MemberPage</code> and so on.</p> <p>The Page model can be represented as a tree, with <code>RootPageNode</code> at the root.</p> <p>Here's an example of how an arbitrary project's <code>Page</code> tree might look like, if the project consists of a module with  3 packages, one of which contains a top level function, a top level property and a class, inside which there's a function and a property:</p> <pre><code>flowchart TD\n    RootPageNode --&gt; firstPackage[PackagePageNode]\n    RootPageNode --&gt; secondPackage[PackagePageNode]\n    RootPageNode --&gt; thirdPackage[PackagePageNode]\n    firstPackage --&gt; firstPackageFirstMember[MemberPageNode - Function]\n    firstPackage --&gt; firstPackageSecondMember[MemberPageNode - Property]\n    firstPackage ---&gt; firstPackageClasslike[ClasslikePageNode - Class]\n    firstPackageClasslike --&gt; firstPackageClasslikeFirstMember[MemberPageNode - Function]\n    firstPackageClasslike --&gt; firstPackageClasslikeSecondMember[MemberPageNode - Property]\n    secondPackage --&gt; etcOne[...]\n    thirdPackage --&gt; etcTwo[...]</code></pre> <p>Almost all pages are derivatives of <code>ContentPage</code> - it's the type of a page that has user-visible content on it.</p>"},{"location":"developer_guide/architecture/data_model/page_content/#content-model","title":"Content Model","text":"<p>The Content model describes what the pages consist of. It is essentially a set of building blocks that you can put  together to represent some content. It is also output-format independent and universal.</p> <p>For an example, have a look at the subclasses of <code>ContentNode</code>: <code>ContentText</code>, <code>ContentList</code>, <code>ContentTable</code>,  <code>ContentCodeBlock</code>, <code>ContentHeader</code> and so on -- all self-explanatory. You can group chunks of content together with  <code>ContentGroup</code> - for example, to wrap all children with a style.</p> <pre><code>// real example of composing content using the `DocumentableContentBuilder` DSL\norderedList {\n    item {\n        text(\"This list contains a nested table:\")\n        table {\n            header {\n                text(\"Col1\")\n                text(\"Col2\")\n            }\n            row {\n                text(\"Text1\")\n                text(\"Text2\")\n            }\n        }\n    }\n    item {\n        group(styles = setOf(TextStyle.Bold)) {\n            text(\"This is bold\")\n            text(\"This is also bold\")\n        }\n    }\n}\n</code></pre> <p>It is the responsibility of the <code>Renderer</code> (i.e a specific output format) to render it in a way the user can process it, be it visually (html pages) or otherwise (json).</p> <p>For instance, <code>HtmlRenderer</code> might render <code>ContentCodeBlock</code> as <code>&lt;code&gt;text&lt;/code&gt;</code>, but <code>CommonmarkRenderer</code> might  render it using backticks.</p>"},{"location":"developer_guide/architecture/data_model/page_content/#dci","title":"DCI","text":"<p>Each node is identified by a unique <code>DCI</code>, which stands for Dokka Content Identifier. </p> <p><code>DCI</code> aggregates <code>DRI</code>s of all documentables that are used by the given <code>ContentNode</code>.</p> <pre><code>data class DCI(val dri: Set&lt;DRI&gt;, val kind: Kind)\n</code></pre> <p>All references to other nodes (other than direct ownership) are described using <code>DCI</code>.</p>"},{"location":"developer_guide/architecture/data_model/page_content/#contentkind","title":"ContentKind","text":"<p><code>ContentKind</code> represents a grouping of content of one kind that can be rendered as part of a composite page, like a single one tab or a block within a class's page.</p> <p>For example, on the same page that describes a class you can have multiple sections (== <code>ContentKind</code>s). One to describe functions, one to describe properties, another one to describe the constructors, and so on.</p>"},{"location":"developer_guide/architecture/data_model/page_content/#styles","title":"Styles","text":"<p>Each <code>ContentNode</code> has a <code>styles</code> property in case you want to indicate to the <code>Renderer</code> that this content needs to be rendered in a certain way.</p> <pre><code>group(styles = setOf(TextStyle.Paragraph)) {\n    text(\"Text1\", styles = setOf(TextStyle.Bold))\n    text(\"Text2\", styles = setOf(TextStyle.Italic))\n}\n</code></pre> <p>It is responsibility of the <code>Renderer</code> (i.e a specific output format) to render it in a way the user can process it.  For instance, <code>HtmlRenderer</code> might render <code>TextStyle.Bold</code> as <code>&lt;b&gt;text&lt;/b&gt;</code>, but <code>CommonmarkRenderer</code> might render it  as <code>**text**</code>.</p> <p>There's a number of existing styles that you can use, most of them are supported by the <code>HtmlRenderer</code> extension out of  the box:</p> <pre><code>// for code highlighting\nenum class TokenStyle : Style {\n    Keyword, Punctuation, Function, Operator, Annotation,\n    Number, String, Boolean, Constant, Builtin, ...\n}\n\nenum class TextStyle : Style {\n    Bold, Italic, Strong, Strikethrough, Paragraph, ...\n}\n\nenum class ContentStyle : Style {\n    TabbedContent, RunnableSample, Wrapped, Indented, ...\n}\n</code></pre>"},{"location":"developer_guide/architecture/data_model/page_content/#extra","title":"Extra","text":"<p><code>ExtraProperty</code> is used to store any additional information that falls outside of the regular model. </p> <p>It is highly recommended to use extras to provide any additional information when creating custom Dokka plugins.</p> <p>All <code>ExtraProperty</code> elements from the <code>Documentable</code> model are propagated into the <code>Content</code> model, and are available in the <code>Renderer</code> extensions.</p> <p>This element is a bit complex, so you can read more about how to use it in a separate section.</p>"},{"location":"developer_guide/architecture/extension_points/base_plugin/","title":"Base plugin","text":"<p><code>DokkaBase</code> represents Dokka's Base plugin, which provides a number of sensible default implementations for  <code>CoreExtensions</code>, as well as declares its own, more high-level abstractions and extension points to be used from other  plugins and output formats.</p> <p>If you want to develop a simple plugin that only changes a few details, it is very convenient to rely on  default implementations and use extension points defined in <code>DokkaBase</code>, as it reduces the scope of changes you need to make. </p> <p><code>DokkaBase</code> is used extensively in Dokka's own output formats.</p> <p>You can learn how to add, use, override and configure extensions and extension points in Introduction to Extensions - all of that information is applicable to the <code>DokkaBase</code> plugin as well.</p>"},{"location":"developer_guide/architecture/extension_points/base_plugin/#extension-points","title":"Extension points","text":"<p>Some notable extension points defined in Dokka's Base plugin.</p>"},{"location":"developer_guide/architecture/extension_points/base_plugin/#premergedocumentabletransformer","title":"PreMergeDocumentableTransformer","text":"<p><code>PreMergeDocumentableTransformer</code> is very similar to the  DocumentableTransformer core extension point, but it is used during  an earlier stage by the Single module generation.</p> <p>This extension point allows you to apply any transformations to the Documentables model  before the project's source sets are merged.</p> <p>It is useful if you want to filter/map existing documentables. For example, if you want to exclude members annotated with <code>@Internal</code>, you most likely need an implementation of <code>PreMergeDocumentableTransformer</code>.</p> <p>For simple condition-based filtering of documentables, consider extending <code>SuppressedByConditionDocumentableFilterTransformer</code> - it implements <code>PreMergeDocumentableTransformer</code> and only requires one function to be overridden, whereas the rest is taken care of.</p>"},{"location":"developer_guide/architecture/extension_points/core_extension_points/","title":"Core extension points","text":"<p>Core extension points represent the main stages of generating documentation. </p> <p>These extension points are plugin and output format independent, meaning it's the very core functionality and as low-level as can get in Dokka. </p> <p>For higher-level extension functions that can be used in different output formats, have a look at the  Base plugin.</p> <p>You can find all core extensions in the <code>CoreExtensions</code> class:</p> <pre><code>object CoreExtensions {\n    val preGenerationCheck by coreExtensionPoint&lt;PreGenerationChecker&gt;()\n    val generation by coreExtensionPoint&lt;Generation&gt;()\n    val sourceToDocumentableTranslator by coreExtensionPoint&lt;SourceToDocumentableTranslator&gt;()\n    val documentableMerger by coreExtensionPoint&lt;DocumentableMerger&gt;()\n    val documentableTransformer by coreExtensionPoint&lt;DocumentableTransformer&gt;()\n    val documentableToPageTranslator by coreExtensionPoint&lt;DocumentableToPageTranslator&gt;()\n    val pageTransformer by coreExtensionPoint&lt;PageTransformer&gt;()\n    val renderer by coreExtensionPoint&lt;Renderer&gt;()\n    val postActions by coreExtensionPoint&lt;PostAction&gt;()\n}\n</code></pre> <p>On this page, we'll go over each extension point individually.</p>"},{"location":"developer_guide/architecture/extension_points/core_extension_points/#pregenerationchecker","title":"PreGenerationChecker","text":"<p><code>PreGenerationChecker</code> can be used to run some checks and constraints. </p> <p>For example, Dokka's Javadoc plugin does not support generating documentation for multi-platform projects, so it uses <code>PreGenerationChecker</code> to check for multi-platform source sets, and fails if it finds any.</p>"},{"location":"developer_guide/architecture/extension_points/core_extension_points/#generation","title":"Generation","text":"<p><code>Generation</code> is responsible for generating documentation as a whole, utilizing higher-level extensions and extension  points where applicable.</p> <p>See Generation implementations to learn about the default implementations.</p>"},{"location":"developer_guide/architecture/extension_points/core_extension_points/#sourcetodocumentabletranslator","title":"SourceToDocumentableTranslator","text":"<p><code>SourceToDocumentableTranslator</code> translates any given sources into the Documentable model. </p> <p>Kotlin and Java sources are supported by default by the Base plugin, but you can analyze any language  as long as you can map it to the Documentable model.</p> <p>For reference, see</p> <ul> <li><code>DefaultDescriptorToDocumentableTranslator</code> (K1) and <code>DefaultSymbolToDocumentableTranslator</code> (K2) for Kotlin sources translation</li> <li><code>DefaultPsiToDocumentableTranslator</code> for Java sources translation</li> </ul>"},{"location":"developer_guide/architecture/extension_points/core_extension_points/#documentablemerger","title":"DocumentableMerger","text":"<p><code>DocumentableMerger</code> merges all <code>DModule</code> instances into one. Only one extension of this type is expected to be  registered.</p>"},{"location":"developer_guide/architecture/extension_points/core_extension_points/#documentabletransformer","title":"DocumentableTransformer","text":"<p><code>DocumentableTransformer</code> performs the same function as <code>PreMergeDocumentableTransformer</code>, but after merging source sets.</p> <p>Notable example is <code>InheritorsExtractorTransformer</code>, it extracts inheritance information from  source sets and creates an inheritance map.</p>"},{"location":"developer_guide/architecture/extension_points/core_extension_points/#documentabletopagetranslator","title":"DocumentableToPageTranslator","text":"<p><code>DocumentableToPageTranslator</code> is responsible for creating pages and their content. See  Page / Content model page for more information and examples.</p> <p>Output formats can either use the same page structure or define their own.</p> <p>Only a single extension of this type is expected to be registered. </p>"},{"location":"developer_guide/architecture/extension_points/core_extension_points/#pagetransformer","title":"PageTransformer","text":"<p><code>PageTransformer</code> is useful if you need to add, remove or modify generated pages or their content.</p> <p>Using this extension point, plugins like <code>org.jetbrains.dokka:mathjax-pligin</code> can add <code>.js</code> scripts to the HTML pages. </p> <p>If you want all overloaded functions to be rendered on the same page instead of separate ones, you can use <code>PageTransformer</code> to combine the pages into a single one.</p>"},{"location":"developer_guide/architecture/extension_points/core_extension_points/#renderer","title":"Renderer","text":"<p><code>Renderer</code> - defines the rules on how to render pages and their content: which files to create and how to display the content properly. </p> <p>Custom output format plugins should use the <code>Renderer</code> extension point. Notable examples are <code>HtmlRenderer</code> and <code>CommonmarkRenderer</code>.</p>"},{"location":"developer_guide/architecture/extension_points/core_extension_points/#postaction","title":"PostAction","text":"<p><code>PostAction</code> can be used for when you want to run some actions after the documentation has been generated - for example, if you want to move some files around or log some informational messages.</p> <p>Dokka's Versioning plugin utilizes <code>PostAction</code>  to move generated documentation to the versioned directories.</p>"},{"location":"developer_guide/architecture/extension_points/extension_points/","title":"Extension points","text":"<p>In this section you can learn how to create new extension points, how to configure existing ones, and how to query for  registered extensions when generating documentation.</p>"},{"location":"developer_guide/architecture/extension_points/extension_points/#declaring-extension-points","title":"Declaring extension points","text":"<p>If you are writing a plugin, you can create your own extension points that other developers (or you) can use in other  plugins / parts of code.</p> <pre><code>class MyPlugin : DokkaPlugin() {\n    val sampleExtensionPoint by extensionPoint&lt;SampleExtensionPointInterface&gt;()\n}\n\ninterface SampleExtensionPointInterface {\n    fun doSomething(input: Input): List&lt;Output&gt;\n}\n\nclass Input\nclass Output\n</code></pre> <p>Usually, you would want to provide some default implementations for your extension points. You can do that within the same plugin class by extending an extension point you've just created. See  Extending from extension points for examples.</p>"},{"location":"developer_guide/architecture/extension_points/extension_points/#extending-from-extension-points","title":"Extending from extension points","text":"<p>You can use extension points to provide your own implementations in order to customize a plugin's behaviour.</p> <p>If you want to provide an implementation for an extension point declared in an external plugin (including <code>DokkaBase</code>),  you can use plugin querying API to do that. </p> <p>The example below shows how to extend <code>MyPlugin</code> (that was created above) with an implementation of  <code>SampleExtensionPointInterface</code>.</p> <pre><code>class MyExtendedPlugin : DokkaPlugin() {\n\n    val mySampleExtensionImplementation by extending {\n        plugin&lt;MyPlugin&gt;().sampleExtensionPoint with SampleExtensionImpl()\n    }\n}\n\nclass SampleExtensionImpl : SampleExtensionPointInterface {\n    override fun doSomething(input: Input): List&lt;Output&gt; = listOf()\n}\n</code></pre> <p>Alternatively, if it is your own plugin, you can do that within the same class as the extension point itself:</p> <pre><code>open class MyPlugin : DokkaPlugin() {\n    val sampleExtensionPoint by extensionPoint&lt;SampleExtensionPointInterface&gt;()\n\n    val defaultSampleExtension by extending {\n        sampleExtensionPoint with DefaultSampleExtension()\n    }\n}\n\nclass DefaultSampleExtension : SampleExtensionPointInterface {\n    override fun doSomething(input: Input): List&lt;Output&gt; = listOf()\n}\n</code></pre>"},{"location":"developer_guide/architecture/extension_points/extension_points/#providing","title":"Providing","text":"<p>If you need to have access to <code>DokkaContext</code> when creating an extension, you can use the <code>providing</code> keyword instead. </p> <pre><code>val defaultSampleExtension by extending {\n    sampleExtensionPoint providing { context -&gt;\n        // can use context to query other extensions or get configuration \n        DefaultSampleExtension() \n    }\n}\n</code></pre> <p>You can read more on what you can do with <code>context</code> in Obtaining extension instance.</p>"},{"location":"developer_guide/architecture/extension_points/extension_points/#override","title":"Override","text":"<p>By extending an extension point, you are registering an additional extension. This behaviour is expected by some extension points, for example the <code>Documentable</code> transformers, because all registered transformer extensions do their own  transformations independently and one after the other.</p> <p>However, a plugin can expect only a single extension to be registered for an extension point. In this case, you can use  the <code>override</code> keyword to override the existing registered extension:</p> <pre><code>class MyExtendedPlugin : DokkaPlugin() {\n    private val myPlugin by lazy { plugin&lt;MyPlugin&gt;() }\n\n    val mySampleExtensionImplementation by extending {\n        (myPlugin.sampleExtensionPoint\n                with SampleExtensionImpl()\n                override myPlugin.defaultSampleExtension)\n    }\n}\n</code></pre> <p>This is also useful if you wish to override some extension from <code>DokkaBase</code>, to disable or alter it.</p>"},{"location":"developer_guide/architecture/extension_points/extension_points/#order","title":"Order","text":"<p>Sometimes, the order in which extensions are invoked matters. This is something you can control as well using the  <code>order</code> construct:</p> <pre><code>class MyExtendedPlugin : DokkaPlugin() {\n    private val myPlugin by lazy { plugin&lt;MyPlugin&gt;() }\n\n    val mySampleExtensionImplementation by extending {\n        myPlugin.sampleExtensionPoint with SampleExtensionImpl() order {\n            before(myPlugin.firstExtension)\n            after(myPlugin.thirdExtension)\n        }\n    }\n}\n</code></pre>"},{"location":"developer_guide/architecture/extension_points/extension_points/#conditional-apply","title":"Conditional apply","text":"<p>If you want your extension to be registered only if some condition is <code>true</code>, you can use the <code>applyIf</code> construct:</p> <pre><code>class MyExtendedPlugin : DokkaPlugin() {\n    private val myPlugin by lazy { plugin&lt;MyPlugin&gt;() }\n\n    val mySampleExtensionImplementation by extending {\n        myPlugin.sampleExtensionPoint with SampleExtensionImpl() applyIf {\n            Random.Default.nextBoolean()\n        }\n    }\n}\n</code></pre>"},{"location":"developer_guide/architecture/extension_points/extension_points/#obtaining-extension-instance","title":"Obtaining extension instance","text":"<p>After an extension point has been created and some extensions have been registered, you can use <code>query</code> and <code>querySingle</code> functions to find all or just a  single implementation.</p> <pre><code>class MyExtension(context: DokkaContext) {\n    // returns all registered extensions for the extension point\n    val allSampleExtensions = context.plugin&lt;MyPlugin&gt;().query { sampleExtensionPoint }\n\n    // will throw an exception if more than one extension is found.\n    // use if you expect only a single extension to be registered for the extension point\n    val singleSampleExtensions = context.plugin&lt;MyPlugin&gt;().querySingle { sampleExtensionPoint }\n\n    fun invoke() {\n        allSampleExtensions.forEach { it.doSomething(Input()) }\n\n        singleSampleExtensions.doSomething(Input())\n    }\n}\n</code></pre> <p>In order to have access to <code>DokkaContext</code>, you can use the providing keyword when registering an extension.</p>"},{"location":"developer_guide/architecture/extension_points/generation_implementations/","title":"Generation implementations","text":"<p>There are two main implementations of the Generation core extension point:</p> <ul> <li><code>SingleModuleGeneration</code> - generates documentation for a single module, for instance when <code>dokkaHtml</code> task is invoked</li> <li><code>AllModulesPageGeneration</code> - generates multi-module documentation, for instance when <code>dokkaHtmlMultiModule</code> task is   invoked.</li> </ul>"},{"location":"developer_guide/architecture/extension_points/generation_implementations/#singlemodulegeneration","title":"SingleModuleGeneration","text":"<p><code>SingleModuleGeneration</code> is at the heart of generating documentation. It utilizes core and  base extensions to build the documentation from start to finish.</p> <p>Below you can see the flow of how Dokka's data model is transformed by various core and base extensions.</p> <pre><code>flowchart TD\n    Input -- SourceToDocumentableTranslator --&gt; doc1[Documentables]\n    subgraph documentables [ ]\n    doc1 -- PreMergeDocumentableTransformer --&gt; doc2[Documentables]\n    doc2 -- DocumentableMerger --&gt; doc3[Documentables]\n    doc3 -- DocumentableTransformer --&gt; doc4[Documentables]\n    end\n    doc4 -- DocumentableToPageTranslator --&gt; page1[Pages]\n    subgraph ide2 [ ]\n    page1 -- PageTransformer --&gt; page2[Pages]\n    end\n    page2 -- Renderer --&gt; Output</code></pre> <p>You can read about what each stage does in Core extension points and  Base plugin.</p>"},{"location":"developer_guide/architecture/extension_points/generation_implementations/#allmodulespagegeneration","title":"AllModulesPageGeneration","text":"<p><code>AllModulesPageGeneration</code> utilizes the output generated by <code>SingleModuleGeneration</code>. </p> <p>Under the hood, it just collects all of the pages generated for individual modules, and assembles it all together,  creating navigation links between the modules and so on.</p>"},{"location":"developer_guide/community/slack/","title":"Slack channel","text":"<p>Dokka has a dedicated <code>#dokka</code> channel in the <code>Kotlin Community Slack</code>, where you can ask questions and chat  about using, customizing or contributing to Dokka. </p> <p>Follow the instructions to get an invite or connect directly. </p>"},{"location":"developer_guide/plugin-development/introduction/","title":"Introduction to plugin development","text":"<p>Dokka was built from the ground up to be easily extensible and highly customizable, which allows the community to  implement plugins for missing or very specific features that are not provided out of the box.</p> <p>Dokka plugins range anywhere from supporting other programming language sources to exotic output formats. You can add  support for your own KDoc tags or annotations, teach Dokka how to render different DSLs that are found in KDoc  descriptions, visually redesign Dokka's pages to be seamlessly integrated into your company's website, integrate  it with other tools and so much more.</p> <p>In order to have an easier time developing plugins, it's a good idea to go through Dokka's internals first, to learn more about its data model and  extensions.</p>"},{"location":"developer_guide/plugin-development/introduction/#setup","title":"Setup","text":""},{"location":"developer_guide/plugin-development/introduction/#template","title":"Template","text":"<p>The easiest way to start is to use the convenient Dokka plugin template. It has pre-configured dependencies, publishing and signing of your artifacts.</p>"},{"location":"developer_guide/plugin-development/introduction/#manual","title":"Manual","text":"<p>At a bare minimum, a Dokka plugin requires <code>dokka-core</code> as a dependency:</p> <pre><code>import org.jetbrains.kotlin.gradle.dsl.JvmTarget\nimport org.jetbrains.kotlin.gradle.tasks.KotlinCompile\n\n\nplugins {\n    kotlin(\"jvm\") version \"&lt;kotlin_version&gt;\"\n}\n\ndependencies {\n    compileOnly(\"org.jetbrains.dokka:dokka-core:&lt;dokka_version&gt;\")\n}\n\ntasks.withType&lt;KotlinCompile&gt;().configureEach {\n    compilerOptions.jvmTarget.set(JvmTarget.JVM_1_8)\n}\n</code></pre> <p>In order to load a plugin into Dokka, your class must extend the <code>DokkaPlugin</code> class. A fully qualified name of that class must be placed in a file named <code>org.jetbrains.dokka.plugability.DokkaPlugin</code> under <code>resources/META-INF/services</code>.  All instances are automatically loaded during Dokka's configuration step using <code>java.util.ServiceLoader</code>.</p>"},{"location":"developer_guide/plugin-development/introduction/#extension-points","title":"Extension points","text":"<p>Dokka provides a set of entry points for which you can create your own implementations. If you are not sure which extension points to use, have a look at core extensions and base extensions.</p> <p>You can learn how to declare extension points and extensions in Introduction to Extension points.</p> <p>In case no suitable extension point exists for your use case, do share the use case with the  maintainers \u2014 it might be added in a future version of Dokka.</p>"},{"location":"developer_guide/plugin-development/introduction/#example","title":"Example","text":"<p>You can follow the sample plugin tutorial, which covers the creation of a simple plugin  that hides members annotated with your own <code>@Internal</code> annotation: that is, it excludes these members from the generated documentation.</p> <p>For more practical examples, have a look at sources of  community plugins.</p>"},{"location":"developer_guide/plugin-development/introduction/#help","title":"Help","text":"<p>If you have any further questions, feel free to get in touch with Dokka's maintainers via Slack  or GitHub.</p>"},{"location":"developer_guide/plugin-development/sample-plugin-tutorial/","title":"Sample plugin tutorial","text":"<p>We'll go over creating a simple plugin that covers a very common use case: generate documentation for everything except  for members annotated with a custom <code>@Internal</code> annotation - they should be hidden.</p> <p>The plugin will be tested with the following code:</p> <pre><code>package org.jetbrains.dokka.internal.test\n\nannotation class Internal\n\nfun shouldBeVisible() {}\n\n@Internal\nfun shouldBeExcludedFromDocumentation() {}\n</code></pre> <p>Expected behavior: function <code>shouldBeExcludedFromDocumentation</code> should not be visible in generated documentation.</p> <p>Full source code of this tutorial can be found in Dokka's examples under  hide-internal-api.</p>"},{"location":"developer_guide/plugin-development/sample-plugin-tutorial/#preparing-the-project","title":"Preparing the project","text":"<p>We'll begin by using Dokka plugin template. Press the  <code>Use this template</code> button and  open this project in IntelliJ IDEA.</p> <p>First, let's rename the pre-made <code>template</code> package and <code>MyAwesomeDokkaPlugin</code> class to something of our own.</p> <p>For instance, package can be renamed to <code>org.example.dokka.plugin</code> and the class to <code>HideInternalApiPlugin</code>:</p> <pre><code>package org.example.dokka.plugin\n\nimport org.jetbrains.dokka.plugability.DokkaPlugin\n\nclass HideInternalApiPlugin : DokkaPlugin() {\n\n}\n</code></pre> <p>After you do that, make sure to update the path to this class in <code>resources/META-INF/services/org.jetbrains.dokka.plugability.DokkaPlugin</code>: <pre><code>org.example.dokka.plugin.HideInternalApiPlugin\n</code></pre></p> <p>At this point you can also change project name in <code>settings.gradle.kts</code> (to <code>hide-internal-api</code> in our case) and <code>groupId</code> in <code>build.gradle.kts</code>. </p>"},{"location":"developer_guide/plugin-development/sample-plugin-tutorial/#extending-dokka","title":"Extending Dokka","text":"<p>After preparing the project we can begin extending Dokka with our own extension.</p> <p>Having read through Core extensions, it's clear that we need a <code>PreMergeDocumentableTransformer</code> extension in order to filter out undesired documentables. </p> <p>Moreover, the article mentioned a convenient abstract transformer <code>SuppressedByConditionDocumentableFilterTransformer</code> which is perfect for our use case, so we can try to implement it.</p> <p>Create a new class, place it next to your plugin and implement the abstract method. You should end up with this:</p> <pre><code>package org.example.dokka.plugin\n\nimport org.jetbrains.dokka.base.transformers.documentables.SuppressedByConditionDocumentableFilterTransformer\nimport org.jetbrains.dokka.model.Documentable\nimport org.jetbrains.dokka.plugability.DokkaContext\nimport org.jetbrains.dokka.plugability.DokkaPlugin\n\nclass HideInternalApiPlugin : DokkaPlugin() {}\n\nclass HideInternalApiTransformer(context: DokkaContext) : SuppressedByConditionDocumentableFilterTransformer(context) {\n\n    override fun shouldBeSuppressed(d: Documentable): Boolean {\n        return false\n    }\n}\n</code></pre> <p>Now we somehow need to find all annotations applied to <code>d: Documentable</code> and see if our <code>@Internal</code> annotation is present. However, it's not very clear how to do that. What usually helps is stopping in debugger and having a look at what fields and values a given <code>Documentable</code> has.</p> <p>To do that, we'll need to register our extension point first, then we can publish our plugin and set the breakpoint.</p> <p>Having read through Introduction to extensions, we now know how to register our extensions:</p> <pre><code>class HideInternalApiPlugin : DokkaPlugin() {\n    val myFilterExtension by extending {\n        plugin&lt;DokkaBase&gt;().preMergeDocumentableTransformer providing ::HideInternalApiTransformer\n    }\n}\n</code></pre> <p>At this point we're ready to debug our plugin locally, it should already work, but do nothing.</p>"},{"location":"developer_guide/plugin-development/sample-plugin-tutorial/#debugging","title":"Debugging","text":"<p>Please read through Debugging Dokka, it goes over the same steps in more detail and with examples. Below you will find rough instructions.</p> <p>First, let's begin by publishing our plugin to <code>mavenLocal()</code>. </p> <pre><code>./gradlew publishToMavenLocal\n</code></pre> <p>This will publish your plugin under the <code>groupId</code>, <code>artifactId</code> and <code>version</code> that you've specified in your <code>build.gradle.kts</code>. In our case it's <code>org.example:hide-internal-api:1.0-SNAPSHOT</code>.</p> <p>Open a debug project of your choosing that has Dokka configured, and add our plugin to dependencies:</p> <pre><code>dependencies {\n    dokkaPlugin(\"org.example:hide-internal-api:1.0-SNAPSHOT\")\n}\n</code></pre> <p>Next, in that project let's run <code>dokkaHtml</code> with debug enabled:</p> <pre><code>./gradlew clean dokkaHtml -Dorg.gradle.debug=true --no-daemon\n</code></pre> <p>Switch to the plugin project, set a breakpoint inside <code>shouldBeSuppressed</code> and run jvm remote debug.</p> <p>If you've done everything correctly, it should stop in debugger and you should be able to observe the values contained inside <code>d: Documentable</code>.</p>"},{"location":"developer_guide/plugin-development/sample-plugin-tutorial/#implementing-plugin-logic","title":"Implementing plugin logic","text":"<p>Now that we've stopped at our breakpoint, let's skip until we see <code>shouldBeExcludedFromDocumentation</code> function in the place of <code>d: Documentable</code> (observe the changing <code>name</code> property).</p> <p>Looking at what's inside the object, you might notice it has 3 values in <code>extra</code>, one of which is <code>Annotations</code>. Sounds like something we need!</p> <p>Having poked around, we come up with the following monstrosity of a code for determining if a given documentable has <code>@Internal</code> annotation (it can of course be refactored.. later):</p> <pre><code>override fun shouldBeSuppressed(d: Documentable): Boolean {\n\n    val annotations: List&lt;Annotations.Annotation&gt; =\n        (d as? WithExtraProperties&lt;*&gt;)\n            ?.extra\n            ?.allOfType&lt;Annotations&gt;()\n            ?.flatMap { it.directAnnotations.values.flatten() }\n            ?: emptyList()\n\n    return annotations.any { isInternalAnnotation(it) }\n}\n\nprivate fun isInternalAnnotation(annotation: Annotations.Annotation): Boolean {\n   return annotation.dri.packageName == \"org.jetbrains.dokka.internal.test\"\n           &amp;&amp; annotation.dri.classNames == \"Internal\"\n}\n</code></pre> <p>Seems like we're done with writing our plugin and can begin testing it manually.</p>"},{"location":"developer_guide/plugin-development/sample-plugin-tutorial/#manual-testing","title":"Manual testing","text":"<p>At this point, the implementation of your plugin should look roughly like this:</p> <pre><code>package org.example.dokka.plugin\n\nimport org.jetbrains.dokka.base.DokkaBase\nimport org.jetbrains.dokka.base.transformers.documentables.SuppressedByConditionDocumentableFilterTransformer\nimport org.jetbrains.dokka.model.Annotations\nimport org.jetbrains.dokka.model.Documentable\nimport org.jetbrains.dokka.model.properties.WithExtraProperties\nimport org.jetbrains.dokka.plugability.DokkaContext\nimport org.jetbrains.dokka.plugability.DokkaPlugin\n\nclass HideInternalApiPlugin : DokkaPlugin() {\n    val myFilterExtension by extending {\n        plugin&lt;DokkaBase&gt;().preMergeDocumentableTransformer providing ::HideInternalApiTransformer\n    }\n}\n\nclass HideInternalApiTransformer(context: DokkaContext) : SuppressedByConditionDocumentableFilterTransformer(context) {\n\n    override fun shouldBeSuppressed(d: Documentable): Boolean {\n        val annotations: List&lt;Annotations.Annotation&gt; =\n            (d as? WithExtraProperties&lt;*&gt;)\n                ?.extra\n                ?.allOfType&lt;Annotations&gt;()\n                ?.flatMap { it.directAnnotations.values.flatten() }\n                ?: emptyList()\n\n        return annotations.any { isInternalAnnotation(it) }\n    }\n\n    private fun isInternalAnnotation(annotation: Annotations.Annotation): Boolean {\n        return annotation.dri.packageName == \"org.jetbrains.dokka.internal.test\"\n                &amp;&amp; annotation.dri.classNames == \"Internal\"\n    }\n}\n</code></pre> <p>Bump plugin version in <code>gradle.build.kts</code>, publish it to maven local, open the debug project and run <code>dokkaHtml</code>  (without debug this time). It should work, you should not be able to see <code>shouldBeExcludedFromDocumentation</code> function in generated documentation.</p> <p>Manual testing is cool and all, but wouldn't it be better if we could somehow write unit tests for it? Indeed!</p>"},{"location":"developer_guide/plugin-development/sample-plugin-tutorial/#unit-testing","title":"Unit testing","text":"<p>You might've noticed that plugin template comes with a pre-made test class. Feel free to move it to another package and rename it.</p> <p>We are mostly interested in a single test case - functions annotated with <code>@Internal</code> should be hidden, while all other public functions should be visible.</p> <p>Plugin API comes with a set of convenient test utilities that are used to test Dokka itself, so it covers a wide range of use cases. When in doubt, see Dokka's tests for reference.</p> <p>Below you will find a complete unit test that passes, and the main takeaways below that.</p> <pre><code>package org.example.dokka.plugin\n\nimport org.jetbrains.dokka.base.testApi.testRunner.BaseAbstractTest\nimport kotlin.test.Test\nimport kotlin.test.assertEquals\n\nclass HideInternalApiPluginTest : BaseAbstractTest() {\n\n    @Test\n    fun `should hide annotated functions`() {\n        val configuration = dokkaConfiguration {\n            sourceSets {\n                sourceSet {\n                    sourceRoots = listOf(\"src/main/kotlin/basic/Test.kt\")\n                }\n            }\n        }\n        val hideInternalPlugin = HideInternalApiPlugin()\n\n        testInline(\n            \"\"\"\n            |/src/main/kotlin/basic/Test.kt\n            |package org.jetbrains.dokka.internal.test\n            |\n            |annotation class Internal\n            |\n            |fun shouldBeVisible() {}\n            |\n            |@Internal\n            |fun shouldBeExcludedFromDocumentation() {}\n        \"\"\".trimMargin(),\n            configuration = configuration,\n            pluginOverrides = listOf(hideInternalPlugin)\n        ) {\n            preMergeDocumentablesTransformationStage = { modules -&gt;\n                val testModule = modules.single { it.name == \"root\" }\n                val testPackage = testModule.packages.single { it.name == \"org.jetbrains.dokka.internal.test\" }\n\n                val packageFunctions = testPackage.functions\n                assertEquals(1, packageFunctions.size)\n                assertEquals(\"shouldBeVisible\", packageFunctions[0].name)\n            }\n        }\n    }\n}\n</code></pre> <p>Note that the package of the tested code (inside <code>testInline</code> function) is the same as the package that we have hardcoded in our plugin. Make sure to change that to your own if you are following along, otherwise it will fail.</p> <p>Things to note and remember:</p> <ol> <li>Your test class should extend <code>BaseAbstractTest</code>, which contains base utility methods for testing.</li> <li>You can configure Dokka to your liking, enable some specific settings, configure     source sets, etc. All done via    <code>dokkaConfiguration</code> DSL.</li> <li><code>testInline</code> function is the main entry point for unit tests</li> <li>You can pass plugins to be used in a test, notice <code>pluginOverrides</code> parameter</li> <li>You can write asserts for different stages of generating documentation, the main ones being <code>Documentables</code> model    generation, <code>Pages</code> generation and <code>Output</code> generation. Since we implemented our plugin to work during    <code>PreMergeDocumentableTransformer</code> stage, we can test it on the same level (that is    <code>preMergeDocumentablesTransformationStage</code>).</li> <li>You will need to write asserts using the model of whatever stage you choose. For <code>Documentable</code> transformation stage     it's <code>Documentable</code>, for <code>Page</code> generation stage you would have <code>Page</code> model, and for <code>Output</code> you can have <code>.html</code>    files that you will need to parse with <code>JSoup</code> (there are also utilities for that).</li> </ol> <p>Full source code of this tutorial can be found in Dokka's examples under hide-internal-api.</p>"}]}