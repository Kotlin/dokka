{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Dokka \u00b6 Dokka is an API documentation engine for Kotlin that performs the same function as the Javadoc tool for Java , but it's modern and highly pluggable. Just like Kotlin itself, Dokka supports mixed-language projects ( Kotlin / Java ). It understands KDoc comments in Kotlin source files as well as Javadoc comments in Java files, and can generate documentation in multiple formats including its own HTML format, Java's Javadoc lookalike and Markdown . Some libraries that use Dokka for API reference docs: kotlinx.coroutines kotlinx.serialization Ktor Spring Framework Dokka provides support for the following build systems: Gradle (preffered) Maven Command line Dokka is also very pluggable and comes with convenient plugin and extension point API. You can write a plugin to support mermaid.js diagrams, mathjax formulas or even write custom processing of your own tags and annotations. For more info, see: Sample plugin tutorial Community plugins Developer guides","title":"Dokka"},{"location":"#dokka","text":"Dokka is an API documentation engine for Kotlin that performs the same function as the Javadoc tool for Java , but it's modern and highly pluggable. Just like Kotlin itself, Dokka supports mixed-language projects ( Kotlin / Java ). It understands KDoc comments in Kotlin source files as well as Javadoc comments in Java files, and can generate documentation in multiple formats including its own HTML format, Java's Javadoc lookalike and Markdown . Some libraries that use Dokka for API reference docs: kotlinx.coroutines kotlinx.serialization Ktor Spring Framework Dokka provides support for the following build systems: Gradle (preffered) Maven Command line Dokka is also very pluggable and comes with convenient plugin and extension point API. You can write a plugin to support mermaid.js diagrams, mathjax formulas or even write custom processing of your own tags and annotations. For more info, see: Sample plugin tutorial Community plugins Developer guides","title":"Dokka"},{"location":"faq/","text":"FAQ \u00b6 If you encounter any problems, please see FAQ .","title":"FAQ"},{"location":"faq/#faq","text":"If you encounter any problems, please see FAQ .","title":"FAQ"},{"location":"community/plugins-list/","text":"Dokka community plugins \u00b6 On this page you can find Dokka plugins which are supported by both Dokka maintainers and community members. If you want to add your plugin to this list, get in touch with maintainers via Slack or GitHub . If you want to learn how to develop plugins for Dokka , see Plugin development section. Output Formats \u00b6 Javadoc (Alpha) \u00b6 Javadoc plugin adds a Javadoc output format that looks like Java's Javadoc , but it's for the most part a lookalike, so you may experience problems if you try to use it with a tool that expects native Javadoc documentation generated by Java . Javadoc plugin does not support multiplatform projects and does not have a multi-module task. Javadoc plugin is shipped with Dokka , so you can start using it right away with one of the following tasks: dokkaJavadoc - builds Javadoc documentation for single-module projects or for a specific module. dokkaJavadocCollector - collects generated Javadoc documentation from submodules and assembles it together. Javadoc plugin has its own signature provider that essentially translates Kotlin signatures to Java ones. This plugin is at its early stages , so you may experience issues and encounter bugs. Feel free to report any errors you see. Plugin source code on GitHub GFM (Alpha) \u00b6 GFM plugins adds the ability to generate documentation in GitHub flavoured Markdown format. Supports both multimodule and multiplatform projects, and is shipped together with Dokka , so you can start using it right away with one of the following tasks: dokkaGfm - generate documentation for a non multi-module project or one specific module. dokkaGfmMultiModule - generate documentation for a multi-module project, assemble it together and generate navigation page/menu for all the modules. Example: // dokka-debug-kts / org.jetbrains.dokka.test / MyClass MyClass \u00b6 [jvm] class MyClass KDoc that describes this class Constructors \u00b6 MyClass [jvm] fun MyClass () Functions \u00b6 Name Summary function [jvm] fun function (): String KDoc comment on top of this function Properties \u00b6 Name Summary property [jvm] val property : String KDoc comment for a property This plugin is at its early stages , so you may experience issues and encounter bugs. Feel free to report any errors you see. Plugin source code on GitHub Jekyll (Alpha) \u00b6 Jekyll plugins adds the ability to generate documentation in Jekyll flavoured Markdown format. Supports both multi-module and multiplatform projects, and is shipped together with Dokka , so you can start using it right away with one of the following tasks: dokkaJekyll - generate documentation for a non multi-module project or one specific module. dokkaJekyllMultiModule - generate documentation for a multi-module project, assemble it together and generate navigation page/menu for all the modules. This plugin is at its early stages , so you may experience issues and encounter bugs. Feel free to report any errors you see. Plugin source code on GitHub Extensions \u00b6 Mathjax \u00b6 MathJax allows you to include mathematics in your web pages. MathJax plugin adds the ability to render mathematics from source code comments. If MathJax plugin encounters @usesMathJax KDoc tag, it adds MathJax.js (ver. 2) with config=TeX-AMS_SVG to generated HTML pages. Usage example: /** * Some math \\(\\sqrt{3x-1}+(1+x)^2\\) * * @usesMathJax */ class Foo {} Which results in: Plugin source code on GitHub Mermaid \u00b6 Mermaid JS lets you create diagrams and visualizations using text and code. Mermaid plugin allows rendering such diagrams and visualizations found in source code documentation. Usage example: /** * See the graph for more details: * \\```mermaid * graph LR * A[Christmas] -->|Get money| B(Go shopping) * B --> C{Let me think} * C -->|One| D[Laptop] * C -->|Two| E[iPhone] * C -->|Three| F[fa:fa-car Car] * \\``` */ class CompositeSubscription Which results in: For more information and examples, see Html Mermaid Dokka plugin repository on GitHub. Kotlin as Java \u00b6 With Kotlin as Java plugin applied, all Kotlin signatures will be rendered as Java signatures. For instance, fun foo(bar: Bar): Baz will be rendered as public final Baz foo(Bar bar) . Kotlin as Java plugin is published to maven central as a separate artifact : org.jetbrains.dokka:kotlin-as-java-plugin:1.7.20 . Plugin source code on GitHub","title":"Community plugins"},{"location":"community/plugins-list/#dokka-community-plugins","text":"On this page you can find Dokka plugins which are supported by both Dokka maintainers and community members. If you want to add your plugin to this list, get in touch with maintainers via Slack or GitHub . If you want to learn how to develop plugins for Dokka , see Plugin development section.","title":"Dokka community plugins"},{"location":"community/plugins-list/#output-formats","text":"","title":"Output Formats"},{"location":"community/plugins-list/#javadoc-alpha","text":"Javadoc plugin adds a Javadoc output format that looks like Java's Javadoc , but it's for the most part a lookalike, so you may experience problems if you try to use it with a tool that expects native Javadoc documentation generated by Java . Javadoc plugin does not support multiplatform projects and does not have a multi-module task. Javadoc plugin is shipped with Dokka , so you can start using it right away with one of the following tasks: dokkaJavadoc - builds Javadoc documentation for single-module projects or for a specific module. dokkaJavadocCollector - collects generated Javadoc documentation from submodules and assembles it together. Javadoc plugin has its own signature provider that essentially translates Kotlin signatures to Java ones. This plugin is at its early stages , so you may experience issues and encounter bugs. Feel free to report any errors you see. Plugin source code on GitHub","title":"Javadoc (Alpha)"},{"location":"community/plugins-list/#gfm-alpha","text":"GFM plugins adds the ability to generate documentation in GitHub flavoured Markdown format. Supports both multimodule and multiplatform projects, and is shipped together with Dokka , so you can start using it right away with one of the following tasks: dokkaGfm - generate documentation for a non multi-module project or one specific module. dokkaGfmMultiModule - generate documentation for a multi-module project, assemble it together and generate navigation page/menu for all the modules. Example: // dokka-debug-kts / org.jetbrains.dokka.test / MyClass","title":"GFM (Alpha)"},{"location":"community/plugins-list/#myclass","text":"[jvm] class MyClass KDoc that describes this class","title":"MyClass"},{"location":"community/plugins-list/#constructors","text":"MyClass [jvm] fun MyClass ()","title":"Constructors"},{"location":"community/plugins-list/#functions","text":"Name Summary function [jvm] fun function (): String KDoc comment on top of this function","title":"Functions"},{"location":"community/plugins-list/#properties","text":"Name Summary property [jvm] val property : String KDoc comment for a property This plugin is at its early stages , so you may experience issues and encounter bugs. Feel free to report any errors you see. Plugin source code on GitHub","title":"Properties"},{"location":"community/plugins-list/#jekyll-alpha","text":"Jekyll plugins adds the ability to generate documentation in Jekyll flavoured Markdown format. Supports both multi-module and multiplatform projects, and is shipped together with Dokka , so you can start using it right away with one of the following tasks: dokkaJekyll - generate documentation for a non multi-module project or one specific module. dokkaJekyllMultiModule - generate documentation for a multi-module project, assemble it together and generate navigation page/menu for all the modules. This plugin is at its early stages , so you may experience issues and encounter bugs. Feel free to report any errors you see. Plugin source code on GitHub","title":"Jekyll (Alpha)"},{"location":"community/plugins-list/#extensions","text":"","title":"Extensions"},{"location":"community/plugins-list/#mathjax","text":"MathJax allows you to include mathematics in your web pages. MathJax plugin adds the ability to render mathematics from source code comments. If MathJax plugin encounters @usesMathJax KDoc tag, it adds MathJax.js (ver. 2) with config=TeX-AMS_SVG to generated HTML pages. Usage example: /** * Some math \\(\\sqrt{3x-1}+(1+x)^2\\) * * @usesMathJax */ class Foo {} Which results in: Plugin source code on GitHub","title":"Mathjax"},{"location":"community/plugins-list/#mermaid","text":"Mermaid JS lets you create diagrams and visualizations using text and code. Mermaid plugin allows rendering such diagrams and visualizations found in source code documentation. Usage example: /** * See the graph for more details: * \\```mermaid * graph LR * A[Christmas] -->|Get money| B(Go shopping) * B --> C{Let me think} * C -->|One| D[Laptop] * C -->|Two| E[iPhone] * C -->|Three| F[fa:fa-car Car] * \\``` */ class CompositeSubscription Which results in: For more information and examples, see Html Mermaid Dokka plugin repository on GitHub.","title":"Mermaid"},{"location":"community/plugins-list/#kotlin-as-java","text":"With Kotlin as Java plugin applied, all Kotlin signatures will be rendered as Java signatures. For instance, fun foo(bar: Bar): Baz will be rendered as public final Baz foo(Bar bar) . Kotlin as Java plugin is published to maven central as a separate artifact : org.jetbrains.dokka:kotlin-as-java-plugin:1.7.20 . Plugin source code on GitHub","title":"Kotlin as Java"},{"location":"community/slack/","text":"Slack channel \u00b6 Dokka has a dedicated #dokka channel in the Kotlin Community Slack , where you can ask questions and chat about using, customizing or contributing to Dokka . Follow the instructions to get an invite or connect directly .","title":"Slack"},{"location":"community/slack/#slack-channel","text":"Dokka has a dedicated #dokka channel in the Kotlin Community Slack , where you can ask questions and chat about using, customizing or contributing to Dokka . Follow the instructions to get an invite or connect directly .","title":"Slack channel"},{"location":"developer_guide/introduction/","text":"Developer guides \u00b6 The purpose of Developer guides section is to get you acquainted with Dokka's internals so that you can start developing your own plugins or contributing features and fixes to Dokka itself. If you want to start hacking on Dokka right away, the only thing you need to be aware of is the general workflow , it will teach you how to build, debug and test Dokka locally. If you want to get into plugin development quick, see Introduction to plugin development . If you have time to spare and want to know more about Dokka's internals, its architecture and capabilities, follow Architecture overview and subsequent sections inside Internals . Having read through all the developer guides, you'll have a pretty good unrestanding of Dokka and how to develop for it. If you have any questions, feel free to get in touch with maintainers via Slack or GitHub .","title":"Developer guides"},{"location":"developer_guide/introduction/#developer-guides","text":"The purpose of Developer guides section is to get you acquainted with Dokka's internals so that you can start developing your own plugins or contributing features and fixes to Dokka itself. If you want to start hacking on Dokka right away, the only thing you need to be aware of is the general workflow , it will teach you how to build, debug and test Dokka locally. If you want to get into plugin development quick, see Introduction to plugin development . If you have time to spare and want to know more about Dokka's internals, its architecture and capabilities, follow Architecture overview and subsequent sections inside Internals . Having read through all the developer guides, you'll have a pretty good unrestanding of Dokka and how to develop for it. If you have any questions, feel free to get in touch with maintainers via Slack or GitHub .","title":"Developer guides"},{"location":"developer_guide/workflow/","text":"Workflow \u00b6 Whether you're contributing a feature/fix to Dokka itself or developing a separate plugin, there's 3 things you'll be doing: Building Dokka / Plugins Using/Testing locally built Dokka in a (debug) project Debugging Dokka / Plugin code We'll go over each step individually in this section. Examples below will be specific to Gradle and Gradle\u2019s Kotlin DSL , but you can apply the same principles and run/test/debug with CLI/Maven runners and build configurations if you wish. Building Dokka \u00b6 Building Dokka is pretty straightforward, with one small caveat: when you run ./gradlew build , it will run integration tests as well, which might take some time and will consume a lot of RAM, so you would usually want to exclude integration tests when building locally. ./gradlew build -x integrationTest Unit tests which are run as part of build should not take much time, but you can also skip it with -x test . Troubleshooting build \u00b6 API check failed for project .. \u00b6 If you see messages like API check failed for project .. during build phase, it indicates that binary compatibility check has failed, meaning you've changed/added/removed some public API. If the change was intentional, run ./gradlew apiDump - it will re-generate .api files with signatures, and you should be able to build Dokka with no errors. These updated files need to be committed as well. Maintainers will review API changes thoroughly, so please make sure it's intentional and rational. Using/testing locally built Dokka \u00b6 Having built Dokka locally, you can publish it to mavenLocal() . This will allow you to test your changes in another project as well as debug code remotely. Change dokka_version in gradle.properties to something that you will use later on as the dependency version. For instance, you can set it to something like 1.7.20-my-fix-SNAPSHOT . This version will be propagated to plugins that reside inside Dokka's project (such as mathjax , kotlin-as-java , etc). Publish it to maven local ( ./gradlew publishToMavenLocal ). Corresponding artifacts should appear in ~/.m2 In the project you want to generate documentation for or debug on, add maven local as a plugin/dependency repository: repositories { mavenLocal () } Update your dokka dependency to the version you've just published: plugins { id ( \"org.jetbrains.dokka\" ) version \"1.7.20-my-fix-SNAPSHOT\" } After completing these steps, you should be able to build documentation using your own version of Dokka. Debugging Dokka \u00b6 Dokka is essentially a gradle plugin, so you can debug it the same way you would any other gradle plugin. Below you'll find instructions on how to debug Dokka's internal logic, but you can apply the same principles if you wish to debug a plugin which resides in a separate project. Choose a project to debug on, it needs to have some code for which documentation will be generated. Prefer using smaller projects that reproduce the exact problem or behaviour you want since the less code you have, the easier it will be to understand what's going on. You can use example projects found in dokka/examples/gradle , there's both simple single-module and more complex multimodule/multiplatform examples. For the debug project, set org.gradle.debug to true in one of the following ways: In your gradle.properties add org.gradle.debug=true When running Dokka tasks: ./gradlew dokkaHtml -Dorg.gradle.debug=true --no-daemon Run desired Dokka task with --no-daemon . Gradle should wait until you attach with debugger before proceeding with the task, so no need to hurry here. Example: ./gradlew dokkaHtml -Dorg.gradle.debug=true --no-daemon . Open Dokka in IntelliJ IDEA, set a breakpoint and, using remote debug in IntelliJ IDEA, Attach to process running on the default port 5005. You can do that either by creating a Remote JVM Debug Run/Debug configuration or by attaching to the process via Run -> Attach to process Note The reason for --no-daemon is that Gradle daemons continue to exist even after the task has completed execution, so you might hang in debug or experience issues with port was already in use if you try to run it again. If you previously ran Dokka with daemons and you are already encountering problems with it, try killing gradle daemons. For instance, via pkill -f gradle.*daemon In case you need to debug some other part of the build - consult the official Gradle tutorials on Troubleshooting Builds .","title":"Workflow"},{"location":"developer_guide/workflow/#workflow","text":"Whether you're contributing a feature/fix to Dokka itself or developing a separate plugin, there's 3 things you'll be doing: Building Dokka / Plugins Using/Testing locally built Dokka in a (debug) project Debugging Dokka / Plugin code We'll go over each step individually in this section. Examples below will be specific to Gradle and Gradle\u2019s Kotlin DSL , but you can apply the same principles and run/test/debug with CLI/Maven runners and build configurations if you wish.","title":"Workflow"},{"location":"developer_guide/workflow/#building-dokka","text":"Building Dokka is pretty straightforward, with one small caveat: when you run ./gradlew build , it will run integration tests as well, which might take some time and will consume a lot of RAM, so you would usually want to exclude integration tests when building locally. ./gradlew build -x integrationTest Unit tests which are run as part of build should not take much time, but you can also skip it with -x test .","title":"Building Dokka"},{"location":"developer_guide/workflow/#troubleshooting-build","text":"","title":"Troubleshooting build"},{"location":"developer_guide/workflow/#api-check-failed-for-project","text":"If you see messages like API check failed for project .. during build phase, it indicates that binary compatibility check has failed, meaning you've changed/added/removed some public API. If the change was intentional, run ./gradlew apiDump - it will re-generate .api files with signatures, and you should be able to build Dokka with no errors. These updated files need to be committed as well. Maintainers will review API changes thoroughly, so please make sure it's intentional and rational.","title":"API check failed for project .."},{"location":"developer_guide/workflow/#usingtesting-locally-built-dokka","text":"Having built Dokka locally, you can publish it to mavenLocal() . This will allow you to test your changes in another project as well as debug code remotely. Change dokka_version in gradle.properties to something that you will use later on as the dependency version. For instance, you can set it to something like 1.7.20-my-fix-SNAPSHOT . This version will be propagated to plugins that reside inside Dokka's project (such as mathjax , kotlin-as-java , etc). Publish it to maven local ( ./gradlew publishToMavenLocal ). Corresponding artifacts should appear in ~/.m2 In the project you want to generate documentation for or debug on, add maven local as a plugin/dependency repository: repositories { mavenLocal () } Update your dokka dependency to the version you've just published: plugins { id ( \"org.jetbrains.dokka\" ) version \"1.7.20-my-fix-SNAPSHOT\" } After completing these steps, you should be able to build documentation using your own version of Dokka.","title":"Using/testing locally built Dokka"},{"location":"developer_guide/workflow/#debugging-dokka","text":"Dokka is essentially a gradle plugin, so you can debug it the same way you would any other gradle plugin. Below you'll find instructions on how to debug Dokka's internal logic, but you can apply the same principles if you wish to debug a plugin which resides in a separate project. Choose a project to debug on, it needs to have some code for which documentation will be generated. Prefer using smaller projects that reproduce the exact problem or behaviour you want since the less code you have, the easier it will be to understand what's going on. You can use example projects found in dokka/examples/gradle , there's both simple single-module and more complex multimodule/multiplatform examples. For the debug project, set org.gradle.debug to true in one of the following ways: In your gradle.properties add org.gradle.debug=true When running Dokka tasks: ./gradlew dokkaHtml -Dorg.gradle.debug=true --no-daemon Run desired Dokka task with --no-daemon . Gradle should wait until you attach with debugger before proceeding with the task, so no need to hurry here. Example: ./gradlew dokkaHtml -Dorg.gradle.debug=true --no-daemon . Open Dokka in IntelliJ IDEA, set a breakpoint and, using remote debug in IntelliJ IDEA, Attach to process running on the default port 5005. You can do that either by creating a Remote JVM Debug Run/Debug configuration or by attaching to the process via Run -> Attach to process Note The reason for --no-daemon is that Gradle daemons continue to exist even after the task has completed execution, so you might hang in debug or experience issues with port was already in use if you try to run it again. If you previously ran Dokka with daemons and you are already encountering problems with it, try killing gradle daemons. For instance, via pkill -f gradle.*daemon In case you need to debug some other part of the build - consult the official Gradle tutorials on Troubleshooting Builds .","title":"Debugging Dokka"},{"location":"developer_guide/architecture/architecture_overview/","text":"Architecture overview \u00b6 Normally, you would think that a tool like Dokka simply parses some programming language sources and generates HTML pages for whatever it sees along the way, with little to no abstractions. That would be the simplest and shortest way to implement an API documentation engine. However, it was clear that Dokka may need to generate documentation from various sources (not only Kotlin ), that users might request additional output formats (like Markdown ), that users might need additional features like supporting custom KDoc tags or rendering mermaid.js diagrams - all these things would require changing a lot of code inside Dokka itself if all solutions were hardcoded. For this reason, Dokka was built from the ground up to be easily extensible and customizable by adding several layers of abstractions to the data model, and by providing pluggable extension points, giving you the ability to introduce selective changes on a single level. Overview of data model \u00b6 Generating API documentation begins with Input source files ( .kts , .java , etc) and ends with some Output files ( .html / .md pages, etc). However, to allow for extensibility and customization, several input and output independent abstractions have been added to the data model. Below you can find the general pipeline of processing data gathered from sources and the explanation for each stage. flowchart TD Input --> Documentables --> Pages --> Output Input - generalization of sources, by default Kotlin / Java sources, but could be virtually anything Documentables - unified data model that represents any parsed sources as a tree, independent of the source language. Examples of a Documentable : class, function, package, property, etc Pages - universal model that represents output pages (e.g a function/property page) and the content it's composed of (lists, text, code blocks) that the users needs to see. Not to be confused with .html pages. Goes hand in hand with so-called Content model. Output - specific output format like HTML / Markdown / Javadoc /etc. This is a mapping of pages/content model to some human-readable and visual representation. For instance: PageNode is mapped as .html file for HTML format .md file for Markdown format ContentList is mapped as <li> / <ul> for HTML format 1. / * for Markdown format ContentCodeBlock is mapped as <code> or <pre> with some CSS styles in HTML format Text wrapped in triple backticks for Markdown format You, as a Dokka developer or a plugin writer, can use extension points to introduce selective changes to the model on one particular level without touching everything else. For instance, if you wanted to make some annotation/function/class invisible in the final documentation, you would only need to modify the Documentables model by filtering undesirable members out. If you wanted to display all overloaded methods on the same page instead of on separate ones, you would only need to modify the Page model by merging multiple pages into one, and so on. For a deeper dive into Dokka's model with more examples and details, see sections about Documentables and Page/Content For an overview of existing extension points that let you transform Dokka's models, see Core extension points and Base extensions . Overview of extension points \u00b6 An extension point usually represents some pluggable interface that performs an action during one of the stages of generating documentation. An extension is therefore an implementation of that interface which is extending the extension point. You can create extension points, provide your own implementations (extensions) and configure them. All of this is possible with Dokka's plugin/extension point API. Here's a sneak peek of the DSL: class MyPlugin : DokkaPlugin () { // create an extension point for other developers val signatureProvider by extensionPoint < SignatureProvider > () // provide a default implementation val defaultSignatureProvider by extending { signatureProvider with KotlinSignatureProvider () } // register our own extension in base plugin and override its default val dokkaBasePlugin by lazy { plugin < DokkaBase > () } val multimoduleLocationProvider by extending { ( dokkaBasePlugin . locationProviderFactory providing MultimoduleLocationProvider :: Factory override dokkaBasePlugin . locationProvider ) } } // use a registered extention, pretty much dependency injection class MyExtension ( val context : DokkaContext ) { val signatureProvider : SignatureProvider = context . plugin < MyPlugin > (). querySingle { signatureProvider } fun doSomething () { signatureProvider . signature (..) } } interface SignatureProvider { fun signature ( documentable : Documentable ): List < ContentNode > } class KotlinSignatureProvider : SignatureProvider { override fun signature ( documentable : Documentable ): List < ContentNode > = listOf () } For a deeper dive into extensions and extension points with more examples and details, see Introduction to Extensions . For an overview of existing extension points, see Core extension points and Base extensions . Historical context \u00b6 This is a second iteration of Dokka that was built from scratch. If you want to learn more about why Dokka has been designed this way, watch this great talk by Pawe\u0142 Marks: New Dokka - Designed for Fearless Creativity . The general principles and general architecture are the same, although it may be outdated in some areas, so please double-check.","title":"Architecture"},{"location":"developer_guide/architecture/architecture_overview/#architecture-overview","text":"Normally, you would think that a tool like Dokka simply parses some programming language sources and generates HTML pages for whatever it sees along the way, with little to no abstractions. That would be the simplest and shortest way to implement an API documentation engine. However, it was clear that Dokka may need to generate documentation from various sources (not only Kotlin ), that users might request additional output formats (like Markdown ), that users might need additional features like supporting custom KDoc tags or rendering mermaid.js diagrams - all these things would require changing a lot of code inside Dokka itself if all solutions were hardcoded. For this reason, Dokka was built from the ground up to be easily extensible and customizable by adding several layers of abstractions to the data model, and by providing pluggable extension points, giving you the ability to introduce selective changes on a single level.","title":"Architecture overview"},{"location":"developer_guide/architecture/architecture_overview/#overview-of-data-model","text":"Generating API documentation begins with Input source files ( .kts , .java , etc) and ends with some Output files ( .html / .md pages, etc). However, to allow for extensibility and customization, several input and output independent abstractions have been added to the data model. Below you can find the general pipeline of processing data gathered from sources and the explanation for each stage. flowchart TD Input --> Documentables --> Pages --> Output Input - generalization of sources, by default Kotlin / Java sources, but could be virtually anything Documentables - unified data model that represents any parsed sources as a tree, independent of the source language. Examples of a Documentable : class, function, package, property, etc Pages - universal model that represents output pages (e.g a function/property page) and the content it's composed of (lists, text, code blocks) that the users needs to see. Not to be confused with .html pages. Goes hand in hand with so-called Content model. Output - specific output format like HTML / Markdown / Javadoc /etc. This is a mapping of pages/content model to some human-readable and visual representation. For instance: PageNode is mapped as .html file for HTML format .md file for Markdown format ContentList is mapped as <li> / <ul> for HTML format 1. / * for Markdown format ContentCodeBlock is mapped as <code> or <pre> with some CSS styles in HTML format Text wrapped in triple backticks for Markdown format You, as a Dokka developer or a plugin writer, can use extension points to introduce selective changes to the model on one particular level without touching everything else. For instance, if you wanted to make some annotation/function/class invisible in the final documentation, you would only need to modify the Documentables model by filtering undesirable members out. If you wanted to display all overloaded methods on the same page instead of on separate ones, you would only need to modify the Page model by merging multiple pages into one, and so on. For a deeper dive into Dokka's model with more examples and details, see sections about Documentables and Page/Content For an overview of existing extension points that let you transform Dokka's models, see Core extension points and Base extensions .","title":"Overview of data model"},{"location":"developer_guide/architecture/architecture_overview/#overview-of-extension-points","text":"An extension point usually represents some pluggable interface that performs an action during one of the stages of generating documentation. An extension is therefore an implementation of that interface which is extending the extension point. You can create extension points, provide your own implementations (extensions) and configure them. All of this is possible with Dokka's plugin/extension point API. Here's a sneak peek of the DSL: class MyPlugin : DokkaPlugin () { // create an extension point for other developers val signatureProvider by extensionPoint < SignatureProvider > () // provide a default implementation val defaultSignatureProvider by extending { signatureProvider with KotlinSignatureProvider () } // register our own extension in base plugin and override its default val dokkaBasePlugin by lazy { plugin < DokkaBase > () } val multimoduleLocationProvider by extending { ( dokkaBasePlugin . locationProviderFactory providing MultimoduleLocationProvider :: Factory override dokkaBasePlugin . locationProvider ) } } // use a registered extention, pretty much dependency injection class MyExtension ( val context : DokkaContext ) { val signatureProvider : SignatureProvider = context . plugin < MyPlugin > (). querySingle { signatureProvider } fun doSomething () { signatureProvider . signature (..) } } interface SignatureProvider { fun signature ( documentable : Documentable ): List < ContentNode > } class KotlinSignatureProvider : SignatureProvider { override fun signature ( documentable : Documentable ): List < ContentNode > = listOf () } For a deeper dive into extensions and extension points with more examples and details, see Introduction to Extensions . For an overview of existing extension points, see Core extension points and Base extensions .","title":"Overview of extension points"},{"location":"developer_guide/architecture/architecture_overview/#historical-context","text":"This is a second iteration of Dokka that was built from scratch. If you want to learn more about why Dokka has been designed this way, watch this great talk by Pawe\u0142 Marks: New Dokka - Designed for Fearless Creativity . The general principles and general architecture are the same, although it may be outdated in some areas, so please double-check.","title":"Historical context"},{"location":"developer_guide/architecture/data_model/documentables/","text":"Documentables Model \u00b6 Documentables represent data that is parsed from sources. Think of this data model as of something that could be seen or produced by a compiler frontend, it's not far off from the truth. By default, documentables are parsed from Descriptor (for Kotlin ) and Psi (for Java ) models. Code-wise, you can have a look at following classes: DefaultDescriptorToDocumentableTranslator - responsible for Kotlin -> Documentable mapping DefaultPsiToDocumentableTranslator - responsible for Java -> Documentable mapping Upon creation, it's a collection of trees, each with DModule as root. Take some arbitrary Kotlin source code that is located within the same module: // Package 1 class Clazz ( val property : String ) { fun function ( parameter : String ) {} } fun topLevelFunction () {} // Package 2 enum class Enum { } val topLevelProperty : String This would be represented roughly as the following Documentable tree: flowchart TD DModule --> firstPackage[DPackage] firstPackage --> DClass firstPackage --> toplevelfunction[DFunction] DClass --> DProperty DClass --> DFunction DFunction --> DParameter DModule --> secondPackage[DPackage] secondPackage --> DEnum secondPackage --> secondPackageProperty[DProperty] At later stages of transformation, all trees are folded into one (by DocumentableMerger ). Documentable \u00b6 The main building block of documentables model is Documentable class. It's the base class for all more specific types that represent elements of parsed sources with mostly self-explanatory names ( DFunction , DPackage , DProperty , etc) . DClasslike is the base class for class-like documentables such as DClass , DEnum , DAnnotation , etc. The contents of each documentable normally represent what you would see in source code. For instance, if you open DClass , you should find that it contains references to functions, properties, companion object, constructors and so on. DEnum should have references to enum entries, and DPackage can have references to both classlikes and top-level functions and properties ( Kotlin -specific). Here's an example of a documentable: data class DClass ( val dri : DRI , val name : String , val constructors : List < DFunction > , val functions : List < DFunction > , val properties : List < DProperty > , val classlikes : List < DClasslike > , val sources : SourceSetDependent < DocumentableSource > , val visibility : SourceSetDependent < Visibility > , val companion : DObject?, val generics : List < DTypeParameter > , val supertypes : SourceSetDependent < List < TypeConstructorWithKind >> , val documentation : SourceSetDependent < DocumentationNode > , val expectPresentInSet : DokkaSourceSet?, val modifier : SourceSetDependent < Modifier > , val sourceSets : Set < DokkaSourceSet > , val isExpectActual : Boolean , val extra : PropertyContainer < DClass > = PropertyContainer . empty () ) : DClasslike (), WithAbstraction , WithCompanion , WithConstructors , WithGenerics , WithSupertypes , WithExtraProperties < DClass > There are three non-documentable classes that important for this model: DRI SourceSetDependent ExtraProperty . DRI \u00b6 DRI stans for Dokka Resource Identifier - a unique value that identifies a specific Documentable . All references and relations between documentables (other than direct ownership) are described using DRI . For example, DFunction with a parameter of type Foo has only Foo 's DRI , not the actual reference to Foo 's Documentable object. Example \u00b6 For an example of how a DRI can look like, let's take the limitedParallelism function from kotlinx.coroutines : package kotlinx.coroutines import ... public abstract class MainCoroutineDispatcher : CoroutineDispatcher () { override fun limitedParallelism ( parallelism : Int ): CoroutineDispatcher { ... } } If we were to re-create the DRI of this function in code, it would look something like this: DRI ( packageName = \"kotlinx.coroutines\" , classNames = \"MainCoroutineDispatcher\" , callable = Callable ( name = \"limitedParallelism\" , receiver = null , params = listOf ( TypeConstructor ( fullyQualifiedName = \"kotlin.Int\" , params = emptyList () ) ) ), target = PointingToDeclaration , extra = null ) If you format it as String , it would look like this: kotlinx.coroutines/MainCoroutineDispatcher/limitedParallelism/#kotlin.Int/PointingToDeclaration/ SourceSetDependent \u00b6 SourceSetDependent helps handling multiplatform data by associating platform-specific data (declared with either expect or actual modifier) with particular source sets . This comes in handy if expect / actual declarations differ. For instance, the default value for actual might differ from that declared in expect , or code comments written for expect might be different from what's written for actual . Under the hood, it's a typealias to a Map : typealias SourceSetDependent < T > = Map < DokkaSourceSet , T > ExtraProperty \u00b6 ExtraProperty is used to store any additional information that falls outside of the regular model. It is highly recommended to use extras to provide any additional information when creating custom Dokka plugins. This element is a bit more complex, so you can read more about how to use it in a separate section . Documentation model \u00b6 Documentation model is used alongside Documentables to store data obtained by parsing code comments (such as KDoc / Javadoc ). DocTag \u00b6 DocTag describes a specific documentation syntax element. It's universal across source languages. For instance, DocTag B is the same for **bold** in Kotlin and <b>bold</b> in Java . However, some DocTag elements are specific to a certain language, there are many such examples for Java because it allows HTML tags inside Javadoc comments, some of which are simply not possible to reproduce with Markdown . DocTag elements can be deeply nested with other DocTag children elements. Examples: data class H1 ( override val children : List < DocTag > = emptyList (), override val params : Map < String , String > = emptyMap () ) : DocTag () data class H2 ( override val children : List < DocTag > = emptyList (), override val params : Map < String , String > = emptyMap () ) : DocTag () data class Strikethrough ( override val children : List < DocTag > = emptyList (), override val params : Map < String , String > = emptyMap () ) : DocTag () data class Strong ( override val children : List < DocTag > = emptyList (), override val params : Map < String , String > = emptyMap () ) : DocTag () data class CodeBlock ( override val children : List < DocTag > = emptyList (), override val params : Map < String , String > = emptyMap () ) : Code () TagWrapper \u00b6 TagWrapper describes the whole comment description or a specific comment tag. For example: @see / @author / @return . Since each such section may contain formatted text inside of it, each TagWrapper has DocTag children. /** * @author **Ben Affleck* * @return nothing, except _sometimes_ it may throw an [Error] */ fun foo () {} DocumentationNode \u00b6 DocumentationNode acts as a container for multiple TagWrapper elements for a specific Documentable , usually used like this: data class DFunction ( ... val documentation : SourceSetDependent < DocumentationNode > , ... )","title":"Documentables"},{"location":"developer_guide/architecture/data_model/documentables/#documentables-model","text":"Documentables represent data that is parsed from sources. Think of this data model as of something that could be seen or produced by a compiler frontend, it's not far off from the truth. By default, documentables are parsed from Descriptor (for Kotlin ) and Psi (for Java ) models. Code-wise, you can have a look at following classes: DefaultDescriptorToDocumentableTranslator - responsible for Kotlin -> Documentable mapping DefaultPsiToDocumentableTranslator - responsible for Java -> Documentable mapping Upon creation, it's a collection of trees, each with DModule as root. Take some arbitrary Kotlin source code that is located within the same module: // Package 1 class Clazz ( val property : String ) { fun function ( parameter : String ) {} } fun topLevelFunction () {} // Package 2 enum class Enum { } val topLevelProperty : String This would be represented roughly as the following Documentable tree: flowchart TD DModule --> firstPackage[DPackage] firstPackage --> DClass firstPackage --> toplevelfunction[DFunction] DClass --> DProperty DClass --> DFunction DFunction --> DParameter DModule --> secondPackage[DPackage] secondPackage --> DEnum secondPackage --> secondPackageProperty[DProperty] At later stages of transformation, all trees are folded into one (by DocumentableMerger ).","title":"Documentables Model"},{"location":"developer_guide/architecture/data_model/documentables/#documentable","text":"The main building block of documentables model is Documentable class. It's the base class for all more specific types that represent elements of parsed sources with mostly self-explanatory names ( DFunction , DPackage , DProperty , etc) . DClasslike is the base class for class-like documentables such as DClass , DEnum , DAnnotation , etc. The contents of each documentable normally represent what you would see in source code. For instance, if you open DClass , you should find that it contains references to functions, properties, companion object, constructors and so on. DEnum should have references to enum entries, and DPackage can have references to both classlikes and top-level functions and properties ( Kotlin -specific). Here's an example of a documentable: data class DClass ( val dri : DRI , val name : String , val constructors : List < DFunction > , val functions : List < DFunction > , val properties : List < DProperty > , val classlikes : List < DClasslike > , val sources : SourceSetDependent < DocumentableSource > , val visibility : SourceSetDependent < Visibility > , val companion : DObject?, val generics : List < DTypeParameter > , val supertypes : SourceSetDependent < List < TypeConstructorWithKind >> , val documentation : SourceSetDependent < DocumentationNode > , val expectPresentInSet : DokkaSourceSet?, val modifier : SourceSetDependent < Modifier > , val sourceSets : Set < DokkaSourceSet > , val isExpectActual : Boolean , val extra : PropertyContainer < DClass > = PropertyContainer . empty () ) : DClasslike (), WithAbstraction , WithCompanion , WithConstructors , WithGenerics , WithSupertypes , WithExtraProperties < DClass > There are three non-documentable classes that important for this model: DRI SourceSetDependent ExtraProperty .","title":"Documentable"},{"location":"developer_guide/architecture/data_model/documentables/#dri","text":"DRI stans for Dokka Resource Identifier - a unique value that identifies a specific Documentable . All references and relations between documentables (other than direct ownership) are described using DRI . For example, DFunction with a parameter of type Foo has only Foo 's DRI , not the actual reference to Foo 's Documentable object.","title":"DRI"},{"location":"developer_guide/architecture/data_model/documentables/#example","text":"For an example of how a DRI can look like, let's take the limitedParallelism function from kotlinx.coroutines : package kotlinx.coroutines import ... public abstract class MainCoroutineDispatcher : CoroutineDispatcher () { override fun limitedParallelism ( parallelism : Int ): CoroutineDispatcher { ... } } If we were to re-create the DRI of this function in code, it would look something like this: DRI ( packageName = \"kotlinx.coroutines\" , classNames = \"MainCoroutineDispatcher\" , callable = Callable ( name = \"limitedParallelism\" , receiver = null , params = listOf ( TypeConstructor ( fullyQualifiedName = \"kotlin.Int\" , params = emptyList () ) ) ), target = PointingToDeclaration , extra = null ) If you format it as String , it would look like this: kotlinx.coroutines/MainCoroutineDispatcher/limitedParallelism/#kotlin.Int/PointingToDeclaration/","title":"Example"},{"location":"developer_guide/architecture/data_model/documentables/#sourcesetdependent","text":"SourceSetDependent helps handling multiplatform data by associating platform-specific data (declared with either expect or actual modifier) with particular source sets . This comes in handy if expect / actual declarations differ. For instance, the default value for actual might differ from that declared in expect , or code comments written for expect might be different from what's written for actual . Under the hood, it's a typealias to a Map : typealias SourceSetDependent < T > = Map < DokkaSourceSet , T >","title":"SourceSetDependent"},{"location":"developer_guide/architecture/data_model/documentables/#extraproperty","text":"ExtraProperty is used to store any additional information that falls outside of the regular model. It is highly recommended to use extras to provide any additional information when creating custom Dokka plugins. This element is a bit more complex, so you can read more about how to use it in a separate section .","title":"ExtraProperty"},{"location":"developer_guide/architecture/data_model/documentables/#documentation-model","text":"Documentation model is used alongside Documentables to store data obtained by parsing code comments (such as KDoc / Javadoc ).","title":"Documentation model"},{"location":"developer_guide/architecture/data_model/documentables/#doctag","text":"DocTag describes a specific documentation syntax element. It's universal across source languages. For instance, DocTag B is the same for **bold** in Kotlin and <b>bold</b> in Java . However, some DocTag elements are specific to a certain language, there are many such examples for Java because it allows HTML tags inside Javadoc comments, some of which are simply not possible to reproduce with Markdown . DocTag elements can be deeply nested with other DocTag children elements. Examples: data class H1 ( override val children : List < DocTag > = emptyList (), override val params : Map < String , String > = emptyMap () ) : DocTag () data class H2 ( override val children : List < DocTag > = emptyList (), override val params : Map < String , String > = emptyMap () ) : DocTag () data class Strikethrough ( override val children : List < DocTag > = emptyList (), override val params : Map < String , String > = emptyMap () ) : DocTag () data class Strong ( override val children : List < DocTag > = emptyList (), override val params : Map < String , String > = emptyMap () ) : DocTag () data class CodeBlock ( override val children : List < DocTag > = emptyList (), override val params : Map < String , String > = emptyMap () ) : Code ()","title":"DocTag"},{"location":"developer_guide/architecture/data_model/documentables/#tagwrapper","text":"TagWrapper describes the whole comment description or a specific comment tag. For example: @see / @author / @return . Since each such section may contain formatted text inside of it, each TagWrapper has DocTag children. /** * @author **Ben Affleck* * @return nothing, except _sometimes_ it may throw an [Error] */ fun foo () {}","title":"TagWrapper"},{"location":"developer_guide/architecture/data_model/documentables/#documentationnode","text":"DocumentationNode acts as a container for multiple TagWrapper elements for a specific Documentable , usually used like this: data class DFunction ( ... val documentation : SourceSetDependent < DocumentationNode > , ... )","title":"DocumentationNode"},{"location":"developer_guide/architecture/data_model/extra/","text":"Extra \u00b6 Introduction \u00b6 ExtraProperty classes are used both by Documentable and Content models. Source code for ExtraProperty : interface ExtraProperty < in C : Any > { interface Key < in C : Any , T : Any > { fun mergeStrategyFor ( left : T , right : T ): MergeStrategy < C > = MergeStrategy . Fail { throw NotImplementedError ( \"Property merging for $ this is not implemented\" ) } } val key : Key < C , *> } To declare a new extra, you need to implement ExtraProperty interface. It is advised to use following pattern when declaring new extras: data class CustomExtra ( [ any data relevant to your extra ] , [ any data relevant to your extra ] ): ExtraProperty < Documentable > { override val key : CustomExtra . Key < Documentable , *> = CustomExtra companion object : CustomExtra . Key < Documentable , CustomExtra > } Merge strategy ( mergeStrategyFor method) for extras is invoked during merging if documentables from different source sets each have their own Extra of the same type. PropertyContainer \u00b6 All extras for ContentNode and Documentable classes are stored in PropertyContainer<C : Any> class instances. data class DFunction ( ... override val extra : PropertyContainer < DFunction > = PropertyContainer . empty () ... ) : WithExtraProperties < DFunction > PropertyContainer has a number of convenient functions for handling extras in a collection-like manner. The C generic class parameter limits the type of properties that can be stored in the container - it must match generic C class parameter from ExtraProperty interface. This allows creating extra properties which can only be stored in a specific Documentable . Usage example \u00b6 In following example we will create a DFunction -only property, store it and then retrieve its value: data class CustomExtra ( val customExtraValue : String ) : ExtraProperty < DFunction > { override val key : ExtraProperty . Key < Documentable , *> = CustomExtra companion object : ExtraProperty . Key < Documentable , CustomExtra > } fun DFunction . withCustomExtraProperty ( data : String ): DFunction { return this . copy ( extra = extra + CustomExtra ( data ) ) } fun DFunction . getCustomExtraPropertyValue (): String? { return this . extra [ CustomExtra ]?. customExtraValue } You can also use extras as markers, without storing any data in them: object MarkerExtra : ExtraProperty < Any > , ExtraProperty . Key < Any , MarkerExtra > { override val key : ExtraProperty . Key < Any , *> = this } fun Documentable . markIfFunction (): Documentable { return when ( this ) { is DFunction -> this . copy ( extra = extra + MarkerExtra ) else -> this } } fun WithExtraProperties < Documentable > . isMarked (): Boolean { return this . extra [ MarkerExtra ] != null }","title":"Extra properties"},{"location":"developer_guide/architecture/data_model/extra/#extra","text":"","title":"Extra"},{"location":"developer_guide/architecture/data_model/extra/#introduction","text":"ExtraProperty classes are used both by Documentable and Content models. Source code for ExtraProperty : interface ExtraProperty < in C : Any > { interface Key < in C : Any , T : Any > { fun mergeStrategyFor ( left : T , right : T ): MergeStrategy < C > = MergeStrategy . Fail { throw NotImplementedError ( \"Property merging for $ this is not implemented\" ) } } val key : Key < C , *> } To declare a new extra, you need to implement ExtraProperty interface. It is advised to use following pattern when declaring new extras: data class CustomExtra ( [ any data relevant to your extra ] , [ any data relevant to your extra ] ): ExtraProperty < Documentable > { override val key : CustomExtra . Key < Documentable , *> = CustomExtra companion object : CustomExtra . Key < Documentable , CustomExtra > } Merge strategy ( mergeStrategyFor method) for extras is invoked during merging if documentables from different source sets each have their own Extra of the same type.","title":"Introduction"},{"location":"developer_guide/architecture/data_model/extra/#propertycontainer","text":"All extras for ContentNode and Documentable classes are stored in PropertyContainer<C : Any> class instances. data class DFunction ( ... override val extra : PropertyContainer < DFunction > = PropertyContainer . empty () ... ) : WithExtraProperties < DFunction > PropertyContainer has a number of convenient functions for handling extras in a collection-like manner. The C generic class parameter limits the type of properties that can be stored in the container - it must match generic C class parameter from ExtraProperty interface. This allows creating extra properties which can only be stored in a specific Documentable .","title":"PropertyContainer"},{"location":"developer_guide/architecture/data_model/extra/#usage-example","text":"In following example we will create a DFunction -only property, store it and then retrieve its value: data class CustomExtra ( val customExtraValue : String ) : ExtraProperty < DFunction > { override val key : ExtraProperty . Key < Documentable , *> = CustomExtra companion object : ExtraProperty . Key < Documentable , CustomExtra > } fun DFunction . withCustomExtraProperty ( data : String ): DFunction { return this . copy ( extra = extra + CustomExtra ( data ) ) } fun DFunction . getCustomExtraPropertyValue (): String? { return this . extra [ CustomExtra ]?. customExtraValue } You can also use extras as markers, without storing any data in them: object MarkerExtra : ExtraProperty < Any > , ExtraProperty . Key < Any , MarkerExtra > { override val key : ExtraProperty . Key < Any , *> = this } fun Documentable . markIfFunction (): Documentable { return when ( this ) { is DFunction -> this . copy ( extra = extra + MarkerExtra ) else -> this } } fun WithExtraProperties < Documentable > . isMarked (): Boolean { return this . extra [ MarkerExtra ] != null }","title":"Usage example"},{"location":"developer_guide/architecture/data_model/page_content/","text":"Page / Content Model \u00b6 Even though Page and Content models reside on the same level (under Page ), it's easier to view it as two different models altogether, even though Content is only used in conjunction with and inside Page model. Page \u00b6 Page model represents the structure of documentation pages to be generated. During rendering, each page is processed separately, so one page corresponds to exactly one output file. Page model is independent of the final output format, in other words it's universal. Which extension the pages should be created as ( .html , .md , etc) and how is up to the Renderer . Subclasses of PageNode represent different kinds of rendered pages, such as ModulePage , PackagePage , ClasslikePage , MemberPage (properties, functions), etc. The Page Model is a tree structure, with RootPageNode at the root. Here's an example of how an arbitrary Page tree might look like for a module with 3 packages, one of which contains a top level function, top level property and a class, inside which there's a function and a property: flowchart TD RootPageNode --> firstPackage[PackagePageNode] RootPageNode --> secondPackage[PackagePageNode] RootPageNode --> thirdPackage[PackagePageNode] firstPackage --> firstPackageFirstMember[MemberPageNode - Function] firstPackage --> firstPackageSecondMember[MemberPageNode - Property] firstPackage ---> firstPackageClasslike[ClasslikePageNode - Class] firstPackageClasslike --> firstPackageClasslikeFirstMember[MemberPageNode - Function] firstPackageClasslike --> firstPackageClasslikeSecondMember[MemberPageNode - Property] secondPackage --> etcOne[...] thirdPackage --> etcTwo[...] Almost all pages are derivatives of ContentPage - it's the type of Page that has Content on it. Content Model \u00b6 Content model describes how the actual Page content is presented. The important thing to understand is that it's also output-format independent and is universal. Content model is essentially a set of building blocks that you can put together to represent some content. Have a look at subclasses of ContentNode : ContentText , ContentList , ContentTable , ContentCodeBlock , ContentHeader and so on. You can group content together with ContentGroup - for instance, to wrap all children with some style. // real example of composing content using `DocumentableContentBuilder` DSL orderedList { item { text ( \"This list contains a nested table:\" ) table { header { text ( \"Col1\" ) text ( \"Col2\" ) } row { text ( \"Text1\" ) text ( \"Text2\" ) } } } item { group ( styles = setOf ( TextStyle . Bold )) { text ( \"This is bald\" ) text ( \"This is also bald\" ) } } } It is then responsibility of Renderer (i.e specific output format) to render it the way it wants. For instance, HtmlRenderer might render ContentCodeBlock as <code>text</code> , but CommonmarkRenderer might render it using backticks. DCI \u00b6 Each node is identified by unique DCI , which stands for Dokka Content Identifier . DCI aggregates DRI s of all Documentables that make up a specific ContentNode . data class DCI ( val dri : Set < DRI > , val kind : Kind ) All references to other nodes (other than direct ownership) are described using DCI . ContentKind \u00b6 ContentKind represents a grouping of content of one kind that can can be rendered as part of a composite page (one tab/block within a class's page, for instance). For instance, on the same page that describes a class you can have multiple sections (== ContentKind ). One to describe functions, one to describe properties, another one to describe constructors and so on. Styles \u00b6 Each ContentNode has styles property in case you want to incidate to Renderer that this content needs to be displayed in a certain way. group ( styles = setOf ( TextStyle . Paragraph )) { text ( \"Text1\" , styles = setOf ( TextStyle . Bold )) text ( \"Text2\" , styles = setOf ( TextStyle . Italic )) } It is then responsibility of Renderer (i.e specific output format) to render it the way it wants. For instance, HtmlRenderer might render TextStyle.Bold as <b>text</b> , but CommonmarkRenderer might render it as **text** . There's a number of existing styles that you can use, most of them are supported by HtmlRenderer out of the box: // for code highlighting enum class TokenStyle : Style { Keyword , Punctuation , Function , Operator , Annotation , Number , String , Boolean , Constant , Builtin , ... } enum class TextStyle : Style { Bold , Italic , Strong , Strikethrough , Paragraph , ... } enum class ContentStyle : Style { TabbedContent , RunnableSample , Wrapped , Indented , ... } Extra \u00b6 ExtraProperty is used to store any additional information that falls outside of the regular model. It is highly recommended to use extras to provide any additional information when creating custom Dokka plugins. All ExtraProperty elements from Documentable model are propagated into Content model and are available for Renderer . This element is a bit complex, so you can read more about how to use it in a separate section .","title":"Page & Content"},{"location":"developer_guide/architecture/data_model/page_content/#page-content-model","text":"Even though Page and Content models reside on the same level (under Page ), it's easier to view it as two different models altogether, even though Content is only used in conjunction with and inside Page model.","title":"Page / Content Model"},{"location":"developer_guide/architecture/data_model/page_content/#page","text":"Page model represents the structure of documentation pages to be generated. During rendering, each page is processed separately, so one page corresponds to exactly one output file. Page model is independent of the final output format, in other words it's universal. Which extension the pages should be created as ( .html , .md , etc) and how is up to the Renderer . Subclasses of PageNode represent different kinds of rendered pages, such as ModulePage , PackagePage , ClasslikePage , MemberPage (properties, functions), etc. The Page Model is a tree structure, with RootPageNode at the root. Here's an example of how an arbitrary Page tree might look like for a module with 3 packages, one of which contains a top level function, top level property and a class, inside which there's a function and a property: flowchart TD RootPageNode --> firstPackage[PackagePageNode] RootPageNode --> secondPackage[PackagePageNode] RootPageNode --> thirdPackage[PackagePageNode] firstPackage --> firstPackageFirstMember[MemberPageNode - Function] firstPackage --> firstPackageSecondMember[MemberPageNode - Property] firstPackage ---> firstPackageClasslike[ClasslikePageNode - Class] firstPackageClasslike --> firstPackageClasslikeFirstMember[MemberPageNode - Function] firstPackageClasslike --> firstPackageClasslikeSecondMember[MemberPageNode - Property] secondPackage --> etcOne[...] thirdPackage --> etcTwo[...] Almost all pages are derivatives of ContentPage - it's the type of Page that has Content on it.","title":"Page"},{"location":"developer_guide/architecture/data_model/page_content/#content-model","text":"Content model describes how the actual Page content is presented. The important thing to understand is that it's also output-format independent and is universal. Content model is essentially a set of building blocks that you can put together to represent some content. Have a look at subclasses of ContentNode : ContentText , ContentList , ContentTable , ContentCodeBlock , ContentHeader and so on. You can group content together with ContentGroup - for instance, to wrap all children with some style. // real example of composing content using `DocumentableContentBuilder` DSL orderedList { item { text ( \"This list contains a nested table:\" ) table { header { text ( \"Col1\" ) text ( \"Col2\" ) } row { text ( \"Text1\" ) text ( \"Text2\" ) } } } item { group ( styles = setOf ( TextStyle . Bold )) { text ( \"This is bald\" ) text ( \"This is also bald\" ) } } } It is then responsibility of Renderer (i.e specific output format) to render it the way it wants. For instance, HtmlRenderer might render ContentCodeBlock as <code>text</code> , but CommonmarkRenderer might render it using backticks.","title":"Content Model"},{"location":"developer_guide/architecture/data_model/page_content/#dci","text":"Each node is identified by unique DCI , which stands for Dokka Content Identifier . DCI aggregates DRI s of all Documentables that make up a specific ContentNode . data class DCI ( val dri : Set < DRI > , val kind : Kind ) All references to other nodes (other than direct ownership) are described using DCI .","title":"DCI"},{"location":"developer_guide/architecture/data_model/page_content/#contentkind","text":"ContentKind represents a grouping of content of one kind that can can be rendered as part of a composite page (one tab/block within a class's page, for instance). For instance, on the same page that describes a class you can have multiple sections (== ContentKind ). One to describe functions, one to describe properties, another one to describe constructors and so on.","title":"ContentKind"},{"location":"developer_guide/architecture/data_model/page_content/#styles","text":"Each ContentNode has styles property in case you want to incidate to Renderer that this content needs to be displayed in a certain way. group ( styles = setOf ( TextStyle . Paragraph )) { text ( \"Text1\" , styles = setOf ( TextStyle . Bold )) text ( \"Text2\" , styles = setOf ( TextStyle . Italic )) } It is then responsibility of Renderer (i.e specific output format) to render it the way it wants. For instance, HtmlRenderer might render TextStyle.Bold as <b>text</b> , but CommonmarkRenderer might render it as **text** . There's a number of existing styles that you can use, most of them are supported by HtmlRenderer out of the box: // for code highlighting enum class TokenStyle : Style { Keyword , Punctuation , Function , Operator , Annotation , Number , String , Boolean , Constant , Builtin , ... } enum class TextStyle : Style { Bold , Italic , Strong , Strikethrough , Paragraph , ... } enum class ContentStyle : Style { TabbedContent , RunnableSample , Wrapped , Indented , ... }","title":"Styles"},{"location":"developer_guide/architecture/data_model/page_content/#extra","text":"ExtraProperty is used to store any additional information that falls outside of the regular model. It is highly recommended to use extras to provide any additional information when creating custom Dokka plugins. All ExtraProperty elements from Documentable model are propagated into Content model and are available for Renderer . This element is a bit complex, so you can read more about how to use it in a separate section .","title":"Extra"},{"location":"developer_guide/architecture/extension_points/base_extensions/","text":"Base extensions \u00b6 DokkaBase class is a base plugin which defines a number of default implementations for CoreExtensions as well as declares its own, more high-level extension points to be used from other plugins and output formats. It's very convenient to use extension points and defaults defined in DokkaBase if you have an idea for a simple plugin that only needs to provide a few extensions or change a single extension point and have everything else be the default. DokkaBase is used extensively for Dokka's own output formats such as HTML , Markdown , Mathjax and others. You can learn how to add/use/override/configure extensions and extension points in Introduction to Extensions , all the information is applicable to DokkaBase plugin as well.","title":"Base extensions"},{"location":"developer_guide/architecture/extension_points/base_extensions/#base-extensions","text":"DokkaBase class is a base plugin which defines a number of default implementations for CoreExtensions as well as declares its own, more high-level extension points to be used from other plugins and output formats. It's very convenient to use extension points and defaults defined in DokkaBase if you have an idea for a simple plugin that only needs to provide a few extensions or change a single extension point and have everything else be the default. DokkaBase is used extensively for Dokka's own output formats such as HTML , Markdown , Mathjax and others. You can learn how to add/use/override/configure extensions and extension points in Introduction to Extensions , all the information is applicable to DokkaBase plugin as well.","title":"Base extensions"},{"location":"developer_guide/architecture/extension_points/core_extensions/","text":"Core extension points \u00b6 Core extension points represent the main stages of generating documentation. These extension points are plugin and output format independent, meaning it's the very core functionality and as low-level as can get. For higher-level extension functions that can be used in different output formats, have a look at Base extensions defined in DokkaBase . You can find all core extensions in CoreExtensions class: object CoreExtensions { val preGenerationCheck by coreExtensionPoint < PreGenerationChecker > () val generation by coreExtensionPoint < Generation > () val sourceToDocumentableTranslator by coreExtensionPoint < SourceToDocumentableTranslator > () val documentableMerger by coreExtensionPoint < DocumentableMerger > () val documentableTransformer by coreExtensionPoint < DocumentableTransformer > () val documentableToPageTranslator by coreExtensionPoint < DocumentableToPageTranslator > () val pageTransformer by coreExtensionPoint < PageTransformer > () val renderer by coreExtensionPoint < Renderer > () val postActions by coreExtensionPoint < PostAction > () } On this page we'll go over each extension point individually. PreGenerationChecker \u00b6 PreGenerationChecker can be used to run some checks and constraints. For instance, Javadoc plugin does not support generating documentation for multi-platform projects, so it uses PreGenerationChecker to check for multi-platform source sets and fails if it finds any. Generation \u00b6 Generation is responsible for generating documentation as a whole, utilizing other extension points where applicable. There are two implementations at the moment: AllModulesPageGeneration - generates multimodule documentation, for instance when dokkaHtmlMultiModule task is invoked. SingleModuleGeneration - generates documentation for a single module, for instance when dokkaHtml task is invoked AllModulesPageGeneration \u00b6 AllModulesPageGeneration utilizes output generated by SingleModuleGeneration . Under the hood it just collects all pages generated for individual modules and assembles everything together, creating navigation pages between the modules and so on. SingleModuleGeneration stages \u00b6 When developing a feature or a plugin, it's more convenient to think that you are generating documentation for single module projects, believing that Dokka will somehow take care of the rest in multimodule environment. SingleModuleGeneration is at heart of generating documentation and utilizes other core extension points, so it's worth going over its stages. Below you can see the transformations of Dokka's models and extension interfaces responsible for each one. Notice how Documentables and Pages are transformed multiple times. flowchart TD Input -- SourceToDocumentableTranslator --> doc1[Documentables] subgraph documentables [ ] doc1 -- PreMergeDocumentableTransformer --> doc2[Documentables] doc2 -- DocumentableMerger --> doc3[Documentables] doc3 -- DocumentableTransformer --> doc4[Documentables] end doc4 -- DocumentableToPageTranslator --> page1[Pages] subgraph ide2 [ ] page1 -- PageTransformer --> page2[Pages] end page2 -- Renderer --> Output SourceToDocumentableTranslator \u00b6 SourceToDocumentableTranslator translates sources into documentable model. Kotlin and Java sources are supported by default, but you can analyze any language as long as you can map it to the Documentable model. For reference, see DefaultDescriptorToDocumentableTranslator for Kotlin sources translation DefaultPsiToDocumentableTranslator for Java sources translation PreMergeDocumentableTransformer \u00b6 This extension point actually comes from DokkaBase and is not a core extension point, but it's used in SingleModuleGeneration nonetheless. If you are implementing your own plugin without relying on DokkaBase , you can either introduce a similar extension point or rely on DocumentableTransformer which will be discussed below. PreMergeDocumentableTransformer allows applying any transformation to Documentables model before different source sets are merged. Useful if you want to filter/map existing documentables. For instance, if you want to exclude members annotated with @Internal , you most likely need an implementation of PreMergeDocumentableTransformer . For simple condition-based filtering of documentables consider extending SuppressedByConditionDocumentableFilterTransformer - it implements PreMergeDocumentableTransformer and only requires one function to be overridden. The rest is taken care of. DocumentableMerger \u00b6 DocumentableMerger merges all DModule instances into one. Only one extension is expected of this type. DocumentableTransformer \u00b6 DocumentableTransformer performs the same function as PreMergeDocumentableTransformer , but after merging source sets. Notable example is InheritorsExtractorTransformer , it extracts inherited classes data across source sets and creates an inheritance map. DocumentableToPageTranslator \u00b6 DocumentableToPageTranslator is responsible for creating pages and their content. See Page/Content model section for more information and examples. Different output formats can either use the same page structure or define their own in case it needs to be different. Only a single extension of this type is expected to be registered. PageTransformer \u00b6 PageTransformer is useful if you need to add/remove/modify generated pages or their content. Plugins like mathjax can add .js scripts to pages using this extension point. If you want all overloaded functions to be rendered on the same page (instead of separate ones), you can also use PageTransformer to delete excessive pages and combine them into a new single one. Renderer \u00b6 Renderer - defines rules on what to do with pages and their content, which files to create and how to display it properly. Output format implementations should use Renderer extension point. Notable examples are HtmlRenderer and CommonmarkRenderer . PostAction \u00b6 PostAction is useful for when you want to run some actions after the documentation has been generated - for instance if you want to move some files around. Versioning plugin utilizes PostAction in order to move generated documentation to versioned folders.","title":"Core extension points"},{"location":"developer_guide/architecture/extension_points/core_extensions/#core-extension-points","text":"Core extension points represent the main stages of generating documentation. These extension points are plugin and output format independent, meaning it's the very core functionality and as low-level as can get. For higher-level extension functions that can be used in different output formats, have a look at Base extensions defined in DokkaBase . You can find all core extensions in CoreExtensions class: object CoreExtensions { val preGenerationCheck by coreExtensionPoint < PreGenerationChecker > () val generation by coreExtensionPoint < Generation > () val sourceToDocumentableTranslator by coreExtensionPoint < SourceToDocumentableTranslator > () val documentableMerger by coreExtensionPoint < DocumentableMerger > () val documentableTransformer by coreExtensionPoint < DocumentableTransformer > () val documentableToPageTranslator by coreExtensionPoint < DocumentableToPageTranslator > () val pageTransformer by coreExtensionPoint < PageTransformer > () val renderer by coreExtensionPoint < Renderer > () val postActions by coreExtensionPoint < PostAction > () } On this page we'll go over each extension point individually.","title":"Core extension points"},{"location":"developer_guide/architecture/extension_points/core_extensions/#pregenerationchecker","text":"PreGenerationChecker can be used to run some checks and constraints. For instance, Javadoc plugin does not support generating documentation for multi-platform projects, so it uses PreGenerationChecker to check for multi-platform source sets and fails if it finds any.","title":"PreGenerationChecker"},{"location":"developer_guide/architecture/extension_points/core_extensions/#generation","text":"Generation is responsible for generating documentation as a whole, utilizing other extension points where applicable. There are two implementations at the moment: AllModulesPageGeneration - generates multimodule documentation, for instance when dokkaHtmlMultiModule task is invoked. SingleModuleGeneration - generates documentation for a single module, for instance when dokkaHtml task is invoked","title":"Generation"},{"location":"developer_guide/architecture/extension_points/core_extensions/#allmodulespagegeneration","text":"AllModulesPageGeneration utilizes output generated by SingleModuleGeneration . Under the hood it just collects all pages generated for individual modules and assembles everything together, creating navigation pages between the modules and so on.","title":"AllModulesPageGeneration"},{"location":"developer_guide/architecture/extension_points/core_extensions/#singlemodulegeneration-stages","text":"When developing a feature or a plugin, it's more convenient to think that you are generating documentation for single module projects, believing that Dokka will somehow take care of the rest in multimodule environment. SingleModuleGeneration is at heart of generating documentation and utilizes other core extension points, so it's worth going over its stages. Below you can see the transformations of Dokka's models and extension interfaces responsible for each one. Notice how Documentables and Pages are transformed multiple times. flowchart TD Input -- SourceToDocumentableTranslator --> doc1[Documentables] subgraph documentables [ ] doc1 -- PreMergeDocumentableTransformer --> doc2[Documentables] doc2 -- DocumentableMerger --> doc3[Documentables] doc3 -- DocumentableTransformer --> doc4[Documentables] end doc4 -- DocumentableToPageTranslator --> page1[Pages] subgraph ide2 [ ] page1 -- PageTransformer --> page2[Pages] end page2 -- Renderer --> Output","title":"SingleModuleGeneration stages"},{"location":"developer_guide/architecture/extension_points/core_extensions/#sourcetodocumentabletranslator","text":"SourceToDocumentableTranslator translates sources into documentable model. Kotlin and Java sources are supported by default, but you can analyze any language as long as you can map it to the Documentable model. For reference, see DefaultDescriptorToDocumentableTranslator for Kotlin sources translation DefaultPsiToDocumentableTranslator for Java sources translation","title":"SourceToDocumentableTranslator"},{"location":"developer_guide/architecture/extension_points/core_extensions/#premergedocumentabletransformer","text":"This extension point actually comes from DokkaBase and is not a core extension point, but it's used in SingleModuleGeneration nonetheless. If you are implementing your own plugin without relying on DokkaBase , you can either introduce a similar extension point or rely on DocumentableTransformer which will be discussed below. PreMergeDocumentableTransformer allows applying any transformation to Documentables model before different source sets are merged. Useful if you want to filter/map existing documentables. For instance, if you want to exclude members annotated with @Internal , you most likely need an implementation of PreMergeDocumentableTransformer . For simple condition-based filtering of documentables consider extending SuppressedByConditionDocumentableFilterTransformer - it implements PreMergeDocumentableTransformer and only requires one function to be overridden. The rest is taken care of.","title":"PreMergeDocumentableTransformer"},{"location":"developer_guide/architecture/extension_points/core_extensions/#documentablemerger","text":"DocumentableMerger merges all DModule instances into one. Only one extension is expected of this type.","title":"DocumentableMerger"},{"location":"developer_guide/architecture/extension_points/core_extensions/#documentabletransformer","text":"DocumentableTransformer performs the same function as PreMergeDocumentableTransformer , but after merging source sets. Notable example is InheritorsExtractorTransformer , it extracts inherited classes data across source sets and creates an inheritance map.","title":"DocumentableTransformer"},{"location":"developer_guide/architecture/extension_points/core_extensions/#documentabletopagetranslator","text":"DocumentableToPageTranslator is responsible for creating pages and their content. See Page/Content model section for more information and examples. Different output formats can either use the same page structure or define their own in case it needs to be different. Only a single extension of this type is expected to be registered.","title":"DocumentableToPageTranslator"},{"location":"developer_guide/architecture/extension_points/core_extensions/#pagetransformer","text":"PageTransformer is useful if you need to add/remove/modify generated pages or their content. Plugins like mathjax can add .js scripts to pages using this extension point. If you want all overloaded functions to be rendered on the same page (instead of separate ones), you can also use PageTransformer to delete excessive pages and combine them into a new single one.","title":"PageTransformer"},{"location":"developer_guide/architecture/extension_points/core_extensions/#renderer","text":"Renderer - defines rules on what to do with pages and their content, which files to create and how to display it properly. Output format implementations should use Renderer extension point. Notable examples are HtmlRenderer and CommonmarkRenderer .","title":"Renderer"},{"location":"developer_guide/architecture/extension_points/core_extensions/#postaction","text":"PostAction is useful for when you want to run some actions after the documentation has been generated - for instance if you want to move some files around. Versioning plugin utilizes PostAction in order to move generated documentation to versioned folders.","title":"PostAction"},{"location":"developer_guide/architecture/extension_points/introduction/","text":"Introduction to extension points \u00b6 In this section you can learn how to create new extension points, how to use and configure existing ones and how to query for extensions when generating documentation. Declaring extension points \u00b6 If you are writing a plugin, you can create your own extension point that other developers (or you) can use later on in some other part of code. class MyPlugin : DokkaPlugin () { val sampleExtensionPoint by extensionPoint < SampleExtensionPointInterface > () } interface SampleExtensionPointInterface { fun doSomething ( input : Input ): List < Output > } class Input class Output Usually you would want to provide some default implementation(s) for your extension point, you can do that within the same plugin class by extending an extension point you've just created. See Extending from extension points for examples. Extending from extension points \u00b6 You can use extension points to provide your own implementation(s) in order to customize plugin's behaviour. You can do that within the same class as the extension point itself: open class MyPlugin : DokkaPlugin () { val sampleExtensionPoint by extensionPoint < SampleExtensionPointInterface > () val defaultSampleExtension by extending { sampleExtensionPoint with DefaultSampleExtension () } } ... class DefaultSampleExtension : SampleExtensionPointInterface { override fun doSomething ( input : Input ): List < Output > = listOf () } If you want to extend someone else's plugin (including DokkaBase ), you can use plugin querying API to do that. In the example below we will extend MyPlugin that was created above with our own implementation of SampleExtensionPointInterface . class MyExtendedPlugin : DokkaPlugin () { val mySampleExtensionImplementation by extending { plugin < MyPlugin > (). sampleExtensionPoint with SampleExtensionImpl () } } class SampleExtensionImpl : SampleExtensionPointInterface { override fun doSomething ( input : Input ): List < Output > = listOf () } Providing \u00b6 If you need to have access to DokkaContext in order to create an extension, you can use providing instead. val defaultSampleExtension by extending { sampleExtensionPoint providing { context -> // can use context to query other extensions or get configuration DefaultSampleExtension () } } You can read more on what you can do with context in Obtaining extension instance . Override \u00b6 By extending an extension point, you are registering an additional extension. This behaviour is expected for some extension points, for instance Documentable transformers, since all transformers do their own transformations and all of them will be invoked before proceeding. However, a plugin can expect only a single registered extension for an extension point. In this case, you can override existing registered extensions: class MyExtendedPlugin : DokkaPlugin () { private val myPlugin by lazy { plugin < MyPlugin > () } val mySampleExtensionImplementation by extending { ( myPlugin . sampleExtensionPoint with SampleExtensionImpl () override myPlugin . defaultSampleExtension ) } } This is also useful if you wish to override some extension from DokkaBase to disable or alter it. Order \u00b6 Sometimes the order in which extensions are invoked matters. This is something you can control as well using order : class MyExtendedPlugin : DokkaPlugin () { private val myPlugin by lazy { plugin < MyPlugin > () } val mySampleExtensionImplementation by extending { myPlugin . sampleExtensionPoint with SampleExtensionImpl () order { before ( myPlugin . firstExtension ) after ( myPlugin . thirdExtension ) } } } Conditional apply \u00b6 If you want your extension to be registered only if some condition is true , you can use applyIf : class MyExtendedPlugin : DokkaPlugin () { private val myPlugin by lazy { plugin < MyPlugin > () } val mySampleExtensionImplementation by extending { myPlugin . sampleExtensionPoint with SampleExtensionImpl () applyIf { Random . Default . nextBoolean () } } } Obtaining extension instance \u00b6 After an extension point has been created and some extension has been registered , you can use query and querySingle to find all or just a single implementation for it. class MyExtension ( context : DokkaContext ) { // returns all registered extensions for this extension point val allSampleExtensions = context . plugin < MyPlugin > (). query { sampleExtensionPoint } // will throw an exception if more than one extension is found // use if you expect only a single extension to be registered for this extension point val singleSampleExtensions = context . plugin < MyPlugin > (). querySingle { sampleExtensionPoint } fun invoke () { allSampleExtensions . forEach { it . doSomething ( Input ()) } singleSampleExtensions . doSomething ( Input ()) } } In order to have access to context you can use providing when registering this as an extension.","title":"Extension points"},{"location":"developer_guide/architecture/extension_points/introduction/#introduction-to-extension-points","text":"In this section you can learn how to create new extension points, how to use and configure existing ones and how to query for extensions when generating documentation.","title":"Introduction to extension points"},{"location":"developer_guide/architecture/extension_points/introduction/#declaring-extension-points","text":"If you are writing a plugin, you can create your own extension point that other developers (or you) can use later on in some other part of code. class MyPlugin : DokkaPlugin () { val sampleExtensionPoint by extensionPoint < SampleExtensionPointInterface > () } interface SampleExtensionPointInterface { fun doSomething ( input : Input ): List < Output > } class Input class Output Usually you would want to provide some default implementation(s) for your extension point, you can do that within the same plugin class by extending an extension point you've just created. See Extending from extension points for examples.","title":"Declaring extension points"},{"location":"developer_guide/architecture/extension_points/introduction/#extending-from-extension-points","text":"You can use extension points to provide your own implementation(s) in order to customize plugin's behaviour. You can do that within the same class as the extension point itself: open class MyPlugin : DokkaPlugin () { val sampleExtensionPoint by extensionPoint < SampleExtensionPointInterface > () val defaultSampleExtension by extending { sampleExtensionPoint with DefaultSampleExtension () } } ... class DefaultSampleExtension : SampleExtensionPointInterface { override fun doSomething ( input : Input ): List < Output > = listOf () } If you want to extend someone else's plugin (including DokkaBase ), you can use plugin querying API to do that. In the example below we will extend MyPlugin that was created above with our own implementation of SampleExtensionPointInterface . class MyExtendedPlugin : DokkaPlugin () { val mySampleExtensionImplementation by extending { plugin < MyPlugin > (). sampleExtensionPoint with SampleExtensionImpl () } } class SampleExtensionImpl : SampleExtensionPointInterface { override fun doSomething ( input : Input ): List < Output > = listOf () }","title":"Extending from extension points"},{"location":"developer_guide/architecture/extension_points/introduction/#providing","text":"If you need to have access to DokkaContext in order to create an extension, you can use providing instead. val defaultSampleExtension by extending { sampleExtensionPoint providing { context -> // can use context to query other extensions or get configuration DefaultSampleExtension () } } You can read more on what you can do with context in Obtaining extension instance .","title":"Providing"},{"location":"developer_guide/architecture/extension_points/introduction/#override","text":"By extending an extension point, you are registering an additional extension. This behaviour is expected for some extension points, for instance Documentable transformers, since all transformers do their own transformations and all of them will be invoked before proceeding. However, a plugin can expect only a single registered extension for an extension point. In this case, you can override existing registered extensions: class MyExtendedPlugin : DokkaPlugin () { private val myPlugin by lazy { plugin < MyPlugin > () } val mySampleExtensionImplementation by extending { ( myPlugin . sampleExtensionPoint with SampleExtensionImpl () override myPlugin . defaultSampleExtension ) } } This is also useful if you wish to override some extension from DokkaBase to disable or alter it.","title":"Override"},{"location":"developer_guide/architecture/extension_points/introduction/#order","text":"Sometimes the order in which extensions are invoked matters. This is something you can control as well using order : class MyExtendedPlugin : DokkaPlugin () { private val myPlugin by lazy { plugin < MyPlugin > () } val mySampleExtensionImplementation by extending { myPlugin . sampleExtensionPoint with SampleExtensionImpl () order { before ( myPlugin . firstExtension ) after ( myPlugin . thirdExtension ) } } }","title":"Order"},{"location":"developer_guide/architecture/extension_points/introduction/#conditional-apply","text":"If you want your extension to be registered only if some condition is true , you can use applyIf : class MyExtendedPlugin : DokkaPlugin () { private val myPlugin by lazy { plugin < MyPlugin > () } val mySampleExtensionImplementation by extending { myPlugin . sampleExtensionPoint with SampleExtensionImpl () applyIf { Random . Default . nextBoolean () } } }","title":"Conditional apply"},{"location":"developer_guide/architecture/extension_points/introduction/#obtaining-extension-instance","text":"After an extension point has been created and some extension has been registered , you can use query and querySingle to find all or just a single implementation for it. class MyExtension ( context : DokkaContext ) { // returns all registered extensions for this extension point val allSampleExtensions = context . plugin < MyPlugin > (). query { sampleExtensionPoint } // will throw an exception if more than one extension is found // use if you expect only a single extension to be registered for this extension point val singleSampleExtensions = context . plugin < MyPlugin > (). querySingle { sampleExtensionPoint } fun invoke () { allSampleExtensions . forEach { it . doSomething ( Input ()) } singleSampleExtensions . doSomething ( Input ()) } } In order to have access to context you can use providing when registering this as an extension.","title":"Obtaining extension instance"},{"location":"developer_guide/plugin-development/introduction/","text":"Introduction to plugin development \u00b6 In order to have an easier time developing plugins, it's a good idea to go through Dokka's internals first to learn more about its data model and extensions . Setup \u00b6 Template \u00b6 The easiest way to start is to use the convenient Dokka plugin template . It has pre-configured dependencies, publishing and signing of your artifacts. Manual \u00b6 At a bare minimum, Dokka requires Kotlin Gradle Plugin and dokka-core dependencies: plugins { kotlin ( \"jvm\" ) version \"<kotlin_version>\" } dependencies { compileOnly ( \"org.jetbrains.dokka:dokka-core:<dokka_version>\" ) } tasks . withType < KotlinCompile > { kotlinOptions . jvmTarget = \"1.8\" } In order to load a plugin into Dokka, your class must extend DokkaPlugin class. A fully qualified name of that class must be placed in a file named org.jetbrains.dokka.plugability.DokkaPlugin under resources/META-INF/services . All instances are automatically loaded during Dokka setup using java.util.ServiceLoader . Extension points \u00b6 Dokka provides a set of entry points for which you can create your own implementations. If you are not sure which extension point to use, have a look at core extensions and base extensions . You can learn how to declare extension points and use extensions in Introduction to Extension points . In case no suitable extension point exists for your use case, do share the details - it might be added in future versions of Dokka. Example \u00b6 You can follow the sample plugin tutorial which covers creation of a simple plugin: hide members annotated with your own @Internal annotation, that is exclude these members from generated documentation. Fore more practical examples, have a look at sources of community plugins . Help \u00b6 If you have any further questions, feel free to get in touch with maintainers via Slack or GitHub .","title":"Plugin development"},{"location":"developer_guide/plugin-development/introduction/#introduction-to-plugin-development","text":"In order to have an easier time developing plugins, it's a good idea to go through Dokka's internals first to learn more about its data model and extensions .","title":"Introduction to plugin development"},{"location":"developer_guide/plugin-development/introduction/#setup","text":"","title":"Setup"},{"location":"developer_guide/plugin-development/introduction/#template","text":"The easiest way to start is to use the convenient Dokka plugin template . It has pre-configured dependencies, publishing and signing of your artifacts.","title":"Template"},{"location":"developer_guide/plugin-development/introduction/#manual","text":"At a bare minimum, Dokka requires Kotlin Gradle Plugin and dokka-core dependencies: plugins { kotlin ( \"jvm\" ) version \"<kotlin_version>\" } dependencies { compileOnly ( \"org.jetbrains.dokka:dokka-core:<dokka_version>\" ) } tasks . withType < KotlinCompile > { kotlinOptions . jvmTarget = \"1.8\" } In order to load a plugin into Dokka, your class must extend DokkaPlugin class. A fully qualified name of that class must be placed in a file named org.jetbrains.dokka.plugability.DokkaPlugin under resources/META-INF/services . All instances are automatically loaded during Dokka setup using java.util.ServiceLoader .","title":"Manual"},{"location":"developer_guide/plugin-development/introduction/#extension-points","text":"Dokka provides a set of entry points for which you can create your own implementations. If you are not sure which extension point to use, have a look at core extensions and base extensions . You can learn how to declare extension points and use extensions in Introduction to Extension points . In case no suitable extension point exists for your use case, do share the details - it might be added in future versions of Dokka.","title":"Extension points"},{"location":"developer_guide/plugin-development/introduction/#example","text":"You can follow the sample plugin tutorial which covers creation of a simple plugin: hide members annotated with your own @Internal annotation, that is exclude these members from generated documentation. Fore more practical examples, have a look at sources of community plugins .","title":"Example"},{"location":"developer_guide/plugin-development/introduction/#help","text":"If you have any further questions, feel free to get in touch with maintainers via Slack or GitHub .","title":"Help"},{"location":"developer_guide/plugin-development/sample-plugin-tutorial/","text":"Sample plugin tutorial \u00b6 We'll go over creating a simple plugin that covers a very common use case: generate documentation for everything except for members annotated with a custom @Internal annotation - they should be hidden. The plugin will be tested with the following code: package org.jetbrains.dokka.internal.test annotation class Internal fun shouldBeVisible () {} @Internal fun shouldBeExcludedFromDocumentation () {} Expected behavior: function shouldBeExcludedFromDocumentation should not be visible in generated documentation. Full source code of this tutorial can be found in Dokka's examples under hide-internal-api . Preparing the project \u00b6 We'll begin by using Dokka plugin template . Press the Use this template button and open this project in IntelliJ IDEA . First, let's rename the pre-made template package and MyAwesomeDokkaPlugin class to something of our own. For instance, package can be renamed to org.example.dokka.plugin and the class to HideInternalApiPlugin : package org.example.dokka.plugin import org.jetbrains.dokka.plugability.DokkaPlugin class HideInternalApiPlugin : DokkaPlugin () { } After you do that, make sure to update the path to this class in resources/META-INF/services/org.jetbrains.dokka.plugability.DokkaPlugin : org . example . dokka . plugin . HideInternalApiPlugin At this point you can also change project name in settings.gradle.kts (to hide-internal-api in our case) and groupId in build.gradle.kts . Extending Dokka \u00b6 After preparing the project we can begin extending Dokka with our own extension. Having read through Core extensions , it's clear that we need a PreMergeDocumentableTransformer extension in order to filter out undesired documentables. Moreover, the article mentioned a convenient abstract transformer SuppressedByConditionDocumentableFilterTransformer which is perfect for our use case, so we can try to implement it. Create a new class, place it next to your plugin and implement the abstract method. You should end up with this: package org.example.dokka.plugin import org.jetbrains.dokka.base.transformers.documentables.SuppressedByConditionDocumentableFilterTransformer import org.jetbrains.dokka.model.Documentable import org.jetbrains.dokka.plugability.DokkaContext import org.jetbrains.dokka.plugability.DokkaPlugin class HideInternalApiPlugin : DokkaPlugin () {} class HideInternalApiTransformer ( context : DokkaContext ) : SuppressedByConditionDocumentableFilterTransformer ( context ) { override fun shouldBeSuppressed ( d : Documentable ): Boolean { return false } } Now we somehow need to find all annotations applied to d: Documentable and see if our @Internal annotation is present. However, it's not very clear how to do that. What usually helps is stopping in debugger and having a look at what fields and values a given Documentable has. To do that, we'll need to register our extension point first, then we can publish our plugin and set the breakpoint. Having read through Introduction to extensions , we now know how to register our extensions: class HideInternalApiPlugin : DokkaPlugin () { val myFilterExtension by extending { plugin < DokkaBase > (). preMergeDocumentableTransformer providing :: HideInternalApiTransformer } } At this point we're ready to debug our plugin locally, it should already work, but do nothing. Debugging \u00b6 Please read through Debugging Dokka , it goes over the same steps in more detail and with examples. Below you will find rough instructions. First, let's begin by publishing our plugin to mavenLocal() . ./gradlew publishToMavenLocal This will publish your plugin under the groupId , artifactId and version that you've specified in your build.gradle.kts . In our case it's org.example:hide-internal-api:1.0-SNAPSHOT . Open a debug project of your choosing that has Dokka configured, and add our plugin to dependencies: dependencies { dokkaPlugin ( \"org.example:hide-internal-api:1.0-SNAPSHOT\" ) } Next, in that project let's run dokkaHtml with debug enabled: ./gradlew clean dokkaHtml -Dorg.gradle.debug = true --no-daemon Switch to the plugin project, set a breakpoint inside shouldBeSuppressed and run jvm remote debug. If you've done everything correctly, it should stop in debugger and you should be able to observe the values contained inside d: Documentable . Implementing plugin logic \u00b6 Now that we've stopped at our breakpoint, let's skip until we see shouldBeExcludedFromDocumentation function in the place of d: Documentable (observe the changing name property). Looking at what's inside the object, you might notice it has 3 values in extra , one of which is Annotations . Sounds like something we need! Having poked around, we come up with the following monstrosity of a code for determining if a given documentable has @Internal annotation (it can of course be refactored.. later): override fun shouldBeSuppressed ( d : Documentable ): Boolean { val annotations : List < Annotations . Annotation > = ( d as? WithExtraProperties <*> ) ?. extra ?. allOfType < Annotations > () ?. flatMap { it . directAnnotations . values . flatten () } ?: emptyList () return annotations . any { isInternalAnnotation ( it ) } } private fun isInternalAnnotation ( annotation : Annotations . Annotation ): Boolean { return annotation . dri . packageName == \"org.jetbrains.dokka.internal.test\" && annotation . dri . classNames == \"Internal\" } Seems like we're done with writing our plugin and can begin testing it manually. Manual testing \u00b6 At this point, the implementation of your plugin should look roughly like this: package org.example.dokka.plugin import org.jetbrains.dokka.base.DokkaBase import org.jetbrains.dokka.base.transformers.documentables.SuppressedByConditionDocumentableFilterTransformer import org.jetbrains.dokka.model.Annotations import org.jetbrains.dokka.model.Documentable import org.jetbrains.dokka.model.properties.WithExtraProperties import org.jetbrains.dokka.plugability.DokkaContext import org.jetbrains.dokka.plugability.DokkaPlugin class HideInternalApiPlugin : DokkaPlugin () { val myFilterExtension by extending { plugin < DokkaBase > (). preMergeDocumentableTransformer providing :: HideInternalApiTransformer } } class HideInternalApiTransformer ( context : DokkaContext ) : SuppressedByConditionDocumentableFilterTransformer ( context ) { override fun shouldBeSuppressed ( d : Documentable ): Boolean { val annotations : List < Annotations . Annotation > = ( d as? WithExtraProperties <*> ) ?. extra ?. allOfType < Annotations > () ?. flatMap { it . directAnnotations . values . flatten () } ?: emptyList () return annotations . any { isInternalAnnotation ( it ) } } private fun isInternalAnnotation ( annotation : Annotations . Annotation ): Boolean { return annotation . dri . packageName == \"org.jetbrains.dokka.internal.test\" && annotation . dri . classNames == \"Internal\" } } Bump plugin version in gradle.build.kts , publish it to maven local, open the debug project and run dokkaHtml (without debug this time). It should work, you should not be able to see shouldBeExcludedFromDocumentation function in generated documentation. Manual testing is cool and all, but wouldn't it be better if we could somehow write unit tests for it? Indeed! Unit testing \u00b6 You might've noticed that plugin template comes with a pre-made test class. Feel free to move it to another package and rename it. We are mostly interested in a single test case - functions annotated with @Internal should be hidden, while all other public functions should be visible. Plugin API comes with a set of convenient test utilities that are used to test Dokka itself, so it covers a wide range of use cases. When in doubt, see Dokka's tests for reference. Below you will find a complete unit test that passes, and the main takeaways below that. package org.example.dokka.plugin import org.jetbrains.dokka.base.testApi.testRunner.BaseAbstractTest import org.junit.Test import kotlin.test.assertEquals class HideInternalApiPluginTest : BaseAbstractTest () { @Test fun `should hide annotated functions` () { val configuration = dokkaConfiguration { sourceSets { sourceSet { sourceRoots = listOf ( \"src/main/kotlin/basic/Test.kt\" ) } } } val hideInternalPlugin = HideInternalApiPlugin () testInline ( \"\"\" |/src/main/kotlin/basic/Test.kt |package org.jetbrains.dokka.internal.test | |annotation class Internal | |fun shouldBeVisible() {} | |@Internal |fun shouldBeExcludedFromDocumentation() {} \"\"\" . trimMargin (), configuration = configuration , pluginOverrides = listOf ( hideInternalPlugin ) ) { preMergeDocumentablesTransformationStage = { modules -> val testModule = modules . single { it . name == \"root\" } val testPackage = testModule . packages . single { it . name == \"org.jetbrains.dokka.internal.test\" } val packageFunctions = testPackage . functions assertEquals ( 1 , packageFunctions . size ) assertEquals ( \"shouldBeVisible\" , packageFunctions [ 0 ] . name ) } } } } Note that the package of the tested code (inside testInline function) is the same as the package that we have hardcoded in our plugin. Make sure to change that to your own if you are following along, otherwise it will fail. Things to note and remember: Your test class should extend BaseAbstractTest , which contains base utility methods for testing. You can configure Dokka to your liking, enable some specific settings, configure source sets , etc. All done via dokkaConfiguration DSL. testInline function is the main entry point for unit tests You can pass plugins to be used in a test, notice pluginOverrides parameter You can write asserts for different stages of generating documentation, the main ones being Documentables model generation, Pages generation and Output generation. Since we implemented our plugin to work during PreMergeDocumentableTransformer stage, we can test it on the same level (that is preMergeDocumentablesTransformationStage ). You will need to write asserts using the model of whatever stage you choose. For Documentable transformation stage it's Documentable , for Page generation stage you would have Page model, and for Output you can have .html files that you will need to parse with JSoup (there are also utilities for that).","title":"Sample plugin tutorial"},{"location":"developer_guide/plugin-development/sample-plugin-tutorial/#sample-plugin-tutorial","text":"We'll go over creating a simple plugin that covers a very common use case: generate documentation for everything except for members annotated with a custom @Internal annotation - they should be hidden. The plugin will be tested with the following code: package org.jetbrains.dokka.internal.test annotation class Internal fun shouldBeVisible () {} @Internal fun shouldBeExcludedFromDocumentation () {} Expected behavior: function shouldBeExcludedFromDocumentation should not be visible in generated documentation. Full source code of this tutorial can be found in Dokka's examples under hide-internal-api .","title":"Sample plugin tutorial"},{"location":"developer_guide/plugin-development/sample-plugin-tutorial/#preparing-the-project","text":"We'll begin by using Dokka plugin template . Press the Use this template button and open this project in IntelliJ IDEA . First, let's rename the pre-made template package and MyAwesomeDokkaPlugin class to something of our own. For instance, package can be renamed to org.example.dokka.plugin and the class to HideInternalApiPlugin : package org.example.dokka.plugin import org.jetbrains.dokka.plugability.DokkaPlugin class HideInternalApiPlugin : DokkaPlugin () { } After you do that, make sure to update the path to this class in resources/META-INF/services/org.jetbrains.dokka.plugability.DokkaPlugin : org . example . dokka . plugin . HideInternalApiPlugin At this point you can also change project name in settings.gradle.kts (to hide-internal-api in our case) and groupId in build.gradle.kts .","title":"Preparing the project"},{"location":"developer_guide/plugin-development/sample-plugin-tutorial/#extending-dokka","text":"After preparing the project we can begin extending Dokka with our own extension. Having read through Core extensions , it's clear that we need a PreMergeDocumentableTransformer extension in order to filter out undesired documentables. Moreover, the article mentioned a convenient abstract transformer SuppressedByConditionDocumentableFilterTransformer which is perfect for our use case, so we can try to implement it. Create a new class, place it next to your plugin and implement the abstract method. You should end up with this: package org.example.dokka.plugin import org.jetbrains.dokka.base.transformers.documentables.SuppressedByConditionDocumentableFilterTransformer import org.jetbrains.dokka.model.Documentable import org.jetbrains.dokka.plugability.DokkaContext import org.jetbrains.dokka.plugability.DokkaPlugin class HideInternalApiPlugin : DokkaPlugin () {} class HideInternalApiTransformer ( context : DokkaContext ) : SuppressedByConditionDocumentableFilterTransformer ( context ) { override fun shouldBeSuppressed ( d : Documentable ): Boolean { return false } } Now we somehow need to find all annotations applied to d: Documentable and see if our @Internal annotation is present. However, it's not very clear how to do that. What usually helps is stopping in debugger and having a look at what fields and values a given Documentable has. To do that, we'll need to register our extension point first, then we can publish our plugin and set the breakpoint. Having read through Introduction to extensions , we now know how to register our extensions: class HideInternalApiPlugin : DokkaPlugin () { val myFilterExtension by extending { plugin < DokkaBase > (). preMergeDocumentableTransformer providing :: HideInternalApiTransformer } } At this point we're ready to debug our plugin locally, it should already work, but do nothing.","title":"Extending Dokka"},{"location":"developer_guide/plugin-development/sample-plugin-tutorial/#debugging","text":"Please read through Debugging Dokka , it goes over the same steps in more detail and with examples. Below you will find rough instructions. First, let's begin by publishing our plugin to mavenLocal() . ./gradlew publishToMavenLocal This will publish your plugin under the groupId , artifactId and version that you've specified in your build.gradle.kts . In our case it's org.example:hide-internal-api:1.0-SNAPSHOT . Open a debug project of your choosing that has Dokka configured, and add our plugin to dependencies: dependencies { dokkaPlugin ( \"org.example:hide-internal-api:1.0-SNAPSHOT\" ) } Next, in that project let's run dokkaHtml with debug enabled: ./gradlew clean dokkaHtml -Dorg.gradle.debug = true --no-daemon Switch to the plugin project, set a breakpoint inside shouldBeSuppressed and run jvm remote debug. If you've done everything correctly, it should stop in debugger and you should be able to observe the values contained inside d: Documentable .","title":"Debugging"},{"location":"developer_guide/plugin-development/sample-plugin-tutorial/#implementing-plugin-logic","text":"Now that we've stopped at our breakpoint, let's skip until we see shouldBeExcludedFromDocumentation function in the place of d: Documentable (observe the changing name property). Looking at what's inside the object, you might notice it has 3 values in extra , one of which is Annotations . Sounds like something we need! Having poked around, we come up with the following monstrosity of a code for determining if a given documentable has @Internal annotation (it can of course be refactored.. later): override fun shouldBeSuppressed ( d : Documentable ): Boolean { val annotations : List < Annotations . Annotation > = ( d as? WithExtraProperties <*> ) ?. extra ?. allOfType < Annotations > () ?. flatMap { it . directAnnotations . values . flatten () } ?: emptyList () return annotations . any { isInternalAnnotation ( it ) } } private fun isInternalAnnotation ( annotation : Annotations . Annotation ): Boolean { return annotation . dri . packageName == \"org.jetbrains.dokka.internal.test\" && annotation . dri . classNames == \"Internal\" } Seems like we're done with writing our plugin and can begin testing it manually.","title":"Implementing plugin logic"},{"location":"developer_guide/plugin-development/sample-plugin-tutorial/#manual-testing","text":"At this point, the implementation of your plugin should look roughly like this: package org.example.dokka.plugin import org.jetbrains.dokka.base.DokkaBase import org.jetbrains.dokka.base.transformers.documentables.SuppressedByConditionDocumentableFilterTransformer import org.jetbrains.dokka.model.Annotations import org.jetbrains.dokka.model.Documentable import org.jetbrains.dokka.model.properties.WithExtraProperties import org.jetbrains.dokka.plugability.DokkaContext import org.jetbrains.dokka.plugability.DokkaPlugin class HideInternalApiPlugin : DokkaPlugin () { val myFilterExtension by extending { plugin < DokkaBase > (). preMergeDocumentableTransformer providing :: HideInternalApiTransformer } } class HideInternalApiTransformer ( context : DokkaContext ) : SuppressedByConditionDocumentableFilterTransformer ( context ) { override fun shouldBeSuppressed ( d : Documentable ): Boolean { val annotations : List < Annotations . Annotation > = ( d as? WithExtraProperties <*> ) ?. extra ?. allOfType < Annotations > () ?. flatMap { it . directAnnotations . values . flatten () } ?: emptyList () return annotations . any { isInternalAnnotation ( it ) } } private fun isInternalAnnotation ( annotation : Annotations . Annotation ): Boolean { return annotation . dri . packageName == \"org.jetbrains.dokka.internal.test\" && annotation . dri . classNames == \"Internal\" } } Bump plugin version in gradle.build.kts , publish it to maven local, open the debug project and run dokkaHtml (without debug this time). It should work, you should not be able to see shouldBeExcludedFromDocumentation function in generated documentation. Manual testing is cool and all, but wouldn't it be better if we could somehow write unit tests for it? Indeed!","title":"Manual testing"},{"location":"developer_guide/plugin-development/sample-plugin-tutorial/#unit-testing","text":"You might've noticed that plugin template comes with a pre-made test class. Feel free to move it to another package and rename it. We are mostly interested in a single test case - functions annotated with @Internal should be hidden, while all other public functions should be visible. Plugin API comes with a set of convenient test utilities that are used to test Dokka itself, so it covers a wide range of use cases. When in doubt, see Dokka's tests for reference. Below you will find a complete unit test that passes, and the main takeaways below that. package org.example.dokka.plugin import org.jetbrains.dokka.base.testApi.testRunner.BaseAbstractTest import org.junit.Test import kotlin.test.assertEquals class HideInternalApiPluginTest : BaseAbstractTest () { @Test fun `should hide annotated functions` () { val configuration = dokkaConfiguration { sourceSets { sourceSet { sourceRoots = listOf ( \"src/main/kotlin/basic/Test.kt\" ) } } } val hideInternalPlugin = HideInternalApiPlugin () testInline ( \"\"\" |/src/main/kotlin/basic/Test.kt |package org.jetbrains.dokka.internal.test | |annotation class Internal | |fun shouldBeVisible() {} | |@Internal |fun shouldBeExcludedFromDocumentation() {} \"\"\" . trimMargin (), configuration = configuration , pluginOverrides = listOf ( hideInternalPlugin ) ) { preMergeDocumentablesTransformationStage = { modules -> val testModule = modules . single { it . name == \"root\" } val testPackage = testModule . packages . single { it . name == \"org.jetbrains.dokka.internal.test\" } val packageFunctions = testPackage . functions assertEquals ( 1 , packageFunctions . size ) assertEquals ( \"shouldBeVisible\" , packageFunctions [ 0 ] . name ) } } } } Note that the package of the tested code (inside testInline function) is the same as the package that we have hardcoded in our plugin. Make sure to change that to your own if you are following along, otherwise it will fail. Things to note and remember: Your test class should extend BaseAbstractTest , which contains base utility methods for testing. You can configure Dokka to your liking, enable some specific settings, configure source sets , etc. All done via dokkaConfiguration DSL. testInline function is the main entry point for unit tests You can pass plugins to be used in a test, notice pluginOverrides parameter You can write asserts for different stages of generating documentation, the main ones being Documentables model generation, Pages generation and Output generation. Since we implemented our plugin to work during PreMergeDocumentableTransformer stage, we can test it on the same level (that is preMergeDocumentablesTransformationStage ). You will need to write asserts using the model of whatever stage you choose. For Documentable transformation stage it's Documentable , for Page generation stage you would have Page model, and for Output you can have .html files that you will need to parse with JSoup (there are also utilities for that).","title":"Unit testing"},{"location":"user_guide/introduction/","text":"Introduction \u00b6 Plugins \u00b6 Dokka can be customized with plugins. Each output format is internally a plugin. Additionally, kotlin-as-java plugin can be used to generate documentation as seen from Java perspective. Currently maintained plugins are: dokka-base - the main plugin needed to run Dokka, contains html format gfm-plugin - configures GFM output format jekyll-plugin - configures Jekyll output format javadoc-plugin - configures Javadoc output format, automatically applies kotlin-as-java-plugin kotlin-as-java-plugin - translates Kotlin definitions to Java android-documentation-plugin - provides android specific enhancements like @hide support Please see the usage instructions for each build system on how to add plugins to Dokka. Source sets \u00b6 Dokka generates documentation based on source sets. For single-platform & multi-platform projects, source sets are the same as in Kotlin plugin: One source set for each platform, eg. jvmMain or jsMain ; One source set for each common source set, eg. the default commonMain and custom ones like jsAndJvmMain . When configuring multi-platform projects manually (eg. in the CLI or in Gradle without the Kotlin Gradle Plugin) source sets must declare their dependent source sets. Eg. in the following Kotlin plugin configuration: jsMain and jvmMain both depend on commonMain (by default and transitively) and jsAndJvmMain ; linuxX64Main only depends on commonMain . kotlin { // Kotlin plugin configuration jvm () js () linuxX64 () sourceSets { val commonMain by getting {} val jvmAndJsSecondCommonMain by creating { dependsOn ( commonMain ) } val jvmMain by getting { dependsOn ( jvmAndJsSecondCommonMain ) } val jsMain by getting { dependsOn ( jvmAndJsSecondCommonMain ) } val linuxX64Main by getting { dependsOn ( commonMain ) } } } Output formats \u00b6 Dokka documents Java classes as seen in Kotlin by default, with javadoc format being the only exception. html - HTML format used by default javadoc - looks like JDK's Javadoc, Kotlin classes are translated to Java gfm - GitHub flavored markdown jekyll - Jekyll compatible markdown If you want to generate the documentation as seen from Java perspective, you can add the kotlin-as-java plugin to the Dokka plugins classpath, eg. in Gradle: dependencies { implementation ( \"...\" ) dokkaGfmPlugin ( \"org.jetbrains.dokka:kotlin-as-java-plugin: ${ dokka - version } \" ) } Platforms \u00b6 Each Dokka source set is analyzed for a specific platform. The platform should be extracted automatically from the Kotlin plugin. In case of a manual source set configuration, you have to select one of the following: jvm js native common","title":"User guides"},{"location":"user_guide/introduction/#introduction","text":"","title":"Introduction"},{"location":"user_guide/introduction/#plugins","text":"Dokka can be customized with plugins. Each output format is internally a plugin. Additionally, kotlin-as-java plugin can be used to generate documentation as seen from Java perspective. Currently maintained plugins are: dokka-base - the main plugin needed to run Dokka, contains html format gfm-plugin - configures GFM output format jekyll-plugin - configures Jekyll output format javadoc-plugin - configures Javadoc output format, automatically applies kotlin-as-java-plugin kotlin-as-java-plugin - translates Kotlin definitions to Java android-documentation-plugin - provides android specific enhancements like @hide support Please see the usage instructions for each build system on how to add plugins to Dokka.","title":"Plugins"},{"location":"user_guide/introduction/#source-sets","text":"Dokka generates documentation based on source sets. For single-platform & multi-platform projects, source sets are the same as in Kotlin plugin: One source set for each platform, eg. jvmMain or jsMain ; One source set for each common source set, eg. the default commonMain and custom ones like jsAndJvmMain . When configuring multi-platform projects manually (eg. in the CLI or in Gradle without the Kotlin Gradle Plugin) source sets must declare their dependent source sets. Eg. in the following Kotlin plugin configuration: jsMain and jvmMain both depend on commonMain (by default and transitively) and jsAndJvmMain ; linuxX64Main only depends on commonMain . kotlin { // Kotlin plugin configuration jvm () js () linuxX64 () sourceSets { val commonMain by getting {} val jvmAndJsSecondCommonMain by creating { dependsOn ( commonMain ) } val jvmMain by getting { dependsOn ( jvmAndJsSecondCommonMain ) } val jsMain by getting { dependsOn ( jvmAndJsSecondCommonMain ) } val linuxX64Main by getting { dependsOn ( commonMain ) } } }","title":"Source sets"},{"location":"user_guide/introduction/#output-formats","text":"Dokka documents Java classes as seen in Kotlin by default, with javadoc format being the only exception. html - HTML format used by default javadoc - looks like JDK's Javadoc, Kotlin classes are translated to Java gfm - GitHub flavored markdown jekyll - Jekyll compatible markdown If you want to generate the documentation as seen from Java perspective, you can add the kotlin-as-java plugin to the Dokka plugins classpath, eg. in Gradle: dependencies { implementation ( \"...\" ) dokkaGfmPlugin ( \"org.jetbrains.dokka:kotlin-as-java-plugin: ${ dokka - version } \" ) }","title":"Output formats"},{"location":"user_guide/introduction/#platforms","text":"Each Dokka source set is analyzed for a specific platform. The platform should be extracted automatically from the Kotlin plugin. In case of a manual source set configuration, you have to select one of the following: jvm js native common","title":"Platforms"},{"location":"user_guide/applying/cli/","text":"Using command line \u00b6 To run Dokka from the command line, download the Dokka CLI runner . To generate documentation, run the following command: java -jar dokka-cli.jar <arguments> Configuration options \u00b6 Dokka supports the following command line arguments: -outputDir - the output directory where the documentation is generated -moduleName - (required) - module name used as a part of source set ID when declaring dependent source sets -cacheRoot - cache directory to enable package-list caching -pluginsClasspath - artifacts with Dokka plugins, separated by ; . At least dokka-base and all its dependencies must be added there -pluginsConfiguration - configuration for plugins in format fqPluginName=json^^fqPluginName=json... -offlineMode - do not resolve package-lists online -failOnWarning - throw an exception instead of a warning -globalPackageOptions - per package options added to all source sets -globalLinks - external documentation links added to all source sets -globalSrcLink - source links added to all source sets -noSuppressObviousFunctions - don't suppress obvious functions like default toString or equals -suppressInheritedMembers - suppress all inherited members that were not overriden in a given class. Eg. using it you can suppress toString or equals functions but you can't suppress componentN or copy on data class -sourceSet - (repeatable) - configuration for a single source set. Following this argument, you can pass other arguments: -sourceSetName - source set name as a part of source set ID when declaring dependent source sets -displayName - source set name displayed in the generated documentation -src - list of source files or directories separated by ; -classpath - list of directories or .jar files to include in the classpath (used for resolving references) separated by ; -samples - list of directories containing sample code (documentation for those directories is not generated but declarations from them can be referenced using the @sample tag) separated by ; -includes - list of files containing the documentation for the module and individual packages separated by ; -includeNonPublic - Deprecated , prefer using documentedVisibilities . Include protected and private code -documentedVisibilities - a list of visibility modifiers (separated by ; ) that should be documented. Overrides includeNonPublic . Default is PUBLIC . Possible values: PUBLIC , PRIVATE , PROTECTED , INTERNAL (Kotlin-specific), PACKAGE (Java-specific package-private) -skipDeprecated - if set, deprecated elements are not included in the generated documentation -reportUndocumented - warn about undocumented members -noSkipEmptyPackages - create index pages for empty packages -perPackageOptions - list of package options in format matchingRegex,-deprecated,-privateApi,+reportUndocumented;+visibility:PRIVATE;matchingRegex, ... , separated by ; -links - list of external documentation links in format url^packageListUrl^^url2... , separated by ; -srcLink - mapping between a source directory and a Web site for browsing the code in format <path>=<url>[#lineSuffix] -noStdlibLink - disable linking to online kotlin-stdlib documentation -noJdkLink - disable linking to online JDK documentation -jdkVersion - version of JDK to use for linking to JDK JavaDoc -analysisPlatform - platform used for analysis, see the Platforms section -dependentSourceSets - list of dependent source sets in format moduleName/sourceSetName , separated by ; -loggingLevel - one of DEBUG , PROGRESS , INFO , WARN , ERROR . Defaults to DEBUG . Please note that this argument can't be passed in JSON. You can also use a JSON file with Dokka configuration: java -jar <dokka_cli.jar> <path_to_config.json> Applying plugins \u00b6 To apply a Dokka plugin you have to provide it and all its dependencies in the pluginsClasspath parameter Base plugin \u00b6 Using CLI runner to generate default documentation requires providing all dependencies manually on classpath. For Base plugins these are: dokka-base.jar dokka-analysis.jar kotlin-analysis-compiler.jar kotlin-analysis-intellij.jar kotlinx-html-jvm.jar All of them are published on maven central. Another dependencies of Base plugin (e.g. kotlinx-coroutines-core and so on) are already included in dokka-cli.jar . To get them on classpath one should add them via pluginsClasspath argument, e. g. java -jar dokka-cli.jar -pluginsClasspath \"dokka-base.jar;dokka-analysis.jar;kotlin-analysis-compiler.jar;kotlin-analysis-intellij.jar;kotlinx-html-jvm.jar\" ... Example using JSON \u00b6 To run Dokka with JSON configuration: java -jar dokka-cli.jar dokkaConfiguration.json Option values of JSON correspond to Gradle ones . The content of JSON file dokkaConfiguration.json : { \"moduleName\" : \"Dokka Example\" , \"moduleVersion\" : null , \"outputDir\" : \"build/dokka/html\" , \"cacheRoot\" : null , \"offlineMode\" : false , \"sourceSets\" : [ { \"displayName\" : \"jvm\" , \"sourceSetID\" : { \"scopeId\" : \":dokkaHtml\" , \"sourceSetName\" : \"main\" }, \"classpath\" : [ \"libs/kotlin-stdlib-1.7.20.jar\" , \"libs/kotlin-stdlib-common-1.7.20.jar\" ], \"sourceRoots\" : [ \"/home/Vadim.Mishenev/dokka/examples/cli/src/main/kotlin\" ], \"dependentSourceSets\" : [], \"samples\" : [], \"includes\" : [ \"Module.md\" ], \"includeNonPublic\" : false , \"documentedVisibilities\" : [ \"PUBLIC\" , \"PRIVATE\" , \"PROTECTED\" , \"INTERNAL\" , \"PACKAGE\" ], \"reportUndocumented\" : false , \"skipEmptyPackages\" : true , \"skipDeprecated\" : false , \"jdkVersion\" : 8 , \"sourceLinks\" : [ { \"localDirectory\" : \"/home/Vadim.Mishenev/dokka/examples/cli/src/main/kotlin\" , \"remoteUrl\" : \"https://github.com/Kotlin/dokka/tree/master/examples/gradle/dokka-gradle-example/src/main/kotlin\" , \"remoteLineSuffix\" : \"#L\" } ], \"perPackageOptions\" : [], \"externalDocumentationLinks\" : [ { \"url\" : \"https://docs.oracle.com/javase/8/docs/api/\" , \"packageListUrl\" : \"https://docs.oracle.com/javase/8/docs/api/package-list\" }, { \"url\" : \"https://kotlinlang.org/api/latest/jvm/stdlib/\" , \"packageListUrl\" : \"https://kotlinlang.org/api/latest/jvm/stdlib/package-list\" } ], \"noStdlibLink\" : false , \"noJdkLink\" : false , \"suppressedFiles\" : [], \"analysisPlatform\" : \"jvm\" } ], \"pluginsClasspath\" : [ \"plugins/dokka-base-1.7.20.jar\" , \"libs/kotlinx-html-jvm-0.7.3.jar\" , \"libs/dokka-analysis-1.7.20.jar\" , \"libs/kotlin-analysis-intellij-1.7.20.jar\" , \"libs/kotlin-analysis-compiler-1.7.20.jar\" ], \"pluginsConfiguration\" : [ { \"fqPluginName\" : \"org.jetbrains.dokka.base.DokkaBase\" , \"serializationFormat\" : \"JSON\" , \"values\" : \"{\\\"separateInheritedMembers\\\":false,\\\"footerMessage\\\":\\\"\u00a9 2021 Copyright\\\"}\" } ], \"modules\" : [], \"failOnWarning\" : false , \"delayTemplateSubstitution\" : false , \"suppressObviousFunctions\" : true , \"includes\" : [], \"suppressInheritedMembers\" : false }","title":"Command line"},{"location":"user_guide/applying/cli/#using-command-line","text":"To run Dokka from the command line, download the Dokka CLI runner . To generate documentation, run the following command: java -jar dokka-cli.jar <arguments>","title":"Using command line"},{"location":"user_guide/applying/cli/#configuration-options","text":"Dokka supports the following command line arguments: -outputDir - the output directory where the documentation is generated -moduleName - (required) - module name used as a part of source set ID when declaring dependent source sets -cacheRoot - cache directory to enable package-list caching -pluginsClasspath - artifacts with Dokka plugins, separated by ; . At least dokka-base and all its dependencies must be added there -pluginsConfiguration - configuration for plugins in format fqPluginName=json^^fqPluginName=json... -offlineMode - do not resolve package-lists online -failOnWarning - throw an exception instead of a warning -globalPackageOptions - per package options added to all source sets -globalLinks - external documentation links added to all source sets -globalSrcLink - source links added to all source sets -noSuppressObviousFunctions - don't suppress obvious functions like default toString or equals -suppressInheritedMembers - suppress all inherited members that were not overriden in a given class. Eg. using it you can suppress toString or equals functions but you can't suppress componentN or copy on data class -sourceSet - (repeatable) - configuration for a single source set. Following this argument, you can pass other arguments: -sourceSetName - source set name as a part of source set ID when declaring dependent source sets -displayName - source set name displayed in the generated documentation -src - list of source files or directories separated by ; -classpath - list of directories or .jar files to include in the classpath (used for resolving references) separated by ; -samples - list of directories containing sample code (documentation for those directories is not generated but declarations from them can be referenced using the @sample tag) separated by ; -includes - list of files containing the documentation for the module and individual packages separated by ; -includeNonPublic - Deprecated , prefer using documentedVisibilities . Include protected and private code -documentedVisibilities - a list of visibility modifiers (separated by ; ) that should be documented. Overrides includeNonPublic . Default is PUBLIC . Possible values: PUBLIC , PRIVATE , PROTECTED , INTERNAL (Kotlin-specific), PACKAGE (Java-specific package-private) -skipDeprecated - if set, deprecated elements are not included in the generated documentation -reportUndocumented - warn about undocumented members -noSkipEmptyPackages - create index pages for empty packages -perPackageOptions - list of package options in format matchingRegex,-deprecated,-privateApi,+reportUndocumented;+visibility:PRIVATE;matchingRegex, ... , separated by ; -links - list of external documentation links in format url^packageListUrl^^url2... , separated by ; -srcLink - mapping between a source directory and a Web site for browsing the code in format <path>=<url>[#lineSuffix] -noStdlibLink - disable linking to online kotlin-stdlib documentation -noJdkLink - disable linking to online JDK documentation -jdkVersion - version of JDK to use for linking to JDK JavaDoc -analysisPlatform - platform used for analysis, see the Platforms section -dependentSourceSets - list of dependent source sets in format moduleName/sourceSetName , separated by ; -loggingLevel - one of DEBUG , PROGRESS , INFO , WARN , ERROR . Defaults to DEBUG . Please note that this argument can't be passed in JSON. You can also use a JSON file with Dokka configuration: java -jar <dokka_cli.jar> <path_to_config.json>","title":"Configuration options"},{"location":"user_guide/applying/cli/#applying-plugins","text":"To apply a Dokka plugin you have to provide it and all its dependencies in the pluginsClasspath parameter","title":"Applying plugins"},{"location":"user_guide/applying/cli/#base-plugin","text":"Using CLI runner to generate default documentation requires providing all dependencies manually on classpath. For Base plugins these are: dokka-base.jar dokka-analysis.jar kotlin-analysis-compiler.jar kotlin-analysis-intellij.jar kotlinx-html-jvm.jar All of them are published on maven central. Another dependencies of Base plugin (e.g. kotlinx-coroutines-core and so on) are already included in dokka-cli.jar . To get them on classpath one should add them via pluginsClasspath argument, e. g. java -jar dokka-cli.jar -pluginsClasspath \"dokka-base.jar;dokka-analysis.jar;kotlin-analysis-compiler.jar;kotlin-analysis-intellij.jar;kotlinx-html-jvm.jar\" ...","title":"Base plugin"},{"location":"user_guide/applying/cli/#example-using-json","text":"To run Dokka with JSON configuration: java -jar dokka-cli.jar dokkaConfiguration.json Option values of JSON correspond to Gradle ones . The content of JSON file dokkaConfiguration.json : { \"moduleName\" : \"Dokka Example\" , \"moduleVersion\" : null , \"outputDir\" : \"build/dokka/html\" , \"cacheRoot\" : null , \"offlineMode\" : false , \"sourceSets\" : [ { \"displayName\" : \"jvm\" , \"sourceSetID\" : { \"scopeId\" : \":dokkaHtml\" , \"sourceSetName\" : \"main\" }, \"classpath\" : [ \"libs/kotlin-stdlib-1.7.20.jar\" , \"libs/kotlin-stdlib-common-1.7.20.jar\" ], \"sourceRoots\" : [ \"/home/Vadim.Mishenev/dokka/examples/cli/src/main/kotlin\" ], \"dependentSourceSets\" : [], \"samples\" : [], \"includes\" : [ \"Module.md\" ], \"includeNonPublic\" : false , \"documentedVisibilities\" : [ \"PUBLIC\" , \"PRIVATE\" , \"PROTECTED\" , \"INTERNAL\" , \"PACKAGE\" ], \"reportUndocumented\" : false , \"skipEmptyPackages\" : true , \"skipDeprecated\" : false , \"jdkVersion\" : 8 , \"sourceLinks\" : [ { \"localDirectory\" : \"/home/Vadim.Mishenev/dokka/examples/cli/src/main/kotlin\" , \"remoteUrl\" : \"https://github.com/Kotlin/dokka/tree/master/examples/gradle/dokka-gradle-example/src/main/kotlin\" , \"remoteLineSuffix\" : \"#L\" } ], \"perPackageOptions\" : [], \"externalDocumentationLinks\" : [ { \"url\" : \"https://docs.oracle.com/javase/8/docs/api/\" , \"packageListUrl\" : \"https://docs.oracle.com/javase/8/docs/api/package-list\" }, { \"url\" : \"https://kotlinlang.org/api/latest/jvm/stdlib/\" , \"packageListUrl\" : \"https://kotlinlang.org/api/latest/jvm/stdlib/package-list\" } ], \"noStdlibLink\" : false , \"noJdkLink\" : false , \"suppressedFiles\" : [], \"analysisPlatform\" : \"jvm\" } ], \"pluginsClasspath\" : [ \"plugins/dokka-base-1.7.20.jar\" , \"libs/kotlinx-html-jvm-0.7.3.jar\" , \"libs/dokka-analysis-1.7.20.jar\" , \"libs/kotlin-analysis-intellij-1.7.20.jar\" , \"libs/kotlin-analysis-compiler-1.7.20.jar\" ], \"pluginsConfiguration\" : [ { \"fqPluginName\" : \"org.jetbrains.dokka.base.DokkaBase\" , \"serializationFormat\" : \"JSON\" , \"values\" : \"{\\\"separateInheritedMembers\\\":false,\\\"footerMessage\\\":\\\"\u00a9 2021 Copyright\\\"}\" } ], \"modules\" : [], \"failOnWarning\" : false , \"delayTemplateSubstitution\" : false , \"suppressObviousFunctions\" : true , \"includes\" : [], \"suppressInheritedMembers\" : false }","title":"Example using JSON"},{"location":"user_guide/applying/gradle/","text":"Using the Gradle plugin \u00b6 Important If you are upgrading from 0.10.x to a current release of Dokka, please have a look at our migration guide Supported versions \u00b6 Dokka should work on gradle newer than 5.6 Setup \u00b6 The preferred way is to use plugins block. build.gradle.kts: plugins { id ( \"org.jetbrains.dokka\" ) version \"1.7.20\" } repositories { mavenCentral () } You can also use the legacy plugin application method with buildscript block. Note that by using the buildscript way type-safe accessors are not available in Gradle Kotlin DSL, eg. you'll have to use named<DokkaTask>(\"dokkaHtml\") instead of dokkaHtml : buildscript { dependencies { classpath ( \"org.jetbrains.dokka:dokka-gradle-plugin: ${ dokka_version } \" ) } } apply ( plugin = \"org.jetbrains.dokka\" ) The plugin adds dokkaHtml , dokkaJavadoc , dokkaGfm and dokkaJekyll tasks to the project. Each task corresponds to one output format, so you should run dokkaGfm when you want to have a documentation in GFM format. Output formats are explained in the introduction If you encounter any problems when migrating from older versions of Dokka, please see the FAQ . Minimal configuration (with custom output directory only): Kotlin DSL tasks . dokkaHtml . configure { outputDirectory . set ( buildDir . resolve ( \"dokka\" )) } Groovy DSL dokkaHtml { outputDirectory . set ( file ( \"${buildDir}/dokka\" )) } Note Dokka extracts the information about sourcesets from the Kotlin Gradle plugin. Therefore, if you are using Dokka in a precompiled script plugin , you will have to add a depencency to the Kotlin Gradle Plugin as well ( implementation(kotlin(\"gradle-plugin\", \"<kotlin-version>\")) resp. implementation(\"org.jetbrains.kotlin:kotlin-gradle-plugin:<kotlin-version>\") ). Configuration options \u00b6 Dokka documents single-platform as well as multi-platform projects. Most of the configuration options are set per one source set. The available configuration options are shown below: import org.jetbrains.dokka.DokkaConfiguration import org.jetbrains.dokka.gradle.DokkaTask val dokkaHtml by getting ( DokkaTask :: class ) { outputDirectory . set ( buildDir . resolve ( \"dokka\" )) // Set module name displayed in the final output moduleName . set ( \"moduleName\" ) // Use default or set to custom path to cache directory // to enable package-list caching // When this is set to default, caches are stored in $USER_HOME/.cache/dokka cacheRoot . set ( file ( \"default\" )) // Suppress obvious functions like default toString or equals. Defaults to true suppressObviousFunctions . set ( false ) // Suppress all inherited members that were not overriden in a given class. // Eg. using it you can suppress toString or equals functions but you can't suppress componentN or copy on data class. To do that use with suppressObviousFunctions // Defaults to false suppressInheritedMembers . set ( true ) // Used to prevent resolving package-lists online. When this option is set to true, only local files are resolved offlineMode . set ( false ) dokkaSourceSets { configureEach { // Or source set name, for single-platform the default source sets are `main` and `test` // Used when configuring source sets manually for declaring which source sets this one depends on dependsOn ( \"otherSourceSetName\" ) // Used to remove a source set from documentation, test source sets are suppressed by default suppress . set ( false ) // Deprecated. Prefer using documentedVisibilities. includeNonPublic . set ( false ) // A set of visibility modifiers that should be documented // If set by user, overrides includeNonPublic. Default is PUBLIC documentedVisibilities . set ( setOf ( DokkaConfiguration . Visibility . PUBLIC , // Same for both Kotlin and Java DokkaConfiguration . Visibility . PRIVATE , // Same for both Kotlin and Java DokkaConfiguration . Visibility . PROTECTED , // Same for both Kotlin and Java DokkaConfiguration . Visibility . INTERNAL , // Kotlin-specific internal modifier DokkaConfiguration . Visibility . PACKAGE , // Java-specific package-private visibility ) ) // Do not output deprecated members. Applies globally, can be overridden by packageOptions skipDeprecated . set ( false ) // Emit warnings about not documented members. Applies globally, also can be overridden by packageOptions reportUndocumented . set ( true ) // Do not create index pages for empty packages skipEmptyPackages . set ( true ) // This name will be shown in the final output displayName . set ( \"JVM\" ) // Platform used for code analysis. See the \"Platforms\" section of this readme platform . set ( org . jetbrains . dokka . Platform . jvm ) // Property used for manual addition of files to the classpath // This property does not override the classpath collected automatically but appends to it classpath . from ( file ( \"libs/dependency.jar\" )) // List of files with module and package documentation // https://kotlinlang.org/docs/reference/kotlin-doc.html#module-and-package-documentation includes . from ( \"packages.md\" , \"extra.md\" ) // List of files or directories containing sample code (referenced with @sample tags) samples . from ( \"samples/basic.kt\" , \"samples/advanced.kt\" ) // By default, sourceRoots are taken from Kotlin Plugin and kotlinTasks, following roots will be appended to them // Repeat for multiple sourceRoots sourceRoots . from ( file ( \"src\" )) // Specifies the location of the project source code on the Web. // If provided, Dokka generates \"source\" links for each declaration. // Repeat for multiple mappings sourceLink { // Unix based directory relative path to the root of the project (where you execute gradle respectively). localDirectory . set ( file ( \"src/main/kotlin\" )) // URL showing where the source code can be accessed through the web browser remoteUrl . set ( java . net . URL ( \"https://github.com/cy6erGn0m/vertx3-lang-kotlin/blob/master/src/main/kotlin\" )) // Suffix which is used to append the line number to the URL. Use #L for GitHub remoteLineSuffix . set ( \"#L\" ) } // Used for linking to JDK documentation jdkVersion . set ( 8 ) // Disable linking to online kotlin-stdlib documentation noStdlibLink . set ( false ) // Disable linking to online JDK documentation noJdkLink . set ( false ) // Disable linking to online Android documentation (only applicable for Android projects) noAndroidSdkLink . set ( false ) // Allows linking to documentation of the project\"s dependencies (generated with Javadoc or Dokka) // Repeat for multiple links externalDocumentationLink { // Root URL of the generated documentation to link with. The trailing slash is required! url . set ( URL ( \"https://example.com/docs/\" )) // If package-list file is located in non-standard location // packageListUrl = URL(\"file:///home/user/localdocs/package-list\") } // Allows to customize documentation generation options on a per-package basis // Repeat for multiple packageOptions // If multiple packages match the same matchingRegex, the longest matchingRegex will be used perPackageOption { // will match kotlin and all sub-packages of it matchingRegex . set ( \"kotlin( $ |\\\\.).*\" ) // All options are optional skipDeprecated . set ( false ) reportUndocumented . set ( true ) // Emit warnings about not documented members includeNonPublic . set ( false ) // Deprecated, prefer using documentedVisibilities // Visibilities that should be included in the documentation // If set by user, overrides includeNonPublic. Default is PUBLIC documentedVisibilities . set ( setOf ( DokkaConfiguration . Visibility . PUBLIC , // Same for both Kotlin and Java DokkaConfiguration . Visibility . PRIVATE , // Same for both Kotlin and Java DokkaConfiguration . Visibility . PROTECTED , // Same for both Kotlin and Java DokkaConfiguration . Visibility . INTERNAL , // Kotlin-specific internal modifier DokkaConfiguration . Visibility . PACKAGE , // Java-specific package-private visibility ) ) } // Suppress a package perPackageOption { matchingRegex . set ( \"\"\".*\\.internal.*\"\"\" ) // will match all .internal packages and sub-packages suppress . set ( true ) } // Include generated files in documentation // By default Dokka will omit all files in folder named generated that is a child of buildDir suppressGeneratedFiles . set ( false ) } // Configures a plugin separately from the global configuration pluginConfiguration < PluginClass , ConfigurationClass > { // values } } } Multiplatform \u00b6 Dokka supports single-platform and multi-platform projects using source sets abstraction. For most mutli-platform projects you should assume that Dokka's source sets correspond to Kotlin plugin's source sets. All source sets are by default registered and configured automatically although test source sets are suppressed Kotlin kotlin { // Kotlin Multiplatform plugin configuration jvm () js ( \"customName\" ) } tasks . withType < DokkaTask > (). configureEach { // custom output directory outputDirectory . set ( buildDir . resolve ( \"dokka\" )) dokkaSourceSets { named ( \"customNameMain\" ) { // The same name as in Kotlin Multiplatform plugin, so the sources are fetched automatically includes . from ( \"packages.md\" , \"extra.md\" ) samples . from ( \"samples/basic.kt\" , \"samples/advanced.kt\" ) } register ( \"differentName\" ) { // Different name, so source roots must be passed explicitly displayName . set ( \"JVM\" ) platform . set ( org . jetbrains . dokka . Platform . jvm ) sourceRoots . from ( kotlin . sourceSets . getByName ( \"jvmMain\" ). kotlin . srcDirs ) sourceRoots . from ( kotlin . sourceSets . getByName ( \"commonMain\" ). kotlin . srcDirs ) } } } Note If you want to share the configuration between source sets, you can use Gradle's configureEach Applying plugins \u00b6 Dokka plugin creates Gradle configuration for each output format in the form of dokka${format}Plugin (or dokka${format}PartialPlugin for multi-module tasks) : dependencies { dokkaHtmlPlugin ( \"org.jetbrains.dokka:kotlin-as-java-plugin:1.7.20\" ) } You can also create a custom Dokka task and add plugins directly inside: val customDokkaTask by creating ( DokkaTask :: class ) { dependencies { plugins ( \"org.jetbrains.dokka:kotlin-as-java-plugin:1.7.20\" ) } } Important Please note that dokkaJavadoc task will properly document only single jvm source set To generate the documentation, use the appropriate dokka${format} Gradle task: ./gradlew dokkaHtml Some plugins can be configured separately using a plugin class and configuration class. For example: import org.jetbrains.dokka.base.DokkaBase import org.jetbrains.dokka.base.DokkaBaseConfiguration pluginConfiguration < DokkaBase , DokkaBaseConfiguration > { customAssets = listOf ( file ( \"<path to asset>\" )) customStyleSheets = listOf ( file ( \"<path to custom stylesheet>\" )) } Keep in mind, that this only works when using a buildscript (with the configured plugin on classpath) since it is not possible to import plugin's class without it. For example, you can add DokkaBase to gain access to aforementioned configuration: buildscript { dependencies { // classpath(\"<plugin coordinates>:<plugin version>\") classpath ( \"org.jetbrains.dokka:dokka-base:1.7.20\" ) } } If you don't want to use a buildscript or use Kotlin version lower than 1.3.50 you can achieve the same behaviour manually: pluginsMapConfiguration . set ( mapOf ( \"<fully qualified plugin's name>\" to \"\"\"<json configuration>\"\"\" )) Android \u00b6 Important Make sure you apply Dokka after com.android.library and kotlin-android . buildscript { dependencies { classpath ( \"org.jetbrains.kotlin:kotlin-gradle-plugin: ${ kotlin_version } \" ) classpath ( \"org.jetbrains.dokka:dokka-gradle-plugin: ${ dokka_version } \" ) } } repositories { mavenCentral () } apply ( plugin = \"com.android.library\" ) apply ( plugin = \"kotlin-android\" ) apply ( plugin = \"org.jetbrains.dokka\" ) dokkaHtml . configure { dokkaSourceSets { named ( \"main\" ) { noAndroidSdkLink . set ( false ) } } } Multi-module projects \u00b6 For documenting Gradle multi-module projects, you can use dokka${format}MultiModule tasks. Dokka plugin adds dokkaHtmlMultiModule , dokkaGfmMultiModule and dokkaJekyllMultiModule tasks to all Gradle parent projects (all projects that have some child projects) as well as dokkaHtmlPartial , dokkaGfmPartial and dokkaJekyllPartial to all projects that have a parent. If you want eg. to add an external link to some dependency you should do so in respective dokka${format}Partial tasks, or configure them all at once using the subprojects block and configureEach method. tasks . dokkaHtmlMultiModule . configure { outputDirectory . set ( buildDir . resolve ( \"dokkaCustomMultiModuleOutput\" )) } DokkaMultiModule depends on all Dokka tasks in the subprojects named dokka${format}Partial , runs them, and creates a top-level page with links to all generated (sub)documentations. It is possible to configure each of them: tasks . dokkaHtmlPartial . configure { failOnWarning . set ( true ) } Example projects \u00b6 Please see the Dokka Gradle single module example project or multimodule for an example. Also see generated documentation in HTML format.","title":"Gradle"},{"location":"user_guide/applying/gradle/#using-the-gradle-plugin","text":"Important If you are upgrading from 0.10.x to a current release of Dokka, please have a look at our migration guide","title":"Using the Gradle plugin"},{"location":"user_guide/applying/gradle/#supported-versions","text":"Dokka should work on gradle newer than 5.6","title":"Supported versions"},{"location":"user_guide/applying/gradle/#setup","text":"The preferred way is to use plugins block. build.gradle.kts: plugins { id ( \"org.jetbrains.dokka\" ) version \"1.7.20\" } repositories { mavenCentral () } You can also use the legacy plugin application method with buildscript block. Note that by using the buildscript way type-safe accessors are not available in Gradle Kotlin DSL, eg. you'll have to use named<DokkaTask>(\"dokkaHtml\") instead of dokkaHtml : buildscript { dependencies { classpath ( \"org.jetbrains.dokka:dokka-gradle-plugin: ${ dokka_version } \" ) } } apply ( plugin = \"org.jetbrains.dokka\" ) The plugin adds dokkaHtml , dokkaJavadoc , dokkaGfm and dokkaJekyll tasks to the project. Each task corresponds to one output format, so you should run dokkaGfm when you want to have a documentation in GFM format. Output formats are explained in the introduction If you encounter any problems when migrating from older versions of Dokka, please see the FAQ . Minimal configuration (with custom output directory only): Kotlin DSL tasks . dokkaHtml . configure { outputDirectory . set ( buildDir . resolve ( \"dokka\" )) } Groovy DSL dokkaHtml { outputDirectory . set ( file ( \"${buildDir}/dokka\" )) } Note Dokka extracts the information about sourcesets from the Kotlin Gradle plugin. Therefore, if you are using Dokka in a precompiled script plugin , you will have to add a depencency to the Kotlin Gradle Plugin as well ( implementation(kotlin(\"gradle-plugin\", \"<kotlin-version>\")) resp. implementation(\"org.jetbrains.kotlin:kotlin-gradle-plugin:<kotlin-version>\") ).","title":"Setup"},{"location":"user_guide/applying/gradle/#configuration-options","text":"Dokka documents single-platform as well as multi-platform projects. Most of the configuration options are set per one source set. The available configuration options are shown below: import org.jetbrains.dokka.DokkaConfiguration import org.jetbrains.dokka.gradle.DokkaTask val dokkaHtml by getting ( DokkaTask :: class ) { outputDirectory . set ( buildDir . resolve ( \"dokka\" )) // Set module name displayed in the final output moduleName . set ( \"moduleName\" ) // Use default or set to custom path to cache directory // to enable package-list caching // When this is set to default, caches are stored in $USER_HOME/.cache/dokka cacheRoot . set ( file ( \"default\" )) // Suppress obvious functions like default toString or equals. Defaults to true suppressObviousFunctions . set ( false ) // Suppress all inherited members that were not overriden in a given class. // Eg. using it you can suppress toString or equals functions but you can't suppress componentN or copy on data class. To do that use with suppressObviousFunctions // Defaults to false suppressInheritedMembers . set ( true ) // Used to prevent resolving package-lists online. When this option is set to true, only local files are resolved offlineMode . set ( false ) dokkaSourceSets { configureEach { // Or source set name, for single-platform the default source sets are `main` and `test` // Used when configuring source sets manually for declaring which source sets this one depends on dependsOn ( \"otherSourceSetName\" ) // Used to remove a source set from documentation, test source sets are suppressed by default suppress . set ( false ) // Deprecated. Prefer using documentedVisibilities. includeNonPublic . set ( false ) // A set of visibility modifiers that should be documented // If set by user, overrides includeNonPublic. Default is PUBLIC documentedVisibilities . set ( setOf ( DokkaConfiguration . Visibility . PUBLIC , // Same for both Kotlin and Java DokkaConfiguration . Visibility . PRIVATE , // Same for both Kotlin and Java DokkaConfiguration . Visibility . PROTECTED , // Same for both Kotlin and Java DokkaConfiguration . Visibility . INTERNAL , // Kotlin-specific internal modifier DokkaConfiguration . Visibility . PACKAGE , // Java-specific package-private visibility ) ) // Do not output deprecated members. Applies globally, can be overridden by packageOptions skipDeprecated . set ( false ) // Emit warnings about not documented members. Applies globally, also can be overridden by packageOptions reportUndocumented . set ( true ) // Do not create index pages for empty packages skipEmptyPackages . set ( true ) // This name will be shown in the final output displayName . set ( \"JVM\" ) // Platform used for code analysis. See the \"Platforms\" section of this readme platform . set ( org . jetbrains . dokka . Platform . jvm ) // Property used for manual addition of files to the classpath // This property does not override the classpath collected automatically but appends to it classpath . from ( file ( \"libs/dependency.jar\" )) // List of files with module and package documentation // https://kotlinlang.org/docs/reference/kotlin-doc.html#module-and-package-documentation includes . from ( \"packages.md\" , \"extra.md\" ) // List of files or directories containing sample code (referenced with @sample tags) samples . from ( \"samples/basic.kt\" , \"samples/advanced.kt\" ) // By default, sourceRoots are taken from Kotlin Plugin and kotlinTasks, following roots will be appended to them // Repeat for multiple sourceRoots sourceRoots . from ( file ( \"src\" )) // Specifies the location of the project source code on the Web. // If provided, Dokka generates \"source\" links for each declaration. // Repeat for multiple mappings sourceLink { // Unix based directory relative path to the root of the project (where you execute gradle respectively). localDirectory . set ( file ( \"src/main/kotlin\" )) // URL showing where the source code can be accessed through the web browser remoteUrl . set ( java . net . URL ( \"https://github.com/cy6erGn0m/vertx3-lang-kotlin/blob/master/src/main/kotlin\" )) // Suffix which is used to append the line number to the URL. Use #L for GitHub remoteLineSuffix . set ( \"#L\" ) } // Used for linking to JDK documentation jdkVersion . set ( 8 ) // Disable linking to online kotlin-stdlib documentation noStdlibLink . set ( false ) // Disable linking to online JDK documentation noJdkLink . set ( false ) // Disable linking to online Android documentation (only applicable for Android projects) noAndroidSdkLink . set ( false ) // Allows linking to documentation of the project\"s dependencies (generated with Javadoc or Dokka) // Repeat for multiple links externalDocumentationLink { // Root URL of the generated documentation to link with. The trailing slash is required! url . set ( URL ( \"https://example.com/docs/\" )) // If package-list file is located in non-standard location // packageListUrl = URL(\"file:///home/user/localdocs/package-list\") } // Allows to customize documentation generation options on a per-package basis // Repeat for multiple packageOptions // If multiple packages match the same matchingRegex, the longest matchingRegex will be used perPackageOption { // will match kotlin and all sub-packages of it matchingRegex . set ( \"kotlin( $ |\\\\.).*\" ) // All options are optional skipDeprecated . set ( false ) reportUndocumented . set ( true ) // Emit warnings about not documented members includeNonPublic . set ( false ) // Deprecated, prefer using documentedVisibilities // Visibilities that should be included in the documentation // If set by user, overrides includeNonPublic. Default is PUBLIC documentedVisibilities . set ( setOf ( DokkaConfiguration . Visibility . PUBLIC , // Same for both Kotlin and Java DokkaConfiguration . Visibility . PRIVATE , // Same for both Kotlin and Java DokkaConfiguration . Visibility . PROTECTED , // Same for both Kotlin and Java DokkaConfiguration . Visibility . INTERNAL , // Kotlin-specific internal modifier DokkaConfiguration . Visibility . PACKAGE , // Java-specific package-private visibility ) ) } // Suppress a package perPackageOption { matchingRegex . set ( \"\"\".*\\.internal.*\"\"\" ) // will match all .internal packages and sub-packages suppress . set ( true ) } // Include generated files in documentation // By default Dokka will omit all files in folder named generated that is a child of buildDir suppressGeneratedFiles . set ( false ) } // Configures a plugin separately from the global configuration pluginConfiguration < PluginClass , ConfigurationClass > { // values } } }","title":"Configuration options"},{"location":"user_guide/applying/gradle/#multiplatform","text":"Dokka supports single-platform and multi-platform projects using source sets abstraction. For most mutli-platform projects you should assume that Dokka's source sets correspond to Kotlin plugin's source sets. All source sets are by default registered and configured automatically although test source sets are suppressed Kotlin kotlin { // Kotlin Multiplatform plugin configuration jvm () js ( \"customName\" ) } tasks . withType < DokkaTask > (). configureEach { // custom output directory outputDirectory . set ( buildDir . resolve ( \"dokka\" )) dokkaSourceSets { named ( \"customNameMain\" ) { // The same name as in Kotlin Multiplatform plugin, so the sources are fetched automatically includes . from ( \"packages.md\" , \"extra.md\" ) samples . from ( \"samples/basic.kt\" , \"samples/advanced.kt\" ) } register ( \"differentName\" ) { // Different name, so source roots must be passed explicitly displayName . set ( \"JVM\" ) platform . set ( org . jetbrains . dokka . Platform . jvm ) sourceRoots . from ( kotlin . sourceSets . getByName ( \"jvmMain\" ). kotlin . srcDirs ) sourceRoots . from ( kotlin . sourceSets . getByName ( \"commonMain\" ). kotlin . srcDirs ) } } } Note If you want to share the configuration between source sets, you can use Gradle's configureEach","title":"Multiplatform"},{"location":"user_guide/applying/gradle/#applying-plugins","text":"Dokka plugin creates Gradle configuration for each output format in the form of dokka${format}Plugin (or dokka${format}PartialPlugin for multi-module tasks) : dependencies { dokkaHtmlPlugin ( \"org.jetbrains.dokka:kotlin-as-java-plugin:1.7.20\" ) } You can also create a custom Dokka task and add plugins directly inside: val customDokkaTask by creating ( DokkaTask :: class ) { dependencies { plugins ( \"org.jetbrains.dokka:kotlin-as-java-plugin:1.7.20\" ) } } Important Please note that dokkaJavadoc task will properly document only single jvm source set To generate the documentation, use the appropriate dokka${format} Gradle task: ./gradlew dokkaHtml Some plugins can be configured separately using a plugin class and configuration class. For example: import org.jetbrains.dokka.base.DokkaBase import org.jetbrains.dokka.base.DokkaBaseConfiguration pluginConfiguration < DokkaBase , DokkaBaseConfiguration > { customAssets = listOf ( file ( \"<path to asset>\" )) customStyleSheets = listOf ( file ( \"<path to custom stylesheet>\" )) } Keep in mind, that this only works when using a buildscript (with the configured plugin on classpath) since it is not possible to import plugin's class without it. For example, you can add DokkaBase to gain access to aforementioned configuration: buildscript { dependencies { // classpath(\"<plugin coordinates>:<plugin version>\") classpath ( \"org.jetbrains.dokka:dokka-base:1.7.20\" ) } } If you don't want to use a buildscript or use Kotlin version lower than 1.3.50 you can achieve the same behaviour manually: pluginsMapConfiguration . set ( mapOf ( \"<fully qualified plugin's name>\" to \"\"\"<json configuration>\"\"\" ))","title":"Applying plugins"},{"location":"user_guide/applying/gradle/#android","text":"Important Make sure you apply Dokka after com.android.library and kotlin-android . buildscript { dependencies { classpath ( \"org.jetbrains.kotlin:kotlin-gradle-plugin: ${ kotlin_version } \" ) classpath ( \"org.jetbrains.dokka:dokka-gradle-plugin: ${ dokka_version } \" ) } } repositories { mavenCentral () } apply ( plugin = \"com.android.library\" ) apply ( plugin = \"kotlin-android\" ) apply ( plugin = \"org.jetbrains.dokka\" ) dokkaHtml . configure { dokkaSourceSets { named ( \"main\" ) { noAndroidSdkLink . set ( false ) } } }","title":"Android"},{"location":"user_guide/applying/gradle/#multi-module-projects","text":"For documenting Gradle multi-module projects, you can use dokka${format}MultiModule tasks. Dokka plugin adds dokkaHtmlMultiModule , dokkaGfmMultiModule and dokkaJekyllMultiModule tasks to all Gradle parent projects (all projects that have some child projects) as well as dokkaHtmlPartial , dokkaGfmPartial and dokkaJekyllPartial to all projects that have a parent. If you want eg. to add an external link to some dependency you should do so in respective dokka${format}Partial tasks, or configure them all at once using the subprojects block and configureEach method. tasks . dokkaHtmlMultiModule . configure { outputDirectory . set ( buildDir . resolve ( \"dokkaCustomMultiModuleOutput\" )) } DokkaMultiModule depends on all Dokka tasks in the subprojects named dokka${format}Partial , runs them, and creates a top-level page with links to all generated (sub)documentations. It is possible to configure each of them: tasks . dokkaHtmlPartial . configure { failOnWarning . set ( true ) }","title":"Multi-module projects"},{"location":"user_guide/applying/gradle/#example-projects","text":"Please see the Dokka Gradle single module example project or multimodule for an example. Also see generated documentation in HTML format.","title":"Example projects"},{"location":"user_guide/applying/maven/","text":"Using the Maven plugin \u00b6 Note Dokka Maven plugin does not support multi-platform projects. Minimal Maven configuration is <plugin> <groupId> org.jetbrains.dokka </groupId> <artifactId> dokka-maven-plugin </artifactId> <version> ${dokka.version} </version> <executions> <execution> <phase> pre-site </phase> <goals> <goal> dokka </goal> </goals> </execution> </executions> </plugin> By default files will be generated in target/dokka . The following goals are provided by the plugin: dokka:dokka - generate HTML documentation in Dokka format (showing declarations in Kotlin syntax) dokka:javadoc - generate HTML documentation in Javadoc format (showing declarations in Java syntax) dokka:javadocJar - generate a .jar file with Javadoc format documentation Configuration options \u00b6 The available configuration options are shown below: <plugin> <groupId> org.jetbrains.dokka </groupId> <artifactId> dokka-maven-plugin </artifactId> <version> ${dokka.version} </version> <executions> <execution> <phase> pre-site </phase> <goals> <goal> dokka </goal> </goals> </execution> </executions> <configuration> <!-- Set to true to skip dokka task, default: false --> <skip> false </skip> <!-- Default: ${project.artifactId} --> <moduleName> data </moduleName> <!-- Default: ${project.basedir}/target/dokka --> <outputDir> some/out/dir </outputDir> <!-- Use default or set to custom path to cache directory to enable package-list caching. --> <!-- When set to default, caches stored in $USER_HOME/.cache/dokka --> <cacheRoot> default </cacheRoot> <!-- Set to true to to prevent resolving package-lists online. --> <!-- When this option is set to true, only local files are resolved, default: false --> <offlineMode> false </offlineMode> <!-- List of '.md' files with package and module docs --> <!-- https://kotlinlang.org/docs/reference/kotlin-doc.html#module-and-package-documentation --> <includes> <include> packages.md </include> <include> extra.md </include> </includes> <!-- A list of visibility modifiers that should be documented --> <!-- If set by user, overrides includeNonPublic. Default is PUBLIC --> <documentedVisibilities> <visibility> PUBLIC </visibility> <!-- Same for both kotlin and java --> <visibility> PRIVATE </visibility> <!-- Same for both kotlin and java --> <visibility> PROTECTED </visibility> <!-- Same for both kotlin and java --> <visibility> INTERNAL </visibility> <!-- Kotlin-specific internal modifier --> <visibility> PACKAGE </visibility> <!-- Java-specific package-private visibility (default) --> </documentedVisibilities> <!-- List of sample roots --> <samples> <dir> src/test/samples </dir> </samples> <!-- Suppress obvious functions like default toString or equals. Defaults to true --> <suppressObviousFunctions> false </suppressObviousFunctions> <!-- Suppress all inherited members that were not overriden in a given class. --> <!-- Eg. using it you can suppress toString or equals functions but you can't suppress componentN or copy on data class. To do that use with suppressObviousFunctions --> <!-- Defaults to false --> <suppressInheritedMembers> true </suppressInheritedMembers> <!-- Used for linking to JDK, default: 6 --> <jdkVersion> 6 </jdkVersion> <!-- Do not output deprecated members, applies globally, can be overridden by packageOptions --> <skipDeprecated> false </skipDeprecated> <!-- Emit warnings about not documented members, applies globally, also can be overridden by packageOptions --> <reportUndocumented> true </reportUndocumented> <!-- Do not create index pages for empty packages --> <skipEmptyPackages> true </skipEmptyPackages> <!-- Short form list of sourceRoots, by default, set to ${project.compileSourceRoots} --> <sourceDirectories> <dir> src/main/kotlin </dir> </sourceDirectories> <!-- Full form list of sourceRoots --> <sourceRoots> <root> <path> src/main/kotlin </path> <!-- See platforms section of documentation --> <platforms> JVM </platforms> </root> </sourceRoots> <!-- Specifies the location of the project source code on the Web. If provided, Dokka generates \"source\" links for each declaration. --> <sourceLinks> <link> <!-- Source directory --> <path> ${project.basedir}/src/main/kotlin </path> <!-- URL showing where the source code can be accessed through the web browser --> <url> https://github.com/cy6erGn0m/vertx3-lang-kotlin/blob/master/src/main/kotlin </url> <!-- //remove src/main/kotlin if you use \"./\" above --> <!--Suffix which is used to append the line number to the URL. Use #L for GitHub --> <lineSuffix> #L </lineSuffix> </link> </sourceLinks> <!-- Disable linking to online kotlin-stdlib documentation --> <noStdlibLink> false </noStdlibLink> <!-- Disable linking to online JDK documentation --> <noJdkLink> false </noJdkLink> <!-- Allows linking to documentation of the project's dependencies (generated with Javadoc or Dokka) --> <externalDocumentationLinks> <link> <!-- Root URL of the generated documentation to link with. The trailing slash is required! --> <url> https://example.com/docs/ </url> <!-- If package-list file located in non-standard location --> <!-- <packageListUrl>file:///home/user/localdocs/package-list</packageListUrl> --> </link> </externalDocumentationLinks> <!-- Allows to customize documentation generation options on a per-package basis --> <perPackageOptions> <packageOptions> <!-- Will match kotlin and all sub-packages of it --> <matchingRegex> kotlin($|\\.).* </matchingRegex> <!-- All options are optional, default values are below: --> <skipDeprecated> false </skipDeprecated> <!-- Emit warnings about not documented members --> <reportUndocumented> true </reportUndocumented> <!-- Deprecated. Prefer using documentedVisibilities --> <includeNonPublic> false </includeNonPublic> <!-- A list of visibility modifiers that should be documented --> <!-- If set by user, overrides includeNonPublic. Default is PUBLIC --> <documentedVisibilities> <visibility> PUBLIC </visibility> <!-- Same for both kotlin and java --> <visibility> PRIVATE </visibility> <!-- Same for both kotlin and java --> <visibility> PROTECTED </visibility> <!-- Same for both kotlin and java --> <visibility> INTERNAL </visibility> <!-- Kotlin-specific internal modifier --> <visibility> PACKAGE </visibility> <!-- Java-specific package-private visibility (default) --> </documentedVisibilities> </packageOptions> </perPackageOptions> <!-- Allows to use any dokka plugin, eg. GFM format --> <dokkaPlugins> <plugin> <groupId> org.jetbrains.dokka </groupId> <artifactId> gfm-plugin </artifactId> <version> ${dokka.version} </version> </plugin> </dokkaPlugins> <!-- Configures a plugin separately --> <pluginsConfiguration> <fullyQualifiedPluginName> <!-- Configuration --> </fullyQualifiedPluginName> </pluginsConfiguration> </configuration> </plugin> Applying plugins \u00b6 You can add plugins inside the dokkaPlugins block: <plugin> <groupId> org.jetbrains.dokka </groupId> <artifactId> dokka-maven-plugin </artifactId> <version> ${dokka.version} </version> <executions> <execution> <phase> pre-site </phase> <goals> <goal> dokka </goal> </goals> </execution> </executions> <configuration> <dokkaPlugins> <plugin> <groupId> org.jetbrains.dokka </groupId> <artifactId> kotlin-as-java-plugin </artifactId> <version> ${dokka.version} </version> </plugin> </dokkaPlugins> </configuration> </plugin> Some plugins can be configured separately using plugin's fully qualified name. For example: <pluginsConfiguration> <org.jetbrains.dokka.base.DokkaBase> <customStyleSheets> <customStyleSheet> <!-- path to custom stylesheet --> </customStyleSheet> </customStyleSheets> <customAssets> <customAsset> <!-- path to custom asset --> </customAsset> </customAssets> </org.jetbrains.dokka.base.DokkaBase> </pluginsConfiguration> Example project \u00b6 Please see the Dokka Maven example project for an example.","title":"Maven"},{"location":"user_guide/applying/maven/#using-the-maven-plugin","text":"Note Dokka Maven plugin does not support multi-platform projects. Minimal Maven configuration is <plugin> <groupId> org.jetbrains.dokka </groupId> <artifactId> dokka-maven-plugin </artifactId> <version> ${dokka.version} </version> <executions> <execution> <phase> pre-site </phase> <goals> <goal> dokka </goal> </goals> </execution> </executions> </plugin> By default files will be generated in target/dokka . The following goals are provided by the plugin: dokka:dokka - generate HTML documentation in Dokka format (showing declarations in Kotlin syntax) dokka:javadoc - generate HTML documentation in Javadoc format (showing declarations in Java syntax) dokka:javadocJar - generate a .jar file with Javadoc format documentation","title":"Using the Maven plugin"},{"location":"user_guide/applying/maven/#configuration-options","text":"The available configuration options are shown below: <plugin> <groupId> org.jetbrains.dokka </groupId> <artifactId> dokka-maven-plugin </artifactId> <version> ${dokka.version} </version> <executions> <execution> <phase> pre-site </phase> <goals> <goal> dokka </goal> </goals> </execution> </executions> <configuration> <!-- Set to true to skip dokka task, default: false --> <skip> false </skip> <!-- Default: ${project.artifactId} --> <moduleName> data </moduleName> <!-- Default: ${project.basedir}/target/dokka --> <outputDir> some/out/dir </outputDir> <!-- Use default or set to custom path to cache directory to enable package-list caching. --> <!-- When set to default, caches stored in $USER_HOME/.cache/dokka --> <cacheRoot> default </cacheRoot> <!-- Set to true to to prevent resolving package-lists online. --> <!-- When this option is set to true, only local files are resolved, default: false --> <offlineMode> false </offlineMode> <!-- List of '.md' files with package and module docs --> <!-- https://kotlinlang.org/docs/reference/kotlin-doc.html#module-and-package-documentation --> <includes> <include> packages.md </include> <include> extra.md </include> </includes> <!-- A list of visibility modifiers that should be documented --> <!-- If set by user, overrides includeNonPublic. Default is PUBLIC --> <documentedVisibilities> <visibility> PUBLIC </visibility> <!-- Same for both kotlin and java --> <visibility> PRIVATE </visibility> <!-- Same for both kotlin and java --> <visibility> PROTECTED </visibility> <!-- Same for both kotlin and java --> <visibility> INTERNAL </visibility> <!-- Kotlin-specific internal modifier --> <visibility> PACKAGE </visibility> <!-- Java-specific package-private visibility (default) --> </documentedVisibilities> <!-- List of sample roots --> <samples> <dir> src/test/samples </dir> </samples> <!-- Suppress obvious functions like default toString or equals. Defaults to true --> <suppressObviousFunctions> false </suppressObviousFunctions> <!-- Suppress all inherited members that were not overriden in a given class. --> <!-- Eg. using it you can suppress toString or equals functions but you can't suppress componentN or copy on data class. To do that use with suppressObviousFunctions --> <!-- Defaults to false --> <suppressInheritedMembers> true </suppressInheritedMembers> <!-- Used for linking to JDK, default: 6 --> <jdkVersion> 6 </jdkVersion> <!-- Do not output deprecated members, applies globally, can be overridden by packageOptions --> <skipDeprecated> false </skipDeprecated> <!-- Emit warnings about not documented members, applies globally, also can be overridden by packageOptions --> <reportUndocumented> true </reportUndocumented> <!-- Do not create index pages for empty packages --> <skipEmptyPackages> true </skipEmptyPackages> <!-- Short form list of sourceRoots, by default, set to ${project.compileSourceRoots} --> <sourceDirectories> <dir> src/main/kotlin </dir> </sourceDirectories> <!-- Full form list of sourceRoots --> <sourceRoots> <root> <path> src/main/kotlin </path> <!-- See platforms section of documentation --> <platforms> JVM </platforms> </root> </sourceRoots> <!-- Specifies the location of the project source code on the Web. If provided, Dokka generates \"source\" links for each declaration. --> <sourceLinks> <link> <!-- Source directory --> <path> ${project.basedir}/src/main/kotlin </path> <!-- URL showing where the source code can be accessed through the web browser --> <url> https://github.com/cy6erGn0m/vertx3-lang-kotlin/blob/master/src/main/kotlin </url> <!-- //remove src/main/kotlin if you use \"./\" above --> <!--Suffix which is used to append the line number to the URL. Use #L for GitHub --> <lineSuffix> #L </lineSuffix> </link> </sourceLinks> <!-- Disable linking to online kotlin-stdlib documentation --> <noStdlibLink> false </noStdlibLink> <!-- Disable linking to online JDK documentation --> <noJdkLink> false </noJdkLink> <!-- Allows linking to documentation of the project's dependencies (generated with Javadoc or Dokka) --> <externalDocumentationLinks> <link> <!-- Root URL of the generated documentation to link with. The trailing slash is required! --> <url> https://example.com/docs/ </url> <!-- If package-list file located in non-standard location --> <!-- <packageListUrl>file:///home/user/localdocs/package-list</packageListUrl> --> </link> </externalDocumentationLinks> <!-- Allows to customize documentation generation options on a per-package basis --> <perPackageOptions> <packageOptions> <!-- Will match kotlin and all sub-packages of it --> <matchingRegex> kotlin($|\\.).* </matchingRegex> <!-- All options are optional, default values are below: --> <skipDeprecated> false </skipDeprecated> <!-- Emit warnings about not documented members --> <reportUndocumented> true </reportUndocumented> <!-- Deprecated. Prefer using documentedVisibilities --> <includeNonPublic> false </includeNonPublic> <!-- A list of visibility modifiers that should be documented --> <!-- If set by user, overrides includeNonPublic. Default is PUBLIC --> <documentedVisibilities> <visibility> PUBLIC </visibility> <!-- Same for both kotlin and java --> <visibility> PRIVATE </visibility> <!-- Same for both kotlin and java --> <visibility> PROTECTED </visibility> <!-- Same for both kotlin and java --> <visibility> INTERNAL </visibility> <!-- Kotlin-specific internal modifier --> <visibility> PACKAGE </visibility> <!-- Java-specific package-private visibility (default) --> </documentedVisibilities> </packageOptions> </perPackageOptions> <!-- Allows to use any dokka plugin, eg. GFM format --> <dokkaPlugins> <plugin> <groupId> org.jetbrains.dokka </groupId> <artifactId> gfm-plugin </artifactId> <version> ${dokka.version} </version> </plugin> </dokkaPlugins> <!-- Configures a plugin separately --> <pluginsConfiguration> <fullyQualifiedPluginName> <!-- Configuration --> </fullyQualifiedPluginName> </pluginsConfiguration> </configuration> </plugin>","title":"Configuration options"},{"location":"user_guide/applying/maven/#applying-plugins","text":"You can add plugins inside the dokkaPlugins block: <plugin> <groupId> org.jetbrains.dokka </groupId> <artifactId> dokka-maven-plugin </artifactId> <version> ${dokka.version} </version> <executions> <execution> <phase> pre-site </phase> <goals> <goal> dokka </goal> </goals> </execution> </executions> <configuration> <dokkaPlugins> <plugin> <groupId> org.jetbrains.dokka </groupId> <artifactId> kotlin-as-java-plugin </artifactId> <version> ${dokka.version} </version> </plugin> </dokkaPlugins> </configuration> </plugin> Some plugins can be configured separately using plugin's fully qualified name. For example: <pluginsConfiguration> <org.jetbrains.dokka.base.DokkaBase> <customStyleSheets> <customStyleSheet> <!-- path to custom stylesheet --> </customStyleSheet> </customStyleSheets> <customAssets> <customAsset> <!-- path to custom asset --> </customAsset> </customAssets> </org.jetbrains.dokka.base.DokkaBase> </pluginsConfiguration>","title":"Applying plugins"},{"location":"user_guide/applying/maven/#example-project","text":"Please see the Dokka Maven example project for an example.","title":"Example project"},{"location":"user_guide/output-formats/html/","text":"Configuration specific to HTML format \u00b6 Prerequisites \u00b6 Dokka's HTML format requires a web server to view documentation correctly. This can be achieved by using the one that is build in IntelliJ or providing your own. If this requisite is not fulfilled Dokka with fail to load navigation pane and search bars. Important Concepts specified below apply only to configuration of the Base Plugin (that contains HTML format) and needs to be applied via pluginsConfiguration and not on the root one. Modifying assets \u00b6 It is possible to change static assets that are used to generate dokka's HTML. Currently, user can modify: customAssets customStyleSheets Every file provided in those values will be applied to every page. Dokka uses 4 stylesheets: style.css - main css file responsible for styling the page jetbrains-mono.css - fonts used across dokka logo-styles.css - logo styling prism.css - code highlighting Also, it uses js scripts. The actual ones are here . User can choose to add or override those files - stylesheets and js scripts. Resources will be overridden when in pluginConfiguration block there is a resource with the same name. Modifying footer \u00b6 Dokka supports custom messages in the footer via footerMessage string property on base plugin configuration. Keep in mind that this value will be passed exactly to the output HTML, so it has to be valid and escaped correctly. Separating inherited members \u00b6 By setting a boolean property separateInheritedMembers dokka will split inherited members (like functions, properties etc.) from ones declared in viewed class. Separated members will have it's own tabs on the page. Merging declarations with name clashing \u00b6 By setting a boolean property mergeImplicitExpectActualDeclarations dokka will merge declarations that do not have expect / actual keywords but have the same fully qualified name. The declarations will be displayed on one page. By default, it is disabled. The page names of such declaration have a prefix that is the name of source set. Examples \u00b6 In order to override a logo and style it accordingly a css file named logo-styles.css is needed: . library-name a { position : relative ; --logo-width : 100 px ; margin-left : calc ( var ( --logo-width ) + 5 px ); } . library-name a :: before { content : '' ; background : url ( \"https://upload.wikimedia.org/wikipedia/commons/9/9d/Ubuntu_logo.svg\" ) center no-repeat ; background-size : contain ; position : absolute ; width : var ( --logo-width ); height : 50 px ; top : -18 px ; left : calc ( -1 * var ( --logo-width ) - 5 px ); /* other styles required to make your page pretty */ } For build system specific instructions please visit dedicated pages: gradle , maven and cli Custom HTML pages \u00b6 Templates are taken from the folder that is defined by the templatesDir property. To customize HTML output, you can use the default template as a starting point. Note To change page assets, you can set properties customAssets and customStyleSheets . Assets are handled by Dokka itself, not FreeMaker. There is a template file with predefined name base.ftl . It defines general design of all pages to render. base.ftl can import another templates that can be set by user as well: includes/header.ftl includes/footer.ftl includes/page_metadata.ftl includes/source_set_selector.ftl . If templatesDir is defined, Dokka will find a template file there. If the file is not found, a default one will be used. Variables given below are available to the template: ${pageName} - the page name ${footerMessage} - text that is set by the footerMessage property ${sourceSets} - a nullable list of source sets, only for multi-platform pages. Each source set has name , platfrom and filter properties. Also, Dokka-defined directives can be used: <@content/> - main content <@resources/> - scripts, stylesheets <@version/> - version ( versioning-plugin will replace this with a version navigator) <@template_cmd name=\"...\"\"> ...<!--@template_cmd--> - is used for variables that depend on the root project (such pathToRoot , projectName ). They are available only inside the directive. This is processed by a multi-module task that assembles partial outputs from modules. Example: <@template_cmd name=\"projectName\"> <span>${projectName}</span> </@template_cmd>","title":"HTML"},{"location":"user_guide/output-formats/html/#configuration-specific-to-html-format","text":"","title":"Configuration specific to HTML format"},{"location":"user_guide/output-formats/html/#prerequisites","text":"Dokka's HTML format requires a web server to view documentation correctly. This can be achieved by using the one that is build in IntelliJ or providing your own. If this requisite is not fulfilled Dokka with fail to load navigation pane and search bars. Important Concepts specified below apply only to configuration of the Base Plugin (that contains HTML format) and needs to be applied via pluginsConfiguration and not on the root one.","title":"Prerequisites"},{"location":"user_guide/output-formats/html/#modifying-assets","text":"It is possible to change static assets that are used to generate dokka's HTML. Currently, user can modify: customAssets customStyleSheets Every file provided in those values will be applied to every page. Dokka uses 4 stylesheets: style.css - main css file responsible for styling the page jetbrains-mono.css - fonts used across dokka logo-styles.css - logo styling prism.css - code highlighting Also, it uses js scripts. The actual ones are here . User can choose to add or override those files - stylesheets and js scripts. Resources will be overridden when in pluginConfiguration block there is a resource with the same name.","title":"Modifying assets"},{"location":"user_guide/output-formats/html/#modifying-footer","text":"Dokka supports custom messages in the footer via footerMessage string property on base plugin configuration. Keep in mind that this value will be passed exactly to the output HTML, so it has to be valid and escaped correctly.","title":"Modifying footer"},{"location":"user_guide/output-formats/html/#separating-inherited-members","text":"By setting a boolean property separateInheritedMembers dokka will split inherited members (like functions, properties etc.) from ones declared in viewed class. Separated members will have it's own tabs on the page.","title":"Separating inherited members"},{"location":"user_guide/output-formats/html/#merging-declarations-with-name-clashing","text":"By setting a boolean property mergeImplicitExpectActualDeclarations dokka will merge declarations that do not have expect / actual keywords but have the same fully qualified name. The declarations will be displayed on one page. By default, it is disabled. The page names of such declaration have a prefix that is the name of source set.","title":"Merging declarations with name clashing"},{"location":"user_guide/output-formats/html/#examples","text":"In order to override a logo and style it accordingly a css file named logo-styles.css is needed: . library-name a { position : relative ; --logo-width : 100 px ; margin-left : calc ( var ( --logo-width ) + 5 px ); } . library-name a :: before { content : '' ; background : url ( \"https://upload.wikimedia.org/wikipedia/commons/9/9d/Ubuntu_logo.svg\" ) center no-repeat ; background-size : contain ; position : absolute ; width : var ( --logo-width ); height : 50 px ; top : -18 px ; left : calc ( -1 * var ( --logo-width ) - 5 px ); /* other styles required to make your page pretty */ } For build system specific instructions please visit dedicated pages: gradle , maven and cli","title":"Examples"},{"location":"user_guide/output-formats/html/#custom-html-pages","text":"Templates are taken from the folder that is defined by the templatesDir property. To customize HTML output, you can use the default template as a starting point. Note To change page assets, you can set properties customAssets and customStyleSheets . Assets are handled by Dokka itself, not FreeMaker. There is a template file with predefined name base.ftl . It defines general design of all pages to render. base.ftl can import another templates that can be set by user as well: includes/header.ftl includes/footer.ftl includes/page_metadata.ftl includes/source_set_selector.ftl . If templatesDir is defined, Dokka will find a template file there. If the file is not found, a default one will be used. Variables given below are available to the template: ${pageName} - the page name ${footerMessage} - text that is set by the footerMessage property ${sourceSets} - a nullable list of source sets, only for multi-platform pages. Each source set has name , platfrom and filter properties. Also, Dokka-defined directives can be used: <@content/> - main content <@resources/> - scripts, stylesheets <@version/> - version ( versioning-plugin will replace this with a version navigator) <@template_cmd name=\"...\"\"> ...<!--@template_cmd--> - is used for variables that depend on the root project (such pathToRoot , projectName ). They are available only inside the directive. This is processed by a multi-module task that assembles partial outputs from modules. Example: <@template_cmd name=\"projectName\"> <span>${projectName}</span> </@template_cmd>","title":"Custom HTML pages"},{"location":"user_guide/plugins/android-plugin/","text":"Android documentation plugin \u00b6 Android documentation plugin aims to improve the documentation on android platform. Features: \u00b6 @hide support - @hide javadoc tag is an equivalent of @suppress tag in kdoc. It hides certain entry from being displayed in the documentation.","title":"Android plugin"},{"location":"user_guide/plugins/android-plugin/#android-documentation-plugin","text":"Android documentation plugin aims to improve the documentation on android platform.","title":"Android documentation plugin"},{"location":"user_guide/plugins/android-plugin/#features","text":"@hide support - @hide javadoc tag is an equivalent of @suppress tag in kdoc. It hides certain entry from being displayed in the documentation.","title":"Features:"},{"location":"user_guide/plugins/versioning-plugin/","text":"Versioning plugin \u00b6 Versioning plugin aims to provide users with ability to create a versioned documentation. Therefore, users of the documentation can view different versions of the documentation by going to the main page and change versions. Versioning can be configured using: version - a string value representing a version that should be displayed in the dropdown. olderVersionsDir - an optional file that represents the parent directory containing folders with previous Dokka outputs. olderVersions - an optional list of directories, each containing a previous Dokka output. Used after the contents of olderVersionsDir (if it's specified). versionsOrdering - an optional list of strings representing the ordering of versions that should be visible. By default, Dokka will try to use semantic versioning to create such ordering. renderVersionsNavigationOnAllPages - a bool value. By default, Dokka renders a versions navigation on all pages. Note You should enable the plugin in all submodules to render a versions navigation on all pages. Above configuration should be placed under the pluginsConfiguration block specific for your build tool. Configuration object is named org.jetbrains.dokka.versioning.VersioningConfiguration . Directory structure required \u00b6 If you pass previous versions using olderVersionsDir , a particular directory structure is required: . \u2514\u2500\u2500 older_versions_dir \u2514\u2500\u2500 1.4.10 \u251c\u2500\u2500 <dokka output> \u2514\u2500\u2500 1.4.20 \u251c\u2500\u2500 <dokka output> ... As can be seen on the diagram, olderVersionsDir should be a parent directory of previous output directories. This can be avoided by manually specifying each past output directory with olderVersions , or they can be used together. olderVersions directories need to contain a past Dokka output. For the above example, you would pass older_versions_dir/1.4.10, older_versions_dir/1.4.20 . Note The previously documentations should be generated with the versioning plugin. Example \u00b6 Versioning plugin in gradle can be configured in 2 ways: by manually adding the versioning plugin to classpath and using pluginsConfiguration by using pluginsMapConfiguration and adding the configuration serialized as json under the org.jetbrains.dokka.versioning.VersioningPlugin key. If you choose the first method the configuration may look like this: buildscript { dependencies { classpath ( \"org.jetbrains.dokka:versioning-plugin:<dokka_version>\" ) } } ... pluginConfiguration < org . jetbrains . dokka . versioning . VersioningPlugin , org . jetbrains . dokka . versioning . VersioningConfiguration > { version = \"1.0\" olderVersionsDir = projectDir . resolve ( \"olderVersionsDir\" ) } Alternatively, without adding plugin to classpath: pluginsMapConfiguration . set ( mapOf ( \"org.jetbrains.dokka.versioning.VersioningPlugin\" to \"\"\"{ \"version\": \"1.0\" }\"\"\" )) Please consult the Gradle documentation for more information about configuring Dokka with this build tool. Please see the Dokka Gradle versioning multi modules example project . Also see the generated documentation .","title":"Versioning plugin"},{"location":"user_guide/plugins/versioning-plugin/#versioning-plugin","text":"Versioning plugin aims to provide users with ability to create a versioned documentation. Therefore, users of the documentation can view different versions of the documentation by going to the main page and change versions. Versioning can be configured using: version - a string value representing a version that should be displayed in the dropdown. olderVersionsDir - an optional file that represents the parent directory containing folders with previous Dokka outputs. olderVersions - an optional list of directories, each containing a previous Dokka output. Used after the contents of olderVersionsDir (if it's specified). versionsOrdering - an optional list of strings representing the ordering of versions that should be visible. By default, Dokka will try to use semantic versioning to create such ordering. renderVersionsNavigationOnAllPages - a bool value. By default, Dokka renders a versions navigation on all pages. Note You should enable the plugin in all submodules to render a versions navigation on all pages. Above configuration should be placed under the pluginsConfiguration block specific for your build tool. Configuration object is named org.jetbrains.dokka.versioning.VersioningConfiguration .","title":"Versioning plugin"},{"location":"user_guide/plugins/versioning-plugin/#directory-structure-required","text":"If you pass previous versions using olderVersionsDir , a particular directory structure is required: . \u2514\u2500\u2500 older_versions_dir \u2514\u2500\u2500 1.4.10 \u251c\u2500\u2500 <dokka output> \u2514\u2500\u2500 1.4.20 \u251c\u2500\u2500 <dokka output> ... As can be seen on the diagram, olderVersionsDir should be a parent directory of previous output directories. This can be avoided by manually specifying each past output directory with olderVersions , or they can be used together. olderVersions directories need to contain a past Dokka output. For the above example, you would pass older_versions_dir/1.4.10, older_versions_dir/1.4.20 . Note The previously documentations should be generated with the versioning plugin.","title":"Directory structure required"},{"location":"user_guide/plugins/versioning-plugin/#example","text":"Versioning plugin in gradle can be configured in 2 ways: by manually adding the versioning plugin to classpath and using pluginsConfiguration by using pluginsMapConfiguration and adding the configuration serialized as json under the org.jetbrains.dokka.versioning.VersioningPlugin key. If you choose the first method the configuration may look like this: buildscript { dependencies { classpath ( \"org.jetbrains.dokka:versioning-plugin:<dokka_version>\" ) } } ... pluginConfiguration < org . jetbrains . dokka . versioning . VersioningPlugin , org . jetbrains . dokka . versioning . VersioningConfiguration > { version = \"1.0\" olderVersionsDir = projectDir . resolve ( \"olderVersionsDir\" ) } Alternatively, without adding plugin to classpath: pluginsMapConfiguration . set ( mapOf ( \"org.jetbrains.dokka.versioning.VersioningPlugin\" to \"\"\"{ \"version\": \"1.0\" }\"\"\" )) Please consult the Gradle documentation for more information about configuring Dokka with this build tool. Please see the Dokka Gradle versioning multi modules example project . Also see the generated documentation .","title":"Example"}]}