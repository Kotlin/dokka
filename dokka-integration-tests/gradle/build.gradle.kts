/*
 * Copyright 2014-2023 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license.
 */
import org.gradle.api.tasks.testing.logging.TestExceptionFormat.FULL
import org.gradle.api.tasks.testing.logging.TestLogEvent.FAILED
import org.gradle.api.tasks.testing.logging.TestLogEvent.SKIPPED
import org.jetbrains.kotlin.gradle.dsl.ExplicitApiMode.Disabled

plugins {
    id("dokkabuild.kotlin-jvm")
    `test-suite-base`
    `java-test-fixtures`
    id("dokkabuild.testing.android-setup")
}

dependencies {
    api(projects.utilities)

    api(libs.jsoup)

    api(libs.kotlin.test)
    api(libs.junit.jupiterApi)
    api(libs.junit.jupiterParams)

    api(gradleTestKit())
}

val dokkaModules = gradle.includedBuild("dokka")
val gradlePluginClassic = gradle.includedBuild("runner-gradle-plugin-classic")

val projectsUnderTest = listOf(
    dokkaModules,
    gradlePluginClassic,
)

// fetch the Maven repos of each IncludedBuild generated by the dev.adamko.dev-publish plugin
val testMavenDirs = files(projectsUnderTest.map { it.projectDir.resolve("build/maven-dev") })

tasks.integrationTestPreparation {
    dependsOn(
        projectsUnderTest.map { it.task(":integrationTestPreparation") }
    )
}

tasks.withType<Test>().configureEach {
    dependsOn(tasks.integrationTestPreparation)
}

val templateProjectsDir = layout.projectDirectory.dir("projects")
val exampleProjectsDir = layout.projectDirectory.dir("../../examples/gradle")
val templateSettingsGradleKts = layout.projectDirectory.file("projects/template.settings.gradle.kts")

@Suppress("UnstableApiUsage")
testing {
    suites {
        withType<JvmTestSuite>().configureEach {
            useJUnitJupiter()

            dependencies {
                implementation(project())
            }

            targets.configureEach {
                testTask.configure {
                    testMavenDirs.forEach { testMavenDir -> inputs.dir(testMavenDir) }
                    systemProperty(
                        "projectLocalMavenDirs",
                        testMavenDirs.joinToString(":") { it.invariantSeparatorsPath }
                    )

                    environment("ANDROID_HOME", templateProjectsDir.dir("ANDROID_SDK").asFile.invariantSeparatorsPath)

                    inputs.file(templateSettingsGradleKts)
                    systemProperty(
                        "templateSettingsGradleKts",
                        templateSettingsGradleKts.asFile.invariantSeparatorsPath
                    )

                    doFirst {
                        logger.lifecycle("running $path with javaLauncher:${javaLauncher.orNull?.metadata?.javaRuntimeVersion}")
                    }
                }
            }

            sources { java { setSrcDirs(emptyList<String>()) } }
        }

        fun registerTestProjectSuite(name: String, dirName: String, configure: JvmTestSuite.() -> Unit = {}) {
            val templateProjectDir = templateProjectsDir.dir(dirName)

            register<JvmTestSuite>(name) {
                targets.configureEach {
                    testTask.configure {
                        inputs.dir(templateProjectDir)
                        systemProperty("templateProjectDir", templateProjectDir.asFile.invariantSeparatorsPath)
                    }
                }
                configure()
            }
        }

        // register a separate test suite for each template project, to help with Gradle caching
        registerTestProjectSuite("projectTestAndroid", "it-android-0") {
            targets.configureEach {
                testTask.configure {
                    // AGP requires JVM 11+
                    javaLauncher = javaToolchains.launcherFor { languageVersion = JavaLanguageVersion.of(11) }
                }
            }
        }
        registerTestProjectSuite("projectTestBasic", "it-basic")
        registerTestProjectSuite("projectTestBasicGroovy", "it-basic-groovy")
        registerTestProjectSuite("projectTestCollector", "it-collector-0")
        registerTestProjectSuite("projectTestConfiguration", "it-configuration")
        registerTestProjectSuite("projectTestJsIr", "it-js-ir-0")
        registerTestProjectSuite("projectTestMultimodule0", "it-multimodule-0")
        registerTestProjectSuite("projectTestMultimodule1", "it-multimodule-1")
        registerTestProjectSuite("projectTestMultimoduleVersioning", "it-multimodule-versioning-0")
        registerTestProjectSuite("projectTestMultiplatform", "it-multiplatform-0")
        registerTestProjectSuite("projectTestSequentialTasksExecutionStress", "it-sequential-tasks-execution-stress")
        registerTestProjectSuite("projectTestWasmBasic", "it-wasm-basic")
        registerTestProjectSuite("projectTestWasmJsWasiBasic", "it-wasm-js-wasi-basic")
    }
    tasks.check {
        dependsOn(suites)
    }
}

kotlin {
    explicitApi = Disabled

    compilerOptions {
        allWarningsAsErrors = false
        optIn.add("kotlin.io.path.ExperimentalPathApi")
    }
}

tasks.withType<Test>().configureEach {
    maxHeapSize = "2G"

    val useK2 = dokkaBuild.tryK2.get()

    useJUnitPlatform {
        if (useK2) excludeTags("onlyDescriptors", "onlyDescriptorsMPP")
    }

    setForkEvery(1)
    project.properties["dokka_integration_test_parallelism"]?.toString()?.toIntOrNull()?.let { parallelism ->
        maxParallelForks = parallelism
    }

    environment(
        "isExhaustive",
        project.properties["dokka_integration_test_is_exhaustive"]?.toString()?.toBoolean()
            ?: System.getenv("DOKKA_INTEGRATION_TEST_IS_EXHAUSTIVE")?.toBoolean()
            ?: false.toString()
    )

    systemProperty("org.jetbrains.dokka.experimental.tryK2", useK2)

    // allow inspecting projects in failing tests
    systemProperty("junit.jupiter.tempdir.cleanup.mode.default", "ON_SUCCESS")

    testLogging {
        exceptionFormat = FULL
        events(SKIPPED, FAILED)
        showExceptions = true
        showCauses = true
        showStackTraces = true
    }
}

val updateProjectsAndroidLocalProperties by tasks.registering {
    description = "updates the local.properties file in each test project"

    // find all Android projects that need a local.properties file
    val androidProjects = templateProjectsDir.asFile.walk()
        .filter { it.isDirectory && it.name in setOf("it-android-0") }

    // determine the task outputs for up-to-date checks
    val propertyFileDestinations = androidProjects.map { project ->
        project.resolve("local.properties")
    }
    outputs.files(propertyFileDestinations.toList()).withPropertyName("propertyFileDestinations")

    // the source local.properties file
    val sourcePropertyFile = tasks.createAndroidLocalPropertiesFile.flatMap { it.localPropertiesFile.asFile }
    inputs.file(sourcePropertyFile).withPropertyName("sourcePropertyFile").normalizeLineEndings()

    doLast("update local.properties files") {
        val src = sourcePropertyFile.get().readText()

        propertyFileDestinations.forEach { dst ->
            dst.createNewFile()
            dst.writeText(src)
        }
    }
}

tasks.integrationTestPreparation {
    dependsOn(updateProjectsAndroidLocalProperties)
}
