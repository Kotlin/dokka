package org.jetbrains.dokka.analysis

import com.intellij.ide.highlighter.JavaClassFileType
import com.intellij.ide.highlighter.JavaFileType
import com.intellij.psi.PsiFile
import com.intellij.psi.PsiNamedElement
import org.jetbrains.dokka.model.DocumentableSource
import org.jetbrains.dokka.model.Language
import org.jetbrains.kotlin.backend.jvm.FacadeClassSourceShimForFragmentCompilation
import org.jetbrains.kotlin.builtins.BuiltInsPackageFragment
import org.jetbrains.kotlin.descriptors.*
import org.jetbrains.kotlin.descriptors.SourceFile.NO_SOURCE_FILE
import org.jetbrains.kotlin.descriptors.runtime.components.ReflectAnnotationSource
import org.jetbrains.kotlin.idea.KotlinFileType
import org.jetbrains.kotlin.js.resolve.diagnostics.findPsi
import org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaPackageFragment
import org.jetbrains.kotlin.load.java.sources.JavaSourceElement
import org.jetbrains.kotlin.load.kotlin.*
import org.jetbrains.kotlin.psi.KtFile
import org.jetbrains.kotlin.resolve.lazy.descriptors.LazyClassDescriptor
import org.jetbrains.kotlin.resolve.source.KotlinSourceElement
import org.jetbrains.kotlin.resolve.source.PsiSourceElement
import org.jetbrains.kotlin.resolve.source.PsiSourceFile
import org.jetbrains.kotlin.descriptors.SourceElement.NO_SOURCE
import org.jetbrains.kotlin.load.java.descriptors.JavaClassDescriptor
import org.jetbrains.kotlin.load.java.structure.JavaClass

import org.jetbrains.kotlin.serialization.deserialization.descriptors.DeserializedMemberDescriptor
import org.jetbrains.kotlin.serialization.deserialization.descriptors.DeserializedSimpleFunctionDescriptor
import org.jetbrains.kotlin.serialization.js.KotlinJavascriptPackageFragment

/**
 * Logic tree for figuring out the source file of a Descriptor:
 * 1. If the descriptor (or psi) has a non-null `containingFile` attribute, use that.
 * 2. If the descriptor is or is in a synthetic method or property that overrides a real method or property
 *      (and thus the real method defines the API surface), use the overridden member's "real" source file
 * 3. If the descriptor is contained within a class, recur onto the outermost class.
 *      (NOTE: this assumes that extension inner classes are not possible, which is a feature request)
 * 4. If the descriptor or something in its containingDeclaration hierarchy is deserialized, return a .class file or a
 *      .jar file, which may be a LiteralSourceFile
 * 5. Else create a LiteralSourceFile based on the package name of the class, with no full path.
 */
data class DescriptorDocumentableSource(val descriptor: DeclarationDescriptor) : DocumentableSource {
    val file = descriptor.file()
    val psi = descriptor.findPsi()
    override val path = file.toString()
    override val language =
        if (descriptor.containingHierarchyHasJavaClass() == (file.getSourceLanguage() == Language.JAVA))
            file.getSourceLanguage()
        else throw RuntimeException("Two methods of finding source language do not agree: " +
                "KSP is Java: ${descriptor.containingHierarchyHasJavaClass()}, " +
                "while complex version is ${file.getSourceLanguage()}.")
    override fun toString() = "DescriptorDocumentableSource(path = $path, element = $psi)"
}
/** The source file in which this declaration exists. Declarations can be contained inside others in the same file. */
fun DeclarationDescriptor.file(): SourceFile = when {
    // Most PSIs/Descriptors will use this case. This case only fails with enum entries, params/types, and a few more.
    this.source.name != null -> this.toSourceElement.containingFile // source is not NO_SOURCE
    // FAKE_OVERRIDE is used in autogenerated functions, like some equals methods. The upstream signature is retained.
    (this is DeserializedSimpleFunctionDescriptor && this.kind == CallableMemberDescriptor.Kind.FAKE_OVERRIDE) ->
        this.overriddenDescriptors.first().file() // TODO: is first() appropriate here?
    (this is PropertyDescriptor && this.kind == CallableMemberDescriptor.Kind.FAKE_OVERRIDE) ->
        this.overriddenDescriptors.first().file()

    //this is PackageFragmentDescriptor -> LiteralSourceFile(fqName.asString(), Language.JAVA)
    this.toSourceElement.getSourceLanguage() != Language.UNKNOWN ->
        LiteralSourceFile(getPackageName()!!, toSourceElement.getSourceLanguage())
    this.containingDeclaration != null -> this.containingDeclaration!!.file()
    else -> NO_SOURCE.containingFile
}

private fun DeclarationDescriptor?.containingHierarchyHasJavaClass(): Boolean = when(this) {
    null -> false
    is JavaClassDescriptor -> true
    else -> this.containingDeclaration.containingHierarchyHasJavaClass()
}

private fun DeclarationDescriptor.getPackageName() = toSourceElement.getPackageName(this) ?:
    containingDeclaration!!.toSourceElement.getPackageName(containingDeclaration!!)

private class LiteralSourceFile(val _name: String, val language: Language, val path: String? = null) : SourceFile {
    override fun getName() = _name
    override fun toString() = this._name
}

private val DeclarationDescriptor.source: SourceFile get() = this.toSourceElement.containingFile

class PsiDocumentableSource(val psi: PsiNamedElement) : DocumentableSource {
    override val path = psi.containingFile.virtualFile.path
    override val language: Language = psi.containingFile.getSourceLanguage()
}

fun PsiFile.getSourceLanguage() = when (this.fileType) {
    is KotlinFileType -> Language.KOTLIN
    is JavaFileType, is JavaClassFileType -> Language.JAVA
    else -> Language.UNKNOWN
}

/**
 * Returns the package of this (presumed)
 * This function assumes that containingFile has already been tried and is NO_SOURCE
 */
private fun SourceElement.getPackageName(parent: DeclarationDescriptor): String? =
    when {
        parent is PackageFragmentDescriptor -> parent.fqName.asString()
        //parent.containingDeclaration.toSourceElement.javaElement is BinaryJavaClass ->
    else -> when(this) {
        is KotlinJvmBinarySourceElement -> this.binaryClass.classId.asString()
        is KotlinJvmBinaryPackageSourceElement ->
            getContainingBinaryClass(parent as DeserializedMemberDescriptor)!!.classId.asString()
        is KotlinSourceElement -> this.psi.name!!
        is JavaSourceElement -> when (this.javaElement) {
            is JavaClass -> (this.javaElement as JavaClass).fqName?.asString()
            else -> this.javaElement.javaClass.canonicalName
        }
        is PsiSourceElement -> this.psi!!.text
        is KotlinJavascriptPackageFragment.JsContainerSource -> this.javaClass.canonicalName
        NO_SOURCE -> null
        else -> throw RuntimeException("Could not get SourceElement PackageName for $this")
    }
}

private fun SourceElement.getSourceLanguage() = when (this) {
    is KotlinSourceElement -> Language.KOTLIN
    is KotlinJvmBinarySourceElement, is KotlinJvmBinaryPackageSourceElement -> Language.KOTLIN
    // TODO: verify that RuntimeSourceElement : JavaSourceElement is actually always from Java source
    is JavaSourceElement -> Language.JAVA
    is KotlinJavascriptPackageFragment.JsContainerSource -> Language.JS
    is PsiSourceElement -> containingFile.getSourceLanguage()
    NO_SOURCE -> Language.UNKNOWN
    is JvmPackagePartSource -> throw RuntimeException("Not yet handled case: JvmPackagePartSource")
    is FacadeClassSourceShimForFragmentCompilation, is ReflectAnnotationSource ->
        throw RuntimeException("Should not be able to get element of this type from real code: ${this::class.java}")
    // This `when` is exhaustive over all SourceElement implementers in the compiler as of 1.7.0-RC
    else ->
        if((this::class.java).name == "XmlSourceElement") Language.XML // This class is private in the compiler
        else throw RuntimeException("Unknown SourceElement type: ${this::class.java}")
}

fun SourceFile.getSourceLanguage() = when (this) {
    NO_SOURCE_FILE ->
        throw RuntimeException("No source file present") // For testing
    is LiteralSourceFile -> this.language
    //is JavaFileType, is JavaClassFileType -> Language.JAVA
    is PsiSourceFile -> {
        when (this.psiFile) {
            is KtFile -> Language.KOTLIN
            else -> throw RuntimeException("Uknown file type: ${this.psiFile}")
        }
    }
    else -> throw RuntimeException("Uknown file type: $this")
}
