package org.jetbrains.dokka.analysis

import com.intellij.ide.highlighter.JavaClassFileType
import com.intellij.ide.highlighter.JavaFileType
import com.intellij.psi.PsiFile
import com.intellij.psi.PsiNamedElement
import org.jetbrains.dokka.model.DocumentableSource
import org.jetbrains.dokka.model.Language
import org.jetbrains.kotlin.builtins.BuiltInsPackageFragment
import org.jetbrains.kotlin.descriptors.*
import org.jetbrains.kotlin.descriptors.SourceFile.NO_SOURCE_FILE
import org.jetbrains.kotlin.idea.KotlinFileType
import org.jetbrains.kotlin.js.resolve.diagnostics.findPsi
import org.jetbrains.kotlin.load.kotlin.toSourceElement
import org.jetbrains.kotlin.psi.KtFile
import org.jetbrains.kotlin.resolve.source.PsiSourceFile
import org.jetbrains.kotlin.serialization.deserialization.descriptors.DeserializedSimpleFunctionDescriptor

data class DescriptorDocumentableSource(val descriptor: DeclarationDescriptor) : DocumentableSource {
    val file = descriptor.file()
    val psi = descriptor.findPsi()
    override val path = file.name!!
    override val language = file.getSourceLanguage()
    override fun toString() = "DescriptorDocumentableSource(path = $path, element = $psi)"
}
/** The source file in which this declaration exists. Declarations can be contained inside others in the same file. */
fun DeclarationDescriptor.file(): SourceFile = when {
    this.source.name != null -> this.toSourceElement.containingFile
    // FAKE_OVERRIDE is used in autogenerated functions, like some equals methods. The upstream signature is retained.
    (this is DeserializedSimpleFunctionDescriptor && this.kind == CallableMemberDescriptor.Kind.FAKE_OVERRIDE) ->
        this.overriddenDescriptors.first().file()
    this is BuiltInsPackageFragment -> when {
        this.fqName.asString().startsWith("kotlin") -> KOTLIN_BUILTINS // Inherited elements, e.g. enum.ordinal
        this.fqName.asString().startsWith("java") -> JAVA_STDLIB
        else -> throw RuntimeException("Unknown BuiltInsPackageFragment fqName: ${this.fqName.asString()}")
    }
    this is PackageFragmentDescriptor -> when {
        this.fqName.asString().startsWith("kotlin") -> KOTLIN_BUILTINS // Mostly happens via external resolver
        this.fqName.asString().startsWith("java") -> JAVA_STDLIB
        else -> throw RuntimeException("Unknown BuiltInsPackageFragment fqName: ${this.fqName.asString()}")
    }

    this.containingDeclaration != null -> this.containingDeclaration!!.file()
    else -> SourceElement.NO_SOURCE.containingFile
}

private val KOTLIN_BUILTINS = SourceFile { "KotlinBuiltins.kt" }
private val JAVA_STDLIB = SourceFile { "JavaStandardLibrary.java" }

private val DeclarationDescriptor.source: SourceFile get() = this.toSourceElement.containingFile

class PsiDocumentableSource(val psi: PsiNamedElement) : DocumentableSource {
    override val path = psi.containingFile.virtualFile.path
    override val language: Language = psi.containingFile.getSourceLanguage()
}

fun PsiFile.getSourceLanguage() = when (this.fileType) {
    is KotlinFileType -> Language.KOTLIN
    is JavaFileType, is JavaClassFileType -> Language.JAVA
    else -> Language.UNKNOWN
}

fun SourceFile.getSourceLanguage() = when (this) {
    NO_SOURCE_FILE ->
        throw RuntimeException("No source file present") // For testing
    KOTLIN_BUILTINS -> Language.KOTLIN
    JAVA_STDLIB -> Language.JAVA
    //is JavaFileType, is JavaClassFileType -> Language.JAVA
    is PsiSourceFile -> {
        when (this.psiFile) {
            is KtFile -> Language.KOTLIN
            else -> throw RuntimeException("Uknown file type: ${this.psiFile}")
        }
    }
    else -> throw RuntimeException("Uknown file type: $this")
}
